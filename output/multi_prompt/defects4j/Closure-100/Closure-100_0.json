[{"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n\n        // Don't traverse functions unless they would normally be able to have a\n        // @this annotation associated with them.\n        if (NodeUtil.isGetOrSetKey(n)) {\n            return true;\n        }\n        if (NodeUtil.isNameDeclaration(n.getParent())) {\n            return true;\n        }\n        if (NodeUtil.isFunctionDeclaration(n)) {\n            return true;\n        }\n        if (NodeUtil.isAssignRight(n)) {\n            Node lhs = n.getParent().getFirstChild();\n            if (NodeUtil.isPrototypeProperty(lhs) || NodeUtil.isPrototypeSubProperty(lhs)) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    }\n\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle nested\n            // assignments properly (e.g., (a = this).property = c;), assignLhsChild\n            // should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (NodeUtil.isPrototypeProperty(lhs) || NodeUtil.isPrototypeSubProperty(lhs)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,38 +1,48 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n-        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n-        // Don't traverse functions unless they would normally\n-        // be able to have a @this annotation associated with them. e.g.,\n-        // var a = function() { }; // or\n-        // function a() {} // or\n-        // a.x = function() {};\n+\n+        // Don't traverse functions unless they would normally be able to have a\n+        // @this annotation associated with them.\n+        if (NodeUtil.isGetOrSetKey(n)) {\n+            return true;\n+        }\n+        if (NodeUtil.isNameDeclaration(n.getParent())) {\n+            return true;\n+        }\n+        if (NodeUtil.isFunctionDeclaration(n)) {\n+            return true;\n+        }\n+        if (NodeUtil.isAssignRight(n)) {\n+            Node lhs = n.getParent().getFirstChild();\n+            if (NodeUtil.isPrototypeProperty(lhs) || NodeUtil.isPrototypeSubProperty(lhs)) {\n+                return false;\n+            }\n+            return true;\n+        }\n+        return false;\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+\n+    if (parent != null && parent.isAssign()) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n-            // Always traverse the left side of the assignment. To handle\n-            // nested assignments properly (e.g., (a = this).property = c;),\n-            // assignLhsChild should not be overridden.\n+            // Always traverse the left side of the assignment. To handle nested\n+            // assignments properly (e.g., (a = this).property = c;), assignLhsChild\n+            // should not be overridden.\n             if (assignLhsChild == null) {\n                 assignLhsChild = lhs;\n             }\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n-                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n-                    return false;\n-                }\n-                String leftName = lhs.getQualifiedName();\n-                if (leftName != null && leftName.contains(\".prototype.\")) {\n-                    return false;\n-                }\n+            if (NodeUtil.isPrototypeProperty(lhs) || NodeUtil.isPrototypeSubProperty(lhs)) {\n+                return false;\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        Node parentType = parent != null ? parent.getType() : null;\n        if (parentType != null && (parentType == Token.CALL || parentType == Token.NEW)) {\n            return false;\n        }\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (NodeUtil.isLhsOfAssign(lhs)) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.isGetProp() && lhs.getLastChild().getString().equals(\"prototype\")) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,8 +1,8 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n-        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n@@ -11,6 +11,10 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        Node parentType = parent != null ? parent.getType() : null;\n+        if (parentType != null && (parentType == Token.CALL || parentType == Token.NEW)) {\n+            return false;\n+        }\n     }\n     if (parent != null && parent.getType() == Token.ASSIGN) {\n         Node lhs = parent.getFirstChild();\n@@ -19,20 +23,14 @@\n             // Always traverse the left side of the assignment. To handle\n             // nested assignments properly (e.g., (a = this).property = c;),\n             // assignLhsChild should not be overridden.\n-            if (assignLhsChild == null) {\n+            if (NodeUtil.isLhsOfAssign(lhs)) {\n                 assignLhsChild = lhs;\n             }\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n-                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n-                    return false;\n-                }\n-                String leftName = lhs.getQualifiedName();\n-                if (leftName != null && leftName.contains(\".prototype.\")) {\n-                    return false;\n-                }\n+            if (lhs.isGetProp() && lhs.getLastChild().getString().equals(\"prototype\")) {\n+                return false;\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the `@this`\n        // annotation.\n        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions that aren't declared or assigned to a variable\n        if (!NodeUtil.isNameDeclaration(parent) && !NodeUtil.isAssignmentOp(parent)) {\n            return false;\n        }\n    }\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.isGetProp()) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,18 +1,17 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n-        // Don't traverse functions that are constructors or have the @this\n+    if (n.isFunction()) {\n+        // Don't traverse functions that are constructors or have the `@this`\n         // annotation.\n-        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n-        // Don't traverse functions unless they would normally\n-        // be able to have a @this annotation associated with them. e.g.,\n-        // var a = function() { }; // or\n-        // function a() {} // or\n-        // a.x = function() {};\n+        // Don't traverse functions that aren't declared or assigned to a variable\n+        if (!NodeUtil.isNameDeclaration(parent) && !NodeUtil.isAssignmentOp(parent)) {\n+            return false;\n+        }\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.isAssign()) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n@@ -25,7 +24,7 @@\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n+            if (lhs.isGetProp()) {\n                 if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                     return false;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n    }\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(\"prototype\")) {\n                return false;\n            }\n            String leftName = lhs.getQualifiedName();\n            if (leftName != null && leftName.contains(\".prototype.\")) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -25,14 +25,12 @@\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n-                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n-                    return false;\n-                }\n-                String leftName = lhs.getQualifiedName();\n-                if (leftName != null && leftName.contains(\".prototype.\")) {\n-                    return false;\n-                }\n+            if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(\"prototype\")) {\n+                return false;\n+            }\n+            String leftName = lhs.getQualifiedName();\n+            if (leftName != null && leftName.contains(\".prototype.\")) {\n+                return false;\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        if (!NodeUtil.mayHaveLocalThis(n)) {\n            return false;\n        }\n    }\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.isGetProp()) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,8 +1,8 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n-        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n@@ -11,8 +11,11 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        if (!NodeUtil.mayHaveLocalThis(n)) {\n+            return false;\n+        }\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.isAssign()) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n@@ -25,7 +28,7 @@\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n+            if (lhs.isGetProp()) {\n                 if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                     return false;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        return NodeUtil.functionCanBeStatic(n);\n    }\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle nested\n            // assignments properly (e.g., (a = this).property = c;), assignLhsChild\n            // should not be overridden.\n            if (assignLhsChild == null) {\n            assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.isGetProp()) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,8 +1,8 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n-        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n@@ -11,21 +11,22 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        return NodeUtil.functionCanBeStatic(n);\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.isAssign()) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n-            // Always traverse the left side of the assignment. To handle\n-            // nested assignments properly (e.g., (a = this).property = c;),\n-            // assignLhsChild should not be overridden.\n+            // Always traverse the left side of the assignment. To handle nested\n+            // assignments properly (e.g., (a = this).property = c;), assignLhsChild\n+            // should not be overridden.\n             if (assignLhsChild == null) {\n-                assignLhsChild = lhs;\n+            assignLhsChild = lhs;\n             }\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n+            if (lhs.isGetProp()) {\n                 if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                     return false;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        return NodeUtil.canBeClassMember(n);\n    }\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.isGetProp()) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,8 +1,8 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n-        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n@@ -11,8 +11,9 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        return NodeUtil.canBeClassMember(n);\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.isAssign()) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n@@ -25,7 +26,7 @@\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n+            if (lhs.isGetProp()) {\n                 if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                     return false;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = n.getJSDocInfo();\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        return NodeUtil.canBeDeclaredFunctionExpression(n);\n    }\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.isGetProp()) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,8 +1,8 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n-        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+        JSDocInfo jsDoc = n.getJSDocInfo();\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n@@ -11,8 +11,9 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        return NodeUtil.canBeDeclaredFunctionExpression(n);\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.isAssign()) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n@@ -25,7 +26,7 @@\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n+            if (lhs.isGetProp()) {\n                 if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                     return false;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        if (!NodeUtil.mayHaveInstanceJsdoc(n)) {\n            return false;\n        }\n    }\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.isGetProp()) {\n                Node propNode = lhs.getLastChild();\n                String propString = propNode.getString();\n                if (\"prototype\".equals(propString)) {\n                    return false;\n                }\n                String leftName = NodeUtil.getBestLValueName(lhs);\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,8 +1,8 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n-        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n@@ -11,25 +11,28 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        if (!NodeUtil.mayHaveInstanceJsdoc(n)) {\n+            return false;\n+        }\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.isAssign()) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n-            // Always traverse the left side of the assignment. To handle\n-            // nested assignments properly (e.g., (a = this).property = c;),\n-            // assignLhsChild should not be overridden.\n+            // Always traverse the left side of the assignment.\n             if (assignLhsChild == null) {\n                 assignLhsChild = lhs;\n             }\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n-                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n+            if (lhs.isGetProp()) {\n+                Node propNode = lhs.getLastChild();\n+                String propString = propNode.getString();\n+                if (\"prototype\".equals(propString)) {\n                     return false;\n                 }\n-                String leftName = lhs.getQualifiedName();\n+                String leftName = NodeUtil.getBestLValueName(lhs);\n                 if (leftName != null && leftName.contains(\".prototype.\")) {\n                     return false;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        return NodeUtil.functionHasOwnThis(t.getScope(), n);\n    }\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.isGetProp() && \"prototype\".equals(lhs.getLastChild().getString())) {\n                return false;\n            }\n            if (NodeUtil.isPrototypeProperty(lhs)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,8 +1,8 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n-        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n@@ -11,8 +11,9 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        return NodeUtil.functionHasOwnThis(t.getScope(), n);\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.isAssign()) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n@@ -25,14 +26,11 @@\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n-                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n-                    return false;\n-                }\n-                String leftName = lhs.getQualifiedName();\n-                if (leftName != null && leftName.contains(\".prototype.\")) {\n-                    return false;\n-                }\n+            if (lhs.isGetProp() && \"prototype\".equals(lhs.getLastChild().getString())) {\n+                return false;\n+            }\n+            if (NodeUtil.isPrototypeProperty(lhs)) {\n+                return false;\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        if (!NodeUtil.canBeClassChild(parent)) {\n            return false;\n        }\n    }\n\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.isGetProp()) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,8 +1,8 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n-        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n@@ -11,8 +11,12 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        if (!NodeUtil.canBeClassChild(parent)) {\n+            return false;\n+        }\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+\n+    if (parent != null && parent.isAssign()) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n@@ -25,7 +29,7 @@\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n+            if (lhs.isGetProp()) {\n                 if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                     return false;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        if (!NodeUtil.isStatementBlockParent(parent)) {\n            return false;\n        }\n    }\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.isGetProp()) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,5 +1,5 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n         JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n@@ -11,8 +11,11 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        if (!NodeUtil.isStatementBlockParent(parent)) {\n+            return false;\n+        }\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.isAssign()) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n@@ -25,7 +28,7 @@\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n+            if (lhs.isGetProp()) {\n                 if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                     return false;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        return NodeUtil.isGetOrSetKey(n);\n    }\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.isGetProp() && \"prototype\".equals(lhs.getLastChild().getString())) {\n                return false;\n            }\n            if (lhs.isQualifiedName() && lhs.getQualifiedName().contains(\".prototype.\")) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,8 +1,8 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n-        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n@@ -11,8 +11,9 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        return NodeUtil.isGetOrSetKey(n);\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.isAssign()) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n@@ -25,14 +26,11 @@\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n-                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n-                    return false;\n-                }\n-                String leftName = lhs.getQualifiedName();\n-                if (leftName != null && leftName.contains(\".prototype.\")) {\n-                    return false;\n-                }\n+            if (lhs.isGetProp() && \"prototype\".equals(lhs.getLastChild().getString())) {\n+                return false;\n+            }\n+            if (lhs.isQualifiedName() && lhs.getQualifiedName().contains(\".prototype.\")) {\n+                return false;\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        if (!n.hasOneChild()) {\n            return false;\n        }\n        if (!n.getFirstChild().isBlock()) {\n            return false;\n        }\n    }\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.isGetProp()) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,5 +1,5 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n         JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n@@ -11,8 +11,14 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        if (!n.hasOneChild()) {\n+            return false;\n+        }\n+        if (!n.getFirstChild().isBlock()) {\n+            return false;\n+        }\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.isAssign()) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n@@ -25,7 +31,7 @@\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n+            if (lhs.isGetProp()) {\n                 if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                     return false;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.getToken() == Token.FUNCTION) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        String name = NodeUtil.getName(n);\n        if (name == null || name.isEmpty() || name.charAt(0) == '$' || name.contains(\".\")) {\n            return false;\n        }\n    }\n    if (parent != null && parent.getToken() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.getToken() == Token.GETPROP) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,8 +1,8 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.getToken() == Token.FUNCTION) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n-        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n@@ -11,8 +11,12 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        String name = NodeUtil.getName(n);\n+        if (name == null || name.isEmpty() || name.charAt(0) == '$' || name.contains(\".\")) {\n+            return false;\n+        }\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.getToken() == Token.ASSIGN) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n@@ -25,7 +29,7 @@\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n+            if (lhs.getToken() == Token.GETPROP) {\n                 if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                     return false;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        return NodeUtil.canBeClassMethod(n);\n    }\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.isGetProp()) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,8 +1,8 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n-        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n@@ -11,8 +11,9 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        return NodeUtil.canBeClassMethod(n);\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.isAssign()) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n@@ -25,7 +26,7 @@\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n+            if (lhs.isGetProp()) {\n                 if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                     return false;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) { // use \"isFunction()\" instead of \"getType() == Token.FUNCTION\"\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        return NodeUtil.canBePropertyKey(n);\n    }\n    if (parent != null && parent.isAssign()) { // use \"isAssign()\" instead of \"getType() == Token.ASSIGN\"\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (NodeUtil.isGet(lhs)) { // use \"isGet()\" instead of \"getType() == Token.GETPROP\"\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,5 +1,5 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) { // use \"isFunction()\" instead of \"getType() == Token.FUNCTION\"\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n         JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n@@ -11,8 +11,9 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        return NodeUtil.canBePropertyKey(n);\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.isAssign()) { // use \"isAssign()\" instead of \"getType() == Token.ASSIGN\"\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n@@ -25,7 +26,7 @@\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n+            if (NodeUtil.isGet(lhs)) { // use \"isGet()\" instead of \"getType() == Token.GETPROP\"\n                 if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                     return false;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = n.getJSDocInfo();\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        if (NodeUtil.isFunctionExpression(n) && parent != null\n                && !parent.isAssign() && !parent.isSetter()) {\n            return false;\n        }\n    }\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs && !NodeUtil.mayHaveSideEffects(rhs)) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.isGetProp()\n                    && \"prototype\".equals(lhs.getLastChild().getString())) {\n                return false;\n            }\n            if (NodeUtil.isLhsByDestructuring(lhs)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,8 +1,8 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n-        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+        JSDocInfo jsDoc = n.getJSDocInfo();\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n@@ -11,11 +11,15 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        if (NodeUtil.isFunctionExpression(n) && parent != null\n+                && !parent.isAssign() && !parent.isSetter()) {\n+            return false;\n+        }\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.isAssign()) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n-        if (n == lhs) {\n+        if (n == lhs && !NodeUtil.mayHaveSideEffects(rhs)) {\n             // Always traverse the left side of the assignment. To handle\n             // nested assignments properly (e.g., (a = this).property = c;),\n             // assignLhsChild should not be overridden.\n@@ -25,14 +29,12 @@\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n-                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n-                    return false;\n-                }\n-                String leftName = lhs.getQualifiedName();\n-                if (leftName != null && leftName.contains(\".prototype.\")) {\n-                    return false;\n-                }\n+            if (lhs.isGetProp()\n+                    && \"prototype\".equals(lhs.getLastChild().getString())) {\n+                return false;\n+            }\n+            if (NodeUtil.isLhsByDestructuring(lhs)) {\n+                return false;\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        return NodeUtil.isPrototypeMethod(n) || NodeUtil.isFunctionExpression(n.getParent());\n    }\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.isGetProp()) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,8 +1,8 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n-        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n@@ -11,8 +11,9 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        return NodeUtil.isPrototypeMethod(n) || NodeUtil.isFunctionExpression(n.getParent());\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.isAssign()) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n@@ -25,7 +26,7 @@\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n+            if (lhs.isGetProp()) {\n                 if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                     return false;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isFunction()) {\n        // Don't traverse functions that are constructors or have the @this\n        // annotation.\n        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n        if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n            return false;\n        }\n        // Don't traverse functions unless they would normally\n        // be able to have a @this annotation associated with them. e.g.,\n        // var a = function() { }; // or\n        // function a() {} // or\n        // a.x = function() {};\n        Scope s = t.getScope();\n        if (!s.getClosestHoistScope(n).isFunctionBlockScope() && !s.isDeclared(NodeUtil.getNameNode(n), false)) {\n            return false;\n        }\n    }\n    if (parent != null && parent.isAssign()) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n            // Always traverse the left side of the assignment. To handle\n            // nested assignments properly (e.g., (a = this).property = c;),\n            // assignLhsChild should not be overridden.\n            if (assignLhsChild == null) {\n                assignLhsChild = lhs;\n            }\n        } else {\n            // Only traverse the right side if it's not an assignment to a prototype\n            // property or subproperty.\n            if (lhs.isGetProp()) {\n                if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                    return false;\n                }\n                String leftName = lhs.getQualifiedName();\n                if (leftName != null && leftName.contains(\".prototype.\")) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n+++ com/google/javascript/jscomp/CheckGlobalThis.java@shouldTraverse\n@@ -1,8 +1,8 @@\n public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() == Token.FUNCTION) {\n+    if (n.isFunction()) {\n         // Don't traverse functions that are constructors or have the @this\n         // annotation.\n-        JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n+        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n         if (jsDoc != null && (jsDoc.isConstructor() || jsDoc.hasThisType())) {\n             return false;\n         }\n@@ -11,8 +11,12 @@\n         // var a = function() { }; // or\n         // function a() {} // or\n         // a.x = function() {};\n+        Scope s = t.getScope();\n+        if (!s.getClosestHoistScope(n).isFunctionBlockScope() && !s.isDeclared(NodeUtil.getNameNode(n), false)) {\n+            return false;\n+        }\n     }\n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n+    if (parent != null && parent.isAssign()) {\n         Node lhs = parent.getFirstChild();\n         Node rhs = lhs.getNext();\n         if (n == lhs) {\n@@ -25,7 +29,7 @@\n         } else {\n             // Only traverse the right side if it's not an assignment to a prototype\n             // property or subproperty.\n-            if (lhs.getType() == Token.GETPROP) {\n+            if (lhs.isGetProp()) {\n                 if (lhs.getLastChild().getString().equals(\"prototype\")) {\n                     return false;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}]