[{"output": "Please note that it is not possible to provide a fixed function for the given code snippet as it is incomplete and is missing certain imports, class definitions and method implementations.", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type.equals(origType)) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer<Object>(conv, delegateType, ser);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -11,7 +11,7 @@\n     boolean staticTyping;\n     // Next: we may have annotations that further define types to use...\n     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n+    if (type.equals(origType)) {\n         // no changes, won't force static typing\n         staticTyping = false;\n     } else {\n@@ -27,7 +27,7 @@\n         // no, simple\n         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n     // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n     if (!delegateType.hasRawClass(type.getRawClass())) {\n         beanDesc = config.introspect(delegateType);\n@@ -38,5 +38,5 @@\n     if (ser == null) {\n         ser = _createSerializer2(prov, delegateType, beanDesc, true);\n     }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n+    return new StdDelegatingSerializer<Object>(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer<Object>(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer<Object>(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer<Object>(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer<Object>(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer<Object>(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer<Object>(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type == origType) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.getRawClass().equals(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -17,7 +17,7 @@\n     } else {\n         // changes; assume static typing; plus, need to re-introspect if class differs\n         staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n             beanDesc = config.introspect(type);\n         }\n     }\n@@ -27,9 +27,9 @@\n         // no, simple\n         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n     // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n         beanDesc = config.introspect(delegateType);\n         // [#359]: explicitly check (again) for @JsonSerializer...\n         ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type.equals(origType)) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -11,7 +11,7 @@\n     boolean staticTyping;\n     // Next: we may have annotations that further define types to use...\n     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n+    if (type.equals(origType)) {\n         // no changes, won't force static typing\n         staticTyping = false;\n     } else {\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type.equals(origType)) { // using equals instead of \"==\"\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -11,7 +11,7 @@\n     boolean staticTyping;\n     // Next: we may have annotations that further define types to use...\n     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n+    if (type.equals(origType)) { // using equals instead of \"==\"\n         // no changes, won't force static typing\n         staticTyping = false;\n     } else {\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // using equals instead of \"==\"\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // using equals instead of \"==\"\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // using equals instead of \"==\"\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // using equals instead of \"==\"\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // using equals instead of \"==\"\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // using equals instead of \"==\"\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type.equals(origType)) {\n        // no changes. Won't force static typing.\n        staticTyping = false;\n    } else {\n        // changes. Assume static typing; plus, need to re-introspect if class differs.\n        staticTyping = true;\n        if (!type.getRawClass().equals(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Do we have a Converter to consider?\n    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // No. Simple.\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    // Yes. Need to make some adjustments.\n    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // Check (again) for @JsonSerializer.\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        if (ser == null) {\n            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n        }\n    }\n    // Skip if nominally java.lang.Object.\n    if (ser == null && !delegateType.isJavaLangObject()) {\n        ser = prov.findValueSerializer(delegateType, beanDesc);\n    }\n    return (JsonSerializer<Object>) new StdDelegatingSerializer(conv, delegateType, ser);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -11,32 +11,35 @@\n     boolean staticTyping;\n     // Next: we may have annotations that further define types to use...\n     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n-        // no changes, won't force static typing\n+    if (type.equals(origType)) {\n+        // no changes. Won't force static typing.\n         staticTyping = false;\n     } else {\n-        // changes; assume static typing; plus, need to re-introspect if class differs\n+        // changes. Assume static typing; plus, need to re-introspect if class differs.\n         staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n             beanDesc = config.introspect(type);\n         }\n     }\n-    // Slight detour: do we have a Converter to consider?\n-    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    // Do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n     if (conv == null) {\n-        // no, simple\n+        // No. Simple.\n         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n-    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    // Yes. Need to make some adjustments.\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n     if (!delegateType.hasRawClass(type.getRawClass())) {\n         beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n+        // Check (again) for @JsonSerializer.\n         ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n     }\n-    // [databind#731]: Should skip if nominally java.lang.Object\n-    if (ser == null) {\n-        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    // Skip if nominally java.lang.Object.\n+    if (ser == null && !delegateType.isJavaLangObject()) {\n+        ser = prov.findValueSerializer(delegateType, beanDesc);\n     }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n+    return (JsonSerializer<Object>) new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,45 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes. Won't force static typing.\n+        staticTyping = false;\n+    } else {\n+        // changes. Assume static typing; plus, need to re-introspect if class differs.\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // No. Simple.\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    // Yes. Need to make some adjustments.\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // Check (again) for @JsonSerializer.\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+    }\n+    // Skip if nominally java.lang.Object.\n+    if (ser == null && !delegateType.isJavaLangObject()) {\n+        ser = prov.findValueSerializer(delegateType, beanDesc);\n+    }\n+    return (JsonSerializer<Object>) new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,45 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes. Won't force static typing.\n+        staticTyping = false;\n+    } else {\n+        // changes. Assume static typing; plus, need to re-introspect if class differs.\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // No. Simple.\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    // Yes. Need to make some adjustments.\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // Check (again) for @JsonSerializer.\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+    }\n+    // Skip if nominally java.lang.Object.\n+    if (ser == null && !delegateType.isJavaLangObject()) {\n+        ser = prov.findValueSerializer(delegateType, beanDesc);\n+    }\n+    return (JsonSerializer<Object>) new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,45 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes. Won't force static typing.\n+        staticTyping = false;\n+    } else {\n+        // changes. Assume static typing; plus, need to re-introspect if class differs.\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // No. Simple.\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    // Yes. Need to make some adjustments.\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // Check (again) for @JsonSerializer.\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+    }\n+    // Skip if nominally java.lang.Object.\n+    if (ser == null && !delegateType.isJavaLangObject()) {\n+        ser = prov.findValueSerializer(delegateType, beanDesc);\n+    }\n+    return (JsonSerializer<Object>) new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,45 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes. Won't force static typing.\n+        staticTyping = false;\n+    } else {\n+        // changes. Assume static typing; plus, need to re-introspect if class differs.\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // No. Simple.\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    // Yes. Need to make some adjustments.\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // Check (again) for @JsonSerializer.\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+    }\n+    // Skip if nominally java.lang.Object.\n+    if (ser == null && !delegateType.isJavaLangObject()) {\n+        ser = prov.findValueSerializer(delegateType, beanDesc);\n+    }\n+    return (JsonSerializer<Object>) new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,45 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes. Won't force static typing.\n+        staticTyping = false;\n+    } else {\n+        // changes. Assume static typing; plus, need to re-introspect if class differs.\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // No. Simple.\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    // Yes. Need to make some adjustments.\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // Check (again) for @JsonSerializer.\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+    }\n+    // Skip if nominally java.lang.Object.\n+    if (ser == null && !delegateType.isJavaLangObject()) {\n+        ser = prov.findValueSerializer(delegateType, beanDesc);\n+    }\n+    return (JsonSerializer<Object>) new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,45 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes. Won't force static typing.\n+        staticTyping = false;\n+    } else {\n+        // changes. Assume static typing; plus, need to re-introspect if class differs.\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // No. Simple.\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    // Yes. Need to make some adjustments.\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // Check (again) for @JsonSerializer.\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+    }\n+    // Skip if nominally java.lang.Object.\n+    if (ser == null && !delegateType.isJavaLangObject()) {\n+        ser = prov.findValueSerializer(delegateType, beanDesc);\n+    }\n+    return (JsonSerializer<Object>) new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type.equals(origType)) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.getRawClass().equals(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -11,13 +11,13 @@\n     boolean staticTyping;\n     // Next: we may have annotations that further define types to use...\n     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n+    if (type.equals(origType)) {\n         // no changes, won't force static typing\n         staticTyping = false;\n     } else {\n         // changes; assume static typing; plus, need to re-introspect if class differs\n         staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n             beanDesc = config.introspect(type);\n         }\n     }\n@@ -27,9 +27,9 @@\n         // no, simple\n         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n     // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n         beanDesc = config.introspect(delegateType);\n         // [#359]: explicitly check (again) for @JsonSerializer...\n         ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type == origType) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        if(ser == null) { // add null check for ser\n            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n        }\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -33,6 +33,9 @@\n         beanDesc = config.introspect(delegateType);\n         // [#359]: explicitly check (again) for @JsonSerializer...\n         ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if(ser == null) { // add null check for ser\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n     }\n     // [databind#731]: Should skip if nominally java.lang.Object\n     if (ser == null) {\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,45 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if(ser == null) { // add null check for ser\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,45 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if(ser == null) { // add null check for ser\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,45 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if(ser == null) { // add null check for ser\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,45 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if(ser == null) { // add null check for ser\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,45 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if(ser == null) { // add null check for ser\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,45 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if(ser == null) { // add null check for ser\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type == origType) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -19,6 +19,7 @@\n         staticTyping = true;\n         if (!type.hasRawClass(origType.getRawClass())) {\n             beanDesc = config.introspect(type);\n+            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n         }\n     }\n     // Slight detour: do we have a Converter to consider?\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,43 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,43 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,43 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,43 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,43 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,43 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+            ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type == origType) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.getRawClass().equals(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -17,7 +17,7 @@\n     } else {\n         // changes; assume static typing; plus, need to re-introspect if class differs\n         staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n             beanDesc = config.introspect(type);\n         }\n     }\n@@ -29,7 +29,7 @@\n     }\n     JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n     // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n         beanDesc = config.introspect(delegateType);\n         // [#359]: explicitly check (again) for @JsonSerializer...\n         ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.getRawClass().equals(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type.getRawClass() != origType.getRawClass()) { // Fix: use getRawClass() to compare types\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        beanDesc = config.introspect(type);\n    } else {\n        // no changes, won't force static typing\n        staticTyping = false;\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -11,15 +11,13 @@\n     boolean staticTyping;\n     // Next: we may have annotations that further define types to use...\n     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n+    if (type.getRawClass() != origType.getRawClass()) { // Fix: use getRawClass() to compare types\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        beanDesc = config.introspect(type);\n+    } else {\n         // no changes, won't force static typing\n         staticTyping = false;\n-    } else {\n-        // changes; assume static typing; plus, need to re-introspect if class differs\n-        staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n-            beanDesc = config.introspect(type);\n-        }\n     }\n     // Slight detour: do we have a Converter to consider?\n     Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,40 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n-        }\n-                delSer = provider.findValueSerializer(delegateType);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.getRawClass() != origType.getRawClass()) { // Fix: use getRawClass() to compare types\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        beanDesc = config.introspect(type);\n+    } else {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,40 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.getRawClass() != origType.getRawClass()) { // Fix: use getRawClass() to compare types\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        beanDesc = config.introspect(type);\n+    } else {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,40 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.getRawClass() != origType.getRawClass()) { // Fix: use getRawClass() to compare types\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        beanDesc = config.introspect(type);\n+    } else {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,40 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.getRawClass() != origType.getRawClass()) { // Fix: use getRawClass() to compare types\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        beanDesc = config.introspect(type);\n+    } else {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,40 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.getRawClass() != origType.getRawClass()) { // Fix: use getRawClass() to compare types\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        beanDesc = config.introspect(type);\n+    } else {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,40 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.getRawClass() != origType.getRawClass()) { // Fix: use getRawClass() to compare types\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        beanDesc = config.introspect(type);\n+    } else {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type == origType) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        // Re-introspect beanDesc with delegateType\n        beanDesc = config.introspect(delegateType);\n        // Find serializer for delegateType if present\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -30,8 +30,9 @@\n     JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n     // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n     if (!delegateType.hasRawClass(type.getRawClass())) {\n+        // Re-introspect beanDesc with delegateType\n         beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n+        // Find serializer for delegateType if present\n         ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     }\n     // [databind#731]: Should skip if nominally java.lang.Object\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,43 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        // Re-introspect beanDesc with delegateType\n+        beanDesc = config.introspect(delegateType);\n+        // Find serializer for delegateType if present\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,43 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        // Re-introspect beanDesc with delegateType\n+        beanDesc = config.introspect(delegateType);\n+        // Find serializer for delegateType if present\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,43 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        // Re-introspect beanDesc with delegateType\n+        beanDesc = config.introspect(delegateType);\n+        // Find serializer for delegateType if present\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,43 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        // Re-introspect beanDesc with delegateType\n+        beanDesc = config.introspect(delegateType);\n+        // Find serializer for delegateType if present\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,43 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        // Re-introspect beanDesc with delegateType\n+        beanDesc = config.introspect(delegateType);\n+        // Find serializer for delegateType if present\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,43 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        // Re-introspect beanDesc with delegateType\n+        beanDesc = config.introspect(delegateType);\n+        // Find serializer for delegateType if present\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type.equals(origType)) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.equals(type)) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -11,7 +11,7 @@\n     boolean staticTyping;\n     // Next: we may have annotations that further define types to use...\n     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n+    if (type.equals(origType)) {\n         // no changes, won't force static typing\n         staticTyping = false;\n     } else {\n@@ -29,7 +29,7 @@\n     }\n     JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n     // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n+    if (!delegateType.equals(type)) {\n         beanDesc = config.introspect(delegateType);\n         // [#359]: explicitly check (again) for @JsonSerializer...\n         ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.equals(type)) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.equals(type)) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.equals(type)) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.equals(type)) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.equals(type)) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.equals(type)) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type.getRawClass() == Object.class) { // check if type is Object\n        staticTyping = false; // if type is Object, skip static typing\n    } else if (type == origType) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer((Converter<Object, Object>) conv, delegateType, ser);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -11,7 +11,9 @@\n     boolean staticTyping;\n     // Next: we may have annotations that further define types to use...\n     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n+    if (type.getRawClass() == Object.class) { // check if type is Object\n+        staticTyping = false; // if type is Object, skip static typing\n+    } else if (type == origType) {\n         // no changes, won't force static typing\n         staticTyping = false;\n     } else {\n@@ -22,7 +24,7 @@\n         }\n     }\n     // Slight detour: do we have a Converter to consider?\n-    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n     if (conv == null) {\n         // no, simple\n         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n@@ -38,5 +40,5 @@\n     if (ser == null) {\n         ser = _createSerializer2(prov, delegateType, beanDesc, true);\n     }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n+    return new StdDelegatingSerializer((Converter<Object, Object>) conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,44 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.getRawClass() == Object.class) { // check if type is Object\n+        staticTyping = false; // if type is Object, skip static typing\n+    } else if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer((Converter<Object, Object>) conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,44 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.getRawClass() == Object.class) { // check if type is Object\n+        staticTyping = false; // if type is Object, skip static typing\n+    } else if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer((Converter<Object, Object>) conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,44 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.getRawClass() == Object.class) { // check if type is Object\n+        staticTyping = false; // if type is Object, skip static typing\n+    } else if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer((Converter<Object, Object>) conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,44 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.getRawClass() == Object.class) { // check if type is Object\n+        staticTyping = false; // if type is Object, skip static typing\n+    } else if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer((Converter<Object, Object>) conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,44 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.getRawClass() == Object.class) { // check if type is Object\n+        staticTyping = false; // if type is Object, skip static typing\n+    } else if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer((Converter<Object, Object>) conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,44 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.getRawClass() == Object.class) { // check if type is Object\n+        staticTyping = false; // if type is Object, skip static typing\n+    } else if (type == origType) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer((Converter<Object, Object>) conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type.getRawClass() == origType.getRawClass()) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -11,7 +11,7 @@\n     boolean staticTyping;\n     // Next: we may have annotations that further define types to use...\n     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n+    if (type.getRawClass() == origType.getRawClass()) {\n         // no changes, won't force static typing\n         staticTyping = false;\n     } else {\n@@ -22,12 +22,12 @@\n         }\n     }\n     // Slight detour: do we have a Converter to consider?\n-    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n     if (conv == null) {\n         // no, simple\n         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n     // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n     if (!delegateType.hasRawClass(type.getRawClass())) {\n         beanDesc = config.introspect(delegateType);\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.getRawClass() == origType.getRawClass()) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.getRawClass() == origType.getRawClass()) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.getRawClass() == origType.getRawClass()) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.getRawClass() == origType.getRawClass()) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.getRawClass() == origType.getRawClass()) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.getRawClass() == origType.getRawClass()) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<?, ?> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type.equals(origType)) {\n        staticTyping = false;\n    } else {\n        staticTyping = true;\n        if (!type.getRawClass().isAssignableFrom(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n    if (!delegateType.getRawClass().isAssignableFrom(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return (JsonSerializer<Object>) new StdDelegatingSerializer(conv, delegateType, ser);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -1,7 +1,6 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n-    // Very first thing, let's check if there is explicit serializer annotation:\n     final SerializationConfig config = prov.getConfig();\n     BeanDescription beanDesc = config.introspect(origType);\n     JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n@@ -9,34 +8,26 @@\n         return (JsonSerializer<Object>) ser;\n     }\n     boolean staticTyping;\n-    // Next: we may have annotations that further define types to use...\n     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n-        // no changes, won't force static typing\n+    if (type.equals(origType)) {\n         staticTyping = false;\n     } else {\n-        // changes; assume static typing; plus, need to re-introspect if class differs\n         staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n+        if (!type.getRawClass().isAssignableFrom(origType.getRawClass())) {\n             beanDesc = config.introspect(type);\n         }\n     }\n-    // Slight detour: do we have a Converter to consider?\n     Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n     if (conv == null) {\n-        // no, simple\n         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n-    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.getRawClass().isAssignableFrom(type.getRawClass())) {\n         beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n         ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     }\n-    // [databind#731]: Should skip if nominally java.lang.Object\n     if (ser == null) {\n         ser = _createSerializer2(prov, delegateType, beanDesc, true);\n     }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n+    return (JsonSerializer<Object>) new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,33 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        staticTyping = false;\n+    } else {\n+        staticTyping = true;\n+        if (!type.getRawClass().isAssignableFrom(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.getRawClass().isAssignableFrom(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return (JsonSerializer<Object>) new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,33 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        staticTyping = false;\n+    } else {\n+        staticTyping = true;\n+        if (!type.getRawClass().isAssignableFrom(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.getRawClass().isAssignableFrom(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return (JsonSerializer<Object>) new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,33 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        staticTyping = false;\n+    } else {\n+        staticTyping = true;\n+        if (!type.getRawClass().isAssignableFrom(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.getRawClass().isAssignableFrom(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return (JsonSerializer<Object>) new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,33 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        staticTyping = false;\n+    } else {\n+        staticTyping = true;\n+        if (!type.getRawClass().isAssignableFrom(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.getRawClass().isAssignableFrom(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return (JsonSerializer<Object>) new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,33 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        staticTyping = false;\n+    } else {\n+        staticTyping = true;\n+        if (!type.getRawClass().isAssignableFrom(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.getRawClass().isAssignableFrom(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return (JsonSerializer<Object>) new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,33 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        staticTyping = false;\n+    } else {\n+        staticTyping = true;\n+        if (!type.getRawClass().isAssignableFrom(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.getRawClass().isAssignableFrom(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return (JsonSerializer<Object>) new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "There seems to be more than one bug in the given code, so I am providing a partial fix for one of the potential bugs.\n\n@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type.equals(origType)) {\n        // The previous code used == operator instead of equals() method which may cause unexpected results\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // The rest of the code needs to be analyzed further for more potential bugs and corresponding fixes\n    ...\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -11,7 +11,8 @@\n     boolean staticTyping;\n     // Next: we may have annotations that further define types to use...\n     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n+    if (type.equals(origType)) {\n+        // The previous code used == operator instead of equals() method which may cause unexpected results\n         // no changes, won't force static typing\n         staticTyping = false;\n     } else {\n@@ -21,22 +22,6 @@\n             beanDesc = config.introspect(type);\n         }\n     }\n-    // Slight detour: do we have a Converter to consider?\n-    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n-    if (conv == null) {\n-        // no, simple\n-        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n-    }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n-    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n-        beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n-        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    }\n-    // [databind#731]: Should skip if nominally java.lang.Object\n-    if (ser == null) {\n-        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n-    }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n+    // The rest of the code needs to be analyzed further for more potential bugs and corresponding fixes\n+    ...\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,27 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // The previous code used == operator instead of equals() method which may cause unexpected results\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n-    }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    // The rest of the code needs to be analyzed further for more potential bugs and corresponding fixes\n+    ...\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,27 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // The previous code used == operator instead of equals() method which may cause unexpected results\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // The rest of the code needs to be analyzed further for more potential bugs and corresponding fixes\n+    ...\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,27 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // The previous code used == operator instead of equals() method which may cause unexpected results\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // The rest of the code needs to be analyzed further for more potential bugs and corresponding fixes\n+    ...\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,27 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // The previous code used == operator instead of equals() method which may cause unexpected results\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // The rest of the code needs to be analyzed further for more potential bugs and corresponding fixes\n+    ...\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,27 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // The previous code used == operator instead of equals() method which may cause unexpected results\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // The rest of the code needs to be analyzed further for more potential bugs and corresponding fixes\n+    ...\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,27 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // The previous code used == operator instead of equals() method which may cause unexpected results\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // The rest of the code needs to be analyzed further for more potential bugs and corresponding fixes\n+    ...\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type.equals(origType)) {\n        staticTyping = false;\n    } else {\n        staticTyping = true;\n        beanDesc = config.introspect(type);\n    }\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -1,7 +1,6 @@\n @Override\n @SuppressWarnings(\"unchecked\")\n public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n-    // Very first thing, let's check if there is explicit serializer annotation:\n     final SerializationConfig config = prov.getConfig();\n     BeanDescription beanDesc = config.introspect(origType);\n     JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n@@ -9,32 +8,22 @@\n         return (JsonSerializer<Object>) ser;\n     }\n     boolean staticTyping;\n-    // Next: we may have annotations that further define types to use...\n     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n-        // no changes, won't force static typing\n+    if (type.equals(origType)) {\n         staticTyping = false;\n     } else {\n-        // changes; assume static typing; plus, need to re-introspect if class differs\n         staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n-            beanDesc = config.introspect(type);\n-        }\n+        beanDesc = config.introspect(type);\n     }\n-    // Slight detour: do we have a Converter to consider?\n     Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n     if (conv == null) {\n-        // no, simple\n         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n-    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n     if (!delegateType.hasRawClass(type.getRawClass())) {\n         beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n         ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n     }\n-    // [databind#731]: Should skip if nominally java.lang.Object\n     if (ser == null) {\n         ser = _createSerializer2(prov, delegateType, beanDesc, true);\n     }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,31 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n-        }\n-                delSer = provider.findValueSerializer(delegateType);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    boolean staticTyping;\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        staticTyping = false;\n+    } else {\n+        staticTyping = true;\n+        beanDesc = config.introspect(type);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,31 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        staticTyping = false;\n+    } else {\n+        staticTyping = true;\n+        beanDesc = config.introspect(type);\n+    }\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,31 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        staticTyping = false;\n+    } else {\n+        staticTyping = true;\n+        beanDesc = config.introspect(type);\n+    }\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,31 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        staticTyping = false;\n+    } else {\n+        staticTyping = true;\n+        beanDesc = config.introspect(type);\n+    }\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,31 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        staticTyping = false;\n+    } else {\n+        staticTyping = true;\n+        beanDesc = config.introspect(type);\n+    }\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,31 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        staticTyping = false;\n+    } else {\n+        staticTyping = true;\n+        beanDesc = config.introspect(type);\n+    }\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(config.getTypeFactory());\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type.equals(origType)) { // check for equality using `equals` method instead of `==`\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.hasRawClass(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -11,7 +11,7 @@\n     boolean staticTyping;\n     // Next: we may have annotations that further define types to use...\n     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n+    if (type.equals(origType)) { // check for equality using `equals` method instead of `==`\n         // no changes, won't force static typing\n         staticTyping = false;\n     } else {\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,42 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // check for equality using `equals` method instead of `==`\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,42 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // check for equality using `equals` method instead of `==`\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,42 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // check for equality using `equals` method instead of `==`\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,42 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // check for equality using `equals` method instead of `==`\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,42 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // check for equality using `equals` method instead of `==`\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,42 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) { // check for equality using `equals` method instead of `==`\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.hasRawClass(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\n@SuppressWarnings(\"unchecked\")\npublic JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n    // Very first thing, let's check if there is explicit serializer annotation:\n    final SerializationConfig config = prov.getConfig();\n    BeanDescription beanDesc = config.introspect(origType);\n    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n    if (ser != null) {\n        return (JsonSerializer<Object>) ser;\n    }\n    boolean staticTyping;\n    // Next: we may have annotations that further define types to use...\n    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n    if (type.equals(origType)) {\n        // no changes, won't force static typing\n        staticTyping = false;\n    } else {\n        // changes; assume static typing; plus, need to re-introspect if class differs\n        staticTyping = true;\n        if (!type.getRawClass().equals(origType.getRawClass())) {\n            beanDesc = config.introspect(type);\n        }\n    }\n    // Slight detour: do we have a Converter to consider?\n    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n    if (conv == null) {\n        // no, simple\n        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n    }\n    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n    if (!delegateType.hasRawClass(type.getRawClass())) {\n        beanDesc = config.introspect(delegateType);\n        // [#359]: explicitly check (again) for @JsonSerializer...\n        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n        if (ser == null) {\n            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n        }\n        return new StdDelegatingSerializer(conv, delegateType, ser);\n    }\n    // [databind#731]: Should skip if nominally java.lang.Object\n    if (ser == null) {\n        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n    }\n    return new StdDelegatingSerializer(conv, delegateType, ser);\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -11,13 +11,13 @@\n     boolean staticTyping;\n     // Next: we may have annotations that further define types to use...\n     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n+    if (type.equals(origType)) {\n         // no changes, won't force static typing\n         staticTyping = false;\n     } else {\n         // changes; assume static typing; plus, need to re-introspect if class differs\n         staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n             beanDesc = config.introspect(type);\n         }\n     }\n@@ -33,6 +33,10 @@\n         beanDesc = config.introspect(delegateType);\n         // [#359]: explicitly check (again) for @JsonSerializer...\n         ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n     }\n     // [databind#731]: Should skip if nominally java.lang.Object\n     if (ser == null) {\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,46 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,46 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,46 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,46 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,46 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,46 @@\n @Override\n-public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+@SuppressWarnings(\"unchecked\")\n+public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n+    // Very first thing, let's check if there is explicit serializer annotation:\n+    final SerializationConfig config = prov.getConfig();\n+    BeanDescription beanDesc = config.introspect(origType);\n+    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+    if (ser != null) {\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    boolean staticTyping;\n+    // Next: we may have annotations that further define types to use...\n+    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+    if (type.equals(origType)) {\n+        // no changes, won't force static typing\n+        staticTyping = false;\n+    } else {\n+        // changes; assume static typing; plus, need to re-introspect if class differs\n+        staticTyping = true;\n+        if (!type.getRawClass().equals(origType.getRawClass())) {\n+            beanDesc = config.introspect(type);\n+        }\n+    }\n+    // Slight detour: do we have a Converter to consider?\n+    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n+    if (conv == null) {\n+        // no, simple\n+        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n+    }\n+    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n+    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n+    if (!delegateType.hasRawClass(type.getRawClass())) {\n+        beanDesc = config.introspect(delegateType);\n+        // [#359]: explicitly check (again) for @JsonSerializer...\n+        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n+        if (ser == null) {\n+            ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+        }\n+        return new StdDelegatingSerializer(conv, delegateType, ser);\n+    }\n+    // [databind#731]: Should skip if nominally java.lang.Object\n+    if (ser == null) {\n+        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n+    }\n+    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]