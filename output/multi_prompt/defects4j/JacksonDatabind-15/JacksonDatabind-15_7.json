[{"output": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n    if (_delegateSerializer != null) {\n        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n    } else {\n        super.acceptJsonFormatVisitor(visitor, typeHint);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -1,42 +1,9 @@\n @Override\n-@SuppressWarnings(\"unchecked\")\n-public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n-    // Very first thing, let's check if there is explicit serializer annotation:\n-    final SerializationConfig config = prov.getConfig();\n-    BeanDescription beanDesc = config.introspect(origType);\n-    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    if (ser != null) {\n-        return (JsonSerializer<Object>) ser;\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    boolean staticTyping;\n-    // Next: we may have annotations that further define types to use...\n-    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n-        // no changes, won't force static typing\n-        staticTyping = false;\n-    } else {\n-        // changes; assume static typing; plus, need to re-introspect if class differs\n-        staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n-            beanDesc = config.introspect(type);\n-        }\n-    }\n-    // Slight detour: do we have a Converter to consider?\n-    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n-    if (conv == null) {\n-        // no, simple\n-        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n-    }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n-    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n-        beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n-        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    }\n-    // [databind#731]: Should skip if nominally java.lang.Object\n-    if (ser == null) {\n-        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n-    }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,9 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n-        }\n-                delSer = provider.findValueSerializer(delegateType);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n-    }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,9 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,9 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,9 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,9 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,9 @@\n @Override\n public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n         // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    if (_delegateSerializer != null) {\n        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n    } else {\n        super.acceptJsonFormatVisitor(visitor, typeHint);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -1,42 +1,8 @@\n @Override\n-@SuppressWarnings(\"unchecked\")\n-public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n-    // Very first thing, let's check if there is explicit serializer annotation:\n-    final SerializationConfig config = prov.getConfig();\n-    BeanDescription beanDesc = config.introspect(origType);\n-    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    if (ser != null) {\n-        return (JsonSerializer<Object>) ser;\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    boolean staticTyping;\n-    // Next: we may have annotations that further define types to use...\n-    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n-        // no changes, won't force static typing\n-        staticTyping = false;\n-    } else {\n-        // changes; assume static typing; plus, need to re-introspect if class differs\n-        staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n-            beanDesc = config.introspect(type);\n-        }\n-    }\n-    // Slight detour: do we have a Converter to consider?\n-    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n-    if (conv == null) {\n-        // no, simple\n-        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n-    }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n-    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n-        beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n-        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    }\n-    // [databind#731]: Should skip if nominally java.lang.Object\n-    if (ser == null) {\n-        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n-    }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,8 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n-        }\n-                delSer = provider.findValueSerializer(delegateType);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n-    }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,8 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,8 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,8 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,8 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,8 @@\n @Override\n public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n        if (_delegateSerializer != null) {\n            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n        } else {\n            super.acceptJsonFormatVisitor(visitor, typeHint);\n        }\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -1,42 +1,8 @@\n @Override\n-@SuppressWarnings(\"unchecked\")\n-public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n-    // Very first thing, let's check if there is explicit serializer annotation:\n-    final SerializationConfig config = prov.getConfig();\n-    BeanDescription beanDesc = config.introspect(origType);\n-    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    if (ser != null) {\n-        return (JsonSerializer<Object>) ser;\n-    }\n-    boolean staticTyping;\n-    // Next: we may have annotations that further define types to use...\n-    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n-        // no changes, won't force static typing\n-        staticTyping = false;\n-    } else {\n-        // changes; assume static typing; plus, need to re-introspect if class differs\n-        staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n-            beanDesc = config.introspect(type);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        if (_delegateSerializer != null) {\n+            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        } else {\n+            super.acceptJsonFormatVisitor(visitor, typeHint);\n         }\n-    }\n-    // Slight detour: do we have a Converter to consider?\n-    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n-    if (conv == null) {\n-        // no, simple\n-        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n-    }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n-    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n-        beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n-        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    }\n-    // [databind#731]: Should skip if nominally java.lang.Object\n-    if (ser == null) {\n-        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n-    }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,8 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        if (_delegateSerializer != null) {\n+            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        } else {\n+            super.acceptJsonFormatVisitor(visitor, typeHint);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n-    }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n-    }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,8 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n-    }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        if (_delegateSerializer != null) {\n+            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        } else {\n+            super.acceptJsonFormatVisitor(visitor, typeHint);\n+        }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,8 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        if (_delegateSerializer != null) {\n+            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        } else {\n+            super.acceptJsonFormatVisitor(visitor, typeHint);\n+        }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,8 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        if (_delegateSerializer != null) {\n+            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        } else {\n+            super.acceptJsonFormatVisitor(visitor, typeHint);\n+        }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,8 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        if (_delegateSerializer != null) {\n+            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        } else {\n+            super.acceptJsonFormatVisitor(visitor, typeHint);\n+        }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,8 @@\n @Override\n public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        if (_delegateSerializer != null) {\n+            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        } else {\n+            super.acceptJsonFormatVisitor(visitor, typeHint);\n+        }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n    if (_delegateSerializer != null) {\n        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -1,42 +1,7 @@\n @Override\n-@SuppressWarnings(\"unchecked\")\n-public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n-    // Very first thing, let's check if there is explicit serializer annotation:\n-    final SerializationConfig config = prov.getConfig();\n-    BeanDescription beanDesc = config.introspect(origType);\n-    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    if (ser != null) {\n-        return (JsonSerializer<Object>) ser;\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    boolean staticTyping;\n-    // Next: we may have annotations that further define types to use...\n-    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n-        // no changes, won't force static typing\n-        staticTyping = false;\n-    } else {\n-        // changes; assume static typing; plus, need to re-introspect if class differs\n-        staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n-            beanDesc = config.introspect(type);\n-        }\n-    }\n-    // Slight detour: do we have a Converter to consider?\n-    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n-    if (conv == null) {\n-        // no, simple\n-        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n-    }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n-    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n-        beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n-        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    }\n-    // [databind#731]: Should skip if nominally java.lang.Object\n-    if (ser == null) {\n-        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n-    }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,7 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n-        }\n-                delSer = provider.findValueSerializer(delegateType);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n-    }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,7 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,7 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,7 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,7 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,7 @@\n @Override\n public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n         // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n        if (_delegateSerializer != null) {\n                _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n        } else {\n                super.acceptJsonFormatVisitor(visitor, typeHint);\n        }\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -1,42 +1,8 @@\n @Override\n-@SuppressWarnings(\"unchecked\")\n-public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n-    // Very first thing, let's check if there is explicit serializer annotation:\n-    final SerializationConfig config = prov.getConfig();\n-    BeanDescription beanDesc = config.introspect(origType);\n-    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    if (ser != null) {\n-        return (JsonSerializer<Object>) ser;\n-    }\n-    boolean staticTyping;\n-    // Next: we may have annotations that further define types to use...\n-    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n-        // no changes, won't force static typing\n-        staticTyping = false;\n-    } else {\n-        // changes; assume static typing; plus, need to re-introspect if class differs\n-        staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n-            beanDesc = config.introspect(type);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        if (_delegateSerializer != null) {\n+                _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        } else {\n+                super.acceptJsonFormatVisitor(visitor, typeHint);\n         }\n-    }\n-    // Slight detour: do we have a Converter to consider?\n-    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n-    if (conv == null) {\n-        // no, simple\n-        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n-    }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n-    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n-        beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n-        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    }\n-    // [databind#731]: Should skip if nominally java.lang.Object\n-    if (ser == null) {\n-        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n-    }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,8 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        if (_delegateSerializer != null) {\n+                _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        } else {\n+                super.acceptJsonFormatVisitor(visitor, typeHint);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n-    }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n-    }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,8 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n-    }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        if (_delegateSerializer != null) {\n+                _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        } else {\n+                super.acceptJsonFormatVisitor(visitor, typeHint);\n+        }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,8 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        if (_delegateSerializer != null) {\n+                _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        } else {\n+                super.acceptJsonFormatVisitor(visitor, typeHint);\n+        }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,8 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        if (_delegateSerializer != null) {\n+                _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        } else {\n+                super.acceptJsonFormatVisitor(visitor, typeHint);\n+        }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,8 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        if (_delegateSerializer != null) {\n+                _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        } else {\n+                super.acceptJsonFormatVisitor(visitor, typeHint);\n+        }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,8 @@\n @Override\n public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        if (_delegateSerializer != null) {\n+                _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        } else {\n+                super.acceptJsonFormatVisitor(visitor, typeHint);\n+        }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n   if (_delegateSerializer != null) {\n      _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n   } else {\n      super.acceptJsonFormatVisitor(visitor, typeHint);\n   }\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -1,42 +1,8 @@\n @Override\n-@SuppressWarnings(\"unchecked\")\n-public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n-    // Very first thing, let's check if there is explicit serializer annotation:\n-    final SerializationConfig config = prov.getConfig();\n-    BeanDescription beanDesc = config.introspect(origType);\n-    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    if (ser != null) {\n-        return (JsonSerializer<Object>) ser;\n-    }\n-    boolean staticTyping;\n-    // Next: we may have annotations that further define types to use...\n-    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n-        // no changes, won't force static typing\n-        staticTyping = false;\n-    } else {\n-        // changes; assume static typing; plus, need to re-introspect if class differs\n-        staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n-            beanDesc = config.introspect(type);\n-        }\n-    }\n-    // Slight detour: do we have a Converter to consider?\n-    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n-    if (conv == null) {\n-        // no, simple\n-        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n-    }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n-    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n-        beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n-        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    }\n-    // [databind#731]: Should skip if nominally java.lang.Object\n-    if (ser == null) {\n-        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n-    }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+   if (_delegateSerializer != null) {\n+      _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+   } else {\n+      super.acceptJsonFormatVisitor(visitor, typeHint);\n+   }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,8 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n-        }\n-                delSer = provider.findValueSerializer(delegateType);\n-    }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n-    }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+   if (_delegateSerializer != null) {\n+      _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+   } else {\n+      super.acceptJsonFormatVisitor(visitor, typeHint);\n+   }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,8 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n-    }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+   if (_delegateSerializer != null) {\n+      _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+   } else {\n+      super.acceptJsonFormatVisitor(visitor, typeHint);\n+   }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,8 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+   if (_delegateSerializer != null) {\n+      _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+   } else {\n+      super.acceptJsonFormatVisitor(visitor, typeHint);\n+   }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,8 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+   if (_delegateSerializer != null) {\n+      _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+   } else {\n+      super.acceptJsonFormatVisitor(visitor, typeHint);\n+   }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,8 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+   if (_delegateSerializer != null) {\n+      _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+   } else {\n+      super.acceptJsonFormatVisitor(visitor, typeHint);\n+   }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,8 @@\n @Override\n public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+   if (_delegateSerializer != null) {\n+      _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+   } else {\n+      super.acceptJsonFormatVisitor(visitor, typeHint);\n+   }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    if (_delegateSerializer != null) { // added null check\n        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -1,42 +1,6 @@\n @Override\n-@SuppressWarnings(\"unchecked\")\n-public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n-    // Very first thing, let's check if there is explicit serializer annotation:\n-    final SerializationConfig config = prov.getConfig();\n-    BeanDescription beanDesc = config.introspect(origType);\n-    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    if (ser != null) {\n-        return (JsonSerializer<Object>) ser;\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    if (_delegateSerializer != null) { // added null check\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    boolean staticTyping;\n-    // Next: we may have annotations that further define types to use...\n-    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n-        // no changes, won't force static typing\n-        staticTyping = false;\n-    } else {\n-        // changes; assume static typing; plus, need to re-introspect if class differs\n-        staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n-            beanDesc = config.introspect(type);\n-        }\n-    }\n-    // Slight detour: do we have a Converter to consider?\n-    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n-    if (conv == null) {\n-        // no, simple\n-        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n-    }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n-    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n-        beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n-        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    }\n-    // [databind#731]: Should skip if nominally java.lang.Object\n-    if (ser == null) {\n-        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n-    }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,6 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n-        }\n-                delSer = provider.findValueSerializer(delegateType);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    if (_delegateSerializer != null) { // added null check\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n-    }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,6 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    if (_delegateSerializer != null) { // added null check\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,6 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    if (_delegateSerializer != null) { // added null check\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,6 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    if (_delegateSerializer != null) { // added null check\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,6 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    if (_delegateSerializer != null) { // added null check\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,6 @@\n @Override\n public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    if (_delegateSerializer != null) { // added null check\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n    if (_delegateSerializer != null) {\n        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n    } else {\n        super.acceptJsonFormatVisitor(visitor, typeHint);\n    }\n }", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n        if (_delegateSerializer != null) {\n            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n        }\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -1,42 +1,6 @@\n @Override\n-@SuppressWarnings(\"unchecked\")\n-public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n-    // Very first thing, let's check if there is explicit serializer annotation:\n-    final SerializationConfig config = prov.getConfig();\n-    BeanDescription beanDesc = config.introspect(origType);\n-    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    if (ser != null) {\n-        return (JsonSerializer<Object>) ser;\n-    }\n-    boolean staticTyping;\n-    // Next: we may have annotations that further define types to use...\n-    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n-        // no changes, won't force static typing\n-        staticTyping = false;\n-    } else {\n-        // changes; assume static typing; plus, need to re-introspect if class differs\n-        staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n-            beanDesc = config.introspect(type);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        if (_delegateSerializer != null) {\n+            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n         }\n-    }\n-    // Slight detour: do we have a Converter to consider?\n-    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n-    if (conv == null) {\n-        // no, simple\n-        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n-    }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n-    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n-        beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n-        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    }\n-    // [databind#731]: Should skip if nominally java.lang.Object\n-    if (ser == null) {\n-        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n-    }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,6 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        if (_delegateSerializer != null) {\n+            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n         }\n-                delSer = provider.findValueSerializer(delegateType);\n-    }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n-    }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,6 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n-    }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        if (_delegateSerializer != null) {\n+            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,6 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        if (_delegateSerializer != null) {\n+            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,6 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        if (_delegateSerializer != null) {\n+            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,6 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+        if (_delegateSerializer != null) {\n+            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,6 @@\n @Override\n public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        if (_delegateSerializer != null) {\n+            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+        }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    // 02-Apr-2015, tatu: For dynamic case, very little we can do\n    if (_delegateSerializer != null) {\n        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n    } else {\n        super.acceptJsonFormatVisitor(visitor, typeHint);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -1,42 +1,9 @@\n @Override\n-@SuppressWarnings(\"unchecked\")\n-public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n-    // Very first thing, let's check if there is explicit serializer annotation:\n-    final SerializationConfig config = prov.getConfig();\n-    BeanDescription beanDesc = config.introspect(origType);\n-    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    if (ser != null) {\n-        return (JsonSerializer<Object>) ser;\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    boolean staticTyping;\n-    // Next: we may have annotations that further define types to use...\n-    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n-        // no changes, won't force static typing\n-        staticTyping = false;\n-    } else {\n-        // changes; assume static typing; plus, need to re-introspect if class differs\n-        staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n-            beanDesc = config.introspect(type);\n-        }\n-    }\n-    // Slight detour: do we have a Converter to consider?\n-    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n-    if (conv == null) {\n-        // no, simple\n-        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n-    }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n-    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n-        beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n-        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    }\n-    // [databind#731]: Should skip if nominally java.lang.Object\n-    if (ser == null) {\n-        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n-    }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,9 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n-        }\n-                delSer = provider.findValueSerializer(delegateType);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n-    }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,9 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,9 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,9 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,9 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,9 @@\n @Override\n public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    // 02-Apr-2015, tatu: For dynamic case, very little we can do\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    // Check if delegateSerializer is null\n    if (_delegateSerializer != null) {\n        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n    }\n    // If delegateSerializer is null, we cannot do anything for dynamic case\n    else {\n        super.acceptJsonFormatVisitor(visitor, typeHint);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -1,42 +1,11 @@\n @Override\n-@SuppressWarnings(\"unchecked\")\n-public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n-    // Very first thing, let's check if there is explicit serializer annotation:\n-    final SerializationConfig config = prov.getConfig();\n-    BeanDescription beanDesc = config.introspect(origType);\n-    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    if (ser != null) {\n-        return (JsonSerializer<Object>) ser;\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    // Check if delegateSerializer is null\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    boolean staticTyping;\n-    // Next: we may have annotations that further define types to use...\n-    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n-        // no changes, won't force static typing\n-        staticTyping = false;\n-    } else {\n-        // changes; assume static typing; plus, need to re-introspect if class differs\n-        staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n-            beanDesc = config.introspect(type);\n-        }\n+    // If delegateSerializer is null, we cannot do anything for dynamic case\n+    else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    // Slight detour: do we have a Converter to consider?\n-    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n-    if (conv == null) {\n-        // no, simple\n-        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n-    }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n-    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n-        beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n-        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    }\n-    // [databind#731]: Should skip if nominally java.lang.Object\n-    if (ser == null) {\n-        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n-    }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,11 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n-        }\n-                delSer = provider.findValueSerializer(delegateType);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    // Check if delegateSerializer is null\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n+    // If delegateSerializer is null, we cannot do anything for dynamic case\n+    else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,11 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    // Check if delegateSerializer is null\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n+    // If delegateSerializer is null, we cannot do anything for dynamic case\n+    else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,11 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    // Check if delegateSerializer is null\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n+    // If delegateSerializer is null, we cannot do anything for dynamic case\n+    else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,11 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    // Check if delegateSerializer is null\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n+    // If delegateSerializer is null, we cannot do anything for dynamic case\n+    else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,11 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    // Check if delegateSerializer is null\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n+    // If delegateSerializer is null, we cannot do anything for dynamic case\n+    else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,11 @@\n @Override\n public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    // Check if delegateSerializer is null\n+    if (_delegateSerializer != null) {\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n+    // If delegateSerializer is null, we cannot do anything for dynamic case\n+    else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n    if (_delegateSerializer != null) { // add null check to prevent NullPointerException\n        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n    } else {\n        super.acceptJsonFormatVisitor(visitor, typeHint); // fallback to super method\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@createSerializer\n@@ -1,42 +1,8 @@\n @Override\n-@SuppressWarnings(\"unchecked\")\n-public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException {\n-    // Very first thing, let's check if there is explicit serializer annotation:\n-    final SerializationConfig config = prov.getConfig();\n-    BeanDescription beanDesc = config.introspect(origType);\n-    JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    if (ser != null) {\n-        return (JsonSerializer<Object>) ser;\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    if (_delegateSerializer != null) { // add null check to prevent NullPointerException\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint); // fallback to super method\n     }\n-    boolean staticTyping;\n-    // Next: we may have annotations that further define types to use...\n-    JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-    if (type == origType) {\n-        // no changes, won't force static typing\n-        staticTyping = false;\n-    } else {\n-        // changes; assume static typing; plus, need to re-introspect if class differs\n-        staticTyping = true;\n-        if (!type.hasRawClass(origType.getRawClass())) {\n-            beanDesc = config.introspect(type);\n-        }\n-    }\n-    // Slight detour: do we have a Converter to consider?\n-    Converter<Object, Object> conv = beanDesc.findSerializationConverter();\n-    if (conv == null) {\n-        // no, simple\n-        return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping);\n-    }\n-    JavaType delegateType = conv.getOutputType(prov.getTypeFactory());\n-    // One more twist, as per [Issue#288]; probably need to get new BeanDesc\n-    if (!delegateType.hasRawClass(type.getRawClass())) {\n-        beanDesc = config.introspect(delegateType);\n-        // [#359]: explicitly check (again) for @JsonSerializer...\n-        ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n-    }\n-    // [databind#731]: Should skip if nominally java.lang.Object\n-    if (ser == null) {\n-        ser = _createSerializer2(prov, delegateType, beanDesc, true);\n-    }\n-    return new StdDelegatingSerializer(conv, delegateType, ser);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@createContextual\n@@ -1,16 +1,8 @@\n @Override\n-public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n-    JsonSerializer<?> delSer = _delegateSerializer;\n-    JavaType delegateType = _delegateType;\n-    if (delSer == null) {\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n-        }\n-                delSer = provider.findValueSerializer(delegateType);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    if (_delegateSerializer != null) { // add null check to prevent NullPointerException\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint); // fallback to super method\n     }\n-    if (delSer instanceof ContextualSerializer) {\n-        delSer = provider.handleSecondaryContextualization(delSer, property);\n-    }\n-    return (delSer == _delegateSerializer) ? this : withDelegate(_converter, delegateType, delSer);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serialize\n@@ -1,11 +1,8 @@\n @Override\n-public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {\n-    Object delegateValue = convertValue(value);\n-    // should we accept nulls?\n-    if (delegateValue == null) {\n-        provider.defaultSerializeNull(gen);\n-        return;\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    if (_delegateSerializer != null) { // add null check to prevent NullPointerException\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint); // fallback to super method\n     }\n-    // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup\n-    _delegateSerializer.serialize(delegateValue, gen, provider);\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@serializeWithType\n@@ -1,5 +1,8 @@\n @Override\n-public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n-        Object delegateValue = convertValue(value);\n-    _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    if (_delegateSerializer != null) { // add null check to prevent NullPointerException\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint); // fallback to super method\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty\n@@ -1,7 +1,8 @@\n @Override\n-// since 2.5\n-@Deprecated\n-public boolean isEmpty(Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    if (_delegateSerializer != null) { // add null check to prevent NullPointerException\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint); // fallback to super method\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@isEmpty4\n@@ -1,5 +1,8 @@\n @Override\n-public boolean isEmpty(SerializerProvider prov, Object value) {\n-    Object delegateValue = convertValue(value);\n-    return _delegateSerializer.isEmpty(prov, delegateValue);\n+public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n+    if (_delegateSerializer != null) { // add null check to prevent NullPointerException\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint); // fallback to super method\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n+++ com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java@acceptJsonFormatVisitor\n@@ -1,5 +1,8 @@\n @Override\n public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-        // 02-Apr-2015, tatu: For dynamic case, very little we can do\n-    _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    if (_delegateSerializer != null) { // add null check to prevent NullPointerException\n+        _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);\n+    } else {\n+        super.acceptJsonFormatVisitor(visitor, typeHint); // fallback to super method\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]