[{"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                char lastChar = code.charAt(length - 1);\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                // Fix: Only add semi-colon if last character is not a newline\n                boolean hasSemiColon = lastChar == ';' || (lastChar != '\\n' && secondLastChar == ';');\n                if (!hasSemiColon) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -34,7 +34,8 @@\n                 int length = code.length();\n                 char lastChar = code.charAt(length - 1);\n                 char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                // Fix: Only add semi-colon if last character is not a newline\n+                boolean hasSemiColon = lastChar == ';' || (lastChar != '\\n' && secondLastChar == ';');\n                 if (!hasSemiColon) {\n                     cb.append(\";\");\n                 }\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,43 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+                // In order to avoid parse ambiguity when files are concatenated\n+                // together, all files should end in a semi-colon. Do a quick\n+                // heuristic check if there's an obvious semi-colon already there.\n+                int length = code.length();\n+                char lastChar = code.charAt(length - 1);\n+                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n+                // Fix: Only add semi-colon if last character is not a newline\n+                boolean hasSemiColon = lastChar == ';' || (lastChar != '\\n' && secondLastChar == ';');\n+                if (!hasSemiColon) {\n+                    cb.append(\";\");\n+                }\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                char lastChar = code.charAt(length - 1);\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                cb.append(code);\n                if (!hasSemiColon) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -27,7 +27,6 @@\n             // for the first input file\n             String code = toSource(root, sourceMap);\n             if (!code.isEmpty()) {\n-                cb.append(code);\n                 // In order to avoid parse ambiguity when files are concatenated\n                 // together, all files should end in a semi-colon. Do a quick\n                 // heuristic check if there's an obvious semi-colon already there.\n@@ -35,6 +34,7 @@\n                 char lastChar = code.charAt(length - 1);\n                 char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                 boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                cb.append(code);\n                 if (!hasSemiColon) {\n                     cb.append(\";\");\n                 }\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,42 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                // In order to avoid parse ambiguity when files are concatenated\n+                // together, all files should end in a semi-colon. Do a quick\n+                // heuristic check if there's an obvious semi-colon already there.\n+                int length = code.length();\n+                char lastChar = code.charAt(length - 1);\n+                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n+                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                cb.append(code);\n+                if (!hasSemiColon) {\n+                    cb.append(\";\");\n+                }\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                char lastChar = code.charAt(length - 1);\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                if (!hasSemiColon) {\n                    cb.append(\";\");\n                }\n            } else {\n                // Ensure that the delimiter is still added even if there is no code to append\n                if (options.printInputDelimiter) {\n                    cb.append(options.inputDelimiter).append(\"\\n\");\n                }\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -38,6 +38,11 @@\n                 if (!hasSemiColon) {\n                     cb.append(\";\");\n                 }\n+            } else {\n+                // Ensure that the delimiter is still added even if there is no code to append\n+                if (options.printInputDelimiter) {\n+                    cb.append(options.inputDelimiter).append(\"\\n\");\n+                }\n             }\n             return null;\n         }\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,47 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+                // In order to avoid parse ambiguity when files are concatenated\n+                // together, all files should end in a semi-colon. Do a quick\n+                // heuristic check if there's an obvious semi-colon already there.\n+                int length = code.length();\n+                char lastChar = code.charAt(length - 1);\n+                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n+                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                if (!hasSemiColon) {\n+                    cb.append(\";\");\n+                }\n+            } else {\n+                // Ensure that the delimiter is still added even if there is no code to append\n+                if (options.printInputDelimiter) {\n+                    cb.append(options.inputDelimiter).append(\"\\n\");\n+                }\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                char lastChar = code.charAt(length - 1);\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                if (!hasSemiColon && root.getNext() != null) {\n                    // Only add semicolon if there is another node following this one\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -35,7 +35,8 @@\n                 char lastChar = code.charAt(length - 1);\n                 char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                 boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-                if (!hasSemiColon) {\n+                if (!hasSemiColon && root.getNext() != null) {\n+                    // Only add semicolon if there is another node following this one\n                     cb.append(\";\");\n                 }\n             }\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,43 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+                // In order to avoid parse ambiguity when files are concatenated\n+                // together, all files should end in a semi-colon. Do a quick\n+                // heuristic check if there's an obvious semi-colon already there.\n+                int length = code.length();\n+                char lastChar = code.charAt(length - 1);\n+                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n+                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                if (!hasSemiColon && root.getNext() != null) {\n+                    // Only add semicolon if there is another node following this one\n+                    cb.append(\";\");\n+                }\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                char lastChar = code.charAt(length - 1);\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                if (!hasSemiColon && root.getLastChild() != null) {\n                    // Append semicolon for all nodes except the last one.\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -35,7 +35,8 @@\n                 char lastChar = code.charAt(length - 1);\n                 char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                 boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-                if (!hasSemiColon) {\n+                if (!hasSemiColon && root.getLastChild() != null) {\n+                    // Append semicolon for all nodes except the last one.\n                     cb.append(\";\");\n                 }\n             }\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,43 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+                // In order to avoid parse ambiguity when files are concatenated\n+                // together, all files should end in a semi-colon. Do a quick\n+                // heuristic check if there's an obvious semi-colon already there.\n+                int length = code.length();\n+                char lastChar = code.charAt(length - 1);\n+                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n+                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                if (!hasSemiColon && root.getLastChild() != null) {\n+                    // Append semicolon for all nodes except the last one.\n+                    cb.append(\";\");\n+                }\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.get().setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                char lastChar = code.charAt(length - 1);\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                if (!hasSemiColon) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -21,7 +21,7 @@\n             // If there is a valid source map, then indicate to it that the current\n             // root node's mappings are offset by the given string builder buffer.\n             if (options.sourceMapOutputPath != null) {\n-                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+                sourceMap.get().setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n             }\n             // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n             // for the first input file\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,42 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.get().setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+                // In order to avoid parse ambiguity when files are concatenated\n+                // together, all files should end in a semi-colon. Do a quick\n+                // heuristic check if there's an obvious semi-colon already there.\n+                int length = code.length();\n+                char lastChar = code.charAt(length - 1);\n+                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n+                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                if (!hasSemiColon) {\n+                    cb.append(\";\");\n+                }\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.setStartingPosition(cb.getLineIndex() + 1, 0); //Fix Offset by adding 1 to line index\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                char lastChar = code.charAt(length - 1);\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                if (!hasSemiColon) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -21,7 +21,7 @@\n             // If there is a valid source map, then indicate to it that the current\n             // root node's mappings are offset by the given string builder buffer.\n             if (options.sourceMapOutputPath != null) {\n-                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+                sourceMap.setStartingPosition(cb.getLineIndex() + 1, 0); //Fix Offset by adding 1 to line index\n             }\n             // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n             // for the first input file\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,42 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.setStartingPosition(cb.getLineIndex() + 1, 0); //Fix Offset by adding 1 to line index\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+                // In order to avoid parse ambiguity when files are concatenated\n+                // together, all files should end in a semi-colon. Do a quick\n+                // heuristic check if there's an obvious semi-colon already there.\n+                int length = code.length();\n+                char lastChar = code.charAt(length - 1);\n+                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n+                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                if (!hasSemiColon) {\n+                    cb.append(\";\");\n+                }\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                if (length == 1) {\n                    char lastChar = code.charAt(length - 1);\n                    boolean hasSemiColon = lastChar == ';';\n                    if (!hasSemiColon) {\n                        cb.append(\";\");\n                    }\n                } else if (length >= 2) {\n                    char lastChar = code.charAt(length - 1);\n                    char secondLastChar = code.charAt(length - 2);\n                    boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                    if (!hasSemiColon) {\n                        cb.append(\";\");\n                    }\n                }\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -32,11 +32,19 @@\n                 // together, all files should end in a semi-colon. Do a quick\n                 // heuristic check if there's an obvious semi-colon already there.\n                 int length = code.length();\n-                char lastChar = code.charAt(length - 1);\n-                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-                if (!hasSemiColon) {\n-                    cb.append(\";\");\n+                if (length == 1) {\n+                    char lastChar = code.charAt(length - 1);\n+                    boolean hasSemiColon = lastChar == ';';\n+                    if (!hasSemiColon) {\n+                        cb.append(\";\");\n+                    }\n+                } else if (length >= 2) {\n+                    char lastChar = code.charAt(length - 1);\n+                    char secondLastChar = code.charAt(length - 2);\n+                    boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                    if (!hasSemiColon) {\n+                        cb.append(\";\");\n+                    }\n                 }\n             }\n             return null;\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,50 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+                // In order to avoid parse ambiguity when files are concatenated\n+                // together, all files should end in a semi-colon. Do a quick\n+                // heuristic check if there's an obvious semi-colon already there.\n+                int length = code.length();\n+                if (length == 1) {\n+                    char lastChar = code.charAt(length - 1);\n+                    boolean hasSemiColon = lastChar == ';';\n+                    if (!hasSemiColon) {\n+                        cb.append(\";\");\n+                    }\n+                } else if (length >= 2) {\n+                    char lastChar = code.charAt(length - 1);\n+                    char secondLastChar = code.charAt(length - 2);\n+                    boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                    if (!hasSemiColon) {\n+                        cb.append(\";\");\n+                    }\n+                }\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                char lastChar = code.charAt(length - 1);\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                if (!hasSemiColon && root.getLastChild() != null &&\n                    (root.getLastChild().isExprResult()\n                     || root.getLastChild().isReturn())) {\n                    // If the last child is an expression statement or return statement, then\n                    // no need to append a semi-colon, since both these statements don't require it.\n                } else {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -35,7 +35,12 @@\n                 char lastChar = code.charAt(length - 1);\n                 char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                 boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-                if (!hasSemiColon) {\n+                if (!hasSemiColon && root.getLastChild() != null &&\n+                    (root.getLastChild().isExprResult()\n+                     || root.getLastChild().isReturn())) {\n+                    // If the last child is an expression statement or return statement, then\n+                    // no need to append a semi-colon, since both these statements don't require it.\n+                } else {\n                     cb.append(\";\");\n                 }\n             }\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,47 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+                // In order to avoid parse ambiguity when files are concatenated\n+                // together, all files should end in a semi-colon. Do a quick\n+                // heuristic check if there's an obvious semi-colon already there.\n+                int length = code.length();\n+                char lastChar = code.charAt(length - 1);\n+                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n+                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                if (!hasSemiColon && root.getLastChild() != null &&\n+                    (root.getLastChild().isExprResult()\n+                     || root.getLastChild().isReturn())) {\n+                    // If the last child is an expression statement or return statement, then\n+                    // no need to append a semi-colon, since both these statements don't require it.\n+                } else {\n+                    cb.append(\";\");\n+                }\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if (cb.getLength() > 0 && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null && sourceMap != null) { // fixed line\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                char lastChar = code.charAt(length - 1);\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                if (!hasSemiColon) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -3,7 +3,7 @@\n \n         public Void call() throws Exception {\n             if (options.printInputDelimiter) {\n-                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                if (cb.getLength() > 0 && !cb.endsWith(\"\\n\")) {\n                     // Make sure that the label starts on a new line\n                     cb.append(\"\\n\");\n                 }\n@@ -20,7 +20,7 @@\n             }\n             // If there is a valid source map, then indicate to it that the current\n             // root node's mappings are offset by the given string builder buffer.\n-            if (options.sourceMapOutputPath != null) {\n+            if (options.sourceMapOutputPath != null && sourceMap != null) { // fixed line\n                 sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n             }\n             // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,42 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if (cb.getLength() > 0 && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null && sourceMap != null) { // fixed line\n+                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+                // In order to avoid parse ambiguity when files are concatenated\n+                // together, all files should end in a semi-colon. Do a quick\n+                // heuristic check if there's an obvious semi-colon already there.\n+                int length = code.length();\n+                char lastChar = code.charAt(length - 1);\n+                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n+                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                if (!hasSemiColon) {\n+                    cb.append(\";\");\n+                }\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                char lastChar = code.charAt(length - 1);\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                if (!hasSemiColon && root.getLastChild().getType() != Token.EXPR_RESULT && root.getLastChild().getType() != Token.RETURN) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -35,7 +35,7 @@\n                 char lastChar = code.charAt(length - 1);\n                 char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                 boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-                if (!hasSemiColon) {\n+                if (!hasSemiColon && root.getLastChild().getType() != Token.EXPR_RESULT && root.getLastChild().getType() != Token.RETURN) {\n                     cb.append(\";\");\n                 }\n             }\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,42 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+                // In order to avoid parse ambiguity when files are concatenated\n+                // together, all files should end in a semi-colon. Do a quick\n+                // heuristic check if there's an obvious semi-colon already there.\n+                int length = code.length();\n+                char lastChar = code.charAt(length - 1);\n+                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n+                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                if (!hasSemiColon && root.getLastChild().getType() != Token.EXPR_RESULT && root.getLastChild().getType() != Token.RETURN) {\n+                    cb.append(\";\");\n+                }\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.addMapping(new SourceMap.Mapping(cb.getLineIndex(), cb.getColumnIndex()));\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                char lastChar = code.charAt(length - 1);\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                if (!hasSemiColon) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -21,7 +21,7 @@\n             // If there is a valid source map, then indicate to it that the current\n             // root node's mappings are offset by the given string builder buffer.\n             if (options.sourceMapOutputPath != null) {\n-                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+                sourceMap.addMapping(new SourceMap.Mapping(cb.getLineIndex(), cb.getColumnIndex()));\n             }\n             // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n             // for the first input file\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,42 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.addMapping(new SourceMap.Mapping(cb.getLineIndex(), cb.getColumnIndex()));\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+                // In order to avoid parse ambiguity when files are concatenated\n+                // together, all files should end in a semi-colon. Do a quick\n+                // heuristic check if there's an obvious semi-colon already there.\n+                int length = code.length();\n+                char lastChar = code.charAt(length - 1);\n+                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n+                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                if (!hasSemiColon) {\n+                    cb.append(\";\");\n+                }\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                char lastChar = code.charAt(length - 1);\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                if (!hasSemiColon && root.getLastChild().getType() != Token.BLOCK) {\n                // if the last character of the code is not ';' and the last child is not a block,\n                // append a semi-colon to the code\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -35,7 +35,9 @@\n                 char lastChar = code.charAt(length - 1);\n                 char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                 boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-                if (!hasSemiColon) {\n+                if (!hasSemiColon && root.getLastChild().getType() != Token.BLOCK) {\n+                // if the last character of the code is not ';' and the last child is not a block,\n+                // append a semi-colon to the code\n                     cb.append(\";\");\n                 }\n             }\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,44 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+                // In order to avoid parse ambiguity when files are concatenated\n+                // together, all files should end in a semi-colon. Do a quick\n+                // heuristic check if there's an obvious semi-colon already there.\n+                int length = code.length();\n+                char lastChar = code.charAt(length - 1);\n+                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n+                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                if (!hasSemiColon && root.getLastChild().getType() != Token.BLOCK) {\n+                // if the last character of the code is not ';' and the last child is not a block,\n+                // append a semi-colon to the code\n+                    cb.append(\";\");\n+                }\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                char lastChar = code.charAt(length - 1);\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                if (!hasSemiColon && !code.endsWith(\"}\")) { // added check for ending with '}'\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -35,7 +35,7 @@\n                 char lastChar = code.charAt(length - 1);\n                 char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                 boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-                if (!hasSemiColon) {\n+                if (!hasSemiColon && !code.endsWith(\"}\")) { // added check for ending with '}'\n                     cb.append(\";\");\n                 }\n             }\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,42 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+                // In order to avoid parse ambiguity when files are concatenated\n+                // together, all files should end in a semi-colon. Do a quick\n+                // heuristic check if there's an obvious semi-colon already there.\n+                int length = code.length();\n+                char lastChar = code.charAt(length - 1);\n+                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n+                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                if (!hasSemiColon && !code.endsWith(\"}\")) { // added check for ending with '}'\n+                    cb.append(\";\");\n+                }\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.addMapping(\n                    new SourceMap.LineAndColumn(\n                        cb.getLineIndex(), \n                        cb.getColumnIndex())\n                    );\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                char lastChar = code.charAt(length - 1);\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                if (!hasSemiColon) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -21,7 +21,11 @@\n             // If there is a valid source map, then indicate to it that the current\n             // root node's mappings are offset by the given string builder buffer.\n             if (options.sourceMapOutputPath != null) {\n-                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+                sourceMap.addMapping(\n+                    new SourceMap.LineAndColumn(\n+                        cb.getLineIndex(), \n+                        cb.getColumnIndex())\n+                    );\n             }\n             // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n             // for the first input file\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,46 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.addMapping(\n+                    new SourceMap.LineAndColumn(\n+                        cb.getLineIndex(), \n+                        cb.getColumnIndex())\n+                    );\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+                // In order to avoid parse ambiguity when files are concatenated\n+                // together, all files should end in a semi-colon. Do a quick\n+                // heuristic check if there's an obvious semi-colon already there.\n+                int length = code.length();\n+                char lastChar = code.charAt(length - 1);\n+                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n+                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                if (!hasSemiColon) {\n+                    cb.append(\";\");\n+                }\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                char lastChar = code.charAt(length - 1);\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                if (!hasSemiColon && !root.getLastChild().matchesQualifiedName(\"goog.module\")) { // fix here\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -35,7 +35,7 @@\n                 char lastChar = code.charAt(length - 1);\n                 char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                 boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-                if (!hasSemiColon) {\n+                if (!hasSemiColon && !root.getLastChild().matchesQualifiedName(\"goog.module\")) { // fix here\n                     cb.append(\";\");\n                 }\n             }\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,42 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+                // In order to avoid parse ambiguity when files are concatenated\n+                // together, all files should end in a semi-colon. Do a quick\n+                // heuristic check if there's an obvious semi-colon already there.\n+                int length = code.length();\n+                char lastChar = code.charAt(length - 1);\n+                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n+                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                if (!hasSemiColon && !root.getLastChild().matchesQualifiedName(\"goog.module\")) { // fix here\n+                    cb.append(\";\");\n+                }\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getIndex());\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                char lastChar = code.charAt(length - 1);\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                if (!hasSemiColon) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -21,7 +21,7 @@\n             // If there is a valid source map, then indicate to it that the current\n             // root node's mappings are offset by the given string builder buffer.\n             if (options.sourceMapOutputPath != null) {\n-                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getIndex());\n             }\n             // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n             // for the first input file\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,42 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getIndex());\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+                // In order to avoid parse ambiguity when files are concatenated\n+                // together, all files should end in a semi-colon. Do a quick\n+                // heuristic check if there's an obvious semi-colon already there.\n+                int length = code.length();\n+                char lastChar = code.charAt(length - 1);\n+                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n+                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                if (!hasSemiColon) {\n+                    cb.append(\";\");\n+                }\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n                // In order to avoid parse ambiguity when files are concatenated\n                // together, all files should end in a semi-colon. Do a quick\n                // heuristic check if there's an obvious semi-colon already there.\n                int length = code.length();\n                char lastChar = code.charAt(length - 1);\n                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                if (!hasSemiColon && root.getLastChild().getType() != Token.BLOCK) {\n                    cb.append(\";\");\n                }\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -35,7 +35,7 @@\n                 char lastChar = code.charAt(length - 1);\n                 char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n                 boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-                if (!hasSemiColon) {\n+                if (!hasSemiColon && root.getLastChild().getType() != Token.BLOCK) {\n                     cb.append(\";\");\n                 }\n             }\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,42 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+                // In order to avoid parse ambiguity when files are concatenated\n+                // together, all files should end in a semi-colon. Do a quick\n+                // heuristic check if there's an obvious semi-colon already there.\n+                int length = code.length();\n+                char lastChar = code.charAt(length - 1);\n+                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n+                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                if (!hasSemiColon && root.getLastChild().getType() != Token.BLOCK) {\n+                    cb.append(\";\");\n+                }\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                cb.append(code);\n            }\n            // In order to avoid parse ambiguity when files are concatenated\n            // together, all files should end in a semi-colon. Do a quick\n            // heuristic check if there's an obvious semi-colon already there.\n            int length = cb.getLength();\n            if (length == 0 || cb.charAt(length - 1) != ';') {\n                cb.append(';');\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -28,16 +28,13 @@\n             String code = toSource(root, sourceMap);\n             if (!code.isEmpty()) {\n                 cb.append(code);\n-                // In order to avoid parse ambiguity when files are concatenated\n-                // together, all files should end in a semi-colon. Do a quick\n-                // heuristic check if there's an obvious semi-colon already there.\n-                int length = code.length();\n-                char lastChar = code.charAt(length - 1);\n-                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-                if (!hasSemiColon) {\n-                    cb.append(\";\");\n-                }\n+            }\n+            // In order to avoid parse ambiguity when files are concatenated\n+            // together, all files should end in a semi-colon. Do a quick\n+            // heuristic check if there's an obvious semi-colon already there.\n+            int length = cb.getLength();\n+            if (length == 0 || cb.charAt(length - 1) != ';') {\n+                cb.append(';');\n             }\n             return null;\n         }\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,39 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                cb.append(code);\n+            }\n+            // In order to avoid parse ambiguity when files are concatenated\n+            // together, all files should end in a semi-colon. Do a quick\n+            // heuristic check if there's an obvious semi-colon already there.\n+            int length = cb.getLength();\n+            if (length == 0 || cb.charAt(length - 1) != ';') {\n+                cb.append(';');\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public void toSource(final CodeBuilder cb, final int inputSeqNum, final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n\n        public Void call() throws Exception {\n            if (options.printInputDelimiter) {\n                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n                    // Make sure that the label starts on a new line\n                    cb.append(\"\\n\");\n                }\n                Preconditions.checkState(root.getType() == Token.SCRIPT);\n                String delimiter = options.inputDelimiter;\n                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n                Preconditions.checkState(sourceName != null);\n                Preconditions.checkState(!sourceName.isEmpty());\n                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n                cb.append(delimiter).append(\"\\n\");\n            }\n            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n            }\n            // If there is a valid source map, then indicate to it that the current\n            // root node's mappings are offset by the given string builder buffer.\n            if (options.sourceMapOutputPath != null) {\n                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n            }\n            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n            // for the first input file\n            String code = toSource(root, sourceMap);\n            if (!code.isEmpty()) {\n                if (cb.getLength() > 0) {\n                    // In order to avoid parse ambiguity when files are concatenated\n                    // together, all files should end in a semi-colon. Do a quick\n                    // heuristic check if there's an obvious semi-colon already there.\n                    int length = cb.getLength();\n                    char lastChar = cb.charAt(length - 1);\n                    char secondLastChar = length >= 2 ? cb.charAt(length - 2) : '\\0';\n                    boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n                    if (!hasSemiColon) {\n                        cb.append(\";\");\n                    }\n                }\n                cb.append(code);\n            }\n            return null;\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@toSource\n+++ com/google/javascript/jscomp/Compiler.java@toSource\n@@ -27,17 +27,19 @@\n             // for the first input file\n             String code = toSource(root, sourceMap);\n             if (!code.isEmpty()) {\n+                if (cb.getLength() > 0) {\n+                    // In order to avoid parse ambiguity when files are concatenated\n+                    // together, all files should end in a semi-colon. Do a quick\n+                    // heuristic check if there's an obvious semi-colon already there.\n+                    int length = cb.getLength();\n+                    char lastChar = cb.charAt(length - 1);\n+                    char secondLastChar = length >= 2 ? cb.charAt(length - 2) : '\\0';\n+                    boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                    if (!hasSemiColon) {\n+                        cb.append(\";\");\n+                    }\n+                }\n                 cb.append(code);\n-                // In order to avoid parse ambiguity when files are concatenated\n-                // together, all files should end in a semi-colon. Do a quick\n-                // heuristic check if there's an obvious semi-colon already there.\n-                int length = code.length();\n-                char lastChar = code.charAt(length - 1);\n-                char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-                boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-                if (!hasSemiColon) {\n-                    cb.append(\";\");\n-                }\n             }\n             return null;\n         }\n--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -1,40 +1,44 @@\n public Void call() throws Exception {\n-    if (options.printInputDelimiter) {\n-        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n-            // Make sure that the label starts on a new line\n-            cb.append(\"\\n\");\n+            if (options.printInputDelimiter) {\n+                if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n+                    // Make sure that the label starts on a new line\n+                    cb.append(\"\\n\");\n+                }\n+                Preconditions.checkState(root.getType() == Token.SCRIPT);\n+                String delimiter = options.inputDelimiter;\n+                String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n+                Preconditions.checkState(sourceName != null);\n+                Preconditions.checkState(!sourceName.isEmpty());\n+                delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n+                cb.append(delimiter).append(\"\\n\");\n+            }\n+            if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n+                cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n+            }\n+            // If there is a valid source map, then indicate to it that the current\n+            // root node's mappings are offset by the given string builder buffer.\n+            if (options.sourceMapOutputPath != null) {\n+                sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+            }\n+            // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n+            // for the first input file\n+            String code = toSource(root, sourceMap);\n+            if (!code.isEmpty()) {\n+                if (cb.getLength() > 0) {\n+                    // In order to avoid parse ambiguity when files are concatenated\n+                    // together, all files should end in a semi-colon. Do a quick\n+                    // heuristic check if there's an obvious semi-colon already there.\n+                    int length = cb.getLength();\n+                    char lastChar = cb.charAt(length - 1);\n+                    char secondLastChar = length >= 2 ? cb.charAt(length - 2) : '\\0';\n+                    boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+                    if (!hasSemiColon) {\n+                        cb.append(\";\");\n+                    }\n+                }\n+                cb.append(code);\n+            }\n+            return null;\n         }\n-        Preconditions.checkState(root.getType() == Token.SCRIPT);\n-        String delimiter = options.inputDelimiter;\n-        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n-        Preconditions.checkState(sourceName != null);\n-        Preconditions.checkState(!sourceName.isEmpty());\n-        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n-        cb.append(delimiter).append(\"\\n\");\n-    }\n-    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n-        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n-    }\n-    // If there is a valid source map, then indicate to it that the current\n-    // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n-    }\n-    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n-    // for the first input file\n-    String code = toSource(root, sourceMap);\n-    if (!code.isEmpty()) {\n-        cb.append(code);\n-        // In order to avoid parse ambiguity when files are concatenated\n-        // together, all files should end in a semi-colon. Do a quick\n-        // heuristic check if there's an obvious semi-colon already there.\n-        int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n-            cb.append(\";\");\n-        }\n-    }\n-    return null;\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]