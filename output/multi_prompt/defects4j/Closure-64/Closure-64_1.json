[{"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getLength() - cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        if (!hasSemiColon) {\n            cb.append(\";\");\n        }\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -18,7 +18,7 @@\n     // If there is a valid source map, then indicate to it that the current\n     // root node's mappings are offset by the given string builder buffer.\n     if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getLength() - cb.getColumnIndex());\n     }\n     // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n     // for the first input file\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        if (!hasSemiColon && lastChar != '}') { // Add a semi-colon if it's not already there and the last character is not a closing brace\n            cb.append(\";\");\n        }\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -32,7 +32,7 @@\n         char lastChar = code.charAt(length - 1);\n         char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n         boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n+        if (!hasSemiColon && lastChar != '}') { // Add a semi-colon if it's not already there and the last character is not a closing brace\n             cb.append(\";\");\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        if (lastChar != ';') {\n            cb.append(\";\");\n        } else if (length > 1 && code.charAt(length - 2) == '\\n') {\n            cb.deleteCharAt(length - 2);\n            cb.append(\";\");\n        }\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -30,9 +30,10 @@\n         // heuristic check if there's an obvious semi-colon already there.\n         int length = code.length();\n         char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n+        if (lastChar != ';') {\n+            cb.append(\";\");\n+        } else if (length > 1 && code.charAt(length - 2) == '\\n') {\n+            cb.deleteCharAt(length - 2);\n             cb.append(\";\");\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        if (!hasSemiColon && lastChar != '}') { // add a semicolon if the last character is not a } (to prevent breaking for loops)\n            cb.append(\";\");\n        }\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -32,7 +32,7 @@\n         char lastChar = code.charAt(length - 1);\n         char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n         boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n+        if (!hasSemiColon && lastChar != '}') { // add a semicolon if the last character is not a } (to prevent breaking for loops)\n             cb.append(\";\");\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        if (!hasSemiColon && lastChar != '}') { // check if last char is also not '}'\n            cb.append(\";\");\n        }\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -32,7 +32,7 @@\n         char lastChar = code.charAt(length - 1);\n         char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n         boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n+        if (!hasSemiColon && lastChar != '}') { // check if last char is also not '}'\n             cb.append(\";\");\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        if (!hasSemiColon && !code.endsWith(\"}\")) { // add this condition to avoid adding semicolon after functions etc.\n            cb.append(\";\");\n        }\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -32,7 +32,7 @@\n         char lastChar = code.charAt(length - 1);\n         char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n         boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n+        if (!hasSemiColon && !code.endsWith(\"}\")) { // add this condition to avoid adding semicolon after functions etc.\n             cb.append(\";\");\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null && sourceMap != null) { // Fix: check if sourceMap is not null before accessing it\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        if (!hasSemiColon) {\n            cb.append(\";\");\n        }\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -17,7 +17,7 @@\n     }\n     // If there is a valid source map, then indicate to it that the current\n     // root node's mappings are offset by the given string builder buffer.\n-    if (options.sourceMapOutputPath != null) {\n+    if (options.sourceMapOutputPath != null && sourceMap != null) { // Fix: check if sourceMap is not null before accessing it\n         sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n     }\n     // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = length >= 1 ? code.charAt(length - 1) : '\\0';\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        cb.append(code);\n        if (!hasSemiColon) {\n            cb.append(\";\");\n        }\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -24,14 +24,14 @@\n     // for the first input file\n     String code = toSource(root, sourceMap);\n     if (!code.isEmpty()) {\n-        cb.append(code);\n         // In order to avoid parse ambiguity when files are concatenated\n         // together, all files should end in a semi-colon. Do a quick\n         // heuristic check if there's an obvious semi-colon already there.\n         int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n+        char lastChar = length >= 1 ? code.charAt(length - 1) : '\\0';\n         char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n         boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+        cb.append(code);\n         if (!hasSemiColon) {\n             cb.append(\";\");\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        if (!hasSemiColon && lastChar != '}') { // add a semi-colon if code does not end with a } or ;\n            cb.append(\";\");\n        }\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -32,7 +32,7 @@\n         char lastChar = code.charAt(length - 1);\n         char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n         boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n+        if (!hasSemiColon && lastChar != '}') { // add a semi-colon if code does not end with a } or ;\n             cb.append(\";\");\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = length > 0 ? code.charAt(length - 1) : '\\0';\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        cb.append(code);\n        if (!hasSemiColon) {\n            cb.append(\";\");\n        }\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -24,14 +24,14 @@\n     // for the first input file\n     String code = toSource(root, sourceMap);\n     if (!code.isEmpty()) {\n-        cb.append(code);\n         // In order to avoid parse ambiguity when files are concatenated\n         // together, all files should end in a semi-colon. Do a quick\n         // heuristic check if there's an obvious semi-colon already there.\n         int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n+        char lastChar = length > 0 ? code.charAt(length - 1) : '\\0';\n         char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n         boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+        cb.append(code);\n         if (!hasSemiColon) {\n             cb.append(\";\");\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex() + 1, 0); // Fixed line index to start at 1 instead of 0\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        if (!hasSemiColon) {\n            cb.append(\";\");\n        }\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -18,7 +18,7 @@\n     // If there is a valid source map, then indicate to it that the current\n     // root node's mappings are offset by the given string builder buffer.\n     if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+        sourceMap.setStartingPosition(cb.getLineIndex() + 1, 0); // Fixed line index to start at 1 instead of 0\n     }\n     // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n     // for the first input file\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        if (!hasSemiColon) {\n            cb.append(\";\");\n        }\n    }\n    return null;\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = '\\0';\n        char secondLastChar = '\\0';\n        if (length >= 1) {\n            lastChar = code.charAt(length - 1);\n        }\n        if (length >= 2) {\n            secondLastChar = code.charAt(length - 2);\n        }\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        if (!hasSemiColon) {\n            cb.append(code).append(\";\");\n        } else {\n            cb.append(code);\n        }\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -24,16 +24,23 @@\n     // for the first input file\n     String code = toSource(root, sourceMap);\n     if (!code.isEmpty()) {\n-        cb.append(code);\n         // In order to avoid parse ambiguity when files are concatenated\n         // together, all files should end in a semi-colon. Do a quick\n         // heuristic check if there's an obvious semi-colon already there.\n         int length = code.length();\n-        char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n+        char lastChar = '\\0';\n+        char secondLastChar = '\\0';\n+        if (length >= 1) {\n+            lastChar = code.charAt(length - 1);\n+        }\n+        if (length >= 2) {\n+            secondLastChar = code.charAt(length - 2);\n+        }\n         boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n         if (!hasSemiColon) {\n-            cb.append(\";\");\n+            cb.append(code).append(\";\");\n+        } else {\n+            cb.append(code);\n         }\n     }\n     return null;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        if (!hasSemiColon) {\n            cb.append(\";\");\n        }\n    } else {\n        cb.append(\";\"); // Add semi-colon for empty code as well\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -35,6 +35,8 @@\n         if (!hasSemiColon) {\n             cb.append(\";\");\n         }\n+    } else {\n+        cb.append(\";\"); // Add semi-colon for empty code as well\n     }\n     return null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        if (!hasSemiColon && !isDirective(code)) {\n            cb.append(\";\");\n        }\n    }\n    return null;\n}\n\n// Helper function to check if a string is a directive (e.g. 'use strict')\nprivate boolean isDirective(String code) {\n    return code.startsWith(\"'use strict'\") || code.startsWith(\"\\\"use strict\\\"\");\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -32,7 +32,7 @@\n         char lastChar = code.charAt(length - 1);\n         char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n         boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n+        if (!hasSemiColon && !isDirective(code)) {\n             cb.append(\";\");\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        if (!hasSemiColon && !endsWithComment(code)) {\n            cb.append(\";\");\n        }\n    }\n    return null;\n}\n\nprivate boolean endsWithComment(String code) {\n    String trimmed = code.trim();\n    return trimmed.endsWith(\"*/\") || trimmed.endsWith(\"//\");\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -32,7 +32,7 @@\n         char lastChar = code.charAt(length - 1);\n         char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n         boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n+        if (!hasSemiColon && !endsWithComment(code)) {\n             cb.append(\";\");\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        if (!hasSemiColon && !code.endsWith(\"}\")) { // Add semi-colon only if code does not end with '}' to avoid syntax errors\n            cb.append(\";\");\n        }\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -32,7 +32,7 @@\n         char lastChar = code.charAt(length - 1);\n         char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n         boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n-        if (!hasSemiColon) {\n+        if (!hasSemiColon && !code.endsWith(\"}\")) { // Add semi-colon only if code does not end with '}' to avoid syntax errors\n             cb.append(\";\");\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        boolean hasSemiColon = lastChar == ';';\n        if (!hasSemiColon) {\n            cb.append(\";\");\n        }\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -30,8 +30,7 @@\n         // heuristic check if there's an obvious semi-colon already there.\n         int length = code.length();\n         char lastChar = code.charAt(length - 1);\n-        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n-        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n+        boolean hasSemiColon = lastChar == ';';\n         if (!hasSemiColon) {\n             cb.append(\";\");\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public Void call() throws Exception {\n    if (options.printInputDelimiter) {\n        if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            // Make sure that the label starts on a new line\n            cb.append(\"\\n\");\n        }\n        Preconditions.checkState(root.getType() == Token.SCRIPT);\n        String delimiter = options.inputDelimiter;\n        String sourceName = (String) root.getProp(Node.SOURCENAME_PROP);\n        Preconditions.checkState(sourceName != null);\n        Preconditions.checkState(!sourceName.isEmpty());\n        delimiter = delimiter.replaceAll(\"%name%\", sourceName).replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n        cb.append(delimiter).append(\"\\n\");\n    }\n    if (root.getJSDocInfo() != null && root.getJSDocInfo().getLicense() != null) {\n        cb.append(\"/*\\n\").append(root.getJSDocInfo().getLicense()).append(\"*/\\n\");\n    }\n    // If there is a valid source map, then indicate to it that the current\n    // root node's mappings are offset by the given string builder buffer.\n    if (options.sourceMapOutputPath != null) {\n        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getOutputIndex());\n    }\n    // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n    // for the first input file\n    String code = toSource(root, sourceMap);\n    if (!code.isEmpty()) {\n        cb.append(code);\n        // In order to avoid parse ambiguity when files are concatenated\n        // together, all files should end in a semi-colon. Do a quick\n        // heuristic check if there's an obvious semi-colon already there.\n        int length = code.length();\n        char lastChar = code.charAt(length - 1);\n        char secondLastChar = length >= 2 ? code.charAt(length - 2) : '\\0';\n        boolean hasSemiColon = lastChar == ';' || (lastChar == '\\n' && secondLastChar == ';');\n        if (!hasSemiColon) {\n            cb.append(\";\");\n        }\n    }\n    return null;\n}", "diff": "--- com/google/javascript/jscomp/Compiler.java@call\n+++ com/google/javascript/jscomp/Compiler.java@call\n@@ -18,7 +18,7 @@\n     // If there is a valid source map, then indicate to it that the current\n     // root node's mappings are offset by the given string builder buffer.\n     if (options.sourceMapOutputPath != null) {\n-        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getColumnIndex());\n+        sourceMap.setStartingPosition(cb.getLineIndex(), cb.getOutputIndex());\n     }\n     // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n     // for the first input file\n", "finish_reason": "stop", "valid": false, "num": 1}]