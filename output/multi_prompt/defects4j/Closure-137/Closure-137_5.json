[{"output": "@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    removeDuplicateDeclarations(root);\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,47 +1,25 @@\n @Override\n-public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n-        String oldName = node.getString();\n-        if (containsSeparator(oldName)) {\n-            Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n-            if (var == null || var.isGlobal()) {\n-                return;\n-            }\n-            if (nameMap.containsKey(var)) {\n-                node.setString(nameMap.get(var));\n-            } else {\n-                int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n-                String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n-                    newName = oldName;\n-                } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n-                    }\n-                    node.setString(newName);\n-                    compiler.reportCodeChange();\n-                }\n-                nameMap.put(var, newName);\n-            }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n-        }\n+public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n+    if (MAKE_LOCAL_NAMES_UNIQUE) {\n+        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n+        NodeTraversal t = new NodeTraversal(compiler, renamer);\n+        t.traverseRoots(externs, root);\n     }\n+    removeDuplicateDeclarations(root);\n+    // It is important that removeDuplicateDeclarations runs after\n+    // MakeDeclaredNamesUnique in order for catch block exception names to be\n+    // handled properly. Specifically, catch block exception names are\n+    // only valid within the catch block, but our currect Scope logic\n+    // has no concept of this and includes it in the containing function\n+    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n+    // names unique so that removeDuplicateDeclarations() will properly handle\n+    // cases where a function scope variable conflict with a exception name:\n+    //   function f() {\n+    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n+    //      var e = 1; // f scope 'e'\n+    //   }\n+    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n+    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n+    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,25 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n-            }\n-            declarations.put(name, newName);\n-        }\n+public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n+    if (MAKE_LOCAL_NAMES_UNIQUE) {\n+        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n+        NodeTraversal t = new NodeTraversal(compiler, renamer);\n+        t.traverseRoots(externs, root);\n     }\n+    removeDuplicateDeclarations(root);\n+    // It is important that removeDuplicateDeclarations runs after\n+    // MakeDeclaredNamesUnique in order for catch block exception names to be\n+    // handled properly. Specifically, catch block exception names are\n+    // only valid within the catch block, but our currect Scope logic\n+    // has no concept of this and includes it in the containing function\n+    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n+    // names unique so that removeDuplicateDeclarations() will properly handle\n+    // cases where a function scope variable conflict with a exception name:\n+    //   function f() {\n+    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n+    //      var e = 1; // f scope 'e'\n+    //   }\n+    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n+    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n+    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,12 +1,12 @@\n @Override\n public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n         MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n         NodeTraversal t = new NodeTraversal(compiler, renamer);\n         t.traverseRoots(externs, root);\n     }\n+    removeDuplicateDeclarations(root);\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n", "finish_reason": "stop", "valid": false, "num": 13}, {"output": "@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    removeDuplicateDeclarations(root);\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with an exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,47 +1,25 @@\n @Override\n-public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n-        String oldName = node.getString();\n-        if (containsSeparator(oldName)) {\n-            Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n-            if (var == null || var.isGlobal()) {\n-                return;\n-            }\n-            if (nameMap.containsKey(var)) {\n-                node.setString(nameMap.get(var));\n-            } else {\n-                int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n-                String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n-                    newName = oldName;\n-                } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n-                    }\n-                    node.setString(newName);\n-                    compiler.reportCodeChange();\n-                }\n-                nameMap.put(var, newName);\n-            }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n-        }\n+public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n+    if (MAKE_LOCAL_NAMES_UNIQUE) {\n+        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n+        NodeTraversal t = new NodeTraversal(compiler, renamer);\n+        t.traverseRoots(externs, root);\n     }\n+    removeDuplicateDeclarations(root);\n+    // It is important that removeDuplicateDeclarations runs after\n+    // MakeDeclaredNamesUnique in order for catch block exception names to be\n+    // handled properly. Specifically, catch block exception names are\n+    // only valid within the catch block, but our current Scope logic\n+    // has no concept of this and includes it in the containing function\n+    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n+    // names unique so that removeDuplicateDeclarations() will properly handle\n+    // cases where a function scope variable conflict with an exception name:\n+    //   function f() {\n+    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n+    //      var e = 1; // f scope 'e'\n+    //   }\n+    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n+    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,25 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n-            }\n-            declarations.put(name, newName);\n-        }\n+public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n+    if (MAKE_LOCAL_NAMES_UNIQUE) {\n+        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n+        NodeTraversal t = new NodeTraversal(compiler, renamer);\n+        t.traverseRoots(externs, root);\n     }\n+    removeDuplicateDeclarations(root);\n+    // It is important that removeDuplicateDeclarations runs after\n+    // MakeDeclaredNamesUnique in order for catch block exception names to be\n+    // handled properly. Specifically, catch block exception names are\n+    // only valid within the catch block, but our current Scope logic\n+    // has no concept of this and includes it in the containing function\n+    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n+    // names unique so that removeDuplicateDeclarations() will properly handle\n+    // cases where a function scope variable conflict with an exception name:\n+    //   function f() {\n+    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n+    //      var e = 1; // f scope 'e'\n+    //   }\n+    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n+    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,25 @@\n @Override\n public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n         MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n         NodeTraversal t = new NodeTraversal(compiler, renamer);\n         t.traverseRoots(externs, root);\n     }\n+    removeDuplicateDeclarations(root);\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n+    // only valid within the catch block, but our current Scope logic\n     // has no concept of this and includes it in the containing function\n     // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n     // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n+    // cases where a function scope variable conflict with an exception name:\n     //   function f() {\n     //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n     //      var e = 1; // f scope 'e'\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n     new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    removeDuplicateDeclarations(root);\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,47 +1,25 @@\n @Override\n-public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n-        String oldName = node.getString();\n-        if (containsSeparator(oldName)) {\n-            Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n-            if (var == null || var.isGlobal()) {\n-                return;\n-            }\n-            if (nameMap.containsKey(var)) {\n-                node.setString(nameMap.get(var));\n-            } else {\n-                int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n-                String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n-                    newName = oldName;\n-                } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n-                    }\n-                    node.setString(newName);\n-                    compiler.reportCodeChange();\n-                }\n-                nameMap.put(var, newName);\n-            }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n-        }\n+public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n+    if (MAKE_LOCAL_NAMES_UNIQUE) {\n+        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n+        NodeTraversal t = new NodeTraversal(compiler, renamer);\n+        t.traverseRoots(externs, root);\n     }\n+    removeDuplicateDeclarations(root);\n+    // It is important that removeDuplicateDeclarations runs after\n+    // MakeDeclaredNamesUnique in order for catch block exception names to be\n+    // handled properly. Specifically, catch block exception names are\n+    // only valid within the catch block, but our currect Scope logic\n+    // has no concept of this and includes it in the containing function\n+    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n+    // names unique so that removeDuplicateDeclarations() will properly handle\n+    // cases where a function scope variable conflict with a exception name:\n+    //   function f() {\n+    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n+    //      var e = 1; // f scope 'e'\n+    //   }\n+    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n+    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,25 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n-            }\n-            declarations.put(name, newName);\n-        }\n+public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n+    if (MAKE_LOCAL_NAMES_UNIQUE) {\n+        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n+        NodeTraversal t = new NodeTraversal(compiler, renamer);\n+        t.traverseRoots(externs, root);\n     }\n+    removeDuplicateDeclarations(root);\n+    // It is important that removeDuplicateDeclarations runs after\n+    // MakeDeclaredNamesUnique in order for catch block exception names to be\n+    // handled properly. Specifically, catch block exception names are\n+    // only valid within the catch block, but our currect Scope logic\n+    // has no concept of this and includes it in the containing function\n+    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n+    // names unique so that removeDuplicateDeclarations() will properly handle\n+    // cases where a function scope variable conflict with a exception name:\n+    //   function f() {\n+    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n+    //      var e = 1; // f scope 'e'\n+    //   }\n+    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n+    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,12 +1,12 @@\n @Override\n public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n         MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n         NodeTraversal t = new NodeTraversal(compiler, renamer);\n         t.traverseRoots(externs, root);\n     }\n+    removeDuplicateDeclarations(root);\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n@@ -20,6 +20,6 @@\n     //      var e = 1; // f scope 'e'\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n     new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n        // move removeDuplicateDeclarations after MakeDeclaredNamesUnique\n        removeDuplicateDeclarations(root);\n        // PropogateConstantAnnotations is not dependent on the order of previous passes\n        new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n    } else {\n        removeDuplicateDeclarations(root);\n        new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with an exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,47 +1,30 @@\n @Override\n-public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n-        String oldName = node.getString();\n-        if (containsSeparator(oldName)) {\n-            Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n-            if (var == null || var.isGlobal()) {\n-                return;\n-            }\n-            if (nameMap.containsKey(var)) {\n-                node.setString(nameMap.get(var));\n-            } else {\n-                int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n-                String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n-                    newName = oldName;\n-                } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n-                    }\n-                    node.setString(newName);\n-                    compiler.reportCodeChange();\n-                }\n-                nameMap.put(var, newName);\n-            }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n-        }\n+public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n+    if (MAKE_LOCAL_NAMES_UNIQUE) {\n+        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n+        NodeTraversal t = new NodeTraversal(compiler, renamer);\n+        t.traverseRoots(externs, root);\n+        // move removeDuplicateDeclarations after MakeDeclaredNamesUnique\n+        removeDuplicateDeclarations(root);\n+        // PropogateConstantAnnotations is not dependent on the order of previous passes\n+        new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n+    } else {\n+        removeDuplicateDeclarations(root);\n+        new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n     }\n+    // It is important that removeDuplicateDeclarations runs after\n+    // MakeDeclaredNamesUnique in order for catch block exception names to be\n+    // handled properly. Specifically, catch block exception names are\n+    // only valid within the catch block, but our current Scope logic\n+    // has no concept of this and includes it in the containing function\n+    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n+    // names unique so that removeDuplicateDeclarations() will properly handle\n+    // cases where a function scope variable conflict with an exception name:\n+    //   function f() {\n+    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n+    //      var e = 1; // f scope 'e'\n+    //   }\n+    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,30 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n+public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n+    if (MAKE_LOCAL_NAMES_UNIQUE) {\n+        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n+        NodeTraversal t = new NodeTraversal(compiler, renamer);\n+        t.traverseRoots(externs, root);\n+        // move removeDuplicateDeclarations after MakeDeclaredNamesUnique\n+        removeDuplicateDeclarations(root);\n+        // PropogateConstantAnnotations is not dependent on the order of previous passes\n+        new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n     } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n-            }\n-            declarations.put(name, newName);\n-        }\n+        removeDuplicateDeclarations(root);\n+        new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n     }\n+    // It is important that removeDuplicateDeclarations runs after\n+    // MakeDeclaredNamesUnique in order for catch block exception names to be\n+    // handled properly. Specifically, catch block exception names are\n+    // only valid within the catch block, but our current Scope logic\n+    // has no concept of this and includes it in the containing function\n+    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n+    // names unique so that removeDuplicateDeclarations() will properly handle\n+    // cases where a function scope variable conflict with an exception name:\n+    //   function f() {\n+    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n+    //      var e = 1; // f scope 'e'\n+    //   }\n+    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,30 @@\n @Override\n public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n         MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n         NodeTraversal t = new NodeTraversal(compiler, renamer);\n         t.traverseRoots(externs, root);\n+        // move removeDuplicateDeclarations after MakeDeclaredNamesUnique\n+        removeDuplicateDeclarations(root);\n+        // PropogateConstantAnnotations is not dependent on the order of previous passes\n+        new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n+    } else {\n+        removeDuplicateDeclarations(root);\n+        new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n     }\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n+    // only valid within the catch block, but our current Scope logic\n     // has no concept of this and includes it in the containing function\n     // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n     // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n+    // cases where a function scope variable conflict with an exception name:\n     //   function f() {\n     //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n     //      var e = 1; // f scope 'e'\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void process(Node externs, Node root) {\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    removeDuplicateDeclarations(root);\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,47 +1,25 @@\n @Override\n-public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n-        String oldName = node.getString();\n-        if (containsSeparator(oldName)) {\n-            Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n-            if (var == null || var.isGlobal()) {\n-                return;\n-            }\n-            if (nameMap.containsKey(var)) {\n-                node.setString(nameMap.get(var));\n-            } else {\n-                int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n-                String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n-                    newName = oldName;\n-                } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n-                    }\n-                    node.setString(newName);\n-                    compiler.reportCodeChange();\n-                }\n-                nameMap.put(var, newName);\n-            }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n-        }\n+public void process(Node externs, Node root) {\n+    if (MAKE_LOCAL_NAMES_UNIQUE) {\n+        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n+        NodeTraversal t = new NodeTraversal(compiler, renamer);\n+        t.traverseRoots(externs, root);\n     }\n+    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n+    removeDuplicateDeclarations(root);\n+    // It is important that removeDuplicateDeclarations runs after\n+    // MakeDeclaredNamesUnique in order for catch block exception names to be\n+    // handled properly. Specifically, catch block exception names are\n+    // only valid within the catch block, but our currect Scope logic\n+    // has no concept of this and includes it in the containing function\n+    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n+    // names unique so that removeDuplicateDeclarations() will properly handle\n+    // cases where a function scope variable conflict with a exception name:\n+    //   function f() {\n+    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n+    //      var e = 1; // f scope 'e'\n+    //   }\n+    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n+    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n+    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,25 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n-            }\n-            declarations.put(name, newName);\n-        }\n+public void process(Node externs, Node root) {\n+    if (MAKE_LOCAL_NAMES_UNIQUE) {\n+        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n+        NodeTraversal t = new NodeTraversal(compiler, renamer);\n+        t.traverseRoots(externs, root);\n     }\n+    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n+    removeDuplicateDeclarations(root);\n+    // It is important that removeDuplicateDeclarations runs after\n+    // MakeDeclaredNamesUnique in order for catch block exception names to be\n+    // handled properly. Specifically, catch block exception names are\n+    // only valid within the catch block, but our currect Scope logic\n+    // has no concept of this and includes it in the containing function\n+    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n+    // names unique so that removeDuplicateDeclarations() will properly handle\n+    // cases where a function scope variable conflict with a exception name:\n+    //   function f() {\n+    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n+    //      var e = 1; // f scope 'e'\n+    //   }\n+    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n+    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n+    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,12 +1,12 @@\n @Override\n public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n         MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n         NodeTraversal t = new NodeTraversal(compiler, renamer);\n         t.traverseRoots(externs, root);\n     }\n+    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n+    removeDuplicateDeclarations(root);\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    removeDuplicateDeclarations(root);\n    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,47 +1,25 @@\n @Override\n-public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n-        String oldName = node.getString();\n-        if (containsSeparator(oldName)) {\n-            Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n-            if (var == null || var.isGlobal()) {\n-                return;\n-            }\n-            if (nameMap.containsKey(var)) {\n-                node.setString(nameMap.get(var));\n-            } else {\n-                int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n-                String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n-                    newName = oldName;\n-                } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n-                    }\n-                    node.setString(newName);\n-                    compiler.reportCodeChange();\n-                }\n-                nameMap.put(var, newName);\n-            }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n-        }\n+public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n+    if (MAKE_LOCAL_NAMES_UNIQUE) {\n+        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n+        NodeTraversal t = new NodeTraversal(compiler, renamer);\n+        t.traverseRoots(externs, root);\n     }\n+    // It is important that removeDuplicateDeclarations runs after\n+    // MakeDeclaredNamesUnique in order for catch block exception names to be\n+    // handled properly. Specifically, catch block exception names are\n+    // only valid within the catch block, but our current Scope logic\n+    // has no concept of this and includes it in the containing function\n+    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n+    // names unique so that removeDuplicateDeclarations() will properly handle\n+    // cases where a function scope variable conflict with a exception name:\n+    //   function f() {\n+    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n+    //      var e = 1; // f scope 'e'\n+    //   }\n+    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n+    removeDuplicateDeclarations(root);\n+    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,25 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n-            }\n-            declarations.put(name, newName);\n-        }\n+public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n+    if (MAKE_LOCAL_NAMES_UNIQUE) {\n+        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n+        NodeTraversal t = new NodeTraversal(compiler, renamer);\n+        t.traverseRoots(externs, root);\n     }\n+    // It is important that removeDuplicateDeclarations runs after\n+    // MakeDeclaredNamesUnique in order for catch block exception names to be\n+    // handled properly. Specifically, catch block exception names are\n+    // only valid within the catch block, but our current Scope logic\n+    // has no concept of this and includes it in the containing function\n+    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n+    // names unique so that removeDuplicateDeclarations() will properly handle\n+    // cases where a function scope variable conflict with a exception name:\n+    //   function f() {\n+    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n+    //      var e = 1; // f scope 'e'\n+    //   }\n+    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n+    removeDuplicateDeclarations(root);\n+    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,7 +1,6 @@\n @Override\n public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n         MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n         NodeTraversal t = new NodeTraversal(compiler, renamer);\n@@ -10,7 +9,7 @@\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n+    // only valid within the catch block, but our current Scope logic\n     // has no concept of this and includes it in the containing function\n     // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n     // names unique so that removeDuplicateDeclarations() will properly handle\n@@ -20,6 +19,7 @@\n     //      var e = 1; // f scope 'e'\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n+    removeDuplicateDeclarations(root);\n     new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n        // move removeDuplicateDeclarations after MakeDeclaredNamesUnique\n        removeDuplicateDeclarations(root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,47 +1,26 @@\n @Override\n-public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n-        String oldName = node.getString();\n-        if (containsSeparator(oldName)) {\n-            Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n-            if (var == null || var.isGlobal()) {\n-                return;\n-            }\n-            if (nameMap.containsKey(var)) {\n-                node.setString(nameMap.get(var));\n-            } else {\n-                int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n-                String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n-                    newName = oldName;\n-                } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n-                    }\n-                    node.setString(newName);\n-                    compiler.reportCodeChange();\n-                }\n-                nameMap.put(var, newName);\n-            }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n-        }\n+public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n+    if (MAKE_LOCAL_NAMES_UNIQUE) {\n+        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n+        NodeTraversal t = new NodeTraversal(compiler, renamer);\n+        t.traverseRoots(externs, root);\n+        // move removeDuplicateDeclarations after MakeDeclaredNamesUnique\n+        removeDuplicateDeclarations(root);\n     }\n+    // It is important that removeDuplicateDeclarations runs after\n+    // MakeDeclaredNamesUnique in order for catch block exception names to be\n+    // handled properly. Specifically, catch block exception names are\n+    // only valid within the catch block, but our currect Scope logic\n+    // has no concept of this and includes it in the containing function\n+    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n+    // names unique so that removeDuplicateDeclarations() will properly handle\n+    // cases where a function scope variable conflict with a exception name:\n+    //   function f() {\n+    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n+    //      var e = 1; // f scope 'e'\n+    //   }\n+    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n+    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n+    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,26 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n-            }\n-            declarations.put(name, newName);\n-        }\n+public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n+    if (MAKE_LOCAL_NAMES_UNIQUE) {\n+        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n+        NodeTraversal t = new NodeTraversal(compiler, renamer);\n+        t.traverseRoots(externs, root);\n+        // move removeDuplicateDeclarations after MakeDeclaredNamesUnique\n+        removeDuplicateDeclarations(root);\n     }\n+    // It is important that removeDuplicateDeclarations runs after\n+    // MakeDeclaredNamesUnique in order for catch block exception names to be\n+    // handled properly. Specifically, catch block exception names are\n+    // only valid within the catch block, but our currect Scope logic\n+    // has no concept of this and includes it in the containing function\n+    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n+    // names unique so that removeDuplicateDeclarations() will properly handle\n+    // cases where a function scope variable conflict with a exception name:\n+    //   function f() {\n+    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n+    //      var e = 1; // f scope 'e'\n+    //   }\n+    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n+    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n+    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,11 +1,12 @@\n @Override\n public void process(Node externs, Node root) {\n     NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n         MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n         NodeTraversal t = new NodeTraversal(compiler, renamer);\n         t.traverseRoots(externs, root);\n+        // move removeDuplicateDeclarations after MakeDeclaredNamesUnique\n+        removeDuplicateDeclarations(root);\n     }\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n", "finish_reason": "stop", "valid": false, "num": 1}]