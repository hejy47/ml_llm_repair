[{"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName()) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = scope.getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOrginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    scope.declare(newName, var.getNameNode(), null, null);\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.isFunction() && parentNode == scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    nameMap.put(var, newName);\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,10 +1,10 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) {\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n+            Var var = scope.getVar(oldName);\n             if (var == null || var.isGlobal()) {\n                 return;\n             }\n@@ -14,34 +14,23 @@\n                 int index = indexOfSeparator(oldName);\n                 String newName = getOrginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n                 boolean recurseScopes = false;\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n+                    scope.declare(newName, var.getNameNode(), null, null);\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode.isFunction() && parentNode == scope.getRootNode()) {\n                         var.getNameNode().setString(newName);\n                     }\n+                    nameMap.put(var, newName);\n                     node.setString(newName);\n                     compiler.reportCodeChange();\n                 }\n-                nameMap.put(var, newName);\n             }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,36 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, var.getNameNode(), null, null);\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    nameMap.put(var, newName);\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+            }\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,36 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, var.getNameNode(), null, null);\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    nameMap.put(var, newName);\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+            }\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.getType() == Token.NAME) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = t.getScope().getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOrginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                \n                // Check if the new name is valid and if it would cause conflicts.\n                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    // Try appending a suffix to the new name to make it unique.\n                    int count = 2;\n                    while (var.scope.isDeclared(newName + count, recurseScopes)) {\n                        count++;\n                    }\n                    newName = newName + count;\n                    // If all possible names are taken, keep the old name.\n                    if (!TokenStream.isJSIdentifier(newName)) {\n                        newName = oldName;\n                    }\n                }\n                \n                var.scope.declare(newName, var.nameNode, null, null);\n                // Adding a reference to the new name to prevent either the parent\n                // scopes or the current scope renaming another var to this new name.\n                Node parentNode = var.getParentNode();\n                if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n                    var.getNameNode().setString(newName);\n                }\n                node.setString(newName);\n                compiler.reportCodeChange();\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -23,20 +23,30 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n+                \n+                // Check if the new name is valid and if it would cause conflicts.\n                 if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n-                    newName = oldName;\n-                } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n+                    // Try appending a suffix to the new name to make it unique.\n+                    int count = 2;\n+                    while (var.scope.isDeclared(newName + count, recurseScopes)) {\n+                        count++;\n                     }\n-                    node.setString(newName);\n-                    compiler.reportCodeChange();\n+                    newName = newName + count;\n+                    // If all possible names are taken, keep the old name.\n+                    if (!TokenStream.isJSIdentifier(newName)) {\n+                        newName = oldName;\n+                    }\n                 }\n+                \n+                var.scope.declare(newName, var.nameNode, null, null);\n+                // Adding a reference to the new name to prevent either the parent\n+                // scopes or the current scope renaming another var to this new name.\n+                Node parentNode = var.getParentNode();\n+                if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    var.getNameNode().setString(newName);\n+                }\n+                node.setString(newName);\n+                compiler.reportCodeChange();\n                 nameMap.put(var, newName);\n             }\n             // Add all referenced names to the set so it is possible to check for\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,57 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                \n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    // Try appending a suffix to the new name to make it unique.\n+                    int count = 2;\n+                    while (var.scope.isDeclared(newName + count, recurseScopes)) {\n+                        count++;\n+                    }\n+                    newName = newName + count;\n+                    // If all possible names are taken, keep the old name.\n+                    if (!TokenStream.isJSIdentifier(newName)) {\n+                        newName = oldName;\n+                    }\n+                }\n+                \n+                var.scope.declare(newName, var.nameNode, null, null);\n+                // Adding a reference to the new name to prevent either the parent\n+                // scopes or the current scope renaming another var to this new name.\n+                Node parentNode = var.getParentNode();\n+                if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    var.getNameNode().setString(newName);\n+                }\n+                node.setString(newName);\n+                compiler.reportCodeChange();\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,57 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                \n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    // Try appending a suffix to the new name to make it unique.\n+                    int count = 2;\n+                    while (var.scope.isDeclared(newName + count, recurseScopes)) {\n+                        count++;\n+                    }\n+                    newName = newName + count;\n+                    // If all possible names are taken, keep the old name.\n+                    if (!TokenStream.isJSIdentifier(newName)) {\n+                        newName = oldName;\n+                    }\n+                }\n+                \n+                var.scope.declare(newName, var.nameNode, null, null);\n+                // Adding a reference to the new name to prevent either the parent\n+                // scopes or the current scope renaming another var to this new name.\n+                Node parentNode = var.getParentNode();\n+                if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    var.getNameNode().setString(newName);\n+                }\n+                node.setString(newName);\n+                compiler.reportCodeChange();\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName()) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = scope.getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                // Check if the new name is valid and if it would cause conflicts.\n                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    var.scope.declare(newName, var.nameNode, null, null);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,10 +1,10 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) {\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n+            Var var = scope.getVar(oldName);\n             if (var == null || var.isGlobal()) {\n                 return;\n             }\n@@ -12,7 +12,7 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n                 // Merge any names that were referenced but not declared in the current\n                 // scope.\n@@ -23,7 +23,7 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n+                // Check if the new name is valid and if it would cause conflicts.\n                 if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n@@ -31,7 +31,7 @@\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,47 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.nameNode, null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,47 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.nameNode, null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName()) { // Using isName() instead of getType() == Token.NAME for better compatibility.\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = scope.getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOrginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                // Check if the new name is valid and if it would cause conflicts.\n                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    scope.declare(newName, var.getNameNode(), null, null);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.isFunction() && parentNode == scope.getRootNode()) { // Using isFunction() instead of getType() == Token.FUNCTION for better compatibility.\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,10 +1,10 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) { // Using isName() instead of getType() == Token.NAME for better compatibility.\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n+            Var var = scope.getVar(oldName);\n             if (var == null || var.isGlobal()) {\n                 return;\n             }\n@@ -23,15 +23,15 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n+                    scope.declare(newName, var.getNameNode(), null, null);\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode.isFunction() && parentNode == scope.getRootNode()) { // Using isFunction() instead of getType() == Token.FUNCTION for better compatibility.\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,47 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) { // Using isName() instead of getType() == Token.NAME for better compatibility.\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, var.getNameNode(), null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == scope.getRootNode()) { // Using isFunction() instead of getType() == Token.FUNCTION for better compatibility.\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,47 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) { // Using isName() instead of getType() == Token.NAME for better compatibility.\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, var.getNameNode(), null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == scope.getRootNode()) { // Using isFunction() instead of getType() == Token.FUNCTION for better compatibility.\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName() && containsSeparator(node.getString())) {\n        String oldName = node.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(oldName);\n        if (var == null || var.isGlobal()) {\n            return;\n        }\n        if (nameMap.containsKey(var)) {\n            node.setString(nameMap.get(var));\n        } else {\n            int index = indexOfSeparator(oldName);\n            String newName = getOrginalNameInternal(oldName, index);\n            String suffix = getNameSuffix(oldName, index);\n            boolean recurseScopes = !suffix.matches(\"^\\\\d+$\");\n            if (!TokenStream.isJSIdentifier(newName) || var.scope.isDeclared(newName, recurseScopes)) {\n                newName = oldName;\n            } else {\n                var.scope.declare(newName, var.nameNode, null, null);\n                if (var.getParentNode().isFunction() && var.scope.isGlobal()) {\n                    var.getNameNode().setString(newName);\n                }\n                nameMap.put(var, newName);\n                node.setString(newName);\n                compiler.reportCodeChange();\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,47 +1,30 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName() && containsSeparator(node.getString())) {\n         String oldName = node.getString();\n-        if (containsSeparator(oldName)) {\n-            Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n-            if (var == null || var.isGlobal()) {\n-                return;\n-            }\n-            if (nameMap.containsKey(var)) {\n-                node.setString(nameMap.get(var));\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(oldName);\n+        if (var == null || var.isGlobal()) {\n+            return;\n+        }\n+        if (nameMap.containsKey(var)) {\n+            node.setString(nameMap.get(var));\n+        } else {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOrginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            boolean recurseScopes = !suffix.matches(\"^\\\\d+$\");\n+            if (!TokenStream.isJSIdentifier(newName) || var.scope.isDeclared(newName, recurseScopes)) {\n+                newName = oldName;\n             } else {\n-                int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n-                String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n-                    newName = oldName;\n-                } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n-                    }\n-                    node.setString(newName);\n-                    compiler.reportCodeChange();\n+                var.scope.declare(newName, var.nameNode, null, null);\n+                if (var.getParentNode().isFunction() && var.scope.isGlobal()) {\n+                    var.getNameNode().setString(newName);\n                 }\n                 nameMap.put(var, newName);\n+                node.setString(newName);\n+                compiler.reportCodeChange();\n             }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,30 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName() && containsSeparator(node.getString())) {\n+        String oldName = node.getString();\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(oldName);\n+        if (var == null || var.isGlobal()) {\n+            return;\n+        }\n+        if (nameMap.containsKey(var)) {\n+            node.setString(nameMap.get(var));\n+        } else {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOrginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            boolean recurseScopes = !suffix.matches(\"^\\\\d+$\");\n+            if (!TokenStream.isJSIdentifier(newName) || var.scope.isDeclared(newName, recurseScopes)) {\n+                newName = oldName;\n+            } else {\n+                var.scope.declare(newName, var.nameNode, null, null);\n+                if (var.getParentNode().isFunction() && var.scope.isGlobal()) {\n+                    var.getNameNode().setString(newName);\n+                }\n+                nameMap.put(var, newName);\n+                node.setString(newName);\n+                compiler.reportCodeChange();\n             }\n-            declarations.put(name, newName);\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,30 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName() && containsSeparator(node.getString())) {\n+        String oldName = node.getString();\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(oldName);\n+        if (var == null || var.isGlobal()) {\n+            return;\n+        }\n+        if (nameMap.containsKey(var)) {\n+            node.setString(nameMap.get(var));\n+        } else {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOrginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            boolean recurseScopes = !suffix.matches(\"^\\\\d+$\");\n+            if (!TokenStream.isJSIdentifier(newName) || var.scope.isDeclared(newName, recurseScopes)) {\n+                newName = oldName;\n+            } else {\n+                var.scope.declare(newName, var.nameNode, null, null);\n+                if (var.getParentNode().isFunction() && var.scope.isGlobal()) {\n+                    var.getNameNode().setString(newName);\n+                }\n+                nameMap.put(var, newName);\n+                node.setString(newName);\n+                compiler.reportCodeChange();\n+            }\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName() && !node.matchesQualifiedName(\"super\")) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = scope.getVar(oldName);\n            if (var == null || var.isGlobal() || !var.getNameNode().isName()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                if (!isValidIdentifier(oldName, index)) {\n                    return;\n                }\n                String newName = getOrginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                // Check if the new name is valid and if it would cause conflicts.\n                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    var.scope.declare(newName, var.getNameNode(), null, null);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.isFunction() && parentNode.getParentNode() == null) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,17 +1,20 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName() && !node.matchesQualifiedName(\"super\")) {\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n-            if (var == null || var.isGlobal()) {\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal() || !var.getNameNode().isName()) {\n                 return;\n             }\n             if (nameMap.containsKey(var)) {\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n+                if (!isValidIdentifier(oldName, index)) {\n+                    return;\n+                }\n                 String newName = getOrginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n                 // Merge any names that were referenced but not declared in the current\n@@ -23,15 +26,15 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n+                // Check if the new name is valid and if it would cause conflicts.\n                 if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n+                    var.scope.declare(newName, var.getNameNode(), null, null);\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode.isFunction() && parentNode.getParentNode() == null) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n@@ -39,9 +42,6 @@\n                 }\n                 nameMap.put(var, newName);\n             }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,47 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName() && !node.matchesQualifiedName(\"super\")) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal() || !var.getNameNode().isName()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                if (!isValidIdentifier(oldName, index)) {\n+                    return;\n+                }\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.getNameNode(), null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode.getParentNode() == null) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,47 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName() && !node.matchesQualifiedName(\"super\")) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal() || !var.getNameNode().isName()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                if (!isValidIdentifier(oldName, index)) {\n+                    return;\n+                }\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.getNameNode(), null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode.getParentNode() == null) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.getType() == Token.NAME) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = scope.getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n\n                // Check if the new name is valid and if it would cause conflicts.\n                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    scope.declare(newName, null, null, var.nameNode);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -4,7 +4,7 @@\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n+            Var var = scope.getVar(oldName);\n             if (var == null || var.isGlobal()) {\n                 return;\n             }\n@@ -12,7 +12,7 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n                 // Merge any names that were referenced but not declared in the current\n                 // scope.\n@@ -23,15 +23,16 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n+                    scope.declare(newName, null, null, var.nameNode);\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,48 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, null, null, var.nameNode);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,48 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, null, null, var.nameNode);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName() && node.getQualifiedName().contains(\".\")) {\n        Scope scope = t.getScope();\n        Var var = t.getScope().getVar(node.getString());\n        if (var != null && !var.isGlobal() && !nameMap.containsKey(var)) {\n            String oldName = var.getName();\n            int index = oldName.lastIndexOf('.');\n            String newName = getOrginalNameInternal(oldName, index);\n            String suffix = getNameSuffix(oldName, index);\n            // Merge any names that were referenced but not declared in the current\n            // scope.\n            // If there isn't anything left in the stack we will be going into the\n            // global scope: don't try to build a set of referenced names for the\n            // global scope.\n            boolean recurseScopes = false;\n            if (!suffix.matches(\"\\\\d+\")) {\n                recurseScopes = true;\n            }\n            // Check if the new name is valid and if it would cause conflicts.\n            if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                newName = oldName;\n            } else {\n                var.scope.declare(newName, var.getNameNode(), null, null);\n                // Adding a reference to the new name to prevent either the parent\n                // scopes or the current scope renaming another var to this new name.\n                Node parentNode = var.getParentNode();\n                if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n                    var.getNameNode().setString(newName);\n                }\n                node.setString(newName);\n                compiler.reportCodeChange();\n            }\n            nameMap.put(var, newName);\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,47 +1,37 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n-        String oldName = node.getString();\n-        if (containsSeparator(oldName)) {\n-            Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n-            if (var == null || var.isGlobal()) {\n-                return;\n+    if (node.isName() && node.getQualifiedName().contains(\".\")) {\n+        Scope scope = t.getScope();\n+        Var var = t.getScope().getVar(node.getString());\n+        if (var != null && !var.isGlobal() && !nameMap.containsKey(var)) {\n+            String oldName = var.getName();\n+            int index = oldName.lastIndexOf('.');\n+            String newName = getOrginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            // Merge any names that were referenced but not declared in the current\n+            // scope.\n+            // If there isn't anything left in the stack we will be going into the\n+            // global scope: don't try to build a set of referenced names for the\n+            // global scope.\n+            boolean recurseScopes = false;\n+            if (!suffix.matches(\"\\\\d+\")) {\n+                recurseScopes = true;\n             }\n-            if (nameMap.containsKey(var)) {\n-                node.setString(nameMap.get(var));\n+            // Check if the new name is valid and if it would cause conflicts.\n+            if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                newName = oldName;\n             } else {\n-                int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n-                String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n+                var.scope.declare(newName, var.getNameNode(), null, null);\n+                // Adding a reference to the new name to prevent either the parent\n+                // scopes or the current scope renaming another var to this new name.\n+                Node parentNode = var.getParentNode();\n+                if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                    var.getNameNode().setString(newName);\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n-                    newName = oldName;\n-                } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n-                    }\n-                    node.setString(newName);\n-                    compiler.reportCodeChange();\n-                }\n-                nameMap.put(var, newName);\n+                node.setString(newName);\n+                compiler.reportCodeChange();\n             }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n+            nameMap.put(var, newName);\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,37 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName() && node.getQualifiedName().contains(\".\")) {\n+        Scope scope = t.getScope();\n+        Var var = t.getScope().getVar(node.getString());\n+        if (var != null && !var.isGlobal() && !nameMap.containsKey(var)) {\n+            String oldName = var.getName();\n+            int index = oldName.lastIndexOf('.');\n+            String newName = getOrginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            // Merge any names that were referenced but not declared in the current\n+            // scope.\n+            // If there isn't anything left in the stack we will be going into the\n+            // global scope: don't try to build a set of referenced names for the\n+            // global scope.\n+            boolean recurseScopes = false;\n+            if (!suffix.matches(\"\\\\d+\")) {\n+                recurseScopes = true;\n             }\n-            declarations.put(name, newName);\n+            // Check if the new name is valid and if it would cause conflicts.\n+            if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                newName = oldName;\n+            } else {\n+                var.scope.declare(newName, var.getNameNode(), null, null);\n+                // Adding a reference to the new name to prevent either the parent\n+                // scopes or the current scope renaming another var to this new name.\n+                Node parentNode = var.getParentNode();\n+                if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                    var.getNameNode().setString(newName);\n+                }\n+                node.setString(newName);\n+                compiler.reportCodeChange();\n+            }\n+            nameMap.put(var, newName);\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,37 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName() && node.getQualifiedName().contains(\".\")) {\n+        Scope scope = t.getScope();\n+        Var var = t.getScope().getVar(node.getString());\n+        if (var != null && !var.isGlobal() && !nameMap.containsKey(var)) {\n+            String oldName = var.getName();\n+            int index = oldName.lastIndexOf('.');\n+            String newName = getOrginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            // Merge any names that were referenced but not declared in the current\n+            // scope.\n+            // If there isn't anything left in the stack we will be going into the\n+            // global scope: don't try to build a set of referenced names for the\n+            // global scope.\n+            boolean recurseScopes = false;\n+            if (!suffix.matches(\"\\\\d+\")) {\n+                recurseScopes = true;\n+            }\n+            // Check if the new name is valid and if it would cause conflicts.\n+            if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                newName = oldName;\n+            } else {\n+                var.scope.declare(newName, var.getNameNode(), null, null);\n+                // Adding a reference to the new name to prevent either the parent\n+                // scopes or the current scope renaming another var to this new name.\n+                Node parentNode = var.getParentNode();\n+                if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                    var.getNameNode().setString(newName);\n+                }\n+                node.setString(newName);\n+                compiler.reportCodeChange();\n+            }\n+            nameMap.put(var, newName);\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.getType() == Token.NAME) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = t.getScope().getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOrginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                // Check if the new name is valid and if it would cause conflicts.\n                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    scope.declare(newName, var.nameNode, null, null);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -23,15 +23,15 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n+                    scope.declare(newName, var.nameNode, null, null);\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,47 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, var.nameNode, null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,47 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, var.nameNode, null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName()) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = scope.getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                // Check if the new name is valid and if it would cause conflicts.\n                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    scope.declare(newName, var.getNameNode(), var.getParentNode(), var.getInitialValue());\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.isFunction() && parentNode == scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,10 +1,10 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) {\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n+            Var var = scope.getVar(oldName);\n             if (var == null || var.isGlobal()) {\n                 return;\n             }\n@@ -12,7 +12,7 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n                 // Merge any names that were referenced but not declared in the current\n                 // scope.\n@@ -23,15 +23,15 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n+                    scope.declare(newName, var.getNameNode(), var.getParentNode(), var.getInitialValue());\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode.isFunction() && parentNode == scope.getRootNode()) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,47 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, var.getNameNode(), var.getParentNode(), var.getInitialValue());\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,47 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, var.getNameNode(), var.getParentNode(), var.getInitialValue());\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName()) { // Use isName() instead of getType() == Token.NAME for better readability\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = scope.getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index); // Fix typo in method name\n                String suffix = getNameSuffix(oldName, index);\n                boolean recurseScopes = true; // Simplify the logic for setting recurseScopes\n                if (suffix.matches(\"\\\\d+\")) { // Fix inverted logic for setting recurseScopes\n                    recurseScopes = false;\n                }\n                if (!TokenStream.isJSIdentifier(newName) || var.scope.isDeclared(newName, recurseScopes)) {\n                    newName = oldName;\n                } else {\n                    var.scope.declare(newName, var.nameNode, null, null);\n                    if (var.getParentNode().isFunction() && var.getParentNode() == var.scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,10 +1,10 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) { // Use isName() instead of getType() == Token.NAME for better readability\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n+            Var var = scope.getVar(oldName);\n             if (var == null || var.isGlobal()) {\n                 return;\n             }\n@@ -12,26 +12,17 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index); // Fix typo in method name\n                 String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n+                boolean recurseScopes = true; // Simplify the logic for setting recurseScopes\n+                if (suffix.matches(\"\\\\d+\")) { // Fix inverted logic for setting recurseScopes\n+                    recurseScopes = false;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                if (!TokenStream.isJSIdentifier(newName) || var.scope.isDeclared(newName, recurseScopes)) {\n                     newName = oldName;\n                 } else {\n                     var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (var.getParentNode().isFunction() && var.getParentNode() == var.scope.getRootNode()) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n@@ -39,9 +30,6 @@\n                 }\n                 nameMap.put(var, newName);\n             }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,35 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) { // Use isName() instead of getType() == Token.NAME for better readability\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index); // Fix typo in method name\n+                String suffix = getNameSuffix(oldName, index);\n+                boolean recurseScopes = true; // Simplify the logic for setting recurseScopes\n+                if (suffix.matches(\"\\\\d+\")) { // Fix inverted logic for setting recurseScopes\n+                    recurseScopes = false;\n+                }\n+                if (!TokenStream.isJSIdentifier(newName) || var.scope.isDeclared(newName, recurseScopes)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.nameNode, null, null);\n+                    if (var.getParentNode().isFunction() && var.getParentNode() == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,35 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) { // Use isName() instead of getType() == Token.NAME for better readability\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index); // Fix typo in method name\n+                String suffix = getNameSuffix(oldName, index);\n+                boolean recurseScopes = true; // Simplify the logic for setting recurseScopes\n+                if (suffix.matches(\"\\\\d+\")) { // Fix inverted logic for setting recurseScopes\n+                    recurseScopes = false;\n+                }\n+                if (!TokenStream.isJSIdentifier(newName) || var.scope.isDeclared(newName, recurseScopes)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.nameNode, null, null);\n+                    if (var.getParentNode().isFunction() && var.getParentNode() == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName() && node.hasChildren() && containsSeparator(node.getString())) {\n        String oldName = node.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(oldName);\n        if (var != null && !var.isGlobal() && !nameMap.containsKey(var)) {\n            int index = indexOfSeparator(oldName);\n            String newName = getOriginalNameInternal(oldName, index);\n            String suffix = getNameSuffix(oldName, index);\n            boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n            if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                newName = oldName;\n            } else {\n                var.scope.declare(newName, var.nameNode, null, null);\n                Node parentNode = var.getParentNode();\n                if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n                    var.getNameNode().setString(newName);\n                }\n                node.setString(newName);\n                nameMap.put(var, newName);\n                compiler.reportCodeChange();\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,47 +1,26 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName() && node.hasChildren() && containsSeparator(node.getString())) {\n         String oldName = node.getString();\n-        if (containsSeparator(oldName)) {\n-            Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n-            if (var == null || var.isGlobal()) {\n-                return;\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(oldName);\n+        if (var != null && !var.isGlobal() && !nameMap.containsKey(var)) {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOriginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+            if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                newName = oldName;\n+            } else {\n+                var.scope.declare(newName, var.nameNode, null, null);\n+                Node parentNode = var.getParentNode();\n+                if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                    var.getNameNode().setString(newName);\n+                }\n+                node.setString(newName);\n+                nameMap.put(var, newName);\n+                compiler.reportCodeChange();\n             }\n-            if (nameMap.containsKey(var)) {\n-                node.setString(nameMap.get(var));\n-            } else {\n-                int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n-                String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n-                    newName = oldName;\n-                } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n-                    }\n-                    node.setString(newName);\n-                    compiler.reportCodeChange();\n-                }\n-                nameMap.put(var, newName);\n-            }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,26 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName() && node.hasChildren() && containsSeparator(node.getString())) {\n+        String oldName = node.getString();\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(oldName);\n+        if (var != null && !var.isGlobal() && !nameMap.containsKey(var)) {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOriginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+            if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                newName = oldName;\n+            } else {\n+                var.scope.declare(newName, var.nameNode, null, null);\n+                Node parentNode = var.getParentNode();\n+                if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                    var.getNameNode().setString(newName);\n+                }\n+                node.setString(newName);\n+                nameMap.put(var, newName);\n+                compiler.reportCodeChange();\n             }\n-            declarations.put(name, newName);\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,26 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName() && node.hasChildren() && containsSeparator(node.getString())) {\n+        String oldName = node.getString();\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(oldName);\n+        if (var != null && !var.isGlobal() && !nameMap.containsKey(var)) {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOriginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+            if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                newName = oldName;\n+            } else {\n+                var.scope.declare(newName, var.nameNode, null, null);\n+                Node parentNode = var.getParentNode();\n+                if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                    var.getNameNode().setString(newName);\n+                }\n+                node.setString(newName);\n+                nameMap.put(var, newName);\n+                compiler.reportCodeChange();\n+            }\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.getType() == Token.NAME) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = t.getScope().getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOrginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                                // Check if the new name is valid and if it would cause conflicts.\n                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    scope.declare(newName, var.nameNode, null, null);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -24,14 +24,14 @@\n                     recurseScopes = true;\n                 }\n                                 // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n+                    scope.declare(newName, var.nameNode, null, null);\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,47 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, var.nameNode, null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,47 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.getType() == Token.NAME) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, var.nameNode, null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.getType() == Token.FUNCTION && parentNode == scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName()) { // Use isName() instead of getType() == Token.NAME\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = checkNotNull(scope.getVar(oldName), \"Unexpected null var\");\n            if (var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOrginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n                // Rename the variable and check for conflicts.\n                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    var.scope.declare(newName, var.nameNode, null, null);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,11 +1,11 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) { // Use isName() instead of getType() == Token.NAME\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n-            if (var == null || var.isGlobal()) {\n+            Var var = checkNotNull(scope.getVar(oldName), \"Unexpected null var\");\n+            if (var.isGlobal()) {\n                 return;\n             }\n             if (nameMap.containsKey(var)) {\n@@ -14,16 +14,8 @@\n                 int index = indexOfSeparator(oldName);\n                 String newName = getOrginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n+                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+                // Rename the variable and check for conflicts.\n                 if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n@@ -31,7 +23,7 @@\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n@@ -39,9 +31,6 @@\n                 }\n                 nameMap.put(var, newName);\n             }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,36 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) { // Use isName() instead of getType() == Token.NAME\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = checkNotNull(scope.getVar(oldName), \"Unexpected null var\");\n+            if (var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+                // Rename the variable and check for conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.nameNode, null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,36 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) { // Use isName() instead of getType() == Token.NAME\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = checkNotNull(scope.getVar(oldName), \"Unexpected null var\");\n+            if (var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+                // Rename the variable and check for conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.declare(newName, var.nameNode, null, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName() && containsSeparator(node.getString())) {\n        String oldName = node.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(oldName);\n        if (var == null || var.isGlobal()) {\n            return;\n        }\n        if (nameMap.containsKey(var)) {\n            node.setString(nameMap.get(var));\n        } else {\n            int index = indexOfSeparator(oldName);\n            String newName = getOrginalNameInternal(oldName, index);\n            String suffix = getNameSuffix(oldName, index);\n            boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n            // Check if the new name is valid and if it would cause conflicts.\n            if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                newName = oldName;\n            } else {\n                scope.declare(newName, var.getNode(), null, null);\n                // Adding a reference to the new name to prevent either the parent\n                // scopes or the current scope renaming another var to this new name.\n                Node parentNode = var.getParentNode();\n                if (parentNode.isFunction() && parentNode == scope.getRootNode()) {\n                    var.getNameNode().setString(newName);\n                }\n                node.setString(newName);\n                compiler.reportCodeChange();\n            }\n            nameMap.put(var, newName);\n        }\n        // Add all referenced names to the set so it is possible to check for conflicts.\n        // Store only references to candidate names in the node map.\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,47 +1,36 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName() && containsSeparator(node.getString())) {\n         String oldName = node.getString();\n-        if (containsSeparator(oldName)) {\n-            Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n-            if (var == null || var.isGlobal()) {\n-                return;\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(oldName);\n+        if (var == null || var.isGlobal()) {\n+            return;\n+        }\n+        if (nameMap.containsKey(var)) {\n+            node.setString(nameMap.get(var));\n+        } else {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOrginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+            // Check if the new name is valid and if it would cause conflicts.\n+            if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                newName = oldName;\n+            } else {\n+                scope.declare(newName, var.getNode(), null, null);\n+                // Adding a reference to the new name to prevent either the parent\n+                // scopes or the current scope renaming another var to this new name.\n+                Node parentNode = var.getParentNode();\n+                if (parentNode.isFunction() && parentNode == scope.getRootNode()) {\n+                    var.getNameNode().setString(newName);\n+                }\n+                node.setString(newName);\n+                compiler.reportCodeChange();\n             }\n-            if (nameMap.containsKey(var)) {\n-                node.setString(nameMap.get(var));\n-            } else {\n-                int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n-                String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n-                    newName = oldName;\n-                } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n-                    }\n-                    node.setString(newName);\n-                    compiler.reportCodeChange();\n-                }\n-                nameMap.put(var, newName);\n-            }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n+            nameMap.put(var, newName);\n         }\n+        // Add all referenced names to the set so it is possible to check for conflicts.\n+        // Store only references to candidate names in the node map.\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,36 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName() && containsSeparator(node.getString())) {\n+        String oldName = node.getString();\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(oldName);\n+        if (var == null || var.isGlobal()) {\n+            return;\n+        }\n+        if (nameMap.containsKey(var)) {\n+            node.setString(nameMap.get(var));\n+        } else {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOrginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+            // Check if the new name is valid and if it would cause conflicts.\n+            if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                newName = oldName;\n+            } else {\n+                scope.declare(newName, var.getNode(), null, null);\n+                // Adding a reference to the new name to prevent either the parent\n+                // scopes or the current scope renaming another var to this new name.\n+                Node parentNode = var.getParentNode();\n+                if (parentNode.isFunction() && parentNode == scope.getRootNode()) {\n+                    var.getNameNode().setString(newName);\n+                }\n+                node.setString(newName);\n+                compiler.reportCodeChange();\n             }\n-            declarations.put(name, newName);\n+            nameMap.put(var, newName);\n         }\n+        // Add all referenced names to the set so it is possible to check for conflicts.\n+        // Store only references to candidate names in the node map.\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,36 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName() && containsSeparator(node.getString())) {\n+        String oldName = node.getString();\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(oldName);\n+        if (var == null || var.isGlobal()) {\n+            return;\n+        }\n+        if (nameMap.containsKey(var)) {\n+            node.setString(nameMap.get(var));\n+        } else {\n+            int index = indexOfSeparator(oldName);\n+            String newName = getOrginalNameInternal(oldName, index);\n+            String suffix = getNameSuffix(oldName, index);\n+            boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+            // Check if the new name is valid and if it would cause conflicts.\n+            if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                newName = oldName;\n+            } else {\n+                scope.declare(newName, var.getNode(), null, null);\n+                // Adding a reference to the new name to prevent either the parent\n+                // scopes or the current scope renaming another var to this new name.\n+                Node parentNode = var.getParentNode();\n+                if (parentNode.isFunction() && parentNode == scope.getRootNode()) {\n+                    var.getNameNode().setString(newName);\n+                }\n+                node.setString(newName);\n+                compiler.reportCodeChange();\n+            }\n+            nameMap.put(var, newName);\n+        }\n+        // Add all referenced names to the set so it is possible to check for conflicts.\n+        // Store only references to candidate names in the node map.\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName()) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = scope.getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOrginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                // Check if the new name is valid and if it would cause conflicts.\n                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    var.setName(newName);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode != null && parentNode.isFunction() && parentNode == scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,10 +1,10 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) {\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n+            Var var = scope.getVar(oldName);\n             if (var == null || var.isGlobal()) {\n                 return;\n             }\n@@ -23,15 +23,15 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n+                    var.setName(newName);\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode != null && parentNode.isFunction() && parentNode == scope.getRootNode()) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,47 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.setName(newName);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode != null && parentNode.isFunction() && parentNode == scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,47 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.setName(newName);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode != null && parentNode.isFunction() && parentNode == scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName() && containsSeparator(node.getString())) {\n        Scope scope = t.getScope();\n        Var var = scope.getVar(node.getString());\n        if (var == null || var.isGlobal()) {\n            return;\n        }\n\n        String newName = null;\n        if (nameMap.containsKey(var)) {\n            newName = nameMap.get(var);\n        } else {\n            String oldName = node.getString();\n            int index = indexOfSeparator(oldName);\n            newName = getOrginalNameInternal(oldName, index);\n\n            if (!TokenStream.isJSIdentifier(newName)) {\n                newName = oldName;\n            } else {\n                if (var.getScope().isDeclared(newName, true)) {\n                    newName = oldName;\n                } else {\n                    var.setName(newName, compiler);\n                    compiler.reportCodeChange();\n                }\n            }\n\n            nameMap.put(var, newName);\n        }\n\n        node.setString(newName);\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,47 +1,34 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n-        String oldName = node.getString();\n-        if (containsSeparator(oldName)) {\n-            Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n-            if (var == null || var.isGlobal()) {\n-                return;\n-            }\n-            if (nameMap.containsKey(var)) {\n-                node.setString(nameMap.get(var));\n+    if (node.isName() && containsSeparator(node.getString())) {\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(node.getString());\n+        if (var == null || var.isGlobal()) {\n+            return;\n+        }\n+\n+        String newName = null;\n+        if (nameMap.containsKey(var)) {\n+            newName = nameMap.get(var);\n+        } else {\n+            String oldName = node.getString();\n+            int index = indexOfSeparator(oldName);\n+            newName = getOrginalNameInternal(oldName, index);\n+\n+            if (!TokenStream.isJSIdentifier(newName)) {\n+                newName = oldName;\n             } else {\n-                int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n-                String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                if (var.getScope().isDeclared(newName, true)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n-                    }\n-                    node.setString(newName);\n+                    var.setName(newName, compiler);\n                     compiler.reportCodeChange();\n                 }\n-                nameMap.put(var, newName);\n             }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n+\n+            nameMap.put(var, newName);\n         }\n+\n+        node.setString(newName);\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,34 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName() && containsSeparator(node.getString())) {\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(node.getString());\n+        if (var == null || var.isGlobal()) {\n+            return;\n+        }\n+\n+        String newName = null;\n+        if (nameMap.containsKey(var)) {\n+            newName = nameMap.get(var);\n+        } else {\n+            String oldName = node.getString();\n+            int index = indexOfSeparator(oldName);\n+            newName = getOrginalNameInternal(oldName, index);\n+\n+            if (!TokenStream.isJSIdentifier(newName)) {\n+                newName = oldName;\n+            } else {\n+                if (var.getScope().isDeclared(newName, true)) {\n+                    newName = oldName;\n+                } else {\n+                    var.setName(newName, compiler);\n+                    compiler.reportCodeChange();\n+                }\n             }\n-            declarations.put(name, newName);\n+\n+            nameMap.put(var, newName);\n         }\n+\n+        node.setString(newName);\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,34 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName() && containsSeparator(node.getString())) {\n+        Scope scope = t.getScope();\n+        Var var = scope.getVar(node.getString());\n+        if (var == null || var.isGlobal()) {\n+            return;\n+        }\n+\n+        String newName = null;\n+        if (nameMap.containsKey(var)) {\n+            newName = nameMap.get(var);\n+        } else {\n+            String oldName = node.getString();\n+            int index = indexOfSeparator(oldName);\n+            newName = getOrginalNameInternal(oldName, index);\n+\n+            if (!TokenStream.isJSIdentifier(newName)) {\n+                newName = oldName;\n+            } else {\n+                if (var.getScope().isDeclared(newName, true)) {\n+                    newName = oldName;\n+                } else {\n+                    var.setName(newName, compiler);\n+                    compiler.reportCodeChange();\n+                }\n+            }\n+\n+            nameMap.put(var, newName);\n+        }\n+\n+        node.setString(newName);\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName()) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = t.getScope().getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOrginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                // Check if the new name is valid and if it would cause conflicts.\n                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    scope.declare(newName, var.getNameNode(), var.input, null);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.isFunction() && parentNode == var.getScopeRoot()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,6 +1,6 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) {\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n@@ -23,15 +23,15 @@\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n+                // Check if the new name is valid and if it would cause conflicts.\n                 if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n+                    scope.declare(newName, var.getNameNode(), var.input, null);\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode.isFunction() && parentNode == var.getScopeRoot()) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,47 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, var.getNameNode(), var.input, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == var.getScopeRoot()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,47 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                // Check if the new name is valid and if it would cause conflicts.\n+                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    scope.declare(newName, var.getNameNode(), var.input, null);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == var.getScopeRoot()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName()) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = scope.getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOriginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                // Merge any names that were referenced but not declared in the current\n                // scope.\n                // If there isn't anything left in the stack we will be going into the\n                // global scope: don't try to build a set of referenced names for the\n                // global scope.\n                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n                // Check if the new name is valid and if it would cause conflicts.\n                Var sameScopeVar = var.scope.getOwnSlot(newName);\n                if (sameScopeVar != null || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    var.scope.getScope(newName).declare(newName, var.getNameNode(), var.input, var.kind);\n                    // Adding a reference to the new name to prevent either the parent\n                    // scopes or the current scope renaming another var to this new name.\n                    Node parentNode = var.getParentNode();\n                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n                        var.getNameNode().setString(newName);\n                    }\n                    node.setString(newName);\n                    compiler.reportCodeChange();\n                }\n                nameMap.put(var, newName);\n            }\n            // Add all referenced names to the set so it is possible to check for\n            // conflicts.\n            // Store only references to candidate names in the node map.\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,10 +1,10 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) {\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n-            Var var = t.getScope().getVar(oldName);\n+            Var var = scope.getVar(oldName);\n             if (var == null || var.isGlobal()) {\n                 return;\n             }\n@@ -12,26 +12,24 @@\n                 node.setString(nameMap.get(var));\n             } else {\n                 int index = indexOfSeparator(oldName);\n-                String newName = getOrginalNameInternal(oldName, index);\n+                String newName = getOriginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n                 // Merge any names that were referenced but not declared in the current\n                 // scope.\n                 // If there isn't anything left in the stack we will be going into the\n                 // global scope: don't try to build a set of referenced names for the\n                 // global scope.\n-                boolean recurseScopes = false;\n-                if (!suffix.matches(\"\\\\d+\")) {\n-                    recurseScopes = true;\n-                }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+                // Check if the new name is valid and if it would cause conflicts.\n+                Var sameScopeVar = var.scope.getOwnSlot(newName);\n+                if (sameScopeVar != null || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n+                    var.scope.getScope(newName).declare(newName, var.getNameNode(), var.input, var.kind);\n                     // Adding a reference to the new name to prevent either the parent\n                     // scopes or the current scope renaming another var to this new name.\n                     Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n+                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n                         var.getNameNode().setString(newName);\n                     }\n                     node.setString(newName);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,45 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+                // Check if the new name is valid and if it would cause conflicts.\n+                Var sameScopeVar = var.scope.getOwnSlot(newName);\n+                if (sameScopeVar != null || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.getScope(newName).declare(newName, var.getNameNode(), var.input, var.kind);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,45 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = scope.getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOriginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                // Merge any names that were referenced but not declared in the current\n+                // scope.\n+                // If there isn't anything left in the stack we will be going into the\n+                // global scope: don't try to build a set of referenced names for the\n+                // global scope.\n+                boolean recurseScopes = !suffix.matches(\"\\\\d+\");\n+                // Check if the new name is valid and if it would cause conflicts.\n+                Var sameScopeVar = var.scope.getOwnSlot(newName);\n+                if (sameScopeVar != null || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    var.scope.getScope(newName).declare(newName, var.getNameNode(), var.input, var.kind);\n+                    // Adding a reference to the new name to prevent either the parent\n+                    // scopes or the current scope renaming another var to this new name.\n+                    Node parentNode = var.getParentNode();\n+                    if (parentNode.isFunction() && parentNode == var.scope.getRootNode()) {\n+                        var.getNameNode().setString(newName);\n+                    }\n+                    node.setString(newName);\n+                    compiler.reportCodeChange();\n+                }\n+                nameMap.put(var, newName);\n+            }\n+            // Add all referenced names to the set so it is possible to check for\n+            // conflicts.\n+            // Store only references to candidate names in the node map.\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node node, Node parent) {\n    if (node.isName()) {\n        String oldName = node.getString();\n        if (containsSeparator(oldName)) {\n            Scope scope = t.getScope();\n            Var var = t.getScope().getVar(oldName);\n            if (var == null || var.isGlobal()) {\n                return;\n            }\n            if (nameMap.containsKey(var)) {\n                node.setString(nameMap.get(var));\n            } else {\n                int index = indexOfSeparator(oldName);\n                String newName = getOrginalNameInternal(oldName, index);\n                String suffix = getNameSuffix(oldName, index);\n                boolean recurseScopes = false;\n                if (!suffix.matches(\"\\\\d+\")) {\n                    recurseScopes = true;\n                }\n                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                    newName = oldName;\n                } else {\n                    Node nameNode = var.getNameNode();\n                    var.setName(newName);\n                    // Update any references to the variable.\n                    NodeTraversal.traverse(compiler, parent, new ChangeNameReferences(oldName, newName));\n                    // Do not add the new name to the mappings if the variable's original scope is the global scope.\n                    if (var.getParentNode().getType() == Token.FUNCTION && var.scope != t.getScope().getGlobalScope()) {\n                        nameMap.put(var, newName);\n                    }\n                    compiler.reportCodeChange();\n                }\n                node.setString(newName);\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,6 +1,6 @@\n @Override\n public void visit(NodeTraversal t, Node node, Node parent) {\n-    if (node.getType() == Token.NAME) {\n+    if (node.isName()) {\n         String oldName = node.getString();\n         if (containsSeparator(oldName)) {\n             Scope scope = t.getScope();\n@@ -14,34 +14,25 @@\n                 int index = indexOfSeparator(oldName);\n                 String newName = getOrginalNameInternal(oldName, index);\n                 String suffix = getNameSuffix(oldName, index);\n-                // Merge any names that were referenced but not declared in the current\n-                // scope.\n-                // If there isn't anything left in the stack we will be going into the\n-                // global scope: don't try to build a set of referenced names for the\n-                // global scope.\n                 boolean recurseScopes = false;\n                 if (!suffix.matches(\"\\\\d+\")) {\n                     recurseScopes = true;\n                 }\n-                                // Check if the new name is valid and if it would cause conflicts.\n-                if (var.scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n                     newName = oldName;\n                 } else {\n-                    var.scope.declare(newName, var.nameNode, null, null);\n-                    // Adding a reference to the new name to prevent either the parent\n-                    // scopes or the current scope renaming another var to this new name.\n-                    Node parentNode = var.getParentNode();\n-                    if (parentNode.getType() == Token.FUNCTION && parentNode == var.scope.getRootNode()) {\n-                        var.getNameNode().setString(newName);\n+                    Node nameNode = var.getNameNode();\n+                    var.setName(newName);\n+                    // Update any references to the variable.\n+                    NodeTraversal.traverse(compiler, parent, new ChangeNameReferences(oldName, newName));\n+                    // Do not add the new name to the mappings if the variable's original scope is the global scope.\n+                    if (var.getParentNode().getType() == Token.FUNCTION && var.scope != t.getScope().getGlobalScope()) {\n+                        nameMap.put(var, newName);\n                     }\n-                    node.setString(newName);\n                     compiler.reportCodeChange();\n                 }\n-                nameMap.put(var, newName);\n+                node.setString(newName);\n             }\n-            // Add all referenced names to the set so it is possible to check for\n-            // conflicts.\n-            // Store only references to candidate names in the node map.\n         }\n     }\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@addDeclaredName\n@@ -1,16 +1,38 @@\n @Override\n-public void addDeclaredName(String name) {\n-    if (global) {\n-        reserveName(name);\n-    } else {\n-        // It hasn't been declared locally yet, so increment the count.\n-        if (!declarations.containsKey(name)) {\n-            int id = incrementNameCount(name);\n-            String newName = null;\n-            if (id != 0) {\n-                newName = getUniqueName(name, id);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n             }\n-            declarations.put(name, newName);\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    Node nameNode = var.getNameNode();\n+                    var.setName(newName);\n+                    // Update any references to the variable.\n+                    NodeTraversal.traverse(compiler, parent, new ChangeNameReferences(oldName, newName));\n+                    // Do not add the new name to the mappings if the variable's original scope is the global scope.\n+                    if (var.getParentNode().getType() == Token.FUNCTION && var.scope != t.getScope().getGlobalScope()) {\n+                        nameMap.put(var, newName);\n+                    }\n+                    compiler.reportCodeChange();\n+                }\n+                node.setString(newName);\n+            }\n         }\n     }\n }\n--- com/google/javascript/jscomp/Normalize.java@process\n+++ com/google/javascript/jscomp/Normalize.java@process\n@@ -1,25 +1,38 @@\n @Override\n-public void process(Node externs, Node root) {\n-    NodeTraversal.traverse(compiler, root, new NormalizeStatements(compiler, assertOnChange));\n-    removeDuplicateDeclarations(root);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-        NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+public void visit(NodeTraversal t, Node node, Node parent) {\n+    if (node.isName()) {\n+        String oldName = node.getString();\n+        if (containsSeparator(oldName)) {\n+            Scope scope = t.getScope();\n+            Var var = t.getScope().getVar(oldName);\n+            if (var == null || var.isGlobal()) {\n+                return;\n+            }\n+            if (nameMap.containsKey(var)) {\n+                node.setString(nameMap.get(var));\n+            } else {\n+                int index = indexOfSeparator(oldName);\n+                String newName = getOrginalNameInternal(oldName, index);\n+                String suffix = getNameSuffix(oldName, index);\n+                boolean recurseScopes = false;\n+                if (!suffix.matches(\"\\\\d+\")) {\n+                    recurseScopes = true;\n+                }\n+                if (scope.isDeclared(newName, recurseScopes) || !TokenStream.isJSIdentifier(newName)) {\n+                    newName = oldName;\n+                } else {\n+                    Node nameNode = var.getNameNode();\n+                    var.setName(newName);\n+                    // Update any references to the variable.\n+                    NodeTraversal.traverse(compiler, parent, new ChangeNameReferences(oldName, newName));\n+                    // Do not add the new name to the mappings if the variable's original scope is the global scope.\n+                    if (var.getParentNode().getType() == Token.FUNCTION && var.scope != t.getScope().getGlobalScope()) {\n+                        nameMap.put(var, newName);\n+                    }\n+                    compiler.reportCodeChange();\n+                }\n+                node.setString(newName);\n+            }\n+        }\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    new PropogateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]