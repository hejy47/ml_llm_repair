[{"output": "@Override\npublic boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n    if (start.isReferenced()) {\n        JSModule startModule = start.getInput().getModule();\n        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n            return dest.markReference(startModule);\n        } else {\n            return dest.markReference(edge);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,12 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getInput().getModule();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,12 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getInput().getModule();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,12 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getInput().getModule();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n     }\n-    return true;\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,12 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getInput().getModule();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n         } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n+            return dest.markReference(edge);\n         }\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,7 +1,7 @@\n @Override\n public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n     if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n+        JSModule startModule = start.getInput().getModule();\n         if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n             return dest.markReference(startModule);\n         } else {\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,12 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getInput().getModule();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n     }\n+    return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n    if (start.isReferenced()) {\n        JSModule startModule = start.getDeepestCommonModuleRef();\n        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n            return dest.markReference(startModule);\n        } else if (!edge.isInline()) { // add check for non-inline edge\n            return dest.markReference(edge);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,12 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        } else if (!edge.isInline()) { // add check for non-inline edge\n+            return dest.markReference(edge);\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,12 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        } else if (!edge.isInline()) { // add check for non-inline edge\n+            return dest.markReference(edge);\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,12 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        } else if (!edge.isInline()) { // add check for non-inline edge\n+            return dest.markReference(edge);\n+        }\n     }\n-    return true;\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,12 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        } else if (!edge.isInline()) { // add check for non-inline edge\n+            return dest.markReference(edge);\n         }\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -4,7 +4,7 @@\n         JSModule startModule = start.getDeepestCommonModuleRef();\n         if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n             return dest.markReference(startModule);\n-        } else {\n+        } else if (!edge.isInline()) { // add check for non-inline edge\n             return dest.markReference(edge);\n         }\n     }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,12 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        } else if (!edge.isInline()) { // add check for non-inline edge\n+            return dest.markReference(edge);\n+        }\n     }\n+    return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n    if (start.isReferenced()) {\n        JSModule startModule = start.getModule();\n        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n            return dest.markReference(startModule);\n        } else {\n            return dest.markReference(edge);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,12 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getModule();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,12 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getModule();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,12 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getModule();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n     }\n-    return true;\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,12 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getModule();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n         } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n+            return dest.markReference(edge);\n         }\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,7 +1,7 @@\n @Override\n public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n     if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n+        JSModule startModule = start.getModule();\n         if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n             return dest.markReference(startModule);\n         } else {\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,12 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getModule();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n     }\n+    return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "@Override\npublic boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n    if (start.isReferenced()) {\n        JSModule startModule = start.getDeepestCommonModuleRef();\n        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n            dest.markReference(startModule);\n        } else {\n            dest.markReference(edge);\n        }\n        return true; // return true if reference was marked\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,13 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+        } else {\n+            dest.markReference(edge);\n+        }\n+        return true; // return true if reference was marked\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,13 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+        } else {\n+            dest.markReference(edge);\n+        }\n+        return true; // return true if reference was marked\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,13 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+        } else {\n+            dest.markReference(edge);\n+        }\n+        return true; // return true if reference was marked\n     }\n-    return true;\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,13 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n         } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n+            dest.markReference(edge);\n         }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n+        return true; // return true if reference was marked\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -3,10 +3,11 @@\n     if (start.isReferenced()) {\n         JSModule startModule = start.getDeepestCommonModuleRef();\n         if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n+            dest.markReference(startModule);\n         } else {\n-            return dest.markReference(edge);\n+            dest.markReference(edge);\n         }\n+        return true; // return true if reference was marked\n     }\n     return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,13 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+        } else {\n+            dest.markReference(edge);\n+        }\n+        return true; // return true if reference was marked\n     }\n+    return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n    if (start.isReferenced()) {\n        JSModule startModule = start.getDeepestCommonModuleRef();\n        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n            // need to add a check for dest being already marked as a reference\n            if (dest.isReferenced()) {\n                return dest.getDeepestCommonModuleRef().equals(start.getDeepestCommonModuleRef());\n            } else {\n                return dest.markReference(startModule);\n            }\n        } else {\n            return dest.markReference(edge);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,17 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            // need to add a check for dest being already marked as a reference\n+            if (dest.isReferenced()) {\n+                return dest.getDeepestCommonModuleRef().equals(start.getDeepestCommonModuleRef());\n+            } else {\n+                return dest.markReference(startModule);\n+            }\n+        } else {\n+            return dest.markReference(edge);\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,17 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            // need to add a check for dest being already marked as a reference\n+            if (dest.isReferenced()) {\n+                return dest.getDeepestCommonModuleRef().equals(start.getDeepestCommonModuleRef());\n+            } else {\n+                return dest.markReference(startModule);\n+            }\n+        } else {\n+            return dest.markReference(edge);\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,17 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            // need to add a check for dest being already marked as a reference\n+            if (dest.isReferenced()) {\n+                return dest.getDeepestCommonModuleRef().equals(start.getDeepestCommonModuleRef());\n+            } else {\n+                return dest.markReference(startModule);\n+            }\n+        } else {\n+            return dest.markReference(edge);\n+        }\n     }\n-    return true;\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,17 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            // need to add a check for dest being already marked as a reference\n+            if (dest.isReferenced()) {\n+                return dest.getDeepestCommonModuleRef().equals(start.getDeepestCommonModuleRef());\n+            } else {\n+                return dest.markReference(startModule);\n+            }\n         } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n+            return dest.markReference(edge);\n         }\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -3,7 +3,12 @@\n     if (start.isReferenced()) {\n         JSModule startModule = start.getDeepestCommonModuleRef();\n         if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n+            // need to add a check for dest being already marked as a reference\n+            if (dest.isReferenced()) {\n+                return dest.getDeepestCommonModuleRef().equals(start.getDeepestCommonModuleRef());\n+            } else {\n+                return dest.markReference(startModule);\n+            }\n         } else {\n             return dest.markReference(edge);\n         }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,17 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            // need to add a check for dest being already marked as a reference\n+            if (dest.isReferenced()) {\n+                return dest.getDeepestCommonModuleRef().equals(start.getDeepestCommonModuleRef());\n+            } else {\n+                return dest.markReference(startModule);\n+            }\n+        } else {\n+            return dest.markReference(edge);\n+        }\n     }\n+    return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n    if (start.isReferenced()) {\n        JSModule startModule = start.getDeepestCommonModuleRef();\n        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n            dest.markReference(startModule);\n            return true;\n        } else {\n            dest.markReference(edge);\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,14 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+            return true;\n+        } else {\n+            dest.markReference(edge);\n+            return true;\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,14 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+            return true;\n+        } else {\n+            dest.markReference(edge);\n+            return true;\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,14 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+            return true;\n+        } else {\n+            dest.markReference(edge);\n+            return true;\n+        }\n     }\n-    return true;\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,14 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+            return true;\n         } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n+            dest.markReference(edge);\n+            return true;\n         }\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -3,9 +3,11 @@\n     if (start.isReferenced()) {\n         JSModule startModule = start.getDeepestCommonModuleRef();\n         if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n+            dest.markReference(startModule);\n+            return true;\n         } else {\n-            return dest.markReference(edge);\n+            dest.markReference(edge);\n+            return true;\n         }\n     }\n     return false;\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,14 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+            return true;\n+        } else {\n+            dest.markReference(edge);\n+            return true;\n+        }\n     }\n+    return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n    if (start.isReferenced()) {\n        JSModule startModule = start.getDeepestCommonModuleRef();\n        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n            dest.markReference(startModule);\n        } else {\n            dest.markReference(edge);\n        }\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,13 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+        } else {\n+            dest.markReference(edge);\n+        }\n+        return true;\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,13 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+        } else {\n+            dest.markReference(edge);\n+        }\n+        return true;\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,13 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+        } else {\n+            dest.markReference(edge);\n+        }\n+        return true;\n     }\n-    return true;\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,13 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n         } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n+            dest.markReference(edge);\n         }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n+        return true;\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -3,10 +3,11 @@\n     if (start.isReferenced()) {\n         JSModule startModule = start.getDeepestCommonModuleRef();\n         if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n+            dest.markReference(startModule);\n         } else {\n-            return dest.markReference(edge);\n+            dest.markReference(edge);\n         }\n+        return true;\n     }\n     return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,13 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+        } else {\n+            dest.markReference(edge);\n+        }\n+        return true;\n     }\n+    return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 4}, {"output": "@Override\npublic boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n    if (start.isReferenced()) {\n        JSModule startModule = start.getDeepestCommonModuleRef();\n        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n            // need to mark start as a reference to the common module too\n            start.markReference(startModule);\n            return dest.markReference(startModule);\n        } else {\n            return dest.markReference(edge);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,14 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            // need to mark start as a reference to the common module too\n+            start.markReference(startModule);\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,14 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            // need to mark start as a reference to the common module too\n+            start.markReference(startModule);\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,14 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            // need to mark start as a reference to the common module too\n+            start.markReference(startModule);\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n     }\n-    return true;\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,14 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            // need to mark start as a reference to the common module too\n+            start.markReference(startModule);\n+            return dest.markReference(startModule);\n         } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n+            return dest.markReference(edge);\n         }\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -3,6 +3,8 @@\n     if (start.isReferenced()) {\n         JSModule startModule = start.getDeepestCommonModuleRef();\n         if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            // need to mark start as a reference to the common module too\n+            start.markReference(startModule);\n             return dest.markReference(startModule);\n         } else {\n             return dest.markReference(edge);\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,14 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            // need to mark start as a reference to the common module too\n+            start.markReference(startModule);\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n     }\n+    return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n    if (start.isReferenced()) {\n        JSModule startModule = start.getDeepestCommonModuleRef();\n        if (startModule != null && startModule != edge && moduleGraph.dependsOn(startModule, edge)) {\n            return dest.markReference(startModule);\n        } else {\n            return dest.markReference(edge);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,12 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && startModule != edge && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,12 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && startModule != edge && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,12 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && startModule != edge && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n     }\n-    return true;\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,12 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && startModule != edge && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n         } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n+            return dest.markReference(edge);\n         }\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -2,7 +2,7 @@\n public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n     if (start.isReferenced()) {\n         JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+        if (startModule != null && startModule != edge && moduleGraph.dependsOn(startModule, edge)) {\n             return dest.markReference(startModule);\n         } else {\n             return dest.markReference(edge);\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,12 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && startModule != edge && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n     }\n+    return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n    if (start.isReferenced()) {\n        JSModule startModule = start.getDeepestCommonModuleRef();\n        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n            dest.markReference(startModule);\n        } \n        dest.markReference(edge);\n        return true; // return true as we have successfully traversed the edge\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,12 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+        } \n+        dest.markReference(edge);\n+        return true; // return true as we have successfully traversed the edge\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,12 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+        } \n+        dest.markReference(edge);\n+        return true; // return true as we have successfully traversed the edge\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,12 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+        } \n+        dest.markReference(edge);\n+        return true; // return true as we have successfully traversed the edge\n     }\n-    return true;\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,12 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+        } \n+        dest.markReference(edge);\n+        return true; // return true as we have successfully traversed the edge\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -3,10 +3,10 @@\n     if (start.isReferenced()) {\n         JSModule startModule = start.getDeepestCommonModuleRef();\n         if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+            dest.markReference(startModule);\n+        } \n+        dest.markReference(edge);\n+        return true; // return true as we have successfully traversed the edge\n     }\n     return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,12 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+        } \n+        dest.markReference(edge);\n+        return true; // return true as we have successfully traversed the edge\n     }\n+    return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n    if (start.isReferenced()) {\n        JSModule startModule = start.getDeepestCommonModuleRef();\n        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n            dest.markReference(startModule);\n        } \n        dest.markReference(edge);\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,12 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+        } \n+        dest.markReference(edge);\n+        return true;\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,12 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+        } \n+        dest.markReference(edge);\n+        return true;\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,12 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+        } \n+        dest.markReference(edge);\n+        return true;\n     }\n-    return true;\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,12 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+        } \n+        dest.markReference(edge);\n+        return true;\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -3,10 +3,10 @@\n     if (start.isReferenced()) {\n         JSModule startModule = start.getDeepestCommonModuleRef();\n         if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+            dest.markReference(startModule);\n+        } \n+        dest.markReference(edge);\n+        return true;\n     }\n     return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,12 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            dest.markReference(startModule);\n+        } \n+        dest.markReference(edge);\n+        return true;\n     }\n+    return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n    if (start.isReferenced()) {\n        JSModule startModule = start.getDeepestCommonModuleRef();\n        if (startModule != null && startModule != edge && moduleGraph.dependsOn(startModule, edge)) {\n            return dest.markReference(startModule);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,10 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && startModule != edge && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,10 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && startModule != edge && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,10 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && startModule != edge && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        }\n     }\n-    return true;\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,10 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && startModule != edge && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n         }\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -2,10 +2,8 @@\n public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n     if (start.isReferenced()) {\n         JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+        if (startModule != null && startModule != edge && moduleGraph.dependsOn(startModule, edge)) {\n             return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n         }\n     }\n     return false;\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,10 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && startModule != edge && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule);\n+        }\n     }\n+    return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n    if (start.isReferenced()) {\n        JSModule startModule = start.getDeepestCommonModuleRef();\n        if (startModule != null && moduleGraph.dependsOn(edge, startModule)) { // fix: parameter order in dependsOn method\n            return dest.markReference(startModule);\n        } else {\n            return dest.markReference(edge);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,12 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(edge, startModule)) { // fix: parameter order in dependsOn method\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,12 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(edge, startModule)) { // fix: parameter order in dependsOn method\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,12 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(edge, startModule)) { // fix: parameter order in dependsOn method\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n     }\n-    return true;\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,12 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(edge, startModule)) { // fix: parameter order in dependsOn method\n+            return dest.markReference(startModule);\n         } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n+            return dest.markReference(edge);\n         }\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -2,7 +2,7 @@\n public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n     if (start.isReferenced()) {\n         JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+        if (startModule != null && moduleGraph.dependsOn(edge, startModule)) { // fix: parameter order in dependsOn method\n             return dest.markReference(startModule);\n         } else {\n             return dest.markReference(edge);\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,12 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(edge, startModule)) { // fix: parameter order in dependsOn method\n+            return dest.markReference(startModule);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n     }\n+    return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n    if (start.isReferenced()) {\n        JSModule startModule = start.getDeepestCommonModuleRef();\n        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n            return dest.markReference(startModule) || startModule.equals(edge);\n        } else {\n            return dest.markReference(edge);\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,12 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule) || startModule.equals(edge);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,12 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule) || startModule.equals(edge);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n+    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,12 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule) || startModule.equals(edge);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n     }\n-    return true;\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,12 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule) || startModule.equals(edge);\n         } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n+            return dest.markReference(edge);\n         }\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -3,7 +3,7 @@\n     if (start.isReferenced()) {\n         JSModule startModule = start.getDeepestCommonModuleRef();\n         if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n+            return dest.markReference(startModule) || startModule.equals(edge);\n         } else {\n             return dest.markReference(edge);\n         }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,12 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n+    if (start.isReferenced()) {\n+        JSModule startModule = start.getDeepestCommonModuleRef();\n+        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n+            return dest.markReference(startModule) || startModule.equals(edge);\n+        } else {\n+            return dest.markReference(edge);\n+        }\n     }\n+    return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]