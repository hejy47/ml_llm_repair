[{"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    scope = scope.getParent();\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,4 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public void exitScope(NodeTraversal t) {\n+    scope = scope.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,4 @@\n @Override\n public void exitScope(NodeTraversal t) {\n+    scope = scope.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,4 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n-    }\n-    return true;\n+public void exitScope(NodeTraversal t) {\n+    scope = scope.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,4 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+public void exitScope(NodeTraversal t) {\n+    scope = scope.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,4 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n-    }\n-    return false;\n+public void exitScope(NodeTraversal t) {\n+    scope = scope.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,4 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n-    }\n+public void exitScope(NodeTraversal t) {\n+    scope = scope.getParent();\n }\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    currentScope = currentScope.getParent();\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,4 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public void exitScope(NodeTraversal t) {\n+    currentScope = currentScope.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,4 @@\n @Override\n public void exitScope(NodeTraversal t) {\n+    currentScope = currentScope.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,4 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n-    }\n-    return true;\n+public void exitScope(NodeTraversal t) {\n+    currentScope = currentScope.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,4 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+public void exitScope(NodeTraversal t) {\n+    currentScope = currentScope.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,4 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n-    }\n-    return false;\n+public void exitScope(NodeTraversal t) {\n+    currentScope = currentScope.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,4 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n-    }\n+public void exitScope(NodeTraversal t) {\n+    currentScope = currentScope.getParent();\n }\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    // Perform necessary actions before exiting the scope\n    // such as cleaning up resources or finalizing computations.\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,5 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public void exitScope(NodeTraversal t) {\n+    // Perform necessary actions before exiting the scope\n+    // such as cleaning up resources or finalizing computations.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,5 @@\n @Override\n public void exitScope(NodeTraversal t) {\n+    // Perform necessary actions before exiting the scope\n+    // such as cleaning up resources or finalizing computations.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,5 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n-    }\n-    return true;\n+public void exitScope(NodeTraversal t) {\n+    // Perform necessary actions before exiting the scope\n+    // such as cleaning up resources or finalizing computations.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,5 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+public void exitScope(NodeTraversal t) {\n+    // Perform necessary actions before exiting the scope\n+    // such as cleaning up resources or finalizing computations.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,5 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n-    }\n-    return false;\n+public void exitScope(NodeTraversal t) {\n+    // Perform necessary actions before exiting the scope\n+    // such as cleaning up resources or finalizing computations.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,5 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n-    }\n+public void exitScope(NodeTraversal t) {\n+    // Perform necessary actions before exiting the scope\n+    // such as cleaning up resources or finalizing computations.\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    t.getScope().clearNamedTypes();\n    t.getScope().clearLocalBindings();\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,5 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearNamedTypes();\n+    t.getScope().clearLocalBindings();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,5 @@\n @Override\n public void exitScope(NodeTraversal t) {\n+    t.getScope().clearNamedTypes();\n+    t.getScope().clearLocalBindings();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,5 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n-    }\n-    return true;\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearNamedTypes();\n+    t.getScope().clearLocalBindings();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,5 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearNamedTypes();\n+    t.getScope().clearLocalBindings();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,5 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n-    }\n-    return false;\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearNamedTypes();\n+    t.getScope().clearLocalBindings();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,5 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n-    }\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearNamedTypes();\n+    t.getScope().clearLocalBindings();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    if (scope != null) {\n        scope.clearNamedTypes();\n        scope.clearConstants();\n    }\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,8 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public void exitScope(NodeTraversal t) {\n+    Scope scope = t.getScope();\n+    if (scope != null) {\n+        scope.clearNamedTypes();\n+        scope.clearConstants();\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,8 @@\n @Override\n public void exitScope(NodeTraversal t) {\n+    Scope scope = t.getScope();\n+    if (scope != null) {\n+        scope.clearNamedTypes();\n+        scope.clearConstants();\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,8 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void exitScope(NodeTraversal t) {\n+    Scope scope = t.getScope();\n+    if (scope != null) {\n+        scope.clearNamedTypes();\n+        scope.clearConstants();\n     }\n-    return true;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,8 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n+public void exitScope(NodeTraversal t) {\n+    Scope scope = t.getScope();\n+    if (scope != null) {\n+        scope.clearNamedTypes();\n+        scope.clearConstants();\n     }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,8 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+public void exitScope(NodeTraversal t) {\n+    Scope scope = t.getScope();\n+    if (scope != null) {\n+        scope.clearNamedTypes();\n+        scope.clearConstants();\n     }\n-    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,8 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void exitScope(NodeTraversal t) {\n+    Scope scope = t.getScope();\n+    if (scope != null) {\n+        scope.clearNamedTypes();\n+        scope.clearConstants();\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    t.getScope().setInFunctionBlock(false); // or any other desired action\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,4 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().setInFunctionBlock(false); // or any other desired action\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,4 @@\n @Override\n public void exitScope(NodeTraversal t) {\n+    t.getScope().setInFunctionBlock(false); // or any other desired action\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,4 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n-    }\n-    return true;\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().setInFunctionBlock(false); // or any other desired action\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,4 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().setInFunctionBlock(false); // or any other desired action\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,4 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n-    }\n-    return false;\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().setInFunctionBlock(false); // or any other desired action\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,4 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n-    }\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().setInFunctionBlock(false); // or any other desired action\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    // perform necessary actions before exiting the scope\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,4 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public void exitScope(NodeTraversal t) {\n+    // perform necessary actions before exiting the scope\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,4 @@\n @Override\n public void exitScope(NodeTraversal t) {\n+    // perform necessary actions before exiting the scope\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,4 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n-    }\n-    return true;\n+public void exitScope(NodeTraversal t) {\n+    // perform necessary actions before exiting the scope\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,4 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+public void exitScope(NodeTraversal t) {\n+    // perform necessary actions before exiting the scope\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,4 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n-    }\n-    return false;\n+public void exitScope(NodeTraversal t) {\n+    // perform necessary actions before exiting the scope\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,4 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n-    }\n+public void exitScope(NodeTraversal t) {\n+    // perform necessary actions before exiting the scope\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    t.getScope().clearNamedTypes();\n    t.getScope().clearLocalNames();\n    t.getScope().clearBlockVars();\n    t.getScope().declareThis();\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,7 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearNamedTypes();\n+    t.getScope().clearLocalNames();\n+    t.getScope().clearBlockVars();\n+    t.getScope().declareThis();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,7 @@\n @Override\n public void exitScope(NodeTraversal t) {\n+    t.getScope().clearNamedTypes();\n+    t.getScope().clearLocalNames();\n+    t.getScope().clearBlockVars();\n+    t.getScope().declareThis();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,7 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n-    }\n-    return true;\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearNamedTypes();\n+    t.getScope().clearLocalNames();\n+    t.getScope().clearBlockVars();\n+    t.getScope().declareThis();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,7 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearNamedTypes();\n+    t.getScope().clearLocalNames();\n+    t.getScope().clearBlockVars();\n+    t.getScope().declareThis();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,7 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n-    }\n-    return false;\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearNamedTypes();\n+    t.getScope().clearLocalNames();\n+    t.getScope().clearBlockVars();\n+    t.getScope().declareThis();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,7 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n-    }\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearNamedTypes();\n+    t.getScope().clearLocalNames();\n+    t.getScope().clearBlockVars();\n+    t.getScope().declareThis();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    t.getScope().clearBlockScope();\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,4 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearBlockScope();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,4 @@\n @Override\n public void exitScope(NodeTraversal t) {\n+    t.getScope().clearBlockScope();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,4 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n-    }\n-    return true;\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearBlockScope();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,4 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearBlockScope();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,4 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n-    }\n-    return false;\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearBlockScope();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,4 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n-    }\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearBlockScope();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    t.getScope().clearNamedTypes();\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,4 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearNamedTypes();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,4 @@\n @Override\n public void exitScope(NodeTraversal t) {\n+    t.getScope().clearNamedTypes();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,4 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n-    }\n-    return true;\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearNamedTypes();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,4 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearNamedTypes();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,4 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n-    }\n-    return false;\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearNamedTypes();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,4 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n-    }\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearNamedTypes();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() == 1) {\n        // Do any necessary cleanup or logging\n    }\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,6 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() == 1) {\n+        // Do any necessary cleanup or logging\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,6 @@\n @Override\n public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() == 1) {\n+        // Do any necessary cleanup or logging\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,6 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() == 1) {\n+        // Do any necessary cleanup or logging\n     }\n-    return true;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,6 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() == 1) {\n+        // Do any necessary cleanup or logging\n     }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,6 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() == 1) {\n+        // Do any necessary cleanup or logging\n     }\n-    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,6 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() == 1) {\n+        // Do any necessary cleanup or logging\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    table = table.getParent();\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,4 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public void exitScope(NodeTraversal t) {\n+    table = table.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,4 @@\n @Override\n public void exitScope(NodeTraversal t) {\n+    table = table.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,4 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n-    }\n-    return true;\n+public void exitScope(NodeTraversal t) {\n+    table = table.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,4 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+public void exitScope(NodeTraversal t) {\n+    table = table.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,4 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n-    }\n-    return false;\n+public void exitScope(NodeTraversal t) {\n+    table = table.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,4 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n-    }\n+public void exitScope(NodeTraversal t) {\n+    table = table.getParent();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    t.getScope().getVars().forEach((name, var) -> {\n        if (var.getScope() == t.getScope()) {\n            var.setFromExterns(false);\n        }\n    });\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,8 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().getVars().forEach((name, var) -> {\n+        if (var.getScope() == t.getScope()) {\n+            var.setFromExterns(false);\n+        }\n+    });\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,8 @@\n @Override\n public void exitScope(NodeTraversal t) {\n+    t.getScope().getVars().forEach((name, var) -> {\n+        if (var.getScope() == t.getScope()) {\n+            var.setFromExterns(false);\n+        }\n+    });\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,8 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n-    }\n-    return true;\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().getVars().forEach((name, var) -> {\n+        if (var.getScope() == t.getScope()) {\n+            var.setFromExterns(false);\n+        }\n+    });\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,8 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().getVars().forEach((name, var) -> {\n+        if (var.getScope() == t.getScope()) {\n+            var.setFromExterns(false);\n         }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    });\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,8 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().getVars().forEach((name, var) -> {\n+        if (var.getScope() == t.getScope()) {\n+            var.setFromExterns(false);\n         }\n-    }\n-    return false;\n+    });\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,8 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n-    }\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().getVars().forEach((name, var) -> {\n+        if (var.getScope() == t.getScope()) {\n+            var.setFromExterns(false);\n+        }\n+    });\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    // perform necessary actions before exiting from current scope\n    scope = scope.getParent();\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,5 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public void exitScope(NodeTraversal t) {\n+    // perform necessary actions before exiting from current scope\n+    scope = scope.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,5 @@\n @Override\n public void exitScope(NodeTraversal t) {\n+    // perform necessary actions before exiting from current scope\n+    scope = scope.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,5 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n-    }\n-    return true;\n+public void exitScope(NodeTraversal t) {\n+    // perform necessary actions before exiting from current scope\n+    scope = scope.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,5 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+public void exitScope(NodeTraversal t) {\n+    // perform necessary actions before exiting from current scope\n+    scope = scope.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,5 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n-    }\n-    return false;\n+public void exitScope(NodeTraversal t) {\n+    // perform necessary actions before exiting from current scope\n+    scope = scope.getParent();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,5 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n-    }\n+public void exitScope(NodeTraversal t) {\n+    // perform necessary actions before exiting from current scope\n+    scope = scope.getParent();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    t.getScope().clearBlockVars();\n    t.getScope().clearDeclarations();\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,5 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearBlockVars();\n+    t.getScope().clearDeclarations();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,5 @@\n @Override\n public void exitScope(NodeTraversal t) {\n+    t.getScope().clearBlockVars();\n+    t.getScope().clearDeclarations();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,5 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n-    }\n-    return true;\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearBlockVars();\n+    t.getScope().clearDeclarations();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,5 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearBlockVars();\n+    t.getScope().clearDeclarations();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,5 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n-    }\n-    return false;\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearBlockVars();\n+    t.getScope().clearDeclarations();\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,5 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n-    }\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().clearBlockVars();\n+    t.getScope().clearDeclarations();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    t.getScope().getVars().forEach((name, var) -> {\n        Var.Symbol symbol = Var.Symbol.fromDeclaration(var.getDeclaration());\n        if (symbol != null) {\n            symbol.handleExit(t, var);\n        }\n    });\n    t.getScope().setVarDeclarations(null);\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,10 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().getVars().forEach((name, var) -> {\n+        Var.Symbol symbol = Var.Symbol.fromDeclaration(var.getDeclaration());\n+        if (symbol != null) {\n+            symbol.handleExit(t, var);\n+        }\n+    });\n+    t.getScope().setVarDeclarations(null);\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,10 @@\n @Override\n public void exitScope(NodeTraversal t) {\n+    t.getScope().getVars().forEach((name, var) -> {\n+        Var.Symbol symbol = Var.Symbol.fromDeclaration(var.getDeclaration());\n+        if (symbol != null) {\n+            symbol.handleExit(t, var);\n+        }\n+    });\n+    t.getScope().setVarDeclarations(null);\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,10 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n-    }\n-    return true;\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().getVars().forEach((name, var) -> {\n+        Var.Symbol symbol = Var.Symbol.fromDeclaration(var.getDeclaration());\n+        if (symbol != null) {\n+            symbol.handleExit(t, var);\n+        }\n+    });\n+    t.getScope().setVarDeclarations(null);\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,10 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().getVars().forEach((name, var) -> {\n+        Var.Symbol symbol = Var.Symbol.fromDeclaration(var.getDeclaration());\n+        if (symbol != null) {\n+            symbol.handleExit(t, var);\n         }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    });\n+    t.getScope().setVarDeclarations(null);\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,10 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().getVars().forEach((name, var) -> {\n+        Var.Symbol symbol = Var.Symbol.fromDeclaration(var.getDeclaration());\n+        if (symbol != null) {\n+            symbol.handleExit(t, var);\n         }\n-    }\n-    return false;\n+    });\n+    t.getScope().setVarDeclarations(null);\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,10 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n-    }\n+public void exitScope(NodeTraversal t) {\n+    t.getScope().getVars().forEach((name, var) -> {\n+        Var.Symbol symbol = Var.Symbol.fromDeclaration(var.getDeclaration());\n+        if (symbol != null) {\n+            symbol.handleExit(t, var);\n+        }\n+    });\n+    t.getScope().setVarDeclarations(null);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]