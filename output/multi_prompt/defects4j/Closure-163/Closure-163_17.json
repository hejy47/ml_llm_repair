[{"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            // The code below can't do anything with unreferenced name\n            // infos.  They should be skipped to avoid NPE since their\n            // deepestCommonModuleRef is null.\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            // We should only move a property across modules if:\n            // 1) We can move it deeper in the module graph, and\n            // 2) it's a function, and\n            // 3) it is not a get or a set, and\n            // 4) the class is available in the global scope.\n            //\n            // #1 should be obvious. #2 is more subtle. It's possible\n            // to copy off of a prototype, as in the code:\n            // for (var k in Foo.prototype) {\n            //   doSomethingWith(Foo.prototype[k]);\n            // }\n            // This is a common way to implement pseudo-multiple inheritance in JS.\n            //\n            // So if we move a prototype method into a deeper module, we must\n            // replace it with a stub function so that it preserves its original\n            // behavior.\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                Node valueParent = value.getParent();\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                    // FUNCTION property definition as a mix-in would get the result\n                    // of a GET instead of the function itself.\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                // example: JSCompiler_stubMethod(id);\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                // stub out the method in the original module\n                // A.prototype.b = JSCompiler_stubMethod(id);\n                valueParent.replaceWith(stubCall);\n                // unstub the function body in the deeper module\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                unstubParent.addChildrenToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n                        IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value),\n                        IR.empty());\n                value.detach();\n                compiler.reportCodeChange();\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        // Declare stub functions in the top-most module.\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -54,13 +54,15 @@\n                 stubCall.putBooleanProp(Node.FREE_CALL, true);\n                 // stub out the method in the original module\n                 // A.prototype.b = JSCompiler_stubMethod(id);\n-                valueParent.replaceChild(value, stubCall);\n+                valueParent.replaceWith(stubCall);\n                 // unstub the function body in the deeper module\n                 Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                 Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n                 unstubCall.putBooleanProp(Node.FREE_CALL, true);\n-                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n-                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n+                unstubParent.addChildrenToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n+                        IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value),\n+                        IR.empty());\n+                value.detach();\n                 compiler.reportCodeChange();\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            // The code below can't do anything with unreferenced name\n            // infos.  They should be skipped to avoid NPE since their\n            // deepestCommonModuleRef is null.\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            // We should only move a property across modules if:\n            // 1) We can move it deeper in the module graph, and\n            // 2) it's a function, and\n            // 3) it is not a get or a set, and\n            // 4) the class is available in the global scope.\n            //\n            // #1 should be obvious. #2 is more subtle. It's possible\n            // to copy off of a prototype, as in the code:\n            // for (var k in Foo.prototype) {\n            //   doSomethingWith(Foo.prototype[k]);\n            // }\n            // This is a common way to implement pseudo-multiple inheritance in JS.\n            //\n            // So if we move a prototype method into a deeper module, we must\n            // replace it with a stub function so that it preserves its original\n            // behavior.\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                Node valueParent = value.getParent();\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                    // FUNCTION property definition as a mix-in would get the result\n                    // of a GET instead of the function itself.\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                // example: JSCompiler_stubMethod(id);\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                // stub out the method in the original module\n                // A.prototype.b = JSCompiler_stubMethod(id);\n                valueParent.replaceWith(stubCall);\n                // unstub the function body in the deeper module\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value.detachFromParent());\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(valueParent));\n                compiler.reportChangeToEnclosingScope(unstubParent);\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        // Declare stub functions in the top-most module.\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n        compiler.reportChangeToEnclosingScope(compiler.getNodeForCodeInsertion(null));\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -54,14 +54,14 @@\n                 stubCall.putBooleanProp(Node.FREE_CALL, true);\n                 // stub out the method in the original module\n                 // A.prototype.b = JSCompiler_stubMethod(id);\n-                valueParent.replaceChild(value, stubCall);\n+                valueParent.replaceWith(stubCall);\n                 // unstub the function body in the deeper module\n                 Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n-                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n+                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value.detachFromParent());\n                 unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                 unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n-                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n-                compiler.reportCodeChange();\n+                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(valueParent));\n+                compiler.reportChangeToEnclosingScope(unstubParent);\n             }\n         }\n     }\n@@ -69,5 +69,6 @@\n         // Declare stub functions in the top-most module.\n         Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n         compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n+        compiler.reportChangeToEnclosingScope(compiler.getNodeForCodeInsertion(null));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            // The code below can't do anything with unreferenced name\n            // infos.  They should be skipped to avoid NPE since their\n            // deepestCommonModuleRef is null.\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            // We should only move a property across modules if:\n            // 1) We can move it deeper in the module graph, and\n            // 2) it's a function, and\n            // 3) it is not a get or a set, and\n            // 4) the class is available in the global scope.\n            //\n            // #1 should be obvious. #2 is more subtle. It's possible\n            // to copy off of a prototype, as in the code:\n            // for (var k in Foo.prototype) {\n            //   doSomethingWith(Foo.prototype[k]);\n            // }\n            // This is a common way to implement pseudo-multiple inheritance in JS.\n            //\n            // So if we move a prototype method into a deeper module, we must\n            // replace it with a stub function so that it preserves its original\n            // behavior.\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule())\n                    && value != null && value.isFunction()) {\n                Node valueParent = value.getParent();\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                    // FUNCTION property definition as a mix-in would get the result\n                    // of a GET instead of the function itself.\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                // example: JSCompiler_stubMethod(id);\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                // stub out the method in the original module\n                // A.prototype.b = JSCompiler_stubMethod(id);\n                valueParent.replaceChild(value, stubCall);\n                // unstub the function body in the deeper module\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                unstubParent.addChildToFront(\n                        // A.prototype.b = JSCompiler_unstubMethod(id, body);\n                        IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n                compiler.reportChangeToEnclosingScope(unstubParent);\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        // Declare stub functions in the top-most module.\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n        compiler.reportChangeToEnclosingScope(compiler.getNodeForCodeInsertion(null));\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -39,7 +39,8 @@\n             // replace it with a stub function so that it preserves its original\n             // behavior.\n             Node value = prop.getValue();\n-            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n+            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule())\n+                    && value != null && value.isFunction()) {\n                 Node valueParent = value.getParent();\n                 if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                     // TODO(johnlenz): a GET or SET can't be deferred like a normal\n@@ -59,9 +60,10 @@\n                 Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                 Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n                 unstubCall.putBooleanProp(Node.FREE_CALL, true);\n-                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n-                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n-                compiler.reportCodeChange();\n+                unstubParent.addChildToFront(\n+                        // A.prototype.b = JSCompiler_unstubMethod(id, body);\n+                        IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n+                compiler.reportChangeToEnclosingScope(unstubParent);\n             }\n         }\n     }\n@@ -69,5 +71,6 @@\n         // Declare stub functions in the top-most module.\n         Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n         compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n+        compiler.reportChangeToEnclosingScope(compiler.getNodeForCodeInsertion(null));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            // The code below can't do anything with unreferenced name\n            // infos.  They should be skipped to avoid NPE since their\n            // deepestCommonModuleRef is null.\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            // We should only move a property across modules if:\n            // 1) We can move it deeper in the module graph, and\n            // 2) it's a function, and\n            // 3) it is not a get or a set, and\n            // 4) the class is available in the global scope.\n            //\n            // #1 should be obvious. #2 is more subtle. It's possible\n            // to copy off of a prototype, as in the code:\n            // for (var k in Foo.prototype) {\n            //   doSomethingWith(Foo.prototype[k]);\n            // }\n            // This is a common way to implement pseudo-multiple inheritance in JS.\n            //\n            // So if we move a prototype method into a deeper module, we must\n            // replace it with a stub function so that it preserves its original\n            // behavior.\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                Node valueParent = value.getParent();\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                    // FUNCTION property definition as a mix-in would get the result\n                    // of a GET instead of the function itself.\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                // example: JSCompiler_stubMethod(id);\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFrom(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                // stub out the method in the original module\n                // A.prototype.b = JSCompiler_stubMethod(id);\n                valueParent.replaceChild(value, stubCall);\n                // unstub the function body in the deeper module\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFrom(value));\n                compiler.reportChangeToEnclosingScope(unstubParent);\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        // Declare stub functions in the top-most module.\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        Node insertionPoint = compiler.getNodeForCodeInsertion(null);\n        insertionPoint.addChildrenToFront(declarations.removeChildren());\n        compiler.reportChangeToEnclosingScope(insertionPoint);\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -50,7 +50,7 @@\n                 Node proto = prop.getPrototype();\n                 int stubId = idGenerator.newId();\n                 // example: JSCompiler_stubMethod(id);\n-                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n+                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFrom(value);\n                 stubCall.putBooleanProp(Node.FREE_CALL, true);\n                 // stub out the method in the original module\n                 // A.prototype.b = JSCompiler_stubMethod(id);\n@@ -60,14 +60,16 @@\n                 Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n                 unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                 unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n-                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n-                compiler.reportCodeChange();\n+                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFrom(value));\n+                compiler.reportChangeToEnclosingScope(unstubParent);\n             }\n         }\n     }\n     if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n         // Declare stub functions in the top-most module.\n         Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n-        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n+        Node insertionPoint = compiler.getNodeForCodeInsertion(null);\n+        insertionPoint.addChildrenToFront(declarations.removeChildren());\n+        compiler.reportChangeToEnclosingScope(insertionPoint);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            // The code below can't do anything with unreferenced name\n            // infos.  They should be skipped to avoid NPE since their\n            // deepestCommonModuleRef is null.\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            // We should only move a property across modules if:\n            // 1) We can move it deeper in the module graph, and\n            // 2) it's a function, and\n            // 3) it is not a get or a set, and\n            // 4) the class is available in the global scope.\n            //\n            // #1 should be obvious. #2 is more subtle. It's possible\n            // to copy off of a prototype, as in the code:\n            // for (var k in Foo.prototype) {\n            //   doSomethingWith(Foo.prototype[k]);\n            // }\n            // This is a common way to implement pseudo-multiple inheritance in JS.\n            //\n            // So if we move a prototype method into a deeper module, we must\n            // replace it with a stub function so that it preserves its original\n            // behavior.\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                Node valueParent = value.getParent();\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                    // FUNCTION property definition as a mix-in would get the result\n                    // of a GET instead of the function itself.\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                // example: JSCompiler_stubMethod(id);\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                // stub out the method in the original module\n                // A.prototype.b = JSCompiler_stubMethod(id);\n                value.replaceWith(stubCall);\n                // unstub the function body in the deeper module\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                unstubParent.addChildrenToBack(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n                compiler.reportCodeChange();\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        // Declare stub functions in the top-most module.\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -54,12 +54,12 @@\n                 stubCall.putBooleanProp(Node.FREE_CALL, true);\n                 // stub out the method in the original module\n                 // A.prototype.b = JSCompiler_stubMethod(id);\n-                valueParent.replaceChild(value, stubCall);\n+                value.replaceWith(stubCall);\n                 // unstub the function body in the deeper module\n                 Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                 Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n                 unstubCall.putBooleanProp(Node.FREE_CALL, true);\n-                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n+                unstubParent.addChildrenToBack(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n                 IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n                 compiler.reportCodeChange();\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            // The code below can't do anything with unreferenced name\n            // infos.  They should be skipped to avoid NPE since their\n            // deepestCommonModuleRef is null.\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            // We should only move a property across modules if:\n            // 1) We can move it deeper in the module graph, and\n            // 2) it's a function, and\n            // 3) it is not a get or a set, and\n            // 4) the class is available in the global scope.\n            //\n            // #1 should be obvious. #2 is more subtle. It's possible\n            // to copy off of a prototype, as in the code:\n            // for (var k in Foo.prototype) {\n            //   doSomethingWith(Foo.prototype[k]);\n            // }\n            // This is a common way to implement pseudo-multiple inheritance in JS.\n            //\n            // So if we move a prototype method into a deeper module, we must\n            // replace it with a stub function so that it preserves its original\n            // behavior.\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                Node valueParent = value.getParent();\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                    // FUNCTION property definition as a mix-in would get the result\n                    // of a GET instead of the function itself.\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                // example: JSCompiler_stubMethod(id);\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                // stub out the method in the original module\n                // A.prototype.b = JSCompiler_stubMethod(id);\n                valueParent.replaceChild(value, stubCall);\n                // unstub the function body in the deeper module\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value.detach());\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                // A.prototype.b = JSCompiler_unstubMethod(id, body);\n                Node exprResult = IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall));\n                exprResult.useSourceInfoIfMissingFromForTree(prop);\n                unstubParent.addChildToFront(exprResult);\n                compiler.reportCodeChange();\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        // Declare stub functions in the top-most module.\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -57,10 +57,12 @@\n                 valueParent.replaceChild(value, stubCall);\n                 // unstub the function body in the deeper module\n                 Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n-                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n+                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value.detach());\n                 unstubCall.putBooleanProp(Node.FREE_CALL, true);\n-                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n-                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n+                // A.prototype.b = JSCompiler_unstubMethod(id, body);\n+                Node exprResult = IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall));\n+                exprResult.useSourceInfoIfMissingFromForTree(prop);\n+                unstubParent.addChildToFront(exprResult);\n                 compiler.reportCodeChange();\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                Node valueParent = value.getParent();\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                valueParent.replaceChild(value, stubCall);\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                unstubParent.addChildToFront(\n                    IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n                compiler.reportChangeToEnclosingScope(unstubParent);\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(compiler.getRoot()).addChildrenToFront(declarations.removeChildren());\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -2,9 +2,6 @@\n     boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n     for (NameInfo nameInfo : allNameInfo) {\n         if (!nameInfo.isReferenced()) {\n-            // The code below can't do anything with unreferenced name\n-            // infos.  They should be skipped to avoid NPE since their\n-            // deepestCommonModuleRef is null.\n             continue;\n         }\n         if (nameInfo.readsClosureVariables()) {\n@@ -22,52 +19,28 @@\n                 continue;\n             }\n             Property prop = (Property) symbol;\n-            // We should only move a property across modules if:\n-            // 1) We can move it deeper in the module graph, and\n-            // 2) it's a function, and\n-            // 3) it is not a get or a set, and\n-            // 4) the class is available in the global scope.\n-            //\n-            // #1 should be obvious. #2 is more subtle. It's possible\n-            // to copy off of a prototype, as in the code:\n-            // for (var k in Foo.prototype) {\n-            //   doSomethingWith(Foo.prototype[k]);\n-            // }\n-            // This is a common way to implement pseudo-multiple inheritance in JS.\n-            //\n-            // So if we move a prototype method into a deeper module, we must\n-            // replace it with a stub function so that it preserves its original\n-            // behavior.\n             Node value = prop.getValue();\n             if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                 Node valueParent = value.getParent();\n                 if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n-                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n-                    // FUNCTION property definition as a mix-in would get the result\n-                    // of a GET instead of the function itself.\n                     continue;\n                 }\n                 Node proto = prop.getPrototype();\n                 int stubId = idGenerator.newId();\n-                // example: JSCompiler_stubMethod(id);\n                 Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                 stubCall.putBooleanProp(Node.FREE_CALL, true);\n-                // stub out the method in the original module\n-                // A.prototype.b = JSCompiler_stubMethod(id);\n                 valueParent.replaceChild(value, stubCall);\n-                // unstub the function body in the deeper module\n                 Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                 Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n                 unstubCall.putBooleanProp(Node.FREE_CALL, true);\n-                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n-                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n-                compiler.reportCodeChange();\n+                unstubParent.addChildToFront(\n+                    IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n+                compiler.reportChangeToEnclosingScope(unstubParent);\n             }\n         }\n     }\n     if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n-        // Declare stub functions in the top-most module.\n         Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n-        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n+        compiler.getNodeForCodeInsertion(compiler.getRoot()).addChildrenToFront(declarations.removeChildren());\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            // The code below can't do anything with unreferenced name\n            // infos.  They should be skipped to avoid NPE since their\n            // deepestCommonModuleRef is null.\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            // We should only move a property across modules if:\n            // 1) We can move it deeper in the module graph, and\n            // 2) it's a function, and\n            // 3) it is not a get or a set, and\n            // 4) the class is available in the global scope.\n            //\n            // #1 should be obvious. #2 is more subtle. It's possible\n            // to copy off of a prototype, as in the code:\n            // for (var k in Foo.prototype) {\n            //   doSomethingWith(Foo.prototype[k]);\n            // }\n            // This is a common way to implement pseudo-multiple inheritance in JS.\n            //\n            // So if we move a prototype method into a deeper module, we must\n            // replace it with a stub function so that it preserves its original\n            // behavior.\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                Node valueParent = value.getParent();\n                // Fixed bug: check both parent's isGetProp() and isSetProp() methods.\n                if ((valueParent.isGetProp() || valueParent.isSetProp())) {\n                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                    // FUNCTION property definition as a mix-in would get the result\n                    // of a GET instead of the function itself.\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                // example: JSCompiler_stubMethod(id);\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                // stub out the method in the original module\n                // A.prototype.b = JSCompiler_stubMethod(id);\n                valueParent.replaceChild(value, stubCall);\n                // unstub the function body in the deeper module\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n                compiler.reportCodeChange();\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        // Declare stub functions in the top-most module.\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -41,7 +41,8 @@\n             Node value = prop.getValue();\n             if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                 Node valueParent = value.getParent();\n-                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n+                // Fixed bug: check both parent's isGetProp() and isSetProp() methods.\n+                if ((valueParent.isGetProp() || valueParent.isSetProp())) {\n                     // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                     // FUNCTION property definition as a mix-in would get the result\n                     // of a GET instead of the function itself.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            // The code below can't do anything with unreferenced name\n            // infos.  They should be skipped to avoid NPE since their\n            // deepestCommonModuleRef is null.\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            // We should only move a property across modules if:\n            // 1) We can move it deeper in the module graph, and\n            // 2) it's a function, and\n            // 3) it is not a get or a set, and\n            // 4) the class is available in the global scope.\n            //\n            // #1 should be obvious. #2 is more subtle. It's possible\n            // to copy off of a prototype, as in the code:\n            // for (var k in Foo.prototype) {\n            //   doSomethingWith(Foo.prototype[k]);\n            // }\n            // This is a common way to implement pseudo-multiple inheritance in JS.\n            //\n            // So if we move a prototype method into a deeper module, we must\n            // replace it with a stub function so that it preserves its original\n            // behavior.\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                Node valueParent = value.getParent();\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                    // FUNCTION property definition as a mix-in would get the result\n                    // of a GET instead of the function itself.\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                // example: JSCompiler_stubMethod(id);\n                Node stubCall = IR.call(\n                    IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFrom(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                // stub out the method in the original module\n                // A.prototype.b = JSCompiler_stubMethod(id);\n                valueParent.replaceChild(value, stubCall);\n                // unstub the function body in the deeper module\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(\n                    IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value.detach());\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n                IR.exprResult(IR.assign(\n                    IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)\n                ).copyInformationFrom(value));\n                compiler.reportChangeToEnclosingScope(unstubParent);\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        // Declare stub functions in the top-most module.\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -50,18 +50,22 @@\n                 Node proto = prop.getPrototype();\n                 int stubId = idGenerator.newId();\n                 // example: JSCompiler_stubMethod(id);\n-                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n+                Node stubCall = IR.call(\n+                    IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFrom(value);\n                 stubCall.putBooleanProp(Node.FREE_CALL, true);\n                 // stub out the method in the original module\n                 // A.prototype.b = JSCompiler_stubMethod(id);\n                 valueParent.replaceChild(value, stubCall);\n                 // unstub the function body in the deeper module\n                 Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n-                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n+                Node unstubCall = IR.call(\n+                    IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value.detach());\n                 unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                 unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n-                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n-                compiler.reportCodeChange();\n+                IR.exprResult(IR.assign(\n+                    IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)\n+                ).copyInformationFrom(value));\n+                compiler.reportChangeToEnclosingScope(unstubParent);\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            Node value = prop.getValue();\n            if (value == null || !moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) ||\n                !value.isFunction() || value.getParent().isFunction()) {\n                continue;\n            }\n            Node proto = prop.getPrototype();\n            if (proto == null) {\n                continue;\n            }\n            int stubId = idGenerator.newId();\n            Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n            stubCall.putBooleanProp(Node.FREE_CALL, true);\n            Node valueParent = value.getParent();\n            valueParent.replaceChild(value, stubCall);\n            Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n            Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n            unstubCall.putBooleanProp(Node.FREE_CALL, true);\n            Node assign = IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value);\n            unstubParent.addChildToFront(assign);\n            compiler.reportCodeChange();\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -2,9 +2,6 @@\n     boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n     for (NameInfo nameInfo : allNameInfo) {\n         if (!nameInfo.isReferenced()) {\n-            // The code below can't do anything with unreferenced name\n-            // infos.  They should be skipped to avoid NPE since their\n-            // deepestCommonModuleRef is null.\n             continue;\n         }\n         if (nameInfo.readsClosureVariables()) {\n@@ -22,51 +19,29 @@\n                 continue;\n             }\n             Property prop = (Property) symbol;\n-            // We should only move a property across modules if:\n-            // 1) We can move it deeper in the module graph, and\n-            // 2) it's a function, and\n-            // 3) it is not a get or a set, and\n-            // 4) the class is available in the global scope.\n-            //\n-            // #1 should be obvious. #2 is more subtle. It's possible\n-            // to copy off of a prototype, as in the code:\n-            // for (var k in Foo.prototype) {\n-            //   doSomethingWith(Foo.prototype[k]);\n-            // }\n-            // This is a common way to implement pseudo-multiple inheritance in JS.\n-            //\n-            // So if we move a prototype method into a deeper module, we must\n-            // replace it with a stub function so that it preserves its original\n-            // behavior.\n             Node value = prop.getValue();\n-            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n-                Node valueParent = value.getParent();\n-                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n-                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n-                    // FUNCTION property definition as a mix-in would get the result\n-                    // of a GET instead of the function itself.\n-                    continue;\n-                }\n-                Node proto = prop.getPrototype();\n-                int stubId = idGenerator.newId();\n-                // example: JSCompiler_stubMethod(id);\n-                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n-                stubCall.putBooleanProp(Node.FREE_CALL, true);\n-                // stub out the method in the original module\n-                // A.prototype.b = JSCompiler_stubMethod(id);\n-                valueParent.replaceChild(value, stubCall);\n-                // unstub the function body in the deeper module\n-                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n-                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n-                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n-                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n-                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n-                compiler.reportCodeChange();\n+            if (value == null || !moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) ||\n+                !value.isFunction() || value.getParent().isFunction()) {\n+                continue;\n             }\n+            Node proto = prop.getPrototype();\n+            if (proto == null) {\n+                continue;\n+            }\n+            int stubId = idGenerator.newId();\n+            Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n+            stubCall.putBooleanProp(Node.FREE_CALL, true);\n+            Node valueParent = value.getParent();\n+            valueParent.replaceChild(value, stubCall);\n+            Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n+            Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n+            unstubCall.putBooleanProp(Node.FREE_CALL, true);\n+            Node assign = IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value);\n+            unstubParent.addChildToFront(assign);\n+            compiler.reportCodeChange();\n         }\n     }\n     if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n-        // Declare stub functions in the top-most module.\n         Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n         compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction() && \n                prop.getOriginalName().isOnLeftOfAssign() && prop.getOriginalName().getFirstChild().getString().equals(\"prototype\")) {\n                Node valueParent = value.getParent();\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                valueParent.replaceChild(value, stubCall);\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value).useSourceInfoIfMissingFromForTree(value);\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                Node lhs = IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)).useSourceInfoIfMissingFromForTree(value);\n                Node assign = IR.assign(lhs, unstubCall).useSourceInfoIfMissingFromForTree(value);\n                Node exprResult = IR.exprResult(assign).useSourceInfoIfMissingFromForTree(value);\n                unstubParent.addChildToFront(exprResult);\n                compiler.reportCodeChange();\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -2,9 +2,6 @@\n     boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n     for (NameInfo nameInfo : allNameInfo) {\n         if (!nameInfo.isReferenced()) {\n-            // The code below can't do anything with unreferenced name\n-            // infos.  They should be skipped to avoid NPE since their\n-            // deepestCommonModuleRef is null.\n             continue;\n         }\n         if (nameInfo.readsClosureVariables()) {\n@@ -22,51 +19,30 @@\n                 continue;\n             }\n             Property prop = (Property) symbol;\n-            // We should only move a property across modules if:\n-            // 1) We can move it deeper in the module graph, and\n-            // 2) it's a function, and\n-            // 3) it is not a get or a set, and\n-            // 4) the class is available in the global scope.\n-            //\n-            // #1 should be obvious. #2 is more subtle. It's possible\n-            // to copy off of a prototype, as in the code:\n-            // for (var k in Foo.prototype) {\n-            //   doSomethingWith(Foo.prototype[k]);\n-            // }\n-            // This is a common way to implement pseudo-multiple inheritance in JS.\n-            //\n-            // So if we move a prototype method into a deeper module, we must\n-            // replace it with a stub function so that it preserves its original\n-            // behavior.\n             Node value = prop.getValue();\n-            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n+            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction() && \n+                prop.getOriginalName().isOnLeftOfAssign() && prop.getOriginalName().getFirstChild().getString().equals(\"prototype\")) {\n                 Node valueParent = value.getParent();\n                 if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n-                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n-                    // FUNCTION property definition as a mix-in would get the result\n-                    // of a GET instead of the function itself.\n                     continue;\n                 }\n                 Node proto = prop.getPrototype();\n                 int stubId = idGenerator.newId();\n-                // example: JSCompiler_stubMethod(id);\n                 Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                 stubCall.putBooleanProp(Node.FREE_CALL, true);\n-                // stub out the method in the original module\n-                // A.prototype.b = JSCompiler_stubMethod(id);\n                 valueParent.replaceChild(value, stubCall);\n-                // unstub the function body in the deeper module\n                 Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n-                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n+                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value).useSourceInfoIfMissingFromForTree(value);\n                 unstubCall.putBooleanProp(Node.FREE_CALL, true);\n-                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n-                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n+                Node lhs = IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)).useSourceInfoIfMissingFromForTree(value);\n+                Node assign = IR.assign(lhs, unstubCall).useSourceInfoIfMissingFromForTree(value);\n+                Node exprResult = IR.exprResult(assign).useSourceInfoIfMissingFromForTree(value);\n+                unstubParent.addChildToFront(exprResult);\n                 compiler.reportCodeChange();\n             }\n         }\n     }\n     if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n-        // Declare stub functions in the top-most module.\n         Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n         compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            // The code below can't do anything with unreferenced name\n            // infos.  They should be skipped to avoid NPE since their\n            // deepestCommonModuleRef is null.\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            // We should only move a property across modules if:\n            // 1) We can move it deeper in the module graph, and\n            // 2) it's a function, and\n            // 3) it is not a get or a set, and\n            // 4) the class is available in the global scope.\n            //\n            // #1 should be obvious. #2 is more subtle. It's possible\n            // to copy off of a prototype, as in the code:\n            // for (var k in Foo.prototype) {\n            //   doSomethingWith(Foo.prototype[k]);\n            // }\n            // This is a common way to implement pseudo-multiple inheritance in JS.\n            //\n            // So if we move a prototype method into a deeper module, we must\n            // replace it with a stub function so that it preserves its original\n            // behavior.\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                Node valueParent = value.getParent();\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                    // FUNCTION property definition as a mix-in would get the result\n                    // of a GET instead of the function itself.\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                // example: JSCompiler_stubMethod(id);\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFrom(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                // stub out the method in the original module\n                // A.prototype.b = JSCompiler_stubMethod(id);\n                Node valueGrandParent = valueParent.getParent();\n                Node replacement = IR.exprResult(IR.assign(IR.getprop(proto.cloneNode(), IR.string(nameInfo.name)), stubCall)).copyInformationFrom(valueParent);\n                valueGrandParent.replaceChild(valueParent, replacement);\n                // unstub the function body in the deeper module\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value).copyInformationFrom(value);\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                Node unstubAssign = IR.assign(IR.getprop(proto.cloneNode(), IR.string(nameInfo.name)), unstubCall);\n                Node unstubExprResult = IR.exprResult(unstubAssign).copyInformationFrom(valueParent);\n                unstubParent.addChildToFront(unstubExprResult);\n                compiler.reportChangeToEnclosingScope(unstubParent);\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        // Declare stub functions in the top-most module.\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        Node nodeForCodeInsertion = compiler.getNodeForCodeInsertion(null);\n        nodeForCodeInsertion.addChildrenToFront(declarations.removeChildren());\n        compiler.reportChangeToEnclosingScope(nodeForCodeInsertion);\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -50,24 +50,29 @@\n                 Node proto = prop.getPrototype();\n                 int stubId = idGenerator.newId();\n                 // example: JSCompiler_stubMethod(id);\n-                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n+                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFrom(value);\n                 stubCall.putBooleanProp(Node.FREE_CALL, true);\n                 // stub out the method in the original module\n                 // A.prototype.b = JSCompiler_stubMethod(id);\n-                valueParent.replaceChild(value, stubCall);\n+                Node valueGrandParent = valueParent.getParent();\n+                Node replacement = IR.exprResult(IR.assign(IR.getprop(proto.cloneNode(), IR.string(nameInfo.name)), stubCall)).copyInformationFrom(valueParent);\n+                valueGrandParent.replaceChild(valueParent, replacement);\n                 // unstub the function body in the deeper module\n                 Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n-                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n+                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value).copyInformationFrom(value);\n                 unstubCall.putBooleanProp(Node.FREE_CALL, true);\n-                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n-                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n-                compiler.reportCodeChange();\n+                Node unstubAssign = IR.assign(IR.getprop(proto.cloneNode(), IR.string(nameInfo.name)), unstubCall);\n+                Node unstubExprResult = IR.exprResult(unstubAssign).copyInformationFrom(valueParent);\n+                unstubParent.addChildToFront(unstubExprResult);\n+                compiler.reportChangeToEnclosingScope(unstubParent);\n             }\n         }\n     }\n     if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n         // Declare stub functions in the top-most module.\n         Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n-        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n+        Node nodeForCodeInsertion = compiler.getNodeForCodeInsertion(null);\n+        nodeForCodeInsertion.addChildrenToFront(declarations.removeChildren());\n+        compiler.reportChangeToEnclosingScope(nodeForCodeInsertion);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            // The code below can't do anything with unreferenced name\n            // infos.  They should be skipped to avoid NPE since their\n            // deepestCommonModuleRef is null.\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            // We should only move a property across modules if:\n            // 1) We can move it deeper in the module graph, and\n            // 2) it's a function, and\n            // 3) it is not a get or a set, and\n            // 4) the class is available in the global scope.\n            //\n            // #1 should be obvious. #2 is more subtle. It's possible\n            // to copy off of a prototype, as in the code:\n            // for (var k in Foo.prototype) {\n            //   doSomethingWith(Foo.prototype[k]);\n            // }\n            // This is a common way to implement pseudo-multiple inheritance in JS.\n            //\n            // So if we move a prototype method into a deeper module, we must\n            // replace it with a stub function so that it preserves its original\n            // behavior.\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                Node valueParent = value.getParent();\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                    // FUNCTION property definition as a mix-in would get the result\n                    // of a GET instead of the function itself.\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                // example: JSCompiler_stubMethod(id);\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                // stub out the method in the original module\n                // A.prototype.b = JSCompiler_stubMethod(id);\n                valueParent.replaceChild(value, stubCall);\n                // unstub the function body in the deeper module\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value.detach());\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                // A.prototype.b = JSCompiler_unstubMethod(id, body);\n                Node assign =\n                    IR.assign(\n                        IR.getprop(\n                            proto.cloneTree(), IR.string(nameInfo.name)),\n                        unstubCall).copyInformationFromForTree(value);\n                Node exprResult = IR.exprResult(assign);\n                exprResult.copyInformationFromForTree(value);\n                unstubParent.addChildToFront(exprResult);\n                compiler.reportCodeChange();\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        // Declare stub functions in the top-most module.\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -57,10 +57,17 @@\n                 valueParent.replaceChild(value, stubCall);\n                 // unstub the function body in the deeper module\n                 Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n-                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n+                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value.detach());\n                 unstubCall.putBooleanProp(Node.FREE_CALL, true);\n-                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n-                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n+                // A.prototype.b = JSCompiler_unstubMethod(id, body);\n+                Node assign =\n+                    IR.assign(\n+                        IR.getprop(\n+                            proto.cloneTree(), IR.string(nameInfo.name)),\n+                        unstubCall).copyInformationFromForTree(value);\n+                Node exprResult = IR.exprResult(assign);\n+                exprResult.copyInformationFromForTree(value);\n+                unstubParent.addChildToFront(exprResult);\n                 compiler.reportCodeChange();\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            // The code below can't do anything with unreferenced name\n            // infos.  They should be skipped to avoid NPE since their\n            // deepestCommonModuleRef is null.\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            // We should only move a property across modules if:\n            // 1) We can move it deeper in the module graph, and\n            // 2) it's a function, and\n            // 3) it is not a get or a set, and\n            // 4) the class is available in the global scope.\n            //\n            // #1 should be obvious. #2 is more subtle. It's possible\n            // to copy off of a prototype, as in the code:\n            // for (var k in Foo.prototype) {\n            //   doSomethingWith(Foo.prototype[k]);\n            // }\n            // This is a common way to implement pseudo-multiple inheritance in JS.\n            //\n            // So if we move a prototype method into a deeper module, we must\n            // replace it with a stub function so that it preserves its original\n            // behavior.\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                Node valueParent = value.getParent();\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                    // FUNCTION property definition as a mix-in would get the result\n                    // of a GET instead of the function itself.\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                // example: JSCompiler_stubMethod(id);\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                // stub out the method in the original module\n                // A.prototype.b = JSCompiler_stubMethod(id);\n                value Parent.replaceChild(value, stubCall);\n                // unstub the function body in the deeper module\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), valueParent.detach());\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n                compiler.reportCodeChange();\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        // Declare stub functions in the top-most module.\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -54,10 +54,10 @@\n                 stubCall.putBooleanProp(Node.FREE_CALL, true);\n                 // stub out the method in the original module\n                 // A.prototype.b = JSCompiler_stubMethod(id);\n-                valueParent.replaceChild(value, stubCall);\n+                value Parent.replaceChild(value, stubCall);\n                 // unstub the function body in the deeper module\n                 Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n-                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n+                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), valueParent.detach());\n                 unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                 unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n                 IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            // The code below can't do anything with unreferenced name\n            // infos.  They should be skipped to avoid NPE since their\n            // deepestCommonModuleRef is null.\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            // We should only move a property across modules if:\n            // 1) We can move it deeper in the module graph, and\n            // 2) it's a function, and\n            // 3) it is not a get or a set, and\n            // 4) the class is available in the global scope.\n            //\n            // #1 should be obvious. #2 is more subtle. It's possible\n            // to copy off of a prototype, as in the code:\n            // for (var k in Foo.prototype) {\n            //   doSomethingWith(Foo.prototype[k]);\n            // }\n            // This is a common way to implement pseudo-multiple inheritance in JS.\n            //\n            // So if we move a prototype method into a deeper module, we must\n            // replace it with a stub function so that it preserves its original\n            // behavior.\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                Node valueParent = value.getParent();\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                    // FUNCTION property definition as a mix-in would get the result\n                    // of a GET instead of the function itself.\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                // example: JSCompiler_stubMethod(id);\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                // stub out the method in the original module\n                // A.prototype.b = JSCompiler_stubMethod(id);\n                valueParent.replaceChild(value, stubCall);\n                // unstub the function body in the deeper module\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value.detach());\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n                compiler.reportCodeChange();\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        // Declare stub functions in the top-most module.\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -57,7 +57,7 @@\n                 valueParent.replaceChild(value, stubCall);\n                 // unstub the function body in the deeper module\n                 Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n-                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n+                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value.detach());\n                 unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                 unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n                 IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            // The code below can't do anything with unreferenced name\n            // infos.  They should be skipped to avoid NPE since their\n            // deepestCommonModuleRef is null.\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            // We should only move a property across modules if:\n            // 1) We can move it deeper in the module graph, and\n            // 2) it's a function, and\n            // 3) it is not a get or a set, and\n            // 4) the class is available in the global scope.\n            //\n            // #1 should be obvious. #2 is more subtle. It's possible\n            // to copy off of a prototype, as in the code:\n            // for (var k in Foo.prototype) {\n            //   doSomethingWith(Foo.prototype[k]);\n            // }\n            // This is a common way to implement pseudo-multiple inheritance in JS.\n            //\n            // So if we move a prototype method into a deeper module, we must\n            // replace it with a stub function so that it preserves its original\n            // behavior.\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                Node valueParent = value.getParent();\n                if (valueParent.isSetterDef() || valueParent.isGetterDef()) {\n                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                    // FUNCTION property definition as a mix-in would get the result\n                    // of a GET instead of the function itself.\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                // example: JSCompiler_stubMethod(id);\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                // stub out the method in the original module\n                // A.prototype.b = JSCompiler_stubMethod(id);\n                valueParent.replaceChild(value, stubCall);\n                // unstub the function body in the deeper module\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value.detach());\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n                compiler.reportCodeChange();\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        // Declare stub functions in the top-most module.\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -41,7 +41,7 @@\n             Node value = prop.getValue();\n             if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                 Node valueParent = value.getParent();\n-                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n+                if (valueParent.isSetterDef() || valueParent.isGetterDef()) {\n                     // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                     // FUNCTION property definition as a mix-in would get the result\n                     // of a GET instead of the function itself.\n@@ -57,7 +57,7 @@\n                 valueParent.replaceChild(value, stubCall);\n                 // unstub the function body in the deeper module\n                 Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n-                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n+                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value.detach());\n                 unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                 unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n                 IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            // The code below can't do anything with unreferenced name\n            // infos.  They should be skipped to avoid NPE since their\n            // deepestCommonModuleRef is null.\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            // We should only move a property across modules if:\n            // 1) We can move it deeper in the module graph, and\n            // 2) it's a function, and\n            // 3) it is not a get or a set, and\n            // 4) the class is available in the global scope.\n            //\n            // #1 should be obvious. #2 is more subtle. It's possible\n            // to copy off of a prototype, as in the code:\n            // for (var k in Foo.prototype) {\n            //   doSomethingWith(Foo.prototype[k]);\n            // }\n            // This is a common way to implement pseudo-multiple inheritance in JS.\n            //\n            // So if we move a prototype method into a deeper module, we must\n            // replace it with a stub function so that it preserves its original\n            // behavior.\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                Node valueParent = value.getParent();\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                    // FUNCTION property definition as a mix-in would get the result\n                    // of a GET instead of the function itself.\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                // example: JSCompiler_stubMethod(id);\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                // stub out the method in the original module\n                // A.prototype.b = JSCompiler_stubMethod(id);\n                valueParent.replaceChild(value, stubCall);\n                // unstub the function body in the deeper module\n                // A.prototype.b = JSCompiler_unstubMethod(id, body);\n                Node unstubCall = IR.call(\n                    IR.name(UNSTUB_METHOD_NAME),\n                    IR.number(stubId),\n                    value.detachFromParent() // Remove the function from the AST\n                ).copyInformationFromForTree(value);\n\n                Node assign = IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)\n                    .copyInformationFromForTree(value);\n                Node exprResult = IR.exprResult(assign)\n                    .copyInformationFromForTree(value);\n                // Attach the resulting node to the destination module\n                final Node insertionPoint = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                insertionPoint.addChildToFront(exprResult);\n                compiler.reportCodeChange();\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        // Declare stub functions in the top-most module.\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -56,11 +56,20 @@\n                 // A.prototype.b = JSCompiler_stubMethod(id);\n                 valueParent.replaceChild(value, stubCall);\n                 // unstub the function body in the deeper module\n-                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n-                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n-                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n-                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n-                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n+                // A.prototype.b = JSCompiler_unstubMethod(id, body);\n+                Node unstubCall = IR.call(\n+                    IR.name(UNSTUB_METHOD_NAME),\n+                    IR.number(stubId),\n+                    value.detachFromParent() // Remove the function from the AST\n+                ).copyInformationFromForTree(value);\n+\n+                Node assign = IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)\n+                    .copyInformationFromForTree(value);\n+                Node exprResult = IR.exprResult(assign)\n+                    .copyInformationFromForTree(value);\n+                // Attach the resulting node to the destination module\n+                final Node insertionPoint = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n+                insertionPoint.addChildToFront(exprResult);\n                 compiler.reportCodeChange();\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            // The code below can't do anything with unreferenced name\n            // infos.  They should be skipped to avoid NPE since their\n            // deepestCommonModuleRef is null.\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            // We should only move a property across modules if:\n            // 1) We can move it deeper in the module graph, and\n            // 2) it's a function, and\n            // 3) it is not a get or a set, and\n            // 4) it is not an arrow function\n            // 5) the class is available in the global scope.\n            //\n            // #1 should be obvious. #2 is more subtle. It's possible\n            // to copy off of a prototype, as in the code:\n            // for (var k in Foo.prototype) {\n            //   doSomethingWith(Foo.prototype[k]);\n            // }\n            // This is a common way to implement pseudo-multiple inheritance in JS.\n            //\n            // So if we move a prototype method into a deeper module, we must\n            // replace it with a stub function so that it preserves its original\n            // behavior.\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction() && !value.isArrowFunction()) {\n                Node valueParent = value.getParent();\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                    // FUNCTION property definition as a mix-in would get the result\n                    // of a GET instead of the function itself.\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                // example: JSCompiler_stubMethod(id);\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                // stub out the method in the original module\n                // A.prototype.b = JSCompiler_stubMethod(id);\n                valueParent.replaceChild(value, stubCall);\n                // unstub the function body in the deeper module\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n                compiler.reportCodeChange();\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        // Declare stub functions in the top-most module.\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -26,7 +26,8 @@\n             // 1) We can move it deeper in the module graph, and\n             // 2) it's a function, and\n             // 3) it is not a get or a set, and\n-            // 4) the class is available in the global scope.\n+            // 4) it is not an arrow function\n+            // 5) the class is available in the global scope.\n             //\n             // #1 should be obvious. #2 is more subtle. It's possible\n             // to copy off of a prototype, as in the code:\n@@ -39,7 +40,7 @@\n             // replace it with a stub function so that it preserves its original\n             // behavior.\n             Node value = prop.getValue();\n-            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n+            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction() && !value.isArrowFunction()) {\n                 Node valueParent = value.getParent();\n                 if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                     // TODO(johnlenz): a GET or SET can't be deferred like a normal\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            // The code below can't do anything with unreferenced name\n            // infos.  They should be skipped to avoid NPE since their\n            // deepestCommonModuleRef is null.\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            // We should only move a property across modules if:\n            // 1) We can move it deeper in the module graph, and\n            // 2) it's a function, and\n            // 3) it is not a get or a set, and\n            // 4) the class is available in the global scope.\n            //\n            // #1 should be obvious. #2 is more subtle. It's possible\n            // to copy off of a prototype, as in the code:\n            // for (var k in Foo.prototype) {\n            //   doSomethingWith(Foo.prototype[k]);\n            // }\n            // This is a common way to implement pseudo-multiple inheritance in JS.\n            //\n            // So if we move a prototype method into a deeper module, we must\n            // replace it with a stub function so that it preserves its original\n            // behavior.\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                Node valueParent = value.getParent();\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                    // FUNCTION property definition as a mix-in would get the result\n                    // of a GET instead of the function itself.\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                // example: JSCompiler_stubMethod(id);\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                // stub out the method in the original module\n                // A.prototype.b = JSCompiler_stubMethod(id);\n                value.replaceWith(stubCall);\n                \n                // unstub the function body in the deeper module\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                Node assign = IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall);\n                assign.putBooleanProp(Node.FREE_CALL, true);\n                Node exprResult = IR.exprResult(assign).copyInformationFromForTree(value);\n                unstubParent.addChildToFront(exprResult);\n                compiler.reportCodeChange();\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        // Declare stub functions in the top-most module.\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -54,13 +54,16 @@\n                 stubCall.putBooleanProp(Node.FREE_CALL, true);\n                 // stub out the method in the original module\n                 // A.prototype.b = JSCompiler_stubMethod(id);\n-                valueParent.replaceChild(value, stubCall);\n+                value.replaceWith(stubCall);\n+                \n                 // unstub the function body in the deeper module\n                 Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                 Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n                 unstubCall.putBooleanProp(Node.FREE_CALL, true);\n-                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n-                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n+                Node assign = IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall);\n+                assign.putBooleanProp(Node.FREE_CALL, true);\n+                Node exprResult = IR.exprResult(assign).copyInformationFromForTree(value);\n+                unstubParent.addChildToFront(exprResult);\n                 compiler.reportCodeChange();\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void moveMethods(Collection<NameInfo> allNameInfo) {\n    boolean hasStubDeclaration = idGenerator.hasGeneratedAnyIds();\n    for (NameInfo nameInfo : allNameInfo) {\n        if (!nameInfo.isReferenced()) {\n            // The code below can't do anything with unreferenced name\n            // infos.  They should be skipped to avoid NPE since their\n            // deepestCommonModuleRef is null.\n            continue;\n        }\n        if (nameInfo.readsClosureVariables()) {\n            continue;\n        }\n        JSModule deepestCommonModuleRef = nameInfo.getDeepestCommonModuleRef();\n        if (deepestCommonModuleRef == null) {\n            compiler.report(JSError.make(NULL_COMMON_MODULE_ERROR));\n            continue;\n        }\n        Iterator<Symbol> declarations = nameInfo.getDeclarations().descendingIterator();\n        while (declarations.hasNext()) {\n            Symbol symbol = declarations.next();\n            if (!(symbol instanceof Property)) {\n                continue;\n            }\n            Property prop = (Property) symbol;\n            // We should only move a property across modules if:\n            // 1) We can move it deeper in the module graph, and\n            // 2) it's a function, and\n            // 3) it is not a get or a set, and\n            // 4) the class is available in the global scope.\n            //\n            // #1 should be obvious. #2 is more subtle. It's possible\n            // to copy off of a prototype, as in the code:\n            // for (var k in Foo.prototype) {\n            //   doSomethingWith(Foo.prototype[k]);\n            // }\n            // This is a common way to implement pseudo-multiple inheritance in JS.\n            //\n            // So if we move a prototype method into a deeper module, we must\n            // replace it with a stub function so that it preserves its original\n            // behavior.\n            Node value = prop.getValue();\n            if (moduleGraph.dependsOn(deepestCommonModuleRef, prop.getModule()) && value.isFunction()) {\n                Node valueParent = value.getParent();\n                if (valueParent.isGetterDef() || valueParent.isSetterDef()) {\n                    // TODO(johnlenz): a GET or SET can't be deferred like a normal\n                    // FUNCTION property definition as a mix-in would get the result\n                    // of a GET instead of the function itself.\n                    continue;\n                }\n                Node proto = prop.getPrototype();\n                int stubId = idGenerator.newId();\n                // example: JSCompiler_stubMethod(id);\n                Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                stubCall.putBooleanProp(Node.FREE_CALL, true);\n                // change the signature to include the global scope\n                // A.prototype.b = JSCompiler_stubMethod(id, $goog$global);\n                Node stubCallWithGlobalScope = IR.call(stubCall.cloneTree())\n                        .copyInformationFrom(stubCall);\n                stubCallWithGlobalScope.addChildToBack(IR.name(\"$goog$global\"));\n                // stub out the method in the original module\n                // A.prototype.b = JSCompiler_stubMethod(id, $goog$global);\n                valueParent.replaceChild(value, stubCallWithGlobalScope);\n                // unstub the function body in the deeper module\n                Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n                unstubCall.putBooleanProp(Node.FREE_CALL, true);\n                // A.prototype.b = JSCompiler_unstubMethod(id, body);\n                Node assignNode = IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall).copyInformationFromForTree(value);\n                unstubParent.addChildToFront(IR.exprResult(assignNode));\n                compiler.reportCodeChange();\n            }\n        }\n    }\n    if (!hasStubDeclaration && idGenerator.hasGeneratedAnyIds()) {\n        // Declare stub functions in the top-most module.\n        Node declarations = compiler.parseSyntheticCode(STUB_DECLARATIONS);\n        compiler.getNodeForCodeInsertion(null).addChildrenToFront(declarations.removeChildren());\n    }\n}", "diff": "--- com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n+++ com/google/javascript/jscomp/CrossModuleMethodMotion.java@moveMethods\n@@ -52,15 +52,21 @@\n                 // example: JSCompiler_stubMethod(id);\n                 Node stubCall = IR.call(IR.name(STUB_METHOD_NAME), IR.number(stubId)).copyInformationFromForTree(value);\n                 stubCall.putBooleanProp(Node.FREE_CALL, true);\n+                // change the signature to include the global scope\n+                // A.prototype.b = JSCompiler_stubMethod(id, $goog$global);\n+                Node stubCallWithGlobalScope = IR.call(stubCall.cloneTree())\n+                        .copyInformationFrom(stubCall);\n+                stubCallWithGlobalScope.addChildToBack(IR.name(\"$goog$global\"));\n                 // stub out the method in the original module\n-                // A.prototype.b = JSCompiler_stubMethod(id);\n-                valueParent.replaceChild(value, stubCall);\n+                // A.prototype.b = JSCompiler_stubMethod(id, $goog$global);\n+                valueParent.replaceChild(value, stubCallWithGlobalScope);\n                 // unstub the function body in the deeper module\n                 Node unstubParent = compiler.getNodeForCodeInsertion(deepestCommonModuleRef);\n                 Node unstubCall = IR.call(IR.name(UNSTUB_METHOD_NAME), IR.number(stubId), value);\n                 unstubCall.putBooleanProp(Node.FREE_CALL, true);\n-                unstubParent.addChildToFront(// A.prototype.b = JSCompiler_unstubMethod(id, body);\n-                IR.exprResult(IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall)).copyInformationFromForTree(value));\n+                // A.prototype.b = JSCompiler_unstubMethod(id, body);\n+                Node assignNode = IR.assign(IR.getprop(proto.cloneTree(), IR.string(nameInfo.name)), unstubCall).copyInformationFromForTree(value);\n+                unstubParent.addChildToFront(IR.exprResult(assignNode));\n                 compiler.reportCodeChange();\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}]