[{"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    SymbolTable.Symbol currentSymbol = symbolStack.peek();\n    currentSymbol.scope = t.getScope();\n\n    if (currentSymbol.node.isFunction()) {\n        if (currentSymbol.node.getFirstChild().isEmpty()) {\n          // If the function does not have a name, give it a unique ID\n          String id = \"FUNCTION_\" + UUID.randomUUID();\n          currentSymbol.node.getFirstChild().setString(id);\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,13 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+    SymbolTable.Symbol currentSymbol = symbolStack.peek();\n+    currentSymbol.scope = t.getScope();\n+\n+    if (currentSymbol.node.isFunction()) {\n+        if (currentSymbol.node.getFirstChild().isEmpty()) {\n+          // If the function does not have a name, give it a unique ID\n+          String id = \"FUNCTION_\" + UUID.randomUUID();\n+          currentSymbol.node.getFirstChild().setString(id);\n+        }\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,13 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    SymbolTable.Symbol currentSymbol = symbolStack.peek();\n+    currentSymbol.scope = t.getScope();\n+\n+    if (currentSymbol.node.isFunction()) {\n+        if (currentSymbol.node.getFirstChild().isEmpty()) {\n+          // If the function does not have a name, give it a unique ID\n+          String id = \"FUNCTION_\" + UUID.randomUUID();\n+          currentSymbol.node.getFirstChild().setString(id);\n+        }\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,13 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    SymbolTable.Symbol currentSymbol = symbolStack.peek();\n+    currentSymbol.scope = t.getScope();\n+\n+    if (currentSymbol.node.isFunction()) {\n+        if (currentSymbol.node.getFirstChild().isEmpty()) {\n+          // If the function does not have a name, give it a unique ID\n+          String id = \"FUNCTION_\" + UUID.randomUUID();\n+          currentSymbol.node.getFirstChild().setString(id);\n+        }\n     }\n-    return true;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,13 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n+public void enterScope(NodeTraversal t) {\n+    SymbolTable.Symbol currentSymbol = symbolStack.peek();\n+    currentSymbol.scope = t.getScope();\n+\n+    if (currentSymbol.node.isFunction()) {\n+        if (currentSymbol.node.getFirstChild().isEmpty()) {\n+          // If the function does not have a name, give it a unique ID\n+          String id = \"FUNCTION_\" + UUID.randomUUID();\n+          currentSymbol.node.getFirstChild().setString(id);\n         }\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,13 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n+public void enterScope(NodeTraversal t) {\n+    SymbolTable.Symbol currentSymbol = symbolStack.peek();\n+    currentSymbol.scope = t.getScope();\n+\n+    if (currentSymbol.node.isFunction()) {\n+        if (currentSymbol.node.getFirstChild().isEmpty()) {\n+          // If the function does not have a name, give it a unique ID\n+          String id = \"FUNCTION_\" + UUID.randomUUID();\n+          currentSymbol.node.getFirstChild().setString(id);\n         }\n     }\n-    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,13 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void enterScope(NodeTraversal t) {\n+    SymbolTable.Symbol currentSymbol = symbolStack.peek();\n+    currentSymbol.scope = t.getScope();\n+\n+    if (currentSymbol.node.isFunction()) {\n+        if (currentSymbol.node.getFirstChild().isEmpty()) {\n+          // If the function does not have a name, give it a unique ID\n+          String id = \"FUNCTION_\" + UUID.randomUUID();\n+          currentSymbol.node.getFirstChild().setString(id);\n+        }\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Scope currentScope = symbolStack.peek();\n    if (currentScope != null) {\n        currentScope.scope = t.getScope();\n    }\n    // NOTE: We use the same anonymous node for all functions that do not have\n    // reasonable names. This is because anonymous nodes can never have in-edges.\n    // They're just there as a placeholder for scope information and do not matter\n    // in the edge propagation.\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,11 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+    Scope currentScope = symbolStack.peek();\n+    if (currentScope != null) {\n+        currentScope.scope = t.getScope();\n+    }\n+    // NOTE: We use the same anonymous node for all functions that do not have\n+    // reasonable names. This is because anonymous nodes can never have in-edges.\n+    // They're just there as a placeholder for scope information and do not matter\n+    // in the edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,11 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    Scope currentScope = symbolStack.peek();\n+    if (currentScope != null) {\n+        currentScope.scope = t.getScope();\n+    }\n+    // NOTE: We use the same anonymous node for all functions that do not have\n+    // reasonable names. This is because anonymous nodes can never have in-edges.\n+    // They're just there as a placeholder for scope information and do not matter\n+    // in the edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,11 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    Scope currentScope = symbolStack.peek();\n+    if (currentScope != null) {\n+        currentScope.scope = t.getScope();\n     }\n-    return true;\n+    // NOTE: We use the same anonymous node for all functions that do not have\n+    // reasonable names. This is because anonymous nodes can never have in-edges.\n+    // They're just there as a placeholder for scope information and do not matter\n+    // in the edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,11 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n+public void enterScope(NodeTraversal t) {\n+    Scope currentScope = symbolStack.peek();\n+    if (currentScope != null) {\n+        currentScope.scope = t.getScope();\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    // NOTE: We use the same anonymous node for all functions that do not have\n+    // reasonable names. This is because anonymous nodes can never have in-edges.\n+    // They're just there as a placeholder for scope information and do not matter\n+    // in the edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,11 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+public void enterScope(NodeTraversal t) {\n+    Scope currentScope = symbolStack.peek();\n+    if (currentScope != null) {\n+        currentScope.scope = t.getScope();\n     }\n-    return false;\n+    // NOTE: We use the same anonymous node for all functions that do not have\n+    // reasonable names. This is because anonymous nodes can never have in-edges.\n+    // They're just there as a placeholder for scope information and do not matter\n+    // in the edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,11 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void enterScope(NodeTraversal t) {\n+    Scope currentScope = symbolStack.peek();\n+    if (currentScope != null) {\n+        currentScope.scope = t.getScope();\n     }\n+    // NOTE: We use the same anonymous node for all functions that do not have\n+    // reasonable names. This is because anonymous nodes can never have in-edges.\n+    // They're just there as a placeholder for scope information and do not matter\n+    // in the edge propagation.\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    symbolStack.peek().scope = t.getScope();\n    // We no longer use anonymous nodes for functions without names,\n    // as they can cause issues with edge propagation. Instead, we\n    // create a unique placeholder node for each function scope.\n    if (t.inFunctionBlock()) {\n        Node functionNode = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n        functionNode.putBooleanProp(Node.FUNCTION_NODE, true);\n        t.getScope().setClosestHoistScopeNode(functionNode);\n    }\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,12 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+    // We no longer use anonymous nodes for functions without names,\n+    // as they can cause issues with edge propagation. Instead, we\n+    // create a unique placeholder node for each function scope.\n+    if (t.inFunctionBlock()) {\n+        Node functionNode = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n+        functionNode.putBooleanProp(Node.FUNCTION_NODE, true);\n+        t.getScope().setClosestHoistScopeNode(functionNode);\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,12 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // We no longer use anonymous nodes for functions without names,\n+    // as they can cause issues with edge propagation. Instead, we\n+    // create a unique placeholder node for each function scope.\n+    if (t.inFunctionBlock()) {\n+        Node functionNode = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n+        functionNode.putBooleanProp(Node.FUNCTION_NODE, true);\n+        t.getScope().setClosestHoistScopeNode(functionNode);\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,12 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // We no longer use anonymous nodes for functions without names,\n+    // as they can cause issues with edge propagation. Instead, we\n+    // create a unique placeholder node for each function scope.\n+    if (t.inFunctionBlock()) {\n+        Node functionNode = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n+        functionNode.putBooleanProp(Node.FUNCTION_NODE, true);\n+        t.getScope().setClosestHoistScopeNode(functionNode);\n     }\n-    return true;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,12 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // We no longer use anonymous nodes for functions without names,\n+    // as they can cause issues with edge propagation. Instead, we\n+    // create a unique placeholder node for each function scope.\n+    if (t.inFunctionBlock()) {\n+        Node functionNode = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n+        functionNode.putBooleanProp(Node.FUNCTION_NODE, true);\n+        t.getScope().setClosestHoistScopeNode(functionNode);\n     }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,12 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // We no longer use anonymous nodes for functions without names,\n+    // as they can cause issues with edge propagation. Instead, we\n+    // create a unique placeholder node for each function scope.\n+    if (t.inFunctionBlock()) {\n+        Node functionNode = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n+        functionNode.putBooleanProp(Node.FUNCTION_NODE, true);\n+        t.getScope().setClosestHoistScopeNode(functionNode);\n     }\n-    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,12 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // We no longer use anonymous nodes for functions without names,\n+    // as they can cause issues with edge propagation. Instead, we\n+    // create a unique placeholder node for each function scope.\n+    if (t.inFunctionBlock()) {\n+        Node functionNode = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n+        functionNode.putBooleanProp(Node.FUNCTION_NODE, true);\n+        t.getScope().setClosestHoistScopeNode(functionNode);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    symbolStack.peek().setScope(t.getScope()); // Use setter instead of directly accessing scope variable\n    if (symbolStack.peek().getName() == null) { // Check if symbol has a name\n        // Create a new, unique anonymous node to represent this symbol\n        int id = symbolIdGenerator.generate();\n        symbolStack.peek().setNode(new Node(Token.SCRIPT, new Node(Token.EMPTY)));\n        symbolStack.peek().getNode().putProp(Node.SYMBOL_VAR, symbolStack.peek().getName());\n        symbolStack.peek().getNode().setIntProp(Node.FUNCTION_PROP, id);\n    }\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,11 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+    symbolStack.peek().setScope(t.getScope()); // Use setter instead of directly accessing scope variable\n+    if (symbolStack.peek().getName() == null) { // Check if symbol has a name\n+        // Create a new, unique anonymous node to represent this symbol\n+        int id = symbolIdGenerator.generate();\n+        symbolStack.peek().setNode(new Node(Token.SCRIPT, new Node(Token.EMPTY)));\n+        symbolStack.peek().getNode().putProp(Node.SYMBOL_VAR, symbolStack.peek().getName());\n+        symbolStack.peek().getNode().setIntProp(Node.FUNCTION_PROP, id);\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,11 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().setScope(t.getScope()); // Use setter instead of directly accessing scope variable\n+    if (symbolStack.peek().getName() == null) { // Check if symbol has a name\n+        // Create a new, unique anonymous node to represent this symbol\n+        int id = symbolIdGenerator.generate();\n+        symbolStack.peek().setNode(new Node(Token.SCRIPT, new Node(Token.EMPTY)));\n+        symbolStack.peek().getNode().putProp(Node.SYMBOL_VAR, symbolStack.peek().getName());\n+        symbolStack.peek().getNode().setIntProp(Node.FUNCTION_PROP, id);\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,11 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().setScope(t.getScope()); // Use setter instead of directly accessing scope variable\n+    if (symbolStack.peek().getName() == null) { // Check if symbol has a name\n+        // Create a new, unique anonymous node to represent this symbol\n+        int id = symbolIdGenerator.generate();\n+        symbolStack.peek().setNode(new Node(Token.SCRIPT, new Node(Token.EMPTY)));\n+        symbolStack.peek().getNode().putProp(Node.SYMBOL_VAR, symbolStack.peek().getName());\n+        symbolStack.peek().getNode().setIntProp(Node.FUNCTION_PROP, id);\n     }\n-    return true;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,11 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().setScope(t.getScope()); // Use setter instead of directly accessing scope variable\n+    if (symbolStack.peek().getName() == null) { // Check if symbol has a name\n+        // Create a new, unique anonymous node to represent this symbol\n+        int id = symbolIdGenerator.generate();\n+        symbolStack.peek().setNode(new Node(Token.SCRIPT, new Node(Token.EMPTY)));\n+        symbolStack.peek().getNode().putProp(Node.SYMBOL_VAR, symbolStack.peek().getName());\n+        symbolStack.peek().getNode().setIntProp(Node.FUNCTION_PROP, id);\n     }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,11 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().setScope(t.getScope()); // Use setter instead of directly accessing scope variable\n+    if (symbolStack.peek().getName() == null) { // Check if symbol has a name\n+        // Create a new, unique anonymous node to represent this symbol\n+        int id = symbolIdGenerator.generate();\n+        symbolStack.peek().setNode(new Node(Token.SCRIPT, new Node(Token.EMPTY)));\n+        symbolStack.peek().getNode().putProp(Node.SYMBOL_VAR, symbolStack.peek().getName());\n+        symbolStack.peek().getNode().setIntProp(Node.FUNCTION_PROP, id);\n     }\n-    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,11 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().setScope(t.getScope()); // Use setter instead of directly accessing scope variable\n+    if (symbolStack.peek().getName() == null) { // Check if symbol has a name\n+        // Create a new, unique anonymous node to represent this symbol\n+        int id = symbolIdGenerator.generate();\n+        symbolStack.peek().setNode(new Node(Token.SCRIPT, new Node(Token.EMPTY)));\n+        symbolStack.peek().getNode().putProp(Node.SYMBOL_VAR, symbolStack.peek().getName());\n+        symbolStack.peek().getNode().setIntProp(Node.FUNCTION_PROP, id);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    symbolStack.peek().scope = t.getScope();\n    // Use a unique anonymous node for each function without a name.\n    // This ensures that edge propagation works correctly.\n    if (t.getScope().isHoistScope()) {\n        t.getScope().setClosestHoistScopeNode(t.getCurrentNode());\n    }\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,9 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+    // Use a unique anonymous node for each function without a name.\n+    // This ensures that edge propagation works correctly.\n+    if (t.getScope().isHoistScope()) {\n+        t.getScope().setClosestHoistScopeNode(t.getCurrentNode());\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,9 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each function without a name.\n+    // This ensures that edge propagation works correctly.\n+    if (t.getScope().isHoistScope()) {\n+        t.getScope().setClosestHoistScopeNode(t.getCurrentNode());\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,9 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each function without a name.\n+    // This ensures that edge propagation works correctly.\n+    if (t.getScope().isHoistScope()) {\n+        t.getScope().setClosestHoistScopeNode(t.getCurrentNode());\n     }\n-    return true;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,9 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each function without a name.\n+    // This ensures that edge propagation works correctly.\n+    if (t.getScope().isHoistScope()) {\n+        t.getScope().setClosestHoistScopeNode(t.getCurrentNode());\n     }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,9 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each function without a name.\n+    // This ensures that edge propagation works correctly.\n+    if (t.getScope().isHoistScope()) {\n+        t.getScope().setClosestHoistScopeNode(t.getCurrentNode());\n     }\n-    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,9 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each function without a name.\n+    // This ensures that edge propagation works correctly.\n+    if (t.getScope().isHoistScope()) {\n+        t.getScope().setClosestHoistScopeNode(t.getCurrentNode());\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    symbolStack.peek().scope = t.getScope();\n    // Use a unique anonymous node for each function that\n    // does not have a reasonable name.\n    if (!NodeUtil.isFunctionExpression(t.getScopeRoot())) {\n        t.getScopeRoot().setIsSyntheticBlock(true);\n    }\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,9 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+    // Use a unique anonymous node for each function that\n+    // does not have a reasonable name.\n+    if (!NodeUtil.isFunctionExpression(t.getScopeRoot())) {\n+        t.getScopeRoot().setIsSyntheticBlock(true);\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,9 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each function that\n+    // does not have a reasonable name.\n+    if (!NodeUtil.isFunctionExpression(t.getScopeRoot())) {\n+        t.getScopeRoot().setIsSyntheticBlock(true);\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,9 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each function that\n+    // does not have a reasonable name.\n+    if (!NodeUtil.isFunctionExpression(t.getScopeRoot())) {\n+        t.getScopeRoot().setIsSyntheticBlock(true);\n     }\n-    return true;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,9 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each function that\n+    // does not have a reasonable name.\n+    if (!NodeUtil.isFunctionExpression(t.getScopeRoot())) {\n+        t.getScopeRoot().setIsSyntheticBlock(true);\n     }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,9 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each function that\n+    // does not have a reasonable name.\n+    if (!NodeUtil.isFunctionExpression(t.getScopeRoot())) {\n+        t.getScopeRoot().setIsSyntheticBlock(true);\n     }\n-    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,9 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each function that\n+    // does not have a reasonable name.\n+    if (!NodeUtil.isFunctionExpression(t.getScopeRoot())) {\n+        t.getScopeRoot().setIsSyntheticBlock(true);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Symbol currentSymbol = symbolStack.peek();\n    if(currentSymbol != null){\n        currentSymbol.scope = t.getScope();\n    }\n    // NOTE: Anonymous nodes do not matter in edge propagation.\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,8 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+    Symbol currentSymbol = symbolStack.peek();\n+    if(currentSymbol != null){\n+        currentSymbol.scope = t.getScope();\n+    }\n+    // NOTE: Anonymous nodes do not matter in edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,8 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    Symbol currentSymbol = symbolStack.peek();\n+    if(currentSymbol != null){\n+        currentSymbol.scope = t.getScope();\n+    }\n+    // NOTE: Anonymous nodes do not matter in edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,8 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    Symbol currentSymbol = symbolStack.peek();\n+    if(currentSymbol != null){\n+        currentSymbol.scope = t.getScope();\n     }\n-    return true;\n+    // NOTE: Anonymous nodes do not matter in edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,8 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n+public void enterScope(NodeTraversal t) {\n+    Symbol currentSymbol = symbolStack.peek();\n+    if(currentSymbol != null){\n+        currentSymbol.scope = t.getScope();\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    // NOTE: Anonymous nodes do not matter in edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,8 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+public void enterScope(NodeTraversal t) {\n+    Symbol currentSymbol = symbolStack.peek();\n+    if(currentSymbol != null){\n+        currentSymbol.scope = t.getScope();\n     }\n-    return false;\n+    // NOTE: Anonymous nodes do not matter in edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,8 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void enterScope(NodeTraversal t) {\n+    Symbol currentSymbol = symbolStack.peek();\n+    if(currentSymbol != null){\n+        currentSymbol.scope = t.getScope();\n     }\n+    // NOTE: Anonymous nodes do not matter in edge propagation.\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    symbolStack.peek().scope = t.getScope();\n    // Use a unique anonymous node for each scope with no name.\n    if (t.getScope().isDeclaredBlock()) {\n        Node anonymousFn = new Node(Token.FUNCTION);\n        anonymousFn.setIsArrowFunction(false);\n        anonymousFn.setIsFromExterns(false);\n        anonymousFn.setJSDocInfo(null);\n        symbolStack.peek().node = anonymousFn;\n        t.getScope().declare(ANONYMOUS_FUN, anonymousFn, null, t.getCompiler());\n    }\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,13 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+    // Use a unique anonymous node for each scope with no name.\n+    if (t.getScope().isDeclaredBlock()) {\n+        Node anonymousFn = new Node(Token.FUNCTION);\n+        anonymousFn.setIsArrowFunction(false);\n+        anonymousFn.setIsFromExterns(false);\n+        anonymousFn.setJSDocInfo(null);\n+        symbolStack.peek().node = anonymousFn;\n+        t.getScope().declare(ANONYMOUS_FUN, anonymousFn, null, t.getCompiler());\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,13 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each scope with no name.\n+    if (t.getScope().isDeclaredBlock()) {\n+        Node anonymousFn = new Node(Token.FUNCTION);\n+        anonymousFn.setIsArrowFunction(false);\n+        anonymousFn.setIsFromExterns(false);\n+        anonymousFn.setJSDocInfo(null);\n+        symbolStack.peek().node = anonymousFn;\n+        t.getScope().declare(ANONYMOUS_FUN, anonymousFn, null, t.getCompiler());\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,13 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each scope with no name.\n+    if (t.getScope().isDeclaredBlock()) {\n+        Node anonymousFn = new Node(Token.FUNCTION);\n+        anonymousFn.setIsArrowFunction(false);\n+        anonymousFn.setIsFromExterns(false);\n+        anonymousFn.setJSDocInfo(null);\n+        symbolStack.peek().node = anonymousFn;\n+        t.getScope().declare(ANONYMOUS_FUN, anonymousFn, null, t.getCompiler());\n     }\n-    return true;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,13 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each scope with no name.\n+    if (t.getScope().isDeclaredBlock()) {\n+        Node anonymousFn = new Node(Token.FUNCTION);\n+        anonymousFn.setIsArrowFunction(false);\n+        anonymousFn.setIsFromExterns(false);\n+        anonymousFn.setJSDocInfo(null);\n+        symbolStack.peek().node = anonymousFn;\n+        t.getScope().declare(ANONYMOUS_FUN, anonymousFn, null, t.getCompiler());\n     }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,13 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each scope with no name.\n+    if (t.getScope().isDeclaredBlock()) {\n+        Node anonymousFn = new Node(Token.FUNCTION);\n+        anonymousFn.setIsArrowFunction(false);\n+        anonymousFn.setIsFromExterns(false);\n+        anonymousFn.setJSDocInfo(null);\n+        symbolStack.peek().node = anonymousFn;\n+        t.getScope().declare(ANONYMOUS_FUN, anonymousFn, null, t.getCompiler());\n     }\n-    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,13 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each scope with no name.\n+    if (t.getScope().isDeclaredBlock()) {\n+        Node anonymousFn = new Node(Token.FUNCTION);\n+        anonymousFn.setIsArrowFunction(false);\n+        anonymousFn.setIsFromExterns(false);\n+        anonymousFn.setJSDocInfo(null);\n+        symbolStack.peek().node = anonymousFn;\n+        t.getScope().declare(ANONYMOUS_FUN, anonymousFn, null, t.getCompiler());\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    symbolStack.peek().scope = t.getScope();\n    // Use a new or existing anonymous node for functions without a reasonable name.\n    if (t.getScope().isFunctionBlockScope()\n            && t.getScope().getRootNode().isFunction()\n            && t.getScope().getRootNode().getFirstChild() == null) {\n        if (anonymousFunctionNode == null) {\n            anonymousFunctionNode = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n        }\n        t.getScope().getRootNode().addChildToFront(anonymousFunctionNode);\n    }\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,13 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+    // Use a new or existing anonymous node for functions without a reasonable name.\n+    if (t.getScope().isFunctionBlockScope()\n+            && t.getScope().getRootNode().isFunction()\n+            && t.getScope().getRootNode().getFirstChild() == null) {\n+        if (anonymousFunctionNode == null) {\n+            anonymousFunctionNode = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n+        }\n+        t.getScope().getRootNode().addChildToFront(anonymousFunctionNode);\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,13 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a new or existing anonymous node for functions without a reasonable name.\n+    if (t.getScope().isFunctionBlockScope()\n+            && t.getScope().getRootNode().isFunction()\n+            && t.getScope().getRootNode().getFirstChild() == null) {\n+        if (anonymousFunctionNode == null) {\n+            anonymousFunctionNode = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n+        }\n+        t.getScope().getRootNode().addChildToFront(anonymousFunctionNode);\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,13 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a new or existing anonymous node for functions without a reasonable name.\n+    if (t.getScope().isFunctionBlockScope()\n+            && t.getScope().getRootNode().isFunction()\n+            && t.getScope().getRootNode().getFirstChild() == null) {\n+        if (anonymousFunctionNode == null) {\n+            anonymousFunctionNode = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n+        }\n+        t.getScope().getRootNode().addChildToFront(anonymousFunctionNode);\n     }\n-    return true;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,13 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a new or existing anonymous node for functions without a reasonable name.\n+    if (t.getScope().isFunctionBlockScope()\n+            && t.getScope().getRootNode().isFunction()\n+            && t.getScope().getRootNode().getFirstChild() == null) {\n+        if (anonymousFunctionNode == null) {\n+            anonymousFunctionNode = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n         }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n+        t.getScope().getRootNode().addChildToFront(anonymousFunctionNode);\n     }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,13 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a new or existing anonymous node for functions without a reasonable name.\n+    if (t.getScope().isFunctionBlockScope()\n+            && t.getScope().getRootNode().isFunction()\n+            && t.getScope().getRootNode().getFirstChild() == null) {\n+        if (anonymousFunctionNode == null) {\n+            anonymousFunctionNode = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n         }\n+        t.getScope().getRootNode().addChildToFront(anonymousFunctionNode);\n     }\n-    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,13 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a new or existing anonymous node for functions without a reasonable name.\n+    if (t.getScope().isFunctionBlockScope()\n+            && t.getScope().getRootNode().isFunction()\n+            && t.getScope().getRootNode().getFirstChild() == null) {\n+        if (anonymousFunctionNode == null) {\n+            anonymousFunctionNode = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n+        }\n+        t.getScope().getRootNode().addChildToFront(anonymousFunctionNode);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    symbolStack.peek().scope = t.getScope();\n    // Use a unique anonymous node for each function that does not have a name.\n    if (t.getScope().isGlobal()) {\n        Node functionNode = NodeUtil.getEnclosingFunction(t.getScope().getRootNode());\n        if (functionNode == null || !functionNode.isFunction()) {\n            NodeUtil.getEnclosingScript(t.getScope().getRootNode())\n                    .addChildToFront(new Node(Token.FUNCTION, new Node(Token.NAME, IR.empty()), IR.block()));\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,12 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+    // Use a unique anonymous node for each function that does not have a name.\n+    if (t.getScope().isGlobal()) {\n+        Node functionNode = NodeUtil.getEnclosingFunction(t.getScope().getRootNode());\n+        if (functionNode == null || !functionNode.isFunction()) {\n+            NodeUtil.getEnclosingScript(t.getScope().getRootNode())\n+                    .addChildToFront(new Node(Token.FUNCTION, new Node(Token.NAME, IR.empty()), IR.block()));\n+        }\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,12 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each function that does not have a name.\n+    if (t.getScope().isGlobal()) {\n+        Node functionNode = NodeUtil.getEnclosingFunction(t.getScope().getRootNode());\n+        if (functionNode == null || !functionNode.isFunction()) {\n+            NodeUtil.getEnclosingScript(t.getScope().getRootNode())\n+                    .addChildToFront(new Node(Token.FUNCTION, new Node(Token.NAME, IR.empty()), IR.block()));\n+        }\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,12 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each function that does not have a name.\n+    if (t.getScope().isGlobal()) {\n+        Node functionNode = NodeUtil.getEnclosingFunction(t.getScope().getRootNode());\n+        if (functionNode == null || !functionNode.isFunction()) {\n+            NodeUtil.getEnclosingScript(t.getScope().getRootNode())\n+                    .addChildToFront(new Node(Token.FUNCTION, new Node(Token.NAME, IR.empty()), IR.block()));\n+        }\n     }\n-    return true;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,12 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each function that does not have a name.\n+    if (t.getScope().isGlobal()) {\n+        Node functionNode = NodeUtil.getEnclosingFunction(t.getScope().getRootNode());\n+        if (functionNode == null || !functionNode.isFunction()) {\n+            NodeUtil.getEnclosingScript(t.getScope().getRootNode())\n+                    .addChildToFront(new Node(Token.FUNCTION, new Node(Token.NAME, IR.empty()), IR.block()));\n         }\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,12 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each function that does not have a name.\n+    if (t.getScope().isGlobal()) {\n+        Node functionNode = NodeUtil.getEnclosingFunction(t.getScope().getRootNode());\n+        if (functionNode == null || !functionNode.isFunction()) {\n+            NodeUtil.getEnclosingScript(t.getScope().getRootNode())\n+                    .addChildToFront(new Node(Token.FUNCTION, new Node(Token.NAME, IR.empty()), IR.block()));\n         }\n     }\n-    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,12 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a unique anonymous node for each function that does not have a name.\n+    if (t.getScope().isGlobal()) {\n+        Node functionNode = NodeUtil.getEnclosingFunction(t.getScope().getRootNode());\n+        if (functionNode == null || !functionNode.isFunction()) {\n+            NodeUtil.getEnclosingScript(t.getScope().getRootNode())\n+                    .addChildToFront(new Node(Token.FUNCTION, new Node(Token.NAME, IR.empty()), IR.block()));\n+        }\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    symbolStack.peek().scope = t.getScope();\n    // NOTE(nicksantos): We use the same anonymous node for all\n    // functions that do not have reasonable names. I can't remember\n    // at the moment why we do this. I think it's because anonymous\n    // nodes can never have in-edges. They're just there as a placeholder\n    // for scope information, and do not matter in the edge propagation.\n    // However, it is still good practice to give each anonymous function\n    // its own unique ID to avoid any potential issues.\n    if (t.getScope().isFunctionBlockScope() && t.getScope().getVarCount() == 0) {\n        Node enclosingFunction = NodeUtil.getEnclosingFunction(t.getScope().getRootNode());\n        if (enclosingFunction != null && NodeUtil.isFunctionExpression(enclosingFunction)) {\n            String functionName = NodeUtil.getName(enclosingFunction.getFirstChild());\n            if (functionName == null || functionName.isEmpty()) {\n                enclosingFunction.putProp(Node.ORIGINALNAME_PROP, \"anonymous_\" + anonymousFunctionCount++);\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -6,4 +6,15 @@\n     // at the moment why we do this. I think it's because anonymous\n     // nodes can never have in-edges. They're just there as a placeholder\n     // for scope information, and do not matter in the edge propagation.\n+    // However, it is still good practice to give each anonymous function\n+    // its own unique ID to avoid any potential issues.\n+    if (t.getScope().isFunctionBlockScope() && t.getScope().getVarCount() == 0) {\n+        Node enclosingFunction = NodeUtil.getEnclosingFunction(t.getScope().getRootNode());\n+        if (enclosingFunction != null && NodeUtil.isFunctionExpression(enclosingFunction)) {\n+            String functionName = NodeUtil.getName(enclosingFunction.getFirstChild());\n+            if (functionName == null || functionName.isEmpty()) {\n+                enclosingFunction.putProp(Node.ORIGINALNAME_PROP, \"anonymous_\" + anonymousFunctionCount++);\n+            }\n+        }\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,20 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // NOTE(nicksantos): We use the same anonymous node for all\n+    // functions that do not have reasonable names. I can't remember\n+    // at the moment why we do this. I think it's because anonymous\n+    // nodes can never have in-edges. They're just there as a placeholder\n+    // for scope information, and do not matter in the edge propagation.\n+    // However, it is still good practice to give each anonymous function\n+    // its own unique ID to avoid any potential issues.\n+    if (t.getScope().isFunctionBlockScope() && t.getScope().getVarCount() == 0) {\n+        Node enclosingFunction = NodeUtil.getEnclosingFunction(t.getScope().getRootNode());\n+        if (enclosingFunction != null && NodeUtil.isFunctionExpression(enclosingFunction)) {\n+            String functionName = NodeUtil.getName(enclosingFunction.getFirstChild());\n+            if (functionName == null || functionName.isEmpty()) {\n+                enclosingFunction.putProp(Node.ORIGINALNAME_PROP, \"anonymous_\" + anonymousFunctionCount++);\n+            }\n+        }\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,20 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // NOTE(nicksantos): We use the same anonymous node for all\n+    // functions that do not have reasonable names. I can't remember\n+    // at the moment why we do this. I think it's because anonymous\n+    // nodes can never have in-edges. They're just there as a placeholder\n+    // for scope information, and do not matter in the edge propagation.\n+    // However, it is still good practice to give each anonymous function\n+    // its own unique ID to avoid any potential issues.\n+    if (t.getScope().isFunctionBlockScope() && t.getScope().getVarCount() == 0) {\n+        Node enclosingFunction = NodeUtil.getEnclosingFunction(t.getScope().getRootNode());\n+        if (enclosingFunction != null && NodeUtil.isFunctionExpression(enclosingFunction)) {\n+            String functionName = NodeUtil.getName(enclosingFunction.getFirstChild());\n+            if (functionName == null || functionName.isEmpty()) {\n+                enclosingFunction.putProp(Node.ORIGINALNAME_PROP, \"anonymous_\" + anonymousFunctionCount++);\n+            }\n+        }\n     }\n-    return true;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,20 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // NOTE(nicksantos): We use the same anonymous node for all\n+    // functions that do not have reasonable names. I can't remember\n+    // at the moment why we do this. I think it's because anonymous\n+    // nodes can never have in-edges. They're just there as a placeholder\n+    // for scope information, and do not matter in the edge propagation.\n+    // However, it is still good practice to give each anonymous function\n+    // its own unique ID to avoid any potential issues.\n+    if (t.getScope().isFunctionBlockScope() && t.getScope().getVarCount() == 0) {\n+        Node enclosingFunction = NodeUtil.getEnclosingFunction(t.getScope().getRootNode());\n+        if (enclosingFunction != null && NodeUtil.isFunctionExpression(enclosingFunction)) {\n+            String functionName = NodeUtil.getName(enclosingFunction.getFirstChild());\n+            if (functionName == null || functionName.isEmpty()) {\n+                enclosingFunction.putProp(Node.ORIGINALNAME_PROP, \"anonymous_\" + anonymousFunctionCount++);\n             }\n         }\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,20 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // NOTE(nicksantos): We use the same anonymous node for all\n+    // functions that do not have reasonable names. I can't remember\n+    // at the moment why we do this. I think it's because anonymous\n+    // nodes can never have in-edges. They're just there as a placeholder\n+    // for scope information, and do not matter in the edge propagation.\n+    // However, it is still good practice to give each anonymous function\n+    // its own unique ID to avoid any potential issues.\n+    if (t.getScope().isFunctionBlockScope() && t.getScope().getVarCount() == 0) {\n+        Node enclosingFunction = NodeUtil.getEnclosingFunction(t.getScope().getRootNode());\n+        if (enclosingFunction != null && NodeUtil.isFunctionExpression(enclosingFunction)) {\n+            String functionName = NodeUtil.getName(enclosingFunction.getFirstChild());\n+            if (functionName == null || functionName.isEmpty()) {\n+                enclosingFunction.putProp(Node.ORIGINALNAME_PROP, \"anonymous_\" + anonymousFunctionCount++);\n+            }\n         }\n     }\n-    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,20 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // NOTE(nicksantos): We use the same anonymous node for all\n+    // functions that do not have reasonable names. I can't remember\n+    // at the moment why we do this. I think it's because anonymous\n+    // nodes can never have in-edges. They're just there as a placeholder\n+    // for scope information, and do not matter in the edge propagation.\n+    // However, it is still good practice to give each anonymous function\n+    // its own unique ID to avoid any potential issues.\n+    if (t.getScope().isFunctionBlockScope() && t.getScope().getVarCount() == 0) {\n+        Node enclosingFunction = NodeUtil.getEnclosingFunction(t.getScope().getRootNode());\n+        if (enclosingFunction != null && NodeUtil.isFunctionExpression(enclosingFunction)) {\n+            String functionName = NodeUtil.getName(enclosingFunction.getFirstChild());\n+            if (functionName == null || functionName.isEmpty()) {\n+                enclosingFunction.putProp(Node.ORIGINALNAME_PROP, \"anonymous_\" + anonymousFunctionCount++);\n+            }\n+        }\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    SymbolEntry currentSymbol = symbolStack.peek();\n    Node anonymousScope = t.getScope().isDeclared() ? t.getScope().getParent() : t.getScope();\n    currentSymbol.scope = anonymousScope;\n    // Use the next unique ID for anonymous functions\n    if (anonymousScope.isFunction()) {\n        anonymousScope.putProp(Node.FUNCTION_SUPPRESS_UNREACHABLE, Boolean.TRUE);\n        currentSymbol.id = nextAnonId++;\n    }\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,11 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+    SymbolEntry currentSymbol = symbolStack.peek();\n+    Node anonymousScope = t.getScope().isDeclared() ? t.getScope().getParent() : t.getScope();\n+    currentSymbol.scope = anonymousScope;\n+    // Use the next unique ID for anonymous functions\n+    if (anonymousScope.isFunction()) {\n+        anonymousScope.putProp(Node.FUNCTION_SUPPRESS_UNREACHABLE, Boolean.TRUE);\n+        currentSymbol.id = nextAnonId++;\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,11 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    SymbolEntry currentSymbol = symbolStack.peek();\n+    Node anonymousScope = t.getScope().isDeclared() ? t.getScope().getParent() : t.getScope();\n+    currentSymbol.scope = anonymousScope;\n+    // Use the next unique ID for anonymous functions\n+    if (anonymousScope.isFunction()) {\n+        anonymousScope.putProp(Node.FUNCTION_SUPPRESS_UNREACHABLE, Boolean.TRUE);\n+        currentSymbol.id = nextAnonId++;\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,11 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    SymbolEntry currentSymbol = symbolStack.peek();\n+    Node anonymousScope = t.getScope().isDeclared() ? t.getScope().getParent() : t.getScope();\n+    currentSymbol.scope = anonymousScope;\n+    // Use the next unique ID for anonymous functions\n+    if (anonymousScope.isFunction()) {\n+        anonymousScope.putProp(Node.FUNCTION_SUPPRESS_UNREACHABLE, Boolean.TRUE);\n+        currentSymbol.id = nextAnonId++;\n     }\n-    return true;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,11 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n+public void enterScope(NodeTraversal t) {\n+    SymbolEntry currentSymbol = symbolStack.peek();\n+    Node anonymousScope = t.getScope().isDeclared() ? t.getScope().getParent() : t.getScope();\n+    currentSymbol.scope = anonymousScope;\n+    // Use the next unique ID for anonymous functions\n+    if (anonymousScope.isFunction()) {\n+        anonymousScope.putProp(Node.FUNCTION_SUPPRESS_UNREACHABLE, Boolean.TRUE);\n+        currentSymbol.id = nextAnonId++;\n     }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,11 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+public void enterScope(NodeTraversal t) {\n+    SymbolEntry currentSymbol = symbolStack.peek();\n+    Node anonymousScope = t.getScope().isDeclared() ? t.getScope().getParent() : t.getScope();\n+    currentSymbol.scope = anonymousScope;\n+    // Use the next unique ID for anonymous functions\n+    if (anonymousScope.isFunction()) {\n+        anonymousScope.putProp(Node.FUNCTION_SUPPRESS_UNREACHABLE, Boolean.TRUE);\n+        currentSymbol.id = nextAnonId++;\n     }\n-    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,11 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void enterScope(NodeTraversal t) {\n+    SymbolEntry currentSymbol = symbolStack.peek();\n+    Node anonymousScope = t.getScope().isDeclared() ? t.getScope().getParent() : t.getScope();\n+    currentSymbol.scope = anonymousScope;\n+    // Use the next unique ID for anonymous functions\n+    if (anonymousScope.isFunction()) {\n+        anonymousScope.putProp(Node.FUNCTION_SUPPRESS_UNREACHABLE, Boolean.TRUE);\n+        currentSymbol.id = nextAnonId++;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    symbolStack.peek().scope = t.getScope();\n    // Set anonymous node for functions without names\n    if (t.getScope().isGlobal()) {\n        // Use a unique ID for anonymous nodes to avoid collisions\n        Node anonymousNode = NodeUtil.newName(t.getCompiler(), \"anonymous#\" + t.getScope().getNextAnonymousId());\n        anonymousNode.putBooleanProp(Node.IS_NAMESPACE, true);\n        anonymousNode.setStaticSourceFile(t.getScope().getRootNode().getStaticSourceFile());\n        t.getScope().declare(anonymousNode, null, t.getCompiler().getTopScope());\n    }\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,12 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+    // Set anonymous node for functions without names\n+    if (t.getScope().isGlobal()) {\n+        // Use a unique ID for anonymous nodes to avoid collisions\n+        Node anonymousNode = NodeUtil.newName(t.getCompiler(), \"anonymous#\" + t.getScope().getNextAnonymousId());\n+        anonymousNode.putBooleanProp(Node.IS_NAMESPACE, true);\n+        anonymousNode.setStaticSourceFile(t.getScope().getRootNode().getStaticSourceFile());\n+        t.getScope().declare(anonymousNode, null, t.getCompiler().getTopScope());\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,12 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Set anonymous node for functions without names\n+    if (t.getScope().isGlobal()) {\n+        // Use a unique ID for anonymous nodes to avoid collisions\n+        Node anonymousNode = NodeUtil.newName(t.getCompiler(), \"anonymous#\" + t.getScope().getNextAnonymousId());\n+        anonymousNode.putBooleanProp(Node.IS_NAMESPACE, true);\n+        anonymousNode.setStaticSourceFile(t.getScope().getRootNode().getStaticSourceFile());\n+        t.getScope().declare(anonymousNode, null, t.getCompiler().getTopScope());\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,12 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Set anonymous node for functions without names\n+    if (t.getScope().isGlobal()) {\n+        // Use a unique ID for anonymous nodes to avoid collisions\n+        Node anonymousNode = NodeUtil.newName(t.getCompiler(), \"anonymous#\" + t.getScope().getNextAnonymousId());\n+        anonymousNode.putBooleanProp(Node.IS_NAMESPACE, true);\n+        anonymousNode.setStaticSourceFile(t.getScope().getRootNode().getStaticSourceFile());\n+        t.getScope().declare(anonymousNode, null, t.getCompiler().getTopScope());\n     }\n-    return true;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,12 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Set anonymous node for functions without names\n+    if (t.getScope().isGlobal()) {\n+        // Use a unique ID for anonymous nodes to avoid collisions\n+        Node anonymousNode = NodeUtil.newName(t.getCompiler(), \"anonymous#\" + t.getScope().getNextAnonymousId());\n+        anonymousNode.putBooleanProp(Node.IS_NAMESPACE, true);\n+        anonymousNode.setStaticSourceFile(t.getScope().getRootNode().getStaticSourceFile());\n+        t.getScope().declare(anonymousNode, null, t.getCompiler().getTopScope());\n     }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,12 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Set anonymous node for functions without names\n+    if (t.getScope().isGlobal()) {\n+        // Use a unique ID for anonymous nodes to avoid collisions\n+        Node anonymousNode = NodeUtil.newName(t.getCompiler(), \"anonymous#\" + t.getScope().getNextAnonymousId());\n+        anonymousNode.putBooleanProp(Node.IS_NAMESPACE, true);\n+        anonymousNode.setStaticSourceFile(t.getScope().getRootNode().getStaticSourceFile());\n+        t.getScope().declare(anonymousNode, null, t.getCompiler().getTopScope());\n     }\n-    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,12 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Set anonymous node for functions without names\n+    if (t.getScope().isGlobal()) {\n+        // Use a unique ID for anonymous nodes to avoid collisions\n+        Node anonymousNode = NodeUtil.newName(t.getCompiler(), \"anonymous#\" + t.getScope().getNextAnonymousId());\n+        anonymousNode.putBooleanProp(Node.IS_NAMESPACE, true);\n+        anonymousNode.setStaticSourceFile(t.getScope().getRootNode().getStaticSourceFile());\n+        t.getScope().declare(anonymousNode, null, t.getCompiler().getTopScope());\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    SymbolTable.Symbol currentSymbol = symbolStack.peek();\n    currentSymbol.scope = t.getScope();\n    if (currentSymbol.name.isEmpty()) {\n        // Create a unique anonymous node for each function with no name.\n        Node functionNode = NodeUtil.getEnclosingFunction(t.getScopeRoot());\n        currentSymbol.name = \"anonymous#\" + functionNode.hashCode();\n    }\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,10 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+    SymbolTable.Symbol currentSymbol = symbolStack.peek();\n+    currentSymbol.scope = t.getScope();\n+    if (currentSymbol.name.isEmpty()) {\n+        // Create a unique anonymous node for each function with no name.\n+        Node functionNode = NodeUtil.getEnclosingFunction(t.getScopeRoot());\n+        currentSymbol.name = \"anonymous#\" + functionNode.hashCode();\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,10 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    SymbolTable.Symbol currentSymbol = symbolStack.peek();\n+    currentSymbol.scope = t.getScope();\n+    if (currentSymbol.name.isEmpty()) {\n+        // Create a unique anonymous node for each function with no name.\n+        Node functionNode = NodeUtil.getEnclosingFunction(t.getScopeRoot());\n+        currentSymbol.name = \"anonymous#\" + functionNode.hashCode();\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,10 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    SymbolTable.Symbol currentSymbol = symbolStack.peek();\n+    currentSymbol.scope = t.getScope();\n+    if (currentSymbol.name.isEmpty()) {\n+        // Create a unique anonymous node for each function with no name.\n+        Node functionNode = NodeUtil.getEnclosingFunction(t.getScopeRoot());\n+        currentSymbol.name = \"anonymous#\" + functionNode.hashCode();\n     }\n-    return true;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,10 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n+public void enterScope(NodeTraversal t) {\n+    SymbolTable.Symbol currentSymbol = symbolStack.peek();\n+    currentSymbol.scope = t.getScope();\n+    if (currentSymbol.name.isEmpty()) {\n+        // Create a unique anonymous node for each function with no name.\n+        Node functionNode = NodeUtil.getEnclosingFunction(t.getScopeRoot());\n+        currentSymbol.name = \"anonymous#\" + functionNode.hashCode();\n     }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,10 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+public void enterScope(NodeTraversal t) {\n+    SymbolTable.Symbol currentSymbol = symbolStack.peek();\n+    currentSymbol.scope = t.getScope();\n+    if (currentSymbol.name.isEmpty()) {\n+        // Create a unique anonymous node for each function with no name.\n+        Node functionNode = NodeUtil.getEnclosingFunction(t.getScopeRoot());\n+        currentSymbol.name = \"anonymous#\" + functionNode.hashCode();\n     }\n-    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,10 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void enterScope(NodeTraversal t) {\n+    SymbolTable.Symbol currentSymbol = symbolStack.peek();\n+    currentSymbol.scope = t.getScope();\n+    if (currentSymbol.name.isEmpty()) {\n+        // Create a unique anonymous node for each function with no name.\n+        Node functionNode = NodeUtil.getEnclosingFunction(t.getScopeRoot());\n+        currentSymbol.name = \"anonymous#\" + functionNode.hashCode();\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Symbol symbol = symbolStack.peek();\n    symbol.scope = t.getScope();\n    if (symbol.node.isFunction()) {\n        symbol.node.setJSDocInfo(new JSDocInfoBuilder(false).build());\n    }\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,8 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+    Symbol symbol = symbolStack.peek();\n+    symbol.scope = t.getScope();\n+    if (symbol.node.isFunction()) {\n+        symbol.node.setJSDocInfo(new JSDocInfoBuilder(false).build());\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,8 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    Symbol symbol = symbolStack.peek();\n+    symbol.scope = t.getScope();\n+    if (symbol.node.isFunction()) {\n+        symbol.node.setJSDocInfo(new JSDocInfoBuilder(false).build());\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,8 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    Symbol symbol = symbolStack.peek();\n+    symbol.scope = t.getScope();\n+    if (symbol.node.isFunction()) {\n+        symbol.node.setJSDocInfo(new JSDocInfoBuilder(false).build());\n     }\n-    return true;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,8 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n+public void enterScope(NodeTraversal t) {\n+    Symbol symbol = symbolStack.peek();\n+    symbol.scope = t.getScope();\n+    if (symbol.node.isFunction()) {\n+        symbol.node.setJSDocInfo(new JSDocInfoBuilder(false).build());\n     }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,8 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+public void enterScope(NodeTraversal t) {\n+    Symbol symbol = symbolStack.peek();\n+    symbol.scope = t.getScope();\n+    if (symbol.node.isFunction()) {\n+        symbol.node.setJSDocInfo(new JSDocInfoBuilder(false).build());\n     }\n-    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,8 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void enterScope(NodeTraversal t) {\n+    Symbol symbol = symbolStack.peek();\n+    symbol.scope = t.getScope();\n+    if (symbol.node.isFunction()) {\n+        symbol.node.setJSDocInfo(new JSDocInfoBuilder(false).build());\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    symbolStack.peek().scope = t.getScope();\n    // Set anonymous nodes for functions without names to null to avoid propagation issues\n    Node currentNode = t.getCurrentNode();\n    if (currentNode.isFunction() && currentNode.getFirstChild().getString().isEmpty()) {\n        currentNode.setJSTypeNull();\n    }\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,9 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+    // Set anonymous nodes for functions without names to null to avoid propagation issues\n+    Node currentNode = t.getCurrentNode();\n+    if (currentNode.isFunction() && currentNode.getFirstChild().getString().isEmpty()) {\n+        currentNode.setJSTypeNull();\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,9 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Set anonymous nodes for functions without names to null to avoid propagation issues\n+    Node currentNode = t.getCurrentNode();\n+    if (currentNode.isFunction() && currentNode.getFirstChild().getString().isEmpty()) {\n+        currentNode.setJSTypeNull();\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,9 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Set anonymous nodes for functions without names to null to avoid propagation issues\n+    Node currentNode = t.getCurrentNode();\n+    if (currentNode.isFunction() && currentNode.getFirstChild().getString().isEmpty()) {\n+        currentNode.setJSTypeNull();\n     }\n-    return true;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,9 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Set anonymous nodes for functions without names to null to avoid propagation issues\n+    Node currentNode = t.getCurrentNode();\n+    if (currentNode.isFunction() && currentNode.getFirstChild().getString().isEmpty()) {\n+        currentNode.setJSTypeNull();\n     }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,9 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Set anonymous nodes for functions without names to null to avoid propagation issues\n+    Node currentNode = t.getCurrentNode();\n+    if (currentNode.isFunction() && currentNode.getFirstChild().getString().isEmpty()) {\n+        currentNode.setJSTypeNull();\n     }\n-    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,9 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Set anonymous nodes for functions without names to null to avoid propagation issues\n+    Node currentNode = t.getCurrentNode();\n+    if (currentNode.isFunction() && currentNode.getFirstChild().getString().isEmpty()) {\n+        currentNode.setJSTypeNull();\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    symbolStack.peek().scope = t.getScope();\n    // Use a new anonymous node for each function without a name\n    if (t.getScope().isDeclared(NodeUtil.JSC_ANON_FUN_NAME, false)) {\n        t.getScope().undeclare(NodeUtil.JSC_ANON_FUN_NAME);\n    }\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,8 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+    // Use a new anonymous node for each function without a name\n+    if (t.getScope().isDeclared(NodeUtil.JSC_ANON_FUN_NAME, false)) {\n+        t.getScope().undeclare(NodeUtil.JSC_ANON_FUN_NAME);\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,8 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a new anonymous node for each function without a name\n+    if (t.getScope().isDeclared(NodeUtil.JSC_ANON_FUN_NAME, false)) {\n+        t.getScope().undeclare(NodeUtil.JSC_ANON_FUN_NAME);\n+    }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,8 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a new anonymous node for each function without a name\n+    if (t.getScope().isDeclared(NodeUtil.JSC_ANON_FUN_NAME, false)) {\n+        t.getScope().undeclare(NodeUtil.JSC_ANON_FUN_NAME);\n     }\n-    return true;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,8 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a new anonymous node for each function without a name\n+    if (t.getScope().isDeclared(NodeUtil.JSC_ANON_FUN_NAME, false)) {\n+        t.getScope().undeclare(NodeUtil.JSC_ANON_FUN_NAME);\n     }\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,8 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a new anonymous node for each function without a name\n+    if (t.getScope().isDeclared(NodeUtil.JSC_ANON_FUN_NAME, false)) {\n+        t.getScope().undeclare(NodeUtil.JSC_ANON_FUN_NAME);\n     }\n-    return false;\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,8 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Use a new anonymous node for each function without a name\n+    if (t.getScope().isDeclared(NodeUtil.JSC_ANON_FUN_NAME, false)) {\n+        t.getScope().undeclare(NodeUtil.JSC_ANON_FUN_NAME);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (!symbolStack.isEmpty()) {\n        symbolStack.peek().scope = t.getScope();\n    } else {\n        Symbol topScope = new Symbol(null, Symbol.Type.SCRIPT);\n        topScope.scope = t.getScope();\n        symbolStack.push(topScope);\n    }\n    // NOTE(nicksantos): We use the same anonymous node for all\n    // functions that do not have reasonable names. I can't remember\n    // at the moment why we do this. I think it's because anonymous\n    // nodes can never have in-edges. They're just there as a placeholder\n    // for scope information, and do not matter in the edge propagation.\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,6 +1,12 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n+    if (!symbolStack.isEmpty()) {\n+        symbolStack.peek().scope = t.getScope();\n+    } else {\n+        Symbol topScope = new Symbol(null, Symbol.Type.SCRIPT);\n+        topScope.scope = t.getScope();\n+        symbolStack.push(topScope);\n+    }\n     // NOTE(nicksantos): We use the same anonymous node for all\n     // functions that do not have reasonable names. I can't remember\n     // at the moment why we do this. I think it's because anonymous\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,15 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    if (!symbolStack.isEmpty()) {\n+        symbolStack.peek().scope = t.getScope();\n+    } else {\n+        Symbol topScope = new Symbol(null, Symbol.Type.SCRIPT);\n+        topScope.scope = t.getScope();\n+        symbolStack.push(topScope);\n+    }\n+    // NOTE(nicksantos): We use the same anonymous node for all\n+    // functions that do not have reasonable names. I can't remember\n+    // at the moment why we do this. I think it's because anonymous\n+    // nodes can never have in-edges. They're just there as a placeholder\n+    // for scope information, and do not matter in the edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,15 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    if (!symbolStack.isEmpty()) {\n+        symbolStack.peek().scope = t.getScope();\n+    } else {\n+        Symbol topScope = new Symbol(null, Symbol.Type.SCRIPT);\n+        topScope.scope = t.getScope();\n+        symbolStack.push(topScope);\n     }\n-    return true;\n+    // NOTE(nicksantos): We use the same anonymous node for all\n+    // functions that do not have reasonable names. I can't remember\n+    // at the moment why we do this. I think it's because anonymous\n+    // nodes can never have in-edges. They're just there as a placeholder\n+    // for scope information, and do not matter in the edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,15 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n+public void enterScope(NodeTraversal t) {\n+    if (!symbolStack.isEmpty()) {\n+        symbolStack.peek().scope = t.getScope();\n+    } else {\n+        Symbol topScope = new Symbol(null, Symbol.Type.SCRIPT);\n+        topScope.scope = t.getScope();\n+        symbolStack.push(topScope);\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    // NOTE(nicksantos): We use the same anonymous node for all\n+    // functions that do not have reasonable names. I can't remember\n+    // at the moment why we do this. I think it's because anonymous\n+    // nodes can never have in-edges. They're just there as a placeholder\n+    // for scope information, and do not matter in the edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,15 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+public void enterScope(NodeTraversal t) {\n+    if (!symbolStack.isEmpty()) {\n+        symbolStack.peek().scope = t.getScope();\n+    } else {\n+        Symbol topScope = new Symbol(null, Symbol.Type.SCRIPT);\n+        topScope.scope = t.getScope();\n+        symbolStack.push(topScope);\n     }\n-    return false;\n+    // NOTE(nicksantos): We use the same anonymous node for all\n+    // functions that do not have reasonable names. I can't remember\n+    // at the moment why we do this. I think it's because anonymous\n+    // nodes can never have in-edges. They're just there as a placeholder\n+    // for scope information, and do not matter in the edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,15 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n+public void enterScope(NodeTraversal t) {\n+    if (!symbolStack.isEmpty()) {\n+        symbolStack.peek().scope = t.getScope();\n     } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+        Symbol topScope = new Symbol(null, Symbol.Type.SCRIPT);\n+        topScope.scope = t.getScope();\n+        symbolStack.push(topScope);\n     }\n+    // NOTE(nicksantos): We use the same anonymous node for all\n+    // functions that do not have reasonable names. I can't remember\n+    // at the moment why we do this. I think it's because anonymous\n+    // nodes can never have in-edges. They're just there as a placeholder\n+    // for scope information, and do not matter in the edge propagation.\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Symbol currentSymbol = symbolStack.peek();\n    if (currentSymbol != null) {\n        currentSymbol.scope = t.getScope();\n    }\n    // NOTE: Anonymous nodes are used for functions without reasonable names.\n    // They can never have in-edges, and only exist as placeholders for scope\n    // information. They do not affect edge propagation.\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,10 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+    Symbol currentSymbol = symbolStack.peek();\n+    if (currentSymbol != null) {\n+        currentSymbol.scope = t.getScope();\n+    }\n+    // NOTE: Anonymous nodes are used for functions without reasonable names.\n+    // They can never have in-edges, and only exist as placeholders for scope\n+    // information. They do not affect edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,10 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    Symbol currentSymbol = symbolStack.peek();\n+    if (currentSymbol != null) {\n+        currentSymbol.scope = t.getScope();\n+    }\n+    // NOTE: Anonymous nodes are used for functions without reasonable names.\n+    // They can never have in-edges, and only exist as placeholders for scope\n+    // information. They do not affect edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,10 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n+public void enterScope(NodeTraversal t) {\n+    Symbol currentSymbol = symbolStack.peek();\n+    if (currentSymbol != null) {\n+        currentSymbol.scope = t.getScope();\n     }\n-    return true;\n+    // NOTE: Anonymous nodes are used for functions without reasonable names.\n+    // They can never have in-edges, and only exist as placeholders for scope\n+    // information. They do not affect edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,10 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n+public void enterScope(NodeTraversal t) {\n+    Symbol currentSymbol = symbolStack.peek();\n+    if (currentSymbol != null) {\n+        currentSymbol.scope = t.getScope();\n     }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+    // NOTE: Anonymous nodes are used for functions without reasonable names.\n+    // They can never have in-edges, and only exist as placeholders for scope\n+    // information. They do not affect edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,10 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n+public void enterScope(NodeTraversal t) {\n+    Symbol currentSymbol = symbolStack.peek();\n+    if (currentSymbol != null) {\n+        currentSymbol.scope = t.getScope();\n     }\n-    return false;\n+    // NOTE: Anonymous nodes are used for functions without reasonable names.\n+    // They can never have in-edges, and only exist as placeholders for scope\n+    // information. They do not affect edge propagation.\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,10 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n+public void enterScope(NodeTraversal t) {\n+    Symbol currentSymbol = symbolStack.peek();\n+    if (currentSymbol != null) {\n+        currentSymbol.scope = t.getScope();\n     }\n+    // NOTE: Anonymous nodes are used for functions without reasonable names.\n+    // They can never have in-edges, and only exist as placeholders for scope\n+    // information. They do not affect edge propagation.\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    symbolStack.peek().scope = t.getScope();\n    // Using a new anonymous node for every function that doesn't have a name\n    // ensures that each function has its own scope and in-edges can be\n    // properly propagated.\n    t.getScope().setStart(new Node(Token.SCOPENAME, \"\"));\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@enterScope\n@@ -1,9 +1,8 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     symbolStack.peek().scope = t.getScope();\n-    // NOTE(nicksantos): We use the same anonymous node for all\n-    // functions that do not have reasonable names. I can't remember\n-    // at the moment why we do this. I think it's because anonymous\n-    // nodes can never have in-edges. They're just there as a placeholder\n-    // for scope information, and do not matter in the edge propagation.\n+    // Using a new anonymous node for every function that doesn't have a name\n+    // ensures that each function has its own scope and in-edges can be\n+    // properly propagated.\n+    t.getScope().setStart(new Node(Token.SCOPENAME, \"\"));\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@exitScope\n@@ -1,3 +1,8 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Using a new anonymous node for every function that doesn't have a name\n+    // ensures that each function has its own scope and in-edges can be\n+    // properly propagated.\n+    t.getScope().setStart(new Node(Token.SCOPENAME, \"\"));\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@shouldTraverse\n@@ -1,13 +1,8 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n)) {\n-        symbolStack.push(new NameContext(getNameInfoForName(n.getFirstChild().getLastChild().getString(), PROPERTY)));\n-    } else if (isGlobalFunctionDeclaration(t, n)) {\n-        String name = parent.isName() ? parent.getString() :         n.getFirstChild().getString();\n-        symbolStack.push(new NameContext(getNameInfoForName(name, VAR)));\n-    } else if (n.isFunction()) {\n-        symbolStack.push(new NameContext(anonymousNode));\n-    }\n-    return true;\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Using a new anonymous node for every function that doesn't have a name\n+    // ensures that each function has its own scope and in-edges can be\n+    // properly propagated.\n+    t.getScope().setStart(new Node(Token.SCOPENAME, \"\"));\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@visit\n@@ -1,58 +1,8 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.isGetProp()) {\n-        String propName = n.getFirstChild().getNext().getString();\n-        if (propName.equals(\"prototype\")) {\n-            processPrototypeParent(t, parent);\n-        } else if (compiler.getCodingConvention().isExported(propName)) {\n-            addGlobalUseOfSymbol(propName, t.getModule(), PROPERTY);\n-        } else {\n-            // Do not mark prototype prop assigns as a 'use' in the global scope.\n-            addSymbolUse(propName, t.getModule(), PROPERTY);\n-        }\n-    } else if (n.isObjectLit() && // Make sure that we're not handling object literals being\n-    // assigned to a prototype, as in:\n-    // Foo.prototype = {bar: 3, baz: 5};\n-    !(parent.isAssign() && parent.getFirstChild().isGetProp() && parent.getFirstChild().getLastChild().getString().equals(\"prototype\"))) {\n-        // var x = {a: 1, b: 2}\n-        // should count as a use of property a and b.\n-        for (Node propNameNode = n.getFirstChild(); propNameNode != null; propNameNode = propNameNode.getNext()) {\n-            // May be STRING, GET, or SET, but NUMBER isn't interesting.\n-            if (!propNameNode.isQuotedString()) {\n-                addSymbolUse(propNameNode.getString(), t.getModule(), PROPERTY);\n-            }\n-        }\n-    } else if (n.isName()) {\n-        String name = n.getString();\n-        Var var = t.getScope().getVar(name);\n-        if (var != null) {\n-            // Only process global functions.\n-            if (var.isGlobal()) {\n-                if (var.getInitialValue() != null && var.getInitialValue().isFunction()) {\n-                    if (t.inGlobalScope()) {\n-                        if (!processGlobalFunctionDeclaration(t, n, parent, parent.getParent())) {\n-                            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n-                        }\n-                    } else {\n-                        addSymbolUse(name, t.getModule(), VAR);\n-                    }\n-                }\n-                // If it is not a global, it might be accessing a local of the outer\n-                // scope. If that's the case the functions between the variable's\n-                // declaring scope and the variable reference scope cannot be moved.\n-            } else if (var.getScope() != t.getScope()) {\n-                for (int i = symbolStack.size() - 1; i >= 0; i--) {\n-                    NameContext context = symbolStack.get(i);\n-                    if (context.scope == var.getScope()) {\n-                        break;\n-                    }\n-                    context.name.readClosureVariables = true;\n-                }\n-            }\n-        }\n-    }\n-    // Process prototype assignments to non-functions.\n-    if (isPrototypePropertyAssign(n) || isGlobalFunctionDeclaration(t, n) || n.isFunction()) {\n-        symbolStack.pop();\n-    }\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Using a new anonymous node for every function that doesn't have a name\n+    // ensures that each function has its own scope and in-edges can be\n+    // properly propagated.\n+    t.getScope().setStart(new Node(Token.SCOPENAME, \"\"));\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@traverseEdge\n@@ -1,12 +1,8 @@\n @Override\n-public boolean traverseEdge(NameInfo start, JSModule edge, NameInfo dest) {\n-    if (start.isReferenced()) {\n-        JSModule startModule = start.getDeepestCommonModuleRef();\n-        if (startModule != null && moduleGraph.dependsOn(startModule, edge)) {\n-            return dest.markReference(startModule);\n-        } else {\n-            return dest.markReference(edge);\n-        }\n-    }\n-    return false;\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Using a new anonymous node for every function that doesn't have a name\n+    // ensures that each function has its own scope and in-edges can be\n+    // properly propagated.\n+    t.getScope().setStart(new Node(Token.SCOPENAME, \"\"));\n }\n--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@remove\n@@ -1,10 +1,8 @@\n @Override\n-public void remove() {\n-    Node parent = nameNode.getParent();\n-    if (parent.isFunction() || parent.hasOneChild()) {\n-        NodeUtil.removeChild(parent.getParent(), parent);\n-    } else {\n-        Preconditions.checkState(parent.isVar());\n-        parent.removeChild(nameNode);\n-    }\n+public void enterScope(NodeTraversal t) {\n+    symbolStack.peek().scope = t.getScope();\n+    // Using a new anonymous node for every function that doesn't have a name\n+    // ensures that each function has its own scope and in-edges can be\n+    // properly propagated.\n+    t.getScope().setStart(new Node(Token.SCOPENAME, \"\"));\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]