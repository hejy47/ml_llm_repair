[{"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if (// Check for a named FUNCTION.\n        isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n        (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Parenthesize condition on second check\n            String name = nameNode.getString();\n            getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n            // If the function name is exported, we should create an edge here\n            // so that it's never removed.\n            if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n                addGlobalUseOfSymbol(name, t.getModule(), VAR);\n            }\n            return true;\n        }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -1,16 +1,16 @@\n private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n     Node firstChild = nameNode.getFirstChild();\n     if (// Check for a named FUNCTION.\n-    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n-    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n-        String name = nameNode.getString();\n-        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n-        // If the function name is exported, we should create an edge here\n-        // so that it's never removed.\n-        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n-            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n+        isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n+        (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Parenthesize condition on second check\n+            String name = nameNode.getString();\n+            getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n+            // If the function name is exported, we should create an edge here\n+            // so that it's never removed.\n+            if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n+                addGlobalUseOfSymbol(name, t.getModule(), VAR);\n+            }\n+            return true;\n         }\n-        return true;\n-    }\n     return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if ((firstChild != null && firstChild.getToken() == Token.FUNCTION) || // Check for a named FUNCTION.\n            (isGlobalVarDeclaration(t, parent) && nameNode.hasOneChild())) { // Check for a VAR declaration.\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}\n\n// Helper function to check for global VAR declaration\nprivate boolean isGlobalVarDeclaration(NodeTraversal t, Node parent) {\n    if (parent != null && parent.isVar() && parent.getParent() == t.getScopeRoot()) {\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -1,8 +1,7 @@\n private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n     Node firstChild = nameNode.getFirstChild();\n-    if (// Check for a named FUNCTION.\n-    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n-    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n+    if ((firstChild != null && firstChild.getToken() == Token.FUNCTION) || // Check for a named FUNCTION.\n+            (isGlobalVarDeclaration(t, parent) && nameNode.hasOneChild())) { // Check for a VAR declaration.\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n         // If the function name is exported, we should create an edge here\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if (// Check for a named FUNCTION.\n    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) || t.getCompiler().getOptions().anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -7,7 +7,7 @@\n         getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n         // If the function name is exported, we should create an edge here\n         // so that it's never removed.\n-        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n+        if (compiler.getCodingConvention().isExported(name) || t.getCompiler().getOptions().anchorUnusedVars) {\n             addGlobalUseOfSymbol(name, t.getModule(), VAR);\n         }\n         return true;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if (// Check for a named FUNCTION.\n        isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n        (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Add parentheses to group the second condition\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -1,8 +1,8 @@\n private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n     Node firstChild = nameNode.getFirstChild();\n     if (// Check for a named FUNCTION.\n-    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n-    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n+        isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n+        (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Add parentheses to group the second condition\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n         // If the function name is exported, we should create an edge here\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if (// Check for a named FUNCTION.\n    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n    (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Added parentheses to ensure proper order of operations\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -2,7 +2,7 @@\n     Node firstChild = nameNode.getFirstChild();\n     if (// Check for a named FUNCTION.\n     isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n-    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n+    (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Added parentheses to ensure proper order of operations\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n         // If the function name is exported, we should create an edge here\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if (// Check for a named FUNCTION.\n    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n    (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Enclose the check for firstChild inside parentheses\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -2,7 +2,7 @@\n     Node firstChild = nameNode.getFirstChild();\n     if (// Check for a named FUNCTION.\n     isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n-    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n+    (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Enclose the check for firstChild inside parentheses\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n         // If the function name is exported, we should create an edge here\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if (// Check for a named FUNCTION.\n    (parent.isVar() || parent.isLet() || parent.isConst()) && // Check for a VAR declaration.\n    isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // If the function name is exported, we should create an edge here so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -1,12 +1,11 @@\n private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n     Node firstChild = nameNode.getFirstChild();\n     if (// Check for a named FUNCTION.\n-    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n-    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n+    (parent.isVar() || parent.isLet() || parent.isConst()) && // Check for a VAR declaration.\n+    isGlobalFunctionDeclaration(t, parent) || firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n-        // If the function name is exported, we should create an edge here\n-        // so that it's never removed.\n+        // If the function name is exported, we should create an edge here so that it's never removed.\n         if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n             addGlobalUseOfSymbol(name, t.getModule(), VAR);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if (// Check for a named FUNCTION.\n    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n    (firstChild != null && firstChild.isFunction())) {\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -2,7 +2,7 @@\n     Node firstChild = nameNode.getFirstChild();\n     if (// Check for a named FUNCTION.\n     isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n-    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n+    (firstChild != null && firstChild.isFunction())) {\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n         // If the function name is exported, we should create an edge here\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if (// Check for a named FUNCTION.\n        isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n                (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) {\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if ((compiler.getCodingConvention() != null && compiler.getCodingConvention().isExported(name)) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -1,13 +1,13 @@\n private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n     Node firstChild = nameNode.getFirstChild();\n     if (// Check for a named FUNCTION.\n-    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n-    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n+        isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n+                (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) {\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n         // If the function name is exported, we should create an edge here\n         // so that it's never removed.\n-        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n+        if ((compiler.getCodingConvention() != null && compiler.getCodingConvention().isExported(name)) || anchorUnusedVars) {\n             addGlobalUseOfSymbol(name, t.getModule(), VAR);\n         }\n         return true;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if (// Check for a named FUNCTION.\n    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n    (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Added brackets to ensure proper order of operations.\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -2,7 +2,7 @@\n     Node firstChild = nameNode.getFirstChild();\n     if (// Check for a named FUNCTION.\n     isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n-    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n+    (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Added brackets to ensure proper order of operations.\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n         // If the function name is exported, we should create an edge here\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if (// Check for a named FUNCTION.\n    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n    (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Added parentheses around condition\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -2,7 +2,7 @@\n     Node firstChild = nameNode.getFirstChild();\n     if (// Check for a named FUNCTION.\n     isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n-    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n+    (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Added parentheses around condition\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n         // If the function name is exported, we should create an edge here\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if (// Check for a named FUNCTION.\n    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n    (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) {\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -2,7 +2,7 @@\n     Node firstChild = nameNode.getFirstChild();\n     if (// Check for a named FUNCTION.\n     isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n-    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n+    (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) {\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n         // If the function name is exported, we should create an edge here\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if ((isGlobalFunctionDeclaration(t, parent) && firstChild == null) || (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) {\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -1,12 +1,8 @@\n private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n     Node firstChild = nameNode.getFirstChild();\n-    if (// Check for a named FUNCTION.\n-    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n-    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n+    if ((isGlobalFunctionDeclaration(t, parent) && firstChild == null) || (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) {\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n-        // If the function name is exported, we should create an edge here\n-        // so that it's never removed.\n         if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n             addGlobalUseOfSymbol(name, t.getModule(), VAR);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if ((firstChild != null && firstChild.isFunction()) || parent != null && parent.isFunction()) {\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -1,8 +1,6 @@\n private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n     Node firstChild = nameNode.getFirstChild();\n-    if (// Check for a named FUNCTION.\n-    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n-    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n+    if ((firstChild != null && firstChild.isFunction()) || parent != null && parent.isFunction()) {\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n         // If the function name is exported, we should create an edge here\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if ((firstChild != null && NodeUtil.isFunctionDeclaration(firstChild)) || // Check for a named FUNCTION.\n    (NodeUtil.isNameDeclaration(parent) && NodeUtil.isVar(parent.getFirstChild()))) { // Check for a VAR declaration.\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -1,8 +1,7 @@\n private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n     Node firstChild = nameNode.getFirstChild();\n-    if (// Check for a named FUNCTION.\n-    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n-    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n+    if ((firstChild != null && NodeUtil.isFunctionDeclaration(firstChild)) || // Check for a named FUNCTION.\n+    (NodeUtil.isNameDeclaration(parent) && NodeUtil.isVar(parent.getFirstChild()))) { // Check for a VAR declaration.\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n         // If the function name is exported, we should create an edge here\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if (// Check for a named FUNCTION.\n    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n    (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Add parentheses to avoid ambiguity\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -2,7 +2,7 @@\n     Node firstChild = nameNode.getFirstChild();\n     if (// Check for a named FUNCTION.\n     isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n-    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n+    (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Add parentheses to avoid ambiguity\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n         // If the function name is exported, we should create an edge here\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if (// Check for a named FUNCTION.\n    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n    (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Added parentheses to properly group the conditions\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -2,7 +2,7 @@\n     Node firstChild = nameNode.getFirstChild();\n     if (// Check for a named FUNCTION.\n     isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n-    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n+    (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Added parentheses to properly group the conditions\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n         // If the function name is exported, we should create an edge here\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if (// Check for a named FUNCTION.\n    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n    (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Add parenthesis for proper condition check\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -2,7 +2,7 @@\n     Node firstChild = nameNode.getFirstChild();\n     if (// Check for a named FUNCTION.\n     isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n-    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n+    (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Add parenthesis for proper condition check\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n         // If the function name is exported, we should create an edge here\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n    Node firstChild = nameNode.getFirstChild();\n    if (// Check for a named FUNCTION.\n        isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n        (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Added parentheses around condition\n        String name = nameNode.getString();\n        getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n        // If the function name is exported, we should create an edge here\n        // so that it's never removed.\n        if (compiler.getCodingConvention().isExported(name) || anchorUnusedVars) {\n            addGlobalUseOfSymbol(name, t.getModule(), VAR);\n        }\n        return true;\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n+++ com/google/javascript/jscomp/AnalyzePrototypeProperties.java@processGlobalFunctionDeclaration\n@@ -1,8 +1,8 @@\n private boolean processGlobalFunctionDeclaration(NodeTraversal t, Node nameNode, Node parent, Node gramps) {\n     Node firstChild = nameNode.getFirstChild();\n     if (// Check for a named FUNCTION.\n-    isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n-    firstChild != null && isGlobalFunctionDeclaration(t, firstChild)) {\n+        isGlobalFunctionDeclaration(t, parent) || // Check for a VAR declaration.\n+        (firstChild != null && isGlobalFunctionDeclaration(t, firstChild))) { // Added parentheses around condition\n         String name = nameNode.getString();\n         getNameInfoForName(name, VAR).getDeclarations().add(new GlobalFunction(nameNode, parent, gramps, t.getModule()));\n         // If the function name is exported, we should create an edge here\n", "finish_reason": "stop", "valid": false, "num": 1}]