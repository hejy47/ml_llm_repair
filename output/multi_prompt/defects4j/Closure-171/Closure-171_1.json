[{"output": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    SyntacticScope<?> syntacticScope = scope.getClosestSyntacticScope();\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -15,6 +15,7 @@\n     if (objectType.hasReferenceName() && !hasLendsName) {\n         return scope;\n     }\n+    SyntacticScope<?> syntacticScope = scope.getClosestSyntacticScope();\n     String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n         String memberName = NodeUtil.getObjectLitKeyName(name);\n@@ -31,7 +32,7 @@\n                 Var var = syntacticScope.getVar(qKeyName);\n                 JSType oldType = var == null ? null : var.getType();\n                 if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n+                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            name.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -31,12 +31,12 @@\n                 Var var = syntacticScope.getVar(qKeyName);\n                 JSType oldType = var == null ? null : var.getType();\n                 if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n+                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n         } else {\n-            n.setJSType(unknownType);\n+            name.setJSType(unknownType);\n         }\n     }\n     return scope;\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            scope = traverse(name.getFirstChild(), scope);\n        }\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -2,7 +2,10 @@\n     JSType type = n.getJSType();\n     Preconditions.checkNotNull(type);\n     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n-        scope = traverse(name.getFirstChild(), scope);\n+        String memberName = NodeUtil.getObjectLitKeyName(name);\n+        if (memberName != null) {\n+            scope = traverse(name.getFirstChild(), scope);\n+        }\n     }\n     // Object literals can be reflected on other types.\n     // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope, SyntacticScope syntacticScope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(\n            NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(\n                    name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName,\n                    valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()\n                        && oldType != null\n                        && !oldType.equals(valueType)) {\n                    var.setType(oldType.getLeastSupertype(valueType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName,\n                        oldType == null ? unknownType : oldType,\n                        valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType;\n            if (rawValueType == null) {\n                valueType = unknownType;\n            } else {\n                valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n                if (valueType == null) {\n                    valueType = unknownType;\n                }\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -20,9 +20,14 @@\n         String memberName = NodeUtil.getObjectLitKeyName(name);\n         if (memberName != null) {\n             JSType rawValueType = name.getFirstChild().getJSType();\n-            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n-            if (valueType == null) {\n+            JSType valueType;\n+            if (rawValueType == null) {\n                 valueType = unknownType;\n+            } else {\n+                valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n+                if (valueType == null) {\n+                    valueType = unknownType;\n+                }\n             }\n             objectType.defineInferredProperty(memberName, valueType, name);\n             // Do normal flow inference if this is a direct property assignment.\n@@ -31,7 +36,7 @@\n                 Var var = syntacticScope.getVar(qKeyName);\n                 JSType oldType = var == null ? null : var.getType();\n                 if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n+                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    SyntacticScope<?> syntacticScope = scope.getSyntacticScope();\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getLastChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -1,6 +1,7 @@\n private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n     JSType type = n.getJSType();\n     Preconditions.checkNotNull(type);\n+    SyntacticScope<?> syntacticScope = scope.getSyntacticScope();\n     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n         scope = traverse(name.getFirstChild(), scope);\n     }\n@@ -19,7 +20,7 @@\n     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n         String memberName = NodeUtil.getObjectLitKeyName(name);\n         if (memberName != null) {\n-            JSType rawValueType = name.getFirstChild().getJSType();\n+            JSType rawValueType = name.getLastChild().getJSType();\n             JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n             if (valueType == null) {\n                 valueType = unknownType;\n@@ -31,7 +32,7 @@\n                 Var var = syntacticScope.getVar(qKeyName);\n                 JSType oldType = var == null ? null : var.getType();\n                 if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n+                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = scope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -28,10 +28,10 @@\n             // Do normal flow inference if this is a direct property assignment.\n             if (qObjName != null && name.isStringKey()) {\n                 String qKeyName = qObjName + \".\" + memberName;\n-                Var var = syntacticScope.getVar(qKeyName);\n+                Var var = scope.getVar(qKeyName);\n                 JSType oldType = var == null ? null : var.getType();\n                 if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n+                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    SyntacticScope<?, ?> syntacticScope = getSyntacticScope();\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getLastChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -16,11 +16,12 @@\n         return scope;\n     }\n     String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n+    SyntacticScope<?, ?> syntacticScope = getSyntacticScope();\n     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n         String memberName = NodeUtil.getObjectLitKeyName(name);\n         if (memberName != null) {\n-            JSType rawValueType = name.getFirstChild().getJSType();\n-            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n+            JSType rawValueType = name.getLastChild().getJSType();\n+            JSType valueType = NodeUtil.getObjectLitValueType(name, rawValueType);\n             if (valueType == null) {\n                 valueType = unknownType;\n             }\n@@ -31,7 +32,7 @@\n                 Var var = syntacticScope.getVar(qKeyName);\n                 JSType oldType = var == null ? null : var.getType();\n                 if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n+                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            ObjectType objectType = ObjectType.cast(type);\n            Preconditions.checkNotNull(objectType);\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -1,8 +1,31 @@\n private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n     JSType type = n.getJSType();\n     Preconditions.checkNotNull(type);\n+    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n-        scope = traverse(name.getFirstChild(), scope);\n+        String memberName = NodeUtil.getObjectLitKeyName(name);\n+        if (memberName != null) {\n+            JSType rawValueType = name.getFirstChild().getJSType();\n+            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n+            if (valueType == null) {\n+                valueType = unknownType;\n+            }\n+            ObjectType objectType = ObjectType.cast(type);\n+            Preconditions.checkNotNull(objectType);\n+            objectType.defineInferredProperty(memberName, valueType, name);\n+            // Do normal flow inference if this is a direct property assignment.\n+            if (qObjName != null && name.isStringKey()) {\n+                String qKeyName = qObjName + \".\" + memberName;\n+                Var var = syntacticScope.getVar(qKeyName);\n+                JSType oldType = var == null ? null : var.getType();\n+                if (var != null && var.isTypeInferred()) {\n+                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n+                }\n+                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n+            }\n+        } else {\n+            n.setJSType(unknownType);\n+        }\n     }\n     // Object literals can be reflected on other types.\n     // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n@@ -15,29 +38,5 @@\n     if (objectType.hasReferenceName() && !hasLendsName) {\n         return scope;\n     }\n-    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n-    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n-        String memberName = NodeUtil.getObjectLitKeyName(name);\n-        if (memberName != null) {\n-            JSType rawValueType = name.getFirstChild().getJSType();\n-            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n-            if (valueType == null) {\n-                valueType = unknownType;\n-            }\n-            objectType.defineInferredProperty(memberName, valueType, name);\n-            // Do normal flow inference if this is a direct property assignment.\n-            if (qObjName != null && name.isStringKey()) {\n-                String qKeyName = qObjName + \".\" + memberName;\n-                Var var = syntacticScope.getVar(qKeyName);\n-                JSType oldType = var == null ? null : var.getType();\n-                if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n-                }\n-                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n-            }\n-        } else {\n-            n.setJSType(unknownType);\n-        }\n-    }\n     return scope;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    SyntacticScope<?> syntacticScope = getSyntacticScope();\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -15,6 +15,7 @@\n     if (objectType.hasReferenceName() && !hasLendsName) {\n         return scope;\n     }\n+    SyntacticScope<?> syntacticScope = getSyntacticScope();\n     String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n     for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n         String memberName = NodeUtil.getObjectLitKeyName(name);\n@@ -31,7 +32,7 @@\n                 Var var = syntacticScope.getVar(qKeyName);\n                 JSType oldType = var == null ? null : var.getType();\n                 if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n+                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                Var var = syntacticScope.getVar(qObjName);\n                if (var != null) {\n                    JSType oldType = var.getType();\n                    if (var.isTypeInferred()) {\n                        var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                    }\n                    String qKeyName = qObjName + \".\" + memberName;\n                    JSType slotType = oldType == null ? unknownType : oldType.getPropertyType(memberName);\n                    scope.inferSlotType(qKeyName, slotType == null ? valueType : slotType);\n                }\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -27,13 +27,16 @@\n             objectType.defineInferredProperty(memberName, valueType, name);\n             // Do normal flow inference if this is a direct property assignment.\n             if (qObjName != null && name.isStringKey()) {\n-                String qKeyName = qObjName + \".\" + memberName;\n-                Var var = syntacticScope.getVar(qKeyName);\n-                JSType oldType = var == null ? null : var.getType();\n-                if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n+                Var var = syntacticScope.getVar(qObjName);\n+                if (var != null) {\n+                    JSType oldType = var.getType();\n+                    if (var.isTypeInferred()) {\n+                        var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n+                    }\n+                    String qKeyName = qObjName + \".\" + memberName;\n+                    JSType slotType = oldType == null ? unknownType : oldType.getPropertyType(memberName);\n+                    scope.inferSlotType(qKeyName, slotType == null ? valueType : slotType);\n                 }\n-                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n         } else {\n             n.setJSType(unknownType);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType((oldType == null || oldType.equals(unknownType)) ? valueType : oldType.getLeastSupertype(valueType));\n                } else {\n                    syntacticScope.declare(qKeyName, name, valueType, false);\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -31,7 +31,9 @@\n                 Var var = syntacticScope.getVar(qKeyName);\n                 JSType oldType = var == null ? null : var.getType();\n                 if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n+                    var.setType((oldType == null || oldType.equals(unknownType)) ? valueType : oldType.getLeastSupertype(valueType));\n+                } else {\n+                    syntacticScope.declare(qKeyName, name, valueType, false);\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    JSType newType = oldType == null ? valueType : oldType.getLeastSupertype(valueType);\n                    // Inferred types should not be narrowed.\n                    if (newType.isUnknownType()) {\n                      var.setType(valueType);\n                    } else {\n                      var.setType(newType);\n                    }\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            name.getFirstChild().setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -31,12 +31,18 @@\n                 Var var = syntacticScope.getVar(qKeyName);\n                 JSType oldType = var == null ? null : var.getType();\n                 if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n+                    JSType newType = oldType == null ? valueType : oldType.getLeastSupertype(valueType);\n+                    // Inferred types should not be narrowed.\n+                    if (newType.isUnknownType()) {\n+                      var.setType(valueType);\n+                    } else {\n+                      var.setType(newType);\n+                    }\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n         } else {\n-            n.setJSType(unknownType);\n+            name.getFirstChild().setJSType(unknownType);\n         }\n     }\n     return scope;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                } // fixed by adding else condition to update existing var type with the LUB if it is not inferred.\n                else if(var != null){\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -31,7 +31,10 @@\n                 Var var = syntacticScope.getVar(qKeyName);\n                 JSType oldType = var == null ? null : var.getType();\n                 if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n+                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n+                } // fixed by adding else condition to update existing var type with the LUB if it is not inferred.\n+                else if(var != null){\n+                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType.hasReferenceName() && !hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            // Use defineDeclaredProperty instead of defineInferredProperty\n            objectType.defineDeclaredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -24,7 +24,8 @@\n             if (valueType == null) {\n                 valueType = unknownType;\n             }\n-            objectType.defineInferredProperty(memberName, valueType, name);\n+            // Use defineDeclaredProperty instead of defineInferredProperty\n+            objectType.defineDeclaredProperty(memberName, valueType, name);\n             // Do normal flow inference if this is a direct property assignment.\n             if (qObjName != null && name.isStringKey()) {\n                 String qKeyName = qObjName + \".\" + memberName;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    if (objectType == null) {\n        return scope;\n    }\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (!objectType.hasReferenceName() || hasLendsName) {\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -12,7 +12,7 @@\n         return scope;\n     }\n     boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n-    if (objectType.hasReferenceName() && !hasLendsName) {\n+    if (!objectType.hasReferenceName() || hasLendsName) {\n         return scope;\n     }\n     String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n@@ -31,7 +31,7 @@\n                 Var var = syntacticScope.getVar(qKeyName);\n                 JSType oldType = var == null ? null : var.getType();\n                 if (var != null && var.isTypeInferred()) {\n-                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n+                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(valueType));\n                 }\n                 scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FlowScope traverseObjectLiteral(Node n, FlowScope scope) {\n    JSType type = n.getJSType();\n    Preconditions.checkNotNull(type);\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        scope = traverse(name.getFirstChild(), scope);\n    }\n    // Object literals can be reflected on other types.\n    // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n    // Ignore these types of literals.\n    ObjectType objectType = ObjectType.cast(type);\n    boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n    if (objectType == null || objectType.isEnumType() || hasLendsName) {\n        // Fixed to include the case where objectType is an enum type or has a lends name.\n        return scope;\n    }\n    String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n    for (Node name = n.getFirstChild(); name != null; name = name.getNext()) {\n        String memberName = NodeUtil.getObjectLitKeyName(name);\n        if (memberName != null) {\n            JSType rawValueType = name.getFirstChild().getJSType();\n            JSType valueType = NodeUtil.getObjectLitKeyTypeFromValueType(name, rawValueType);\n            if (valueType == null) {\n                valueType = unknownType;\n            }\n            objectType.defineInferredProperty(memberName, valueType, name);\n            // Do normal flow inference if this is a direct property assignment.\n            if (qObjName != null && name.isStringKey()) {\n                String qKeyName = qObjName + \".\" + memberName;\n                Var var = syntacticScope.getVar(qKeyName);\n                JSType oldType = var == null ? null : var.getType();\n                if (var != null && var.isTypeInferred()) {\n                    var.setType(oldType == null ? valueType : oldType.getLeastSupertype(oldType));\n                }\n                scope.inferQualifiedSlot(name, qKeyName, oldType == null ? unknownType : oldType, valueType);\n            }\n        } else {\n            n.setJSType(unknownType);\n        }\n    }\n    return scope;\n}", "diff": "--- com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n+++ com/google/javascript/jscomp/TypeInference.java@traverseObjectLiteral\n@@ -8,11 +8,9 @@\n     // See CodingConvention#getObjectLiteralCase and goog.object.reflect.\n     // Ignore these types of literals.\n     ObjectType objectType = ObjectType.cast(type);\n-    if (objectType == null) {\n-        return scope;\n-    }\n     boolean hasLendsName = n.getJSDocInfo() != null && n.getJSDocInfo().getLendsName() != null;\n-    if (objectType.hasReferenceName() && !hasLendsName) {\n+    if (objectType == null || objectType.isEnumType() || hasLendsName) {\n+        // Fixed to include the case where objectType is an enum type or has a lends name.\n         return scope;\n     }\n     String qObjName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(n));\n", "finish_reason": "stop", "valid": false, "num": 1}]