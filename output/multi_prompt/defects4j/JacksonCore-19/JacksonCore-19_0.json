[{"output": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen, _textBuffer.getCurrentSegment());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -106,5 +106,5 @@\n     }\n     _textBuffer.setCurrentLength(outPtr);\n     // And there we have it!\n-    return reset(neg, intLen, fractLen, expLen);\n+    return reset(neg, intLen, fractLen, expLen, _textBuffer.getCurrentSegment());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                eof = true;\n                break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        } else {\n            c = _inputBuffer[_inputPtr++];\n        }\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    eof = true;\n                    break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            } else {\n                c = _inputBuffer[_inputPtr++];\n            }\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                reportUnexpectedNumberChar(c, \"expected a digit for number exponent\");\n            }\n            c = _inputBuffer[_inputPtr++];\n        } else {\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    reportUnexpectedNumberChar(c, \"expected a digit for number exponent\");\n                }\n                c = _inputBuffer[_inputPtr++];\n            } else {\n                c = _inputBuffer[_inputPtr++];\n            }\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            } else {\n                c = _inputBuffer[_inputPtr++];\n            }\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -21,13 +21,15 @@\n             outPtr = 0;\n         }\n         outBuf[outPtr++] = c;\n-        if (_inputPtr >= _inputEnd && !loadMore()) {\n-            // EOF is legal for main level int values\n-            c = CHAR_NULL;\n-            eof = true;\n-            break int_loop;\n+        if (_inputPtr >= _inputEnd) {\n+            if (!loadMore()) {\n+                eof = true;\n+                break int_loop;\n+            }\n+            c = _inputBuffer[_inputPtr++];\n+        } else {\n+            c = _inputBuffer[_inputPtr++];\n         }\n-        c = _inputBuffer[_inputPtr++];\n     }\n     // Also, integer part is not optional\n     if (intLen == 0) {\n@@ -39,11 +41,15 @@\n         // yes, fraction\n         outBuf[outPtr++] = c;\n         fract_loop: while (true) {\n-            if (_inputPtr >= _inputEnd && !loadMore()) {\n-                eof = true;\n-                break fract_loop;\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    eof = true;\n+                    break fract_loop;\n+                }\n+                c = _inputBuffer[_inputPtr++];\n+            } else {\n+                c = _inputBuffer[_inputPtr++];\n             }\n-            c = _inputBuffer[_inputPtr++];\n             if (c < INT_0 || c > INT_9) {\n                 break fract_loop;\n             }\n@@ -68,7 +74,14 @@\n         }\n         outBuf[outPtr++] = c;\n         // Not optional, can require that we get one more char\n-        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n+        if (_inputPtr >= _inputEnd) {\n+            if (!loadMore()) {\n+                reportUnexpectedNumberChar(c, \"expected a digit for number exponent\");\n+            }\n+            c = _inputBuffer[_inputPtr++];\n+        } else {\n+            c = _inputBuffer[_inputPtr++];\n+        }\n         // Sign indicator?\n         if (c == '-' || c == '+') {\n             if (outPtr >= outBuf.length) {\n@@ -77,7 +90,14 @@\n             }\n             outBuf[outPtr++] = c;\n             // Likewise, non optional:\n-            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    reportUnexpectedNumberChar(c, \"expected a digit for number exponent\");\n+                }\n+                c = _inputBuffer[_inputPtr++];\n+            } else {\n+                c = _inputBuffer[_inputPtr++];\n+            }\n         }\n         exp_loop: while (c <= INT_9 && c >= INT_0) {\n             ++expLen;\n@@ -86,11 +106,15 @@\n                 outPtr = 0;\n             }\n             outBuf[outPtr++] = c;\n-            if (_inputPtr >= _inputEnd && !loadMore()) {\n-                eof = true;\n-                break exp_loop;\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    eof = true;\n+                    break exp_loop;\n+                }\n+                c = _inputBuffer[_inputPtr++];\n+            } else {\n+                c = _inputBuffer[_inputPtr++];\n             }\n-            c = _inputBuffer[_inputPtr++];\n         }\n         // must be followed by sequence of ints, one minimum\n         if (expLen == 0) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n            throw _constructError(\"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n            throw _constructError(\"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -57,6 +57,7 @@\n         // must be followed by sequence of ints, one minimum\n         if (fractLen == 0) {\n             reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n+            throw _constructError(\"Decimal point not followed by a digit\");\n         }\n     }\n     int expLen = 0;\n@@ -95,6 +96,7 @@\n         // must be followed by sequence of ints, one minimum\n         if (expLen == 0) {\n             reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n+            throw _constructError(\"Exponent indicator not followed by a digit\");\n         }\n     }\n     // Ok; unless we hit end-of-input, need to push last char read back\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n        if (c == CHAR_NULL) {\n            return resetInt(true, intLen);\n        }\n    } else if (c < '1' || c > '9') {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    intLoop:\n    while (true) {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            c = CHAR_NULL;\n            break intLoop;\n        }\n        c = _inputBuffer[_inputPtr++];\n        if (c < '0' || c > '9') {\n            break intLoop;\n        }\n    }\n    int fractLen = 0;\n    if (c == '.') {\n        outBuf[outPtr++] = c;\n        fractLoop:\n        while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                break;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < '0' || c > '9') {\n                break fractLoop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        while (c >= '0' && c <= '9') {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                break;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    if (c != CHAR_NULL) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -11,10 +11,14 @@\n     char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n     if (c == '0') {\n         c = _verifyNoLeadingZeroes();\n+        if (c == CHAR_NULL) {\n+            return resetInt(true, intLen);\n+        }\n+    } else if (c < '1' || c > '9') {\n+        return _handleInvalidNumberStart(c, neg);\n     }\n-    boolean eof = false;\n-    // Ok, first the obligatory integer part:\n-    int_loop: while (c >= '0' && c <= '9') {\n+    intLoop:\n+    while (true) {\n         ++intLen;\n         if (outPtr >= outBuf.length) {\n             outBuf = _textBuffer.finishCurrentSegment();\n@@ -22,30 +26,25 @@\n         }\n         outBuf[outPtr++] = c;\n         if (_inputPtr >= _inputEnd && !loadMore()) {\n-            // EOF is legal for main level int values\n             c = CHAR_NULL;\n-            eof = true;\n-            break int_loop;\n+            break intLoop;\n         }\n         c = _inputBuffer[_inputPtr++];\n-    }\n-    // Also, integer part is not optional\n-    if (intLen == 0) {\n-        return _handleInvalidNumberStart(c, neg);\n+        if (c < '0' || c > '9') {\n+            break intLoop;\n+        }\n     }\n     int fractLen = 0;\n-    // And then see if we get other parts\n     if (c == '.') {\n-        // yes, fraction\n         outBuf[outPtr++] = c;\n-        fract_loop: while (true) {\n+        fractLoop:\n+        while (true) {\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n-                eof = true;\n-                break fract_loop;\n+                break;\n             }\n             c = _inputBuffer[_inputPtr++];\n-            if (c < INT_0 || c > INT_9) {\n-                break fract_loop;\n+            if (c < '0' || c > '9') {\n+                break fractLoop;\n             }\n             ++fractLen;\n             if (outPtr >= outBuf.length) {\n@@ -54,32 +53,27 @@\n             }\n             outBuf[outPtr++] = c;\n         }\n-        // must be followed by sequence of ints, one minimum\n         if (fractLen == 0) {\n             reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n         }\n     }\n     int expLen = 0;\n     if (c == 'e' || c == 'E') {\n-        // exponent?\n         if (outPtr >= outBuf.length) {\n             outBuf = _textBuffer.finishCurrentSegment();\n             outPtr = 0;\n         }\n         outBuf[outPtr++] = c;\n-        // Not optional, can require that we get one more char\n         c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n-        // Sign indicator?\n         if (c == '-' || c == '+') {\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n                 outPtr = 0;\n             }\n             outBuf[outPtr++] = c;\n-            // Likewise, non optional:\n             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        while (c >= '0' && c <= '9') {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n@@ -87,18 +81,15 @@\n             }\n             outBuf[outPtr++] = c;\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n-                eof = true;\n-                break exp_loop;\n+                break;\n             }\n             c = _inputBuffer[_inputPtr++];\n         }\n-        // must be followed by sequence of ints, one minimum\n         if (expLen == 0) {\n             reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n         }\n     }\n-    // Ok; unless we hit end-of-input, need to push last char read back\n-    if (!eof) {\n+    if (c != CHAR_NULL) {\n         --_inputPtr;\n         if (_parsingContext.inRoot()) {\n             _verifyRootSpace(c);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n              // EOF is legal for main level int values\n              break int_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        } else {\n            c = _inputBuffer[_inputPtr++];\n        }\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                  eof = true;\n                  break fract_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            } else {\n                c = _inputBuffer[_inputPtr++];\n            }\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n              reportUnexpectedNumberChar(c, \"expected a digit for number exponent\");\n            }\n            c = _inputBuffer[_inputPtr++];\n        } else {\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                  reportUnexpectedNumberChar(c, \"expected a digit for number exponent\");\n                }\n                c = _inputBuffer[_inputPtr++];\n            } else {\n                c = _inputBuffer[_inputPtr++];\n            }\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                  eof = true;\n                  break exp_loop;\n                }\n                c = _inputBuffer[_inputPtr++];\n            } else {\n                c = _inputBuffer[_inputPtr++];\n            }\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -21,13 +21,15 @@\n             outPtr = 0;\n         }\n         outBuf[outPtr++] = c;\n-        if (_inputPtr >= _inputEnd && !loadMore()) {\n-            // EOF is legal for main level int values\n-            c = CHAR_NULL;\n-            eof = true;\n-            break int_loop;\n+        if (_inputPtr >= _inputEnd) {\n+            if (!loadMore()) {\n+              // EOF is legal for main level int values\n+              break int_loop;\n+            }\n+            c = _inputBuffer[_inputPtr++];\n+        } else {\n+            c = _inputBuffer[_inputPtr++];\n         }\n-        c = _inputBuffer[_inputPtr++];\n     }\n     // Also, integer part is not optional\n     if (intLen == 0) {\n@@ -39,11 +41,15 @@\n         // yes, fraction\n         outBuf[outPtr++] = c;\n         fract_loop: while (true) {\n-            if (_inputPtr >= _inputEnd && !loadMore()) {\n-                eof = true;\n-                break fract_loop;\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                  eof = true;\n+                  break fract_loop;\n+                }\n+                c = _inputBuffer[_inputPtr++];\n+            } else {\n+                c = _inputBuffer[_inputPtr++];\n             }\n-            c = _inputBuffer[_inputPtr++];\n             if (c < INT_0 || c > INT_9) {\n                 break fract_loop;\n             }\n@@ -68,7 +74,14 @@\n         }\n         outBuf[outPtr++] = c;\n         // Not optional, can require that we get one more char\n-        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n+        if (_inputPtr >= _inputEnd) {\n+            if (!loadMore()) {\n+              reportUnexpectedNumberChar(c, \"expected a digit for number exponent\");\n+            }\n+            c = _inputBuffer[_inputPtr++];\n+        } else {\n+            c = _inputBuffer[_inputPtr++];\n+        }\n         // Sign indicator?\n         if (c == '-' || c == '+') {\n             if (outPtr >= outBuf.length) {\n@@ -77,7 +90,14 @@\n             }\n             outBuf[outPtr++] = c;\n             // Likewise, non optional:\n-            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                  reportUnexpectedNumberChar(c, \"expected a digit for number exponent\");\n+                }\n+                c = _inputBuffer[_inputPtr++];\n+            } else {\n+                c = _inputBuffer[_inputPtr++];\n+            }\n         }\n         exp_loop: while (c <= INT_9 && c >= INT_0) {\n             ++expLen;\n@@ -86,11 +106,15 @@\n                 outPtr = 0;\n             }\n             outBuf[outPtr++] = c;\n-            if (_inputPtr >= _inputEnd && !loadMore()) {\n-                eof = true;\n-                break exp_loop;\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                  eof = true;\n+                  break exp_loop;\n+                }\n+                c = _inputBuffer[_inputPtr++];\n+            } else {\n+                c = _inputBuffer[_inputPtr++];\n             }\n-            c = _inputBuffer[_inputPtr++];\n         }\n         // must be followed by sequence of ints, one minimum\n         if (expLen == 0) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < '0' || c > '9') { // fixed: used '0' and '9' instead of INT_0 and INT_9\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= '9' && c >= '0') { // fixed: used '0' and '9' instead of INT_0 and INT_9\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -44,7 +44,7 @@\n                 break fract_loop;\n             }\n             c = _inputBuffer[_inputPtr++];\n-            if (c < INT_0 || c > INT_9) {\n+            if (c < '0' || c > '9') { // fixed: used '0' and '9' instead of INT_0 and INT_9\n                 break fract_loop;\n             }\n             ++fractLen;\n@@ -79,7 +79,7 @@\n             // Likewise, non optional:\n             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c <= '9' && c >= '0') { // fixed: used '0' and '9' instead of INT_0 and INT_9\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < '0' || c > '9') { // Fixed\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= '9' && c >= '0') { // Fixed\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -44,7 +44,7 @@\n                 break fract_loop;\n             }\n             c = _inputBuffer[_inputPtr++];\n-            if (c < INT_0 || c > INT_9) {\n+            if (c < '0' || c > '9') { // Fixed\n                 break fract_loop;\n             }\n             ++fractLen;\n@@ -79,7 +79,7 @@\n             // Likewise, non optional:\n             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c <= '9' && c >= '0') { // Fixed\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        int expIntLen = 0;\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expIntLen;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expIntLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n        expLen += expIntLen;\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -79,13 +79,9 @@\n             // Likewise, non optional:\n             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n         }\n+        int expIntLen = 0;\n         exp_loop: while (c <= INT_9 && c >= INT_0) {\n-            ++expLen;\n-            if (outPtr >= outBuf.length) {\n-                outBuf = _textBuffer.finishCurrentSegment();\n-                outPtr = 0;\n-            }\n-            outBuf[outPtr++] = c;\n+            ++expIntLen;\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n                 eof = true;\n                 break exp_loop;\n@@ -93,9 +89,10 @@\n             c = _inputBuffer[_inputPtr++];\n         }\n         // must be followed by sequence of ints, one minimum\n-        if (expLen == 0) {\n+        if (expIntLen == 0) {\n             reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n         }\n+        expLen += expIntLen;\n     }\n     // Ok; unless we hit end-of-input, need to push last char read back\n     if (!eof) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = _inputBuffer[_inputPtr++];\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -62,13 +62,16 @@\n     int expLen = 0;\n     if (c == 'e' || c == 'E') {\n         // exponent?\n+        if (_inputPtr >= _inputEnd) {\n+            loadMoreGuaranteed();\n+        }\n         if (outPtr >= outBuf.length) {\n             outBuf = _textBuffer.finishCurrentSegment();\n             outPtr = 0;\n         }\n         outBuf[outPtr++] = c;\n         // Not optional, can require that we get one more char\n-        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n+        c = _inputBuffer[_inputPtr++];\n         // Sign indicator?\n         if (c == '-' || c == '+') {\n             if (outPtr >= outBuf.length) {\n@@ -77,7 +80,10 @@\n             }\n             outBuf[outPtr++] = c;\n             // Likewise, non optional:\n-            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n+            if (_inputPtr >= _inputEnd) {\n+                loadMoreGuaranteed();\n+            }\n+            c = _inputBuffer[_inputPtr++];\n         }\n         exp_loop: while (c <= INT_9 && c >= INT_0) {\n             ++expLen;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while ('0' <= c && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < '0' || c > '9') {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while ('0' <= c && c <= '9') {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -14,7 +14,7 @@\n     }\n     boolean eof = false;\n     // Ok, first the obligatory integer part:\n-    int_loop: while (c >= '0' && c <= '9') {\n+    int_loop: while ('0' <= c && c <= '9') {\n         ++intLen;\n         if (outPtr >= outBuf.length) {\n             outBuf = _textBuffer.finishCurrentSegment();\n@@ -23,7 +23,6 @@\n         outBuf[outPtr++] = c;\n         if (_inputPtr >= _inputEnd && !loadMore()) {\n             // EOF is legal for main level int values\n-            c = CHAR_NULL;\n             eof = true;\n             break int_loop;\n         }\n@@ -44,7 +43,7 @@\n                 break fract_loop;\n             }\n             c = _inputBuffer[_inputPtr++];\n-            if (c < INT_0 || c > INT_9) {\n+            if (c < '0' || c > '9') {\n                 break fract_loop;\n             }\n             ++fractLen;\n@@ -79,7 +78,7 @@\n             // Likewise, non optional:\n             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while ('0' <= c && c <= '9') {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] >= '0' && _inputBuffer[_inputPtr] <= '9') {\n            reportInvalidNumber(\"Numbers cannot have leading zeroes\");\n        }\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -10,7 +10,9 @@\n     int intLen = 0;\n     char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n     if (c == '0') {\n-        c = _verifyNoLeadingZeroes();\n+        if (_inputPtr < _inputEnd && _inputBuffer[_inputPtr] >= '0' && _inputBuffer[_inputPtr] <= '9') {\n+            reportInvalidNumber(\"Numbers cannot have leading zeroes\");\n+        }\n     }\n     boolean eof = false;\n     // Ok, first the obligatory integer part:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < '0' || c > '9') {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= '9' && c >= '0') {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);     \n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -44,7 +44,7 @@\n                 break fract_loop;\n             }\n             c = _inputBuffer[_inputPtr++];\n-            if (c < INT_0 || c > INT_9) {\n+            if (c < '0' || c > '9') {\n                 break fract_loop;\n             }\n             ++fractLen;\n@@ -79,7 +79,7 @@\n             // Likewise, non optional:\n             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c <= '9' && c >= '0') {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n@@ -106,5 +106,5 @@\n     }\n     _textBuffer.setCurrentLength(outPtr);\n     // And there we have it!\n-    return reset(neg, intLen, fractLen, expLen);\n+    return reset(neg, intLen, fractLen, expLen);     \n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c >= INT_0 && c <= INT_9) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -79,7 +79,7 @@\n             // Likewise, non optional:\n             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c >= INT_0 && c <= INT_9) {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = getNextChar(\"No digit found\");\n    // Modified condition so that 'c' is actually checked.\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -8,7 +8,8 @@\n     }\n     // This is the place to do leading-zero check(s) too:\n     int intLen = 0;\n-    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n+    char c = getNextChar(\"No digit found\");\n+    // Modified condition so that 'c' is actually checked.\n     if (c == '0') {\n         c = _verifyNoLeadingZeroes();\n     }\n@@ -68,7 +69,7 @@\n         }\n         outBuf[outPtr++] = c;\n         // Not optional, can require that we get one more char\n-        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n+        c = getNextChar(\"expected a digit for number exponent\");\n         // Sign indicator?\n         if (c == '-' || c == '+') {\n             if (outPtr >= outBuf.length) {\n@@ -77,7 +78,7 @@\n             }\n             outBuf[outPtr++] = c;\n             // Likewise, non optional:\n-            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n+            c = getNextChar(\"expected a digit for number exponent\");\n         }\n         exp_loop: while (c <= INT_9 && c >= INT_0) {\n             ++expLen;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < '0' || c > '9') {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c >= '0' && c <= '9') {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -44,7 +44,7 @@\n                 break fract_loop;\n             }\n             c = _inputBuffer[_inputPtr++];\n-            if (c < INT_0 || c > INT_9) {\n+            if (c < '0' || c > '9') {\n                 break fract_loop;\n             }\n             ++fractLen;\n@@ -79,7 +79,7 @@\n             // Likewise, non optional:\n             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c >= '0' && c <= '9') {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n        if (c == '.' || c == 'e' || c == 'E') {\n            return _handleInvalidNumberStart(c, neg);\n        }\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -11,6 +11,9 @@\n     char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n     if (c == '0') {\n         c = _verifyNoLeadingZeroes();\n+        if (c == '.' || c == 'e' || c == 'E') {\n+            return _handleInvalidNumberStart(c, neg);\n+        }\n     }\n     boolean eof = false;\n     // Ok, first the obligatory integer part:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException {\n    _inputPtr = neg ? (startPtr + 1) : startPtr;\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (neg) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        return _handleInvalidNumberStart(c, neg);\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        if (_parsingContext.inRoot()) {\n            _verifyRootSpace(c);\n        }\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(neg, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -79,7 +79,7 @@\n             // Likewise, non optional:\n             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        while (c <= INT_9 && c >= INT_0) {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n@@ -88,7 +88,7 @@\n             outBuf[outPtr++] = c;\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n                 eof = true;\n-                break exp_loop;\n+                break;\n             }\n             c = _inputBuffer[_inputPtr++];\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}]