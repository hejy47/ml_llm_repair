[{"output": "import static java.lang.Math.exp;\n\npublic static double cosh(double x) {\n    if (Double.isNaN(x)) {\n        return Double.NaN;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    if (x > 20) {\n        double expX = exp(x);\n        return (expX / 2) + (0.5 / expX);\n    }\n    if (x == 0.0) {\n        return 1.0;\n    }\n    if (x < 0.0) {\n        x = -x;\n    }\n    double expX = exp(x);\n    return (expX + (1.0 / expX)) / 2.0;\n}", "diff": "--- org/apache/commons/math3/util/FastMath.java@cosh\n+++ org/apache/commons/math3/util/FastMath.java@cosh\n@@ -1,45 +1,18 @@\n public static double cosh(double x) {\n-    if (x != x) {\n-        return x;\n+    if (Double.isNaN(x)) {\n+        return Double.NaN;\n     }\n     // cosh[z] = (exp(z) + exp(-z))/2\n-    // for numbers with magnitude 20 or so,\n-    // exp(-z) can be ignored in comparison with exp(z)\n     if (x > 20) {\n-        // Avoid overflow (MATH-905).\n-        return 0.5 * exp(x);\n+        double expX = exp(x);\n+        return (expX / 2) + (0.5 / expX);\n     }\n-    if (x < -20) {\n-        // Avoid overflow (MATH-905).\n-        return 0.5 * exp(-x);\n+    if (x == 0.0) {\n+        return 1.0;\n     }\n-    final double[] hiPrec = new double[2];\n     if (x < 0.0) {\n         x = -x;\n     }\n-    exp(x, 0.0, hiPrec);\n-    double ya = hiPrec[0] + hiPrec[1];\n-    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n-    double temp = ya * HEX_40000000;\n-    double yaa = ya + temp - temp;\n-    double yab = ya - yaa;\n-    // recip = 1/y\n-    double recip = 1.0 / ya;\n-    temp = recip * HEX_40000000;\n-    double recipa = recip + temp - temp;\n-    double recipb = recip - recipa;\n-    // Correct for rounding in division\n-    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n-    // Account for yb\n-    recipb += -yb * recip * recip;\n-    // y = y + 1/y\n-    temp = ya + recipa;\n-    yb += -(temp - ya - recipa);\n-    ya = temp;\n-    temp = ya + recipb;\n-    yb += -(temp - ya - recipb);\n-    ya = temp;\n-    double result = ya + yb;\n-    result *= 0.5;\n-    return result;\n+    double expX = exp(x);\n+    return (expX + (1.0 / expX)) / 2.0;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "import static java.lang.Math.*;\n\npublic static double cosh(double x) {\n    if (Double.isNaN(x)) {\n        return x;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        // Avoid overflow (MATH-905).\n        double tempExp = exp(x);\n        return 0.5 * tempExp;\n    }\n    if (x < -20) {\n        // Avoid overflow (MATH-905).\n        double tempExp = exp(-x);\n        return 0.5 * tempExp;\n    }\n    final double[] hiPrec = new double[2];\n    if (x < 0.0) {\n        x = -x;\n    }\n    exp(x, 0.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double temp = ya * HEX_40000000;\n    double yaa = ya + temp - temp;\n    double yab = ya - yaa;\n    // recip = 1/y\n    double recip = 1.0 / ya;\n    temp = recip * HEX_40000000;\n    double recipa = recip + temp - temp;\n    double recipb = recip - recipa;\n    // Correct for rounding in division\n    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n    // Account for yb\n    recipb += -yb * recip * recip;\n    // y = y + 1/y\n    temp = ya + recipa;\n    yb += -(temp - ya - recipa);\n    ya = temp;\n    temp = ya + recipb;\n    yb += -(temp - ya - recipb);\n    ya = temp;\n    double result = ya + yb;\n    result *= 0.5;\n    return result;\n}", "diff": "--- org/apache/commons/math3/util/FastMath.java@cosh\n+++ org/apache/commons/math3/util/FastMath.java@cosh\n@@ -1,5 +1,5 @@\n public static double cosh(double x) {\n-    if (x != x) {\n+    if (Double.isNaN(x)) {\n         return x;\n     }\n     // cosh[z] = (exp(z) + exp(-z))/2\n@@ -7,11 +7,13 @@\n     // exp(-z) can be ignored in comparison with exp(z)\n     if (x > 20) {\n         // Avoid overflow (MATH-905).\n-        return 0.5 * exp(x);\n+        double tempExp = exp(x);\n+        return 0.5 * tempExp;\n     }\n     if (x < -20) {\n         // Avoid overflow (MATH-905).\n-        return 0.5 * exp(-x);\n+        double tempExp = exp(-x);\n+        return 0.5 * tempExp;\n     }\n     final double[] hiPrec = new double[2];\n     if (x < 0.0) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "import static java.lang.Math.*;\n\npublic static double cosh(double x) {\n    if (x != x) {\n        return x;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * exp(x);\n    }\n    if (x < -20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * exp(-x);\n    }\n    final double[] hiPrec = new double[2];\n    if (x < 0.0) {\n        x = -x;\n    }\n    exp(x, 0.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double temp = ya * HEX_40000000;\n    double yaa = ya + temp - temp;\n    double yab = ya - yaa;\n    // recip = 1/y\n    double recip = 1.0 / ya;\n    temp = recip * HEX_40000000;\n    double recipa = recip + temp - temp;\n    double recipb = recip - recipa;\n    // Account for rounding in division\n    temp = ya*recipa;\n    double r1 = ya - temp;\n    double r2 = yb*recip;\n    r2 -= temp*r2;\n    r2 -= yab*recipa;\n    temp = r1 + r2;\n    r2 = -(temp - r1 - r2);\n    r1 = temp;\n    // Correct for rounding in division\n    recipb += (1.0 - yaa * recipa - r1 - yab * recipa - r2) * recip;\n    // Account for yb\n    recipb += -yb * recip * recip + 2.0 * yb * recipb;\n    // y = y + 1/y\n    temp = ya + recipa;\n    yb += -(temp - ya - recipa);\n    ya = temp;\n    temp = ya + recipb;\n    yb += -(temp - ya - recipb);\n    ya = temp;\n    double result = ya + yb;\n    result *= 0.5;\n    return result;\n}", "diff": "--- org/apache/commons/math3/util/FastMath.java@cosh\n+++ org/apache/commons/math3/util/FastMath.java@cosh\n@@ -28,10 +28,19 @@\n     temp = recip * HEX_40000000;\n     double recipa = recip + temp - temp;\n     double recipb = recip - recipa;\n+    // Account for rounding in division\n+    temp = ya*recipa;\n+    double r1 = ya - temp;\n+    double r2 = yb*recip;\n+    r2 -= temp*r2;\n+    r2 -= yab*recipa;\n+    temp = r1 + r2;\n+    r2 = -(temp - r1 - r2);\n+    r1 = temp;\n     // Correct for rounding in division\n-    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n+    recipb += (1.0 - yaa * recipa - r1 - yab * recipa - r2) * recip;\n     // Account for yb\n-    recipb += -yb * recip * recip;\n+    recipb += -yb * recip * recip + 2.0 * yb * recipb;\n     // y = y + 1/y\n     temp = ya + recipa;\n     yb += -(temp - ya - recipa);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "import java.lang.Math;\n\npublic static double cosh(double x) {\n    if (Double.isNaN(x)) {\n        return Double.NaN;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * Math.exp(x);\n    }\n    if (x < -20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * Math.exp(-x);\n    }\n    final double[] hiPrec = new double[2];\n    if (x < 0.0) {\n        x = -x;\n    }\n    Math.exp(x, 0.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double temp = ya * HEX_40000000;\n    double yaa = ya + temp - temp;\n    double yab = ya - yaa;\n    // recip = 1/y\n    double recip = 1.0 / ya;\n    temp = recip * HEX_40000000;\n    double recipa = recip + temp - temp;\n    double recipb = recip - recipa;\n    // Correct for rounding in division\n    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n    // Account for yb\n    recipb += -yb * recip * recip;\n    // y = y + 1/y\n    temp = ya + recipa;\n    yb += -(temp - ya - recipa);\n    ya = temp;\n    temp = ya + recipb;\n    yb += -(temp - ya - recipb);\n    ya = temp;\n    double result = ya + yb;\n    result *= 0.5;\n    return result;\n}", "diff": "--- org/apache/commons/math3/util/FastMath.java@cosh\n+++ org/apache/commons/math3/util/FastMath.java@cosh\n@@ -1,23 +1,23 @@\n public static double cosh(double x) {\n-    if (x != x) {\n-        return x;\n+    if (Double.isNaN(x)) {\n+        return Double.NaN;\n     }\n     // cosh[z] = (exp(z) + exp(-z))/2\n     // for numbers with magnitude 20 or so,\n     // exp(-z) can be ignored in comparison with exp(z)\n     if (x > 20) {\n         // Avoid overflow (MATH-905).\n-        return 0.5 * exp(x);\n+        return 0.5 * Math.exp(x);\n     }\n     if (x < -20) {\n         // Avoid overflow (MATH-905).\n-        return 0.5 * exp(-x);\n+        return 0.5 * Math.exp(-x);\n     }\n     final double[] hiPrec = new double[2];\n     if (x < 0.0) {\n         x = -x;\n     }\n-    exp(x, 0.0, hiPrec);\n+    Math.exp(x, 0.0, hiPrec);\n     double ya = hiPrec[0] + hiPrec[1];\n     double yb = -(ya - hiPrec[0] - hiPrec[1]);\n     double temp = ya * HEX_40000000;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "import static java.lang.Math.exp;\n\npublic static double cosh(double x) {\n    if (Double.isNaN(x)) {\n        return Double.NaN;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * exp(x);\n    }\n    if (x < -20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * exp(-x);\n    }\n    final double[] hiPrec = new double[2];\n    if (x < 0.0) {\n        x = -x;\n    }\n    exp(x, 0.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double temp = ya * HEX_40000000;\n    double yaa = ya + temp - temp;\n    double yab = ya - yaa;\n    // recip = 1/y\n    double recip = 1.0 / ya;\n    temp = recip * HEX_40000000;\n    double recipa = recip + temp - temp;\n    double recipb = recip - recipa;\n    // Correct for rounding in division\n    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n    // Account for yb\n    recipb += -yb * recip * recip;\n    // y = y + 1/y\n    temp = ya + recipa;\n    yb += -(temp - ya - recipa);\n    ya = temp;\n    temp = ya + recipb;\n    yb += -(temp - ya - recipb);\n    ya = temp;\n    double result = ya + yb;\n    result *= 0.5;\n    return result;\n}", "diff": "--- org/apache/commons/math3/util/FastMath.java@cosh\n+++ org/apache/commons/math3/util/FastMath.java@cosh\n@@ -1,6 +1,6 @@\n public static double cosh(double x) {\n-    if (x != x) {\n-        return x;\n+    if (Double.isNaN(x)) {\n+        return Double.NaN;\n     }\n     // cosh[z] = (exp(z) + exp(-z))/2\n     // for numbers with magnitude 20 or so,\n", "finish_reason": "stop", "valid": false, "num": 5}, {"output": "import static java.lang.Math.*;\n\npublic static double cosh(double x) {\n    if (Double.isNaN(x)) {\n        return Double.NaN;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * exp(x);\n    }\n    if (x < -20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * exp(-x);\n    }\n    final double[] hiPrec = new double[2];\n    if (x < 0.0) {\n        x = -x;\n    }\n    exp(x, 0.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double temp = ya * HEX_40000000;\n    double yaa = ya + temp - temp;\n    double yab = ya - yaa;\n    // recip = 1/y\n    double recip = 1.0 / ya;\n    temp = recip * HEX_40000000;\n    double recipa = recip + temp - temp;\n    double recipb = recip - recipa;\n    // Correct for rounding in division\n    temp = recipa * ya;\n    double epsA = 1.0 - temp;\n    double temp2 = epsA - recipa * yaa;\n    epsA = temp2 + epsA;\n    temp2 = epsA - recipa * yab;\n    epsA = temp2 + epsA;\n    temp2 = epsA - recipb * ya;\n    epsA = temp2 + epsA;\n    temp2 = epsA - recipb * yaa;\n    epsA = temp2 + epsA;\n    temp2 = epsA - recipb * yab;\n    epsA = temp2 + epsA;\n    epsA += -yb * recip * recip;\n    epsB = -(epsA - ya * epsA - yb * recipb);\n\n    temp = ya + recipa;\n    yb += -(temp - ya - recipa);\n    ya = temp;\n    temp = ya + recipb;\n    yb += -(temp - ya - recipb);\n    ya = temp;\n    double result = ya + yb;\n    if (Double.isInfinite(result)) {\n        return Double.POSITIVE_INFINITY;\n    }\n    return result;\n}", "diff": "--- org/apache/commons/math3/util/FastMath.java@cosh\n+++ org/apache/commons/math3/util/FastMath.java@cosh\n@@ -1,6 +1,6 @@\n public static double cosh(double x) {\n-    if (x != x) {\n-        return x;\n+    if (Double.isNaN(x)) {\n+        return Double.NaN;\n     }\n     // cosh[z] = (exp(z) + exp(-z))/2\n     // for numbers with magnitude 20 or so,\n@@ -29,10 +29,21 @@\n     double recipa = recip + temp - temp;\n     double recipb = recip - recipa;\n     // Correct for rounding in division\n-    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n-    // Account for yb\n-    recipb += -yb * recip * recip;\n-    // y = y + 1/y\n+    temp = recipa * ya;\n+    double epsA = 1.0 - temp;\n+    double temp2 = epsA - recipa * yaa;\n+    epsA = temp2 + epsA;\n+    temp2 = epsA - recipa * yab;\n+    epsA = temp2 + epsA;\n+    temp2 = epsA - recipb * ya;\n+    epsA = temp2 + epsA;\n+    temp2 = epsA - recipb * yaa;\n+    epsA = temp2 + epsA;\n+    temp2 = epsA - recipb * yab;\n+    epsA = temp2 + epsA;\n+    epsA += -yb * recip * recip;\n+    epsB = -(epsA - ya * epsA - yb * recipb);\n+\n     temp = ya + recipa;\n     yb += -(temp - ya - recipa);\n     ya = temp;\n@@ -40,6 +51,8 @@\n     yb += -(temp - ya - recipb);\n     ya = temp;\n     double result = ya + yb;\n-    result *= 0.5;\n+    if (Double.isInfinite(result)) {\n+        return Double.POSITIVE_INFINITY;\n+    }\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "import static java.lang.Math.exp;\n\npublic static double cosh(double x) {\n    if (Double.isNaN(x)) {\n        return x;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * exp(x);\n    }\n    if (x < -20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * exp(-x);\n    }\n    final double[] hiPrec = new double[2];\n    if (x < 0.0) {\n        x = -x;\n    }\n    exp(x, 0.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double temp = ya * HEX_40000000;\n    double yaa = ya + temp - temp;\n    double yab = ya - yaa;\n    // recip = 1/y\n    double recip = 1.0 / ya;\n    temp = recip * HEX_40000000;\n    double recipa = recip + temp - temp;\n    double recipb = recip - recipa;\n    // Correct for rounding in division\n    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n    // Account for yb\n    recipb += -yb * recip * recip;\n    // y = y + 1/y\n    temp = ya + recipa;\n    yb += -(temp - ya - recipa);\n    ya = temp;\n    temp = ya + recipb;\n    yb += -(temp - ya - recipb);\n    ya = temp;\n    double result = ya + yb;\n    result *= 0.5;\n    return result;\n}", "diff": "--- org/apache/commons/math3/util/FastMath.java@cosh\n+++ org/apache/commons/math3/util/FastMath.java@cosh\n@@ -1,5 +1,5 @@\n public static double cosh(double x) {\n-    if (x != x) {\n+    if (Double.isNaN(x)) {\n         return x;\n     }\n     // cosh[z] = (exp(z) + exp(-z))/2\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "import java.lang.Math;\npublic static double cosh(double x) {\n    if (x != x || x==Double.POSITIVE_INFINITY){\n        // NaN or positive infinity\n        return Double.NaN;\n    } else if (x==Double.NEGATIVE_INFINITY){\n        // negative infinity\n        return Double.POSITIVE_INFINITY;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * Math.exp(x);\n    }\n    if (x < -20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * Math.exp(-x);\n    }\n    final double[] hiPrec = new double[2];\n    if (x < 0.0) {\n        x = -x;\n    }\n    Math.exp(x, 0.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double temp = ya * HEX_40000000;\n    double yaa = ya + temp - temp;\n    double yab = ya - yaa;\n    // recip = 1/y\n    double recip = 1.0 / ya;\n    temp = recip * HEX_40000000;\n    double recipa = recip + temp - temp;\n    double recipb = recip - recipa;\n    // Correct for rounding in division\n    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n    // Account for yb\n    recipb += -yb * recip * recip;\n    // y = y + 1/y\n    temp = ya + recipa;\n    yb += -(temp - ya - recipa);\n    ya = temp;\n    temp = ya + recipb;\n    yb += -(temp - ya - recipb);\n    ya = temp;\n    double result = ya + yb;\n    result *= 0.5;\n    return result;\n}", "diff": "--- org/apache/commons/math3/util/FastMath.java@cosh\n+++ org/apache/commons/math3/util/FastMath.java@cosh\n@@ -1,23 +1,27 @@\n public static double cosh(double x) {\n-    if (x != x) {\n-        return x;\n+    if (x != x || x==Double.POSITIVE_INFINITY){\n+        // NaN or positive infinity\n+        return Double.NaN;\n+    } else if (x==Double.NEGATIVE_INFINITY){\n+        // negative infinity\n+        return Double.POSITIVE_INFINITY;\n     }\n     // cosh[z] = (exp(z) + exp(-z))/2\n     // for numbers with magnitude 20 or so,\n     // exp(-z) can be ignored in comparison with exp(z)\n     if (x > 20) {\n         // Avoid overflow (MATH-905).\n-        return 0.5 * exp(x);\n+        return 0.5 * Math.exp(x);\n     }\n     if (x < -20) {\n         // Avoid overflow (MATH-905).\n-        return 0.5 * exp(-x);\n+        return 0.5 * Math.exp(-x);\n     }\n     final double[] hiPrec = new double[2];\n     if (x < 0.0) {\n         x = -x;\n     }\n-    exp(x, 0.0, hiPrec);\n+    Math.exp(x, 0.0, hiPrec);\n     double ya = hiPrec[0] + hiPrec[1];\n     double yb = -(ya - hiPrec[0] - hiPrec[1]);\n     double temp = ya * HEX_40000000;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "import static java.lang.Math.exp;\n\npublic static double cosh(double x) {\n    if (Double.isNaN(x)) {\n        return Double.NaN;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * exp(x);\n    }\n    if (x < -20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * exp(-x);\n    }\n    final double[] hiPrec = new double[2];\n    double xa = Math.abs(x);\n    if (xa < 0.5) {\n        double tmp = Math.expm1(xa);\n        return 1.0 + tmp * tmp / (2.0 * (1.0 + tmp));\n    }\n    exp(xa, 0.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double temp = ya * HEX_40000000;\n    double yaa = ya + temp - temp;\n    double yab = ya - yaa;\n    // recip = 1/y\n    double recip = 1.0 / ya;\n    temp = recip * HEX_40000000;\n    double recipa = recip + temp - temp;\n    double recipb = recip - recipa;\n    // Correct for rounding in division\n    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n    // Account for yb\n    recipb += -yb * recip * recip;\n    // y = y + 1/y\n    temp = ya + recipa;\n    yb += -(temp - ya - recipa);\n    ya = temp;\n    temp = ya + recipb;\n    yb += -(temp - ya - recipb);\n    ya = temp;\n    double result = ya + yb;\n    if (x < 0.0) {\n        // cosh(-x) = cosh(x)\n        result = -result;\n    }\n    return result;\n}", "diff": "--- org/apache/commons/math3/util/FastMath.java@cosh\n+++ org/apache/commons/math3/util/FastMath.java@cosh\n@@ -1,6 +1,6 @@\n public static double cosh(double x) {\n-    if (x != x) {\n-        return x;\n+    if (Double.isNaN(x)) {\n+        return Double.NaN;\n     }\n     // cosh[z] = (exp(z) + exp(-z))/2\n     // for numbers with magnitude 20 or so,\n@@ -14,10 +14,12 @@\n         return 0.5 * exp(-x);\n     }\n     final double[] hiPrec = new double[2];\n-    if (x < 0.0) {\n-        x = -x;\n+    double xa = Math.abs(x);\n+    if (xa < 0.5) {\n+        double tmp = Math.expm1(xa);\n+        return 1.0 + tmp * tmp / (2.0 * (1.0 + tmp));\n     }\n-    exp(x, 0.0, hiPrec);\n+    exp(xa, 0.0, hiPrec);\n     double ya = hiPrec[0] + hiPrec[1];\n     double yb = -(ya - hiPrec[0] - hiPrec[1]);\n     double temp = ya * HEX_40000000;\n@@ -40,6 +42,9 @@\n     yb += -(temp - ya - recipb);\n     ya = temp;\n     double result = ya + yb;\n-    result *= 0.5;\n+    if (x < 0.0) {\n+        // cosh(-x) = cosh(x)\n+        result = -result;\n+    }\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "import static java.lang.Math.*;\n\npublic static double cosh(double x) {\n    if (Double.isNaN(x)) {\n        return Double.NaN;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        return exp(x) / 2.0;\n    }\n    if (x < -20) {\n        return exp(-x) / 2.0;\n    }\n    final double[] hiPrec = new double[2];\n    if (x < 0.0) {\n        x = -x;\n    }\n    exp(x, 0.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double temp = ya * HEX_40000000;\n    double yaa = ya + temp - temp;\n    double yab = ya - yaa;\n    // recip = 1/y\n    double recip = 1.0 / ya;\n    temp = recip * HEX_40000000;\n    double recipa = recip + temp - temp;\n    double recipb = recip - recipa;\n    // Correct for rounding in division\n    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n    // Account for yb\n    recipb += -yb * recip * recip;\n    // y = y + 1/y\n    temp = ya + recipa;\n    yb += -(temp - ya - recipa);\n    ya = temp;\n    temp = ya + recipb;\n    yb += -(temp - ya - recipb);\n    ya = temp;\n    double result = ya + yb;\n    result *= 0.5;\n    return result;\n}", "diff": "--- org/apache/commons/math3/util/FastMath.java@cosh\n+++ org/apache/commons/math3/util/FastMath.java@cosh\n@@ -1,17 +1,15 @@\n public static double cosh(double x) {\n-    if (x != x) {\n-        return x;\n+    if (Double.isNaN(x)) {\n+        return Double.NaN;\n     }\n     // cosh[z] = (exp(z) + exp(-z))/2\n     // for numbers with magnitude 20 or so,\n     // exp(-z) can be ignored in comparison with exp(z)\n     if (x > 20) {\n-        // Avoid overflow (MATH-905).\n-        return 0.5 * exp(x);\n+        return exp(x) / 2.0;\n     }\n     if (x < -20) {\n-        // Avoid overflow (MATH-905).\n-        return 0.5 * exp(-x);\n+        return exp(-x) / 2.0;\n     }\n     final double[] hiPrec = new double[2];\n     if (x < 0.0) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "import static java.lang.Math.*;\n\npublic static double cosh(double x) {\n    if (x != x) {\n        return x;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * exp(x);\n    }\n    if (x < -20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * exp(-x);\n    }\n    final double[] hiPrec = new double[2];\n    if (x < 0.0) {\n        x = -x;\n    }\n    exp(x, 0.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double temp = ya * HEX_40000000;\n    double yaa = ya + temp - temp;\n    double yab = ya - yaa;\n    // recip = 1/y\n    double recip = 1.0 / ya;\n    temp = recip * HEX_40000000;\n    double recipa = recip + temp - temp;\n    double recipb = recip - recipa;\n    // Correct for rounding in division\n    recipb += (1.0 - yaa * recipa - yab * recipa - yaa * recipb - yab * recipb) * recip;\n    // Account for yb\n    recipb += -yb * recip * recip;\n    // y = y + 1/y\n    temp = ya + recipa;\n    yb += -(temp - ya - recipa);\n    ya = temp;\n    temp = ya + recipb;\n    yb += -(temp - ya - recipb);\n    ya = temp;\n    double result = ya + yb;\n    if (result > MAX_VALUE) {\n        return Double.POSITIVE_INFINITY;\n    } else if (result < -MAX_VALUE) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    result *= 0.5;\n    return result;\n}", "diff": "--- org/apache/commons/math3/util/FastMath.java@cosh\n+++ org/apache/commons/math3/util/FastMath.java@cosh\n@@ -29,7 +29,7 @@\n     double recipa = recip + temp - temp;\n     double recipb = recip - recipa;\n     // Correct for rounding in division\n-    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n+    recipb += (1.0 - yaa * recipa - yab * recipa - yaa * recipb - yab * recipb) * recip;\n     // Account for yb\n     recipb += -yb * recip * recip;\n     // y = y + 1/y\n@@ -40,6 +40,11 @@\n     yb += -(temp - ya - recipb);\n     ya = temp;\n     double result = ya + yb;\n+    if (result > MAX_VALUE) {\n+        return Double.POSITIVE_INFINITY;\n+    } else if (result < -MAX_VALUE) {\n+        return Double.NEGATIVE_INFINITY;\n+    }\n     result *= 0.5;\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "import static java.lang.Math.*;\n\npublic static double cosh(double x) {\n    if (Double.isNaN(x)) {\n        return Double.NaN;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        // Avoid overflow (MATH-905).\n        return (exp(x) + exp(-x)) / 2;\n    }\n    if (x < -20) {\n        // Avoid overflow (MATH-905).\n        return (exp(x) + exp(-x)) / 2;\n    }\n    return (exp(x) + exp(-x)) / 2;\n}", "diff": "--- org/apache/commons/math3/util/FastMath.java@cosh\n+++ org/apache/commons/math3/util/FastMath.java@cosh\n@@ -1,45 +1,17 @@\n public static double cosh(double x) {\n-    if (x != x) {\n-        return x;\n+    if (Double.isNaN(x)) {\n+        return Double.NaN;\n     }\n     // cosh[z] = (exp(z) + exp(-z))/2\n     // for numbers with magnitude 20 or so,\n     // exp(-z) can be ignored in comparison with exp(z)\n     if (x > 20) {\n         // Avoid overflow (MATH-905).\n-        return 0.5 * exp(x);\n+        return (exp(x) + exp(-x)) / 2;\n     }\n     if (x < -20) {\n         // Avoid overflow (MATH-905).\n-        return 0.5 * exp(-x);\n+        return (exp(x) + exp(-x)) / 2;\n     }\n-    final double[] hiPrec = new double[2];\n-    if (x < 0.0) {\n-        x = -x;\n-    }\n-    exp(x, 0.0, hiPrec);\n-    double ya = hiPrec[0] + hiPrec[1];\n-    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n-    double temp = ya * HEX_40000000;\n-    double yaa = ya + temp - temp;\n-    double yab = ya - yaa;\n-    // recip = 1/y\n-    double recip = 1.0 / ya;\n-    temp = recip * HEX_40000000;\n-    double recipa = recip + temp - temp;\n-    double recipb = recip - recipa;\n-    // Correct for rounding in division\n-    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n-    // Account for yb\n-    recipb += -yb * recip * recip;\n-    // y = y + 1/y\n-    temp = ya + recipa;\n-    yb += -(temp - ya - recipa);\n-    ya = temp;\n-    temp = ya + recipb;\n-    yb += -(temp - ya - recipb);\n-    ya = temp;\n-    double result = ya + yb;\n-    result *= 0.5;\n-    return result;\n+    return (exp(x) + exp(-x)) / 2;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "import static java.lang.Math.*;\n\npublic static double cosh(double x) {\n    if (x != x) {\n        return x;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * exp(x);\n    }\n    if (x < -20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * exp(-x);\n    }\n    final double[] hiPrec = new double[2];\n    if (x < 0.0) {\n        x = -x;\n    }\n    exp(x, 0.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double temp = ya * HEX_40000000;\n    double yaa = ya + temp - temp;\n    double yab = ya - yaa;\n    // recip = 1/y\n    double recip = 1.0 / ya;\n    temp = recip * HEX_40000000;\n    double recipa = recip + temp - temp;\n    double recipb = recip - recipa;\n    // Correct for rounding in division\n    recipb += (1.0 - yaa * recipa - yab * recipa) * recip;\n    // Account for yb\n    recipb += -yb * recip * recip;\n    // y = y + 1/y\n    temp = ya + recipa;\n    yb += -(temp - ya - recipa);\n    ya = temp;\n    temp = ya + recipb;\n    yb += -(temp - ya - recipb);\n    ya = temp;\n    double result = ya + yb;\n    result *= 0.5;\n    return result;\n}", "diff": "--- org/apache/commons/math3/util/FastMath.java@cosh\n+++ org/apache/commons/math3/util/FastMath.java@cosh\n@@ -29,7 +29,7 @@\n     double recipa = recip + temp - temp;\n     double recipb = recip - recipa;\n     // Correct for rounding in division\n-    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n+    recipb += (1.0 - yaa * recipa - yab * recipa) * recip;\n     // Account for yb\n     recipb += -yb * recip * recip;\n     // y = y + 1/y\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "import java.lang.Math;\n\npublic static double cosh(double x) {\n    if (Double.isNaN(x)) {\n        return Double.NaN;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * Math.exp(x);\n    }\n    if (x < -20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * Math.exp(-x);\n    }\n    final double[] hiPrec = new double[2];\n    if (x < 0.0) {\n        x = -x;\n    }\n    Math.exp(x, 0.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double temp = ya * MathUtil.HEX_40000000;\n    double yaa = ya + temp - temp;\n    double yab = ya - yaa;\n    // recip = 1/y\n    double recip = 1.0 / ya;\n    temp = recip * MathUtil.HEX_40000000;\n    double recipa = recip + temp - temp;\n    double recipb = recip - recipa;\n    // Correct for rounding in division\n    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n    // Account for yb\n    recipb += -yb * recip * recip;\n    // y = y + 1/y\n    temp = ya + recipa;\n    yb += -(temp - ya - recipa);\n    ya = temp;\n    temp = ya + recipb;\n    yb += -(temp - ya - recipb);\n    ya = temp;\n    double result = ya + yb;\n    result *= 0.5;\n    return result;\n}", "diff": "--- org/apache/commons/math3/util/FastMath.java@cosh\n+++ org/apache/commons/math3/util/FastMath.java@cosh\n@@ -1,31 +1,31 @@\n public static double cosh(double x) {\n-    if (x != x) {\n-        return x;\n+    if (Double.isNaN(x)) {\n+        return Double.NaN;\n     }\n     // cosh[z] = (exp(z) + exp(-z))/2\n     // for numbers with magnitude 20 or so,\n     // exp(-z) can be ignored in comparison with exp(z)\n     if (x > 20) {\n         // Avoid overflow (MATH-905).\n-        return 0.5 * exp(x);\n+        return 0.5 * Math.exp(x);\n     }\n     if (x < -20) {\n         // Avoid overflow (MATH-905).\n-        return 0.5 * exp(-x);\n+        return 0.5 * Math.exp(-x);\n     }\n     final double[] hiPrec = new double[2];\n     if (x < 0.0) {\n         x = -x;\n     }\n-    exp(x, 0.0, hiPrec);\n+    Math.exp(x, 0.0, hiPrec);\n     double ya = hiPrec[0] + hiPrec[1];\n     double yb = -(ya - hiPrec[0] - hiPrec[1]);\n-    double temp = ya * HEX_40000000;\n+    double temp = ya * MathUtil.HEX_40000000;\n     double yaa = ya + temp - temp;\n     double yab = ya - yaa;\n     // recip = 1/y\n     double recip = 1.0 / ya;\n-    temp = recip * HEX_40000000;\n+    temp = recip * MathUtil.HEX_40000000;\n     double recipa = recip + temp - temp;\n     double recipb = recip - recipa;\n     // Correct for rounding in division\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "import static java.lang.Math.exp;\n\npublic static double cosh(double x) {\n    if (Double.isNaN(x)) {\n        return Double.NaN;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * exp(x);\n    }\n    if (x < -20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * exp(-x);\n    }\n    final double[] hiPrec = new double[2];\n    if (x < 0.0) {\n        x = -x;\n    }\n    exp(x, 0.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double temp = ya * HEX_40000000;\n    double yaa = ya + temp - temp;\n    double yab = ya - yaa;\n    // recip = 1/y\n    double recip = 1.0 / ya;\n    temp = recip * HEX_40000000;\n    double recipa = recip + temp - temp;\n    double recipb = recip - recipa;\n    // Account for rounding in division.\n    // The code uses the compensation algorithm described in Knuth section 4.2.1.\n    double t = 0.0;\n    if (yaa < HEX_30000000) { // 2^-28\n        double tmp = yaa * HEX_40000000;\n        t = (yaa + tmp) - tmp;\n    }\n    double e = yaa - t - ya;\n    t = (e + HEX_40000000) - HEX_40000000;\n    recipb += e - t;\n    // Correct for rounding in multiplication.\n    // The adjustment to account for q, a.k.a. 1-recip*y,\n    // is where the correction for IEEE behavior differs from\n    // the Knuth algorithm. We instead define err = 1 - q*y.\n    double err = 1.0 - yaa * recipa;\n    err -= yab * recipa;\n    err -= yaa * recipb;\n    err -= yab * recipb;\n    err *= recip;\n    // Another round of compensation for err. (Nickel's idea.)\n    if (err > 0.0) {\n        t = err * HEX_40000000;\n        t = (err + t) - t;\n        err = t / HEX_40000000;\n    } else {\n        t = err * -HEX_40000000;\n        t = (err - t) + t;\n        err = t / -HEX_40000000;\n    }\n    ya += err;\n    yb += -(ya - err);\n    // y = y + 1/y\n    temp = ya + recipa;\n    yb += -(temp - ya - recipa);\n    ya = temp;\n    temp = ya + recipb;\n    yb += -(temp - ya - recipb);\n    ya = temp;\n    double result = ya + yb;\n    result *= 0.5;\n    return result;\n}", "diff": "--- org/apache/commons/math3/util/FastMath.java@cosh\n+++ org/apache/commons/math3/util/FastMath.java@cosh\n@@ -1,6 +1,6 @@\n public static double cosh(double x) {\n-    if (x != x) {\n-        return x;\n+    if (Double.isNaN(x)) {\n+        return Double.NaN;\n     }\n     // cosh[z] = (exp(z) + exp(-z))/2\n     // for numbers with magnitude 20 or so,\n@@ -28,10 +28,37 @@\n     temp = recip * HEX_40000000;\n     double recipa = recip + temp - temp;\n     double recipb = recip - recipa;\n-    // Correct for rounding in division\n-    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n-    // Account for yb\n-    recipb += -yb * recip * recip;\n+    // Account for rounding in division.\n+    // The code uses the compensation algorithm described in Knuth section 4.2.1.\n+    double t = 0.0;\n+    if (yaa < HEX_30000000) { // 2^-28\n+        double tmp = yaa * HEX_40000000;\n+        t = (yaa + tmp) - tmp;\n+    }\n+    double e = yaa - t - ya;\n+    t = (e + HEX_40000000) - HEX_40000000;\n+    recipb += e - t;\n+    // Correct for rounding in multiplication.\n+    // The adjustment to account for q, a.k.a. 1-recip*y,\n+    // is where the correction for IEEE behavior differs from\n+    // the Knuth algorithm. We instead define err = 1 - q*y.\n+    double err = 1.0 - yaa * recipa;\n+    err -= yab * recipa;\n+    err -= yaa * recipb;\n+    err -= yab * recipb;\n+    err *= recip;\n+    // Another round of compensation for err. (Nickel's idea.)\n+    if (err > 0.0) {\n+        t = err * HEX_40000000;\n+        t = (err + t) - t;\n+        err = t / HEX_40000000;\n+    } else {\n+        t = err * -HEX_40000000;\n+        t = (err - t) + t;\n+        err = t / -HEX_40000000;\n+    }\n+    ya += err;\n+    yb += -(ya - err);\n     // y = y + 1/y\n     temp = ya + recipa;\n     yb += -(temp - ya - recipa);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "import static java.lang.Math.*;\n\npublic static double cosh(double x) {\n    if (Double.isNaN(x)) {\n        return x;\n    }\n    // cosh[z] = (exp(z) + exp(-z))/2\n    // for numbers with magnitude 20 or so,\n    // exp(-z) can be ignored in comparison with exp(z)\n    if (x > 20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * exp(x);\n    }\n    if (x < -20) {\n        // Avoid overflow (MATH-905).\n        return 0.5 * exp(-x);\n    }\n    final double[] hiPrec = new double[2];\n    if (x < 0.0) {\n        x = -x;\n    }\n    exp(x, 0.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double temp = ya * HEX_40000000;\n    double yaa = ya + temp - temp;\n    double yab = ya - yaa;\n    // recip = 1/y\n    double recip = 1.0 / ya;\n    temp = recip * HEX_40000000;\n    double recipa = recip + temp - temp;\n    double recipb = recip - recipa;\n    // Correct for rounding in division\n    if (recipa != 0.0) {\n        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n    } else {\n        recipb += -yaa * recipb * recip;\n    }\n    // Account for yb\n    recipb += -yb * recip * recip;\n    // y = y + 1/y\n    temp = ya + recipa;\n    yb += -(temp - ya - recipa);\n    ya = temp;\n    temp = ya + recipb;\n    yb += -(temp - ya - recipb);\n    ya = temp;\n    double result = ya + yb;\n    result *= 0.5;\n    return result;\n}", "diff": "--- org/apache/commons/math3/util/FastMath.java@cosh\n+++ org/apache/commons/math3/util/FastMath.java@cosh\n@@ -1,5 +1,5 @@\n public static double cosh(double x) {\n-    if (x != x) {\n+    if (Double.isNaN(x)) {\n         return x;\n     }\n     // cosh[z] = (exp(z) + exp(-z))/2\n@@ -29,7 +29,11 @@\n     double recipa = recip + temp - temp;\n     double recipb = recip - recipa;\n     // Correct for rounding in division\n-    recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n+    if (recipa != 0.0) {\n+        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n+    } else {\n+        recipb += -yaa * recipb * recip;\n+    }\n     // Account for yb\n     recipb += -yb * recip * recip;\n     // y = y + 1/y\n", "finish_reason": "stop", "valid": false, "num": 1}]