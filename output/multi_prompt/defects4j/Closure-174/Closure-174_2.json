[{"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n            // The correct way to link debug info is to put them in the final QNAME node\n            // (not the LHS). The correct way to propagate source info is to explicitly set\n            // it (not let useSourceInfoIfMissing do it).\n            Node nameNode = newDecl.getFirstChild();\n            nameNode.setJSDocInfo(v.getJSDocInfo());\n            Node lhsNode = nameNode.getFirstChild();\n            lhsNode.setJSDocInfo(n.getJSDocInfo());\n            lhsNode.useSourceInfoFrom(n);\n            NodeUtil.setDebugInformation(nameNode, n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().replaceWith(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n));\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -22,10 +22,18 @@\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n             Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+            // The correct way to link debug info is to put them in the final QNAME node\n+            // (not the LHS). The correct way to propagate source info is to explicitly set\n+            // it (not let useSourceInfoIfMissing do it).\n+            Node nameNode = newDecl.getFirstChild();\n+            nameNode.setJSDocInfo(v.getJSDocInfo());\n+            Node lhsNode = nameNode.getFirstChild();\n+            lhsNode.setJSDocInfo(n.getJSDocInfo());\n+            lhsNode.useSourceInfoFrom(n);\n+            NodeUtil.setDebugInformation(nameNode, n, name);\n             parent.getParent().addChildBefore(newDecl, parent);\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            v.getNameNode().replaceWith(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n));\n             recordAlias(v);\n         } else {\n             // Do not allow hoisted functions or other kinds of local symbols.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            Node nameNode = v.getNameNode();\n            nameNode.replaceWith(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            v.setNameNode(nameNode);\n\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -25,7 +25,10 @@\n             NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n             parent.getParent().addChildBefore(newDecl, parent);\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            Node nameNode = v.getNameNode();\n+            nameNode.replaceWith(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            v.setNameNode(nameNode);\n+\n             recordAlias(v);\n         } else {\n             // Do not allow hoisted functions or other kinds of local symbols.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\"+nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoFromForTree(n);\n            NodeUtil.setDebugInformation(newDecl, n);\n            parent.getParent().addChildBefore(newDecl, parent);\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getInitialValue().replaceChild(n.getFirstChild(), NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -17,15 +17,15 @@\n             String name = n.getString();\n             int nameCount = scopedAliasNames.count(name);\n             scopedAliasNames.add(name);\n-            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n+            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\"+nameCount));\n             compiler.ensureLibraryInjected(\"base\");\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n-            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoFromForTree(n);\n+            NodeUtil.setDebugInformation(newDecl, n);\n             parent.getParent().addChildBefore(newDecl, parent);\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            v.getInitialValue().replaceChild(n.getFirstChild(), NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n             recordAlias(v);\n         } else {\n             // Do not allow hoisted functions or other kinds of local symbols.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n\n            // Rewrite \"var name = EXPR;\" to \"var $jscomp$scope$name = EXPR;\"\n            String newVarName = \"$jscomp$scope$\" + name;\n            v.setName(newVarName); // Update the Var object with new name\n            NodeUtil.newName(v.getNameNode(), newVarName); // Update the name node of the variable\n            NodeUtil.setDebugInformation(v.getNameNode(), n, newVarName); // Update debug information\n\n            // Rewrite \"name\" to \"$jscomp$scope$name\" in variable declaration\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, newVarName));\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -24,8 +24,15 @@\n             Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n             NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n             parent.getParent().addChildBefore(newDecl, parent);\n-            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+\n+            // Rewrite \"var name = EXPR;\" to \"var $jscomp$scope$name = EXPR;\"\n+            String newVarName = \"$jscomp$scope$\" + name;\n+            v.setName(newVarName); // Update the Var object with new name\n+            NodeUtil.newName(v.getNameNode(), newVarName); // Update the name node of the variable\n+            NodeUtil.setDebugInformation(v.getNameNode(), n, newVarName); // Update debug information\n+\n+            // Rewrite \"name\" to \"$jscomp$scope$name\" in variable declaration\n+            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, newVarName));\n             recordAlias(v);\n         } else {\n             // Do not allow hoisted functions or other kinds of local symbols.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            Node newNameNode = NodeUtil.newQName(compiler, globalName).srcrefTree(n);\n            v.getNameNode().replaceWith(newNameNode);\n            v.setNameNode(newNameNode);\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -25,7 +25,9 @@\n             NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n             parent.getParent().addChildBefore(newDecl, parent);\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            Node newNameNode = NodeUtil.newQName(compiler, globalName).srcrefTree(n);\n+            v.getNameNode().replaceWith(newNameNode);\n+            v.setNameNode(newNameNode);\n             recordAlias(v);\n         } else {\n             // Do not allow hoisted functions or other kinds of local symbols.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoFrom(n);\n            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().replaceWith(Node.newQName(compiler, globalName));\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -21,11 +21,11 @@\n             compiler.ensureLibraryInjected(\"base\");\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n-            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n+            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoFrom(n);\n             NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n             parent.getParent().addChildBefore(newDecl, parent);\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            v.getNameNode().replaceWith(Node.newQName(compiler, globalName));\n             recordAlias(v);\n         } else {\n             // Do not allow hoisted functions or other kinds of local symbols.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent != null && parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n            if (parent.getParent() != null) {\n              parent.getParent().addChildBefore(newDecl, parent);\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -9,7 +9,7 @@\n         } else if (v.isBleedingFunction()) {\n             // Bleeding functions already get a BAD_PARAMETERS error, so just\n             // do nothing.\n-        } else if (parent.getType() == Token.LP) {\n+        } else if (parent != null && parent.getType() == Token.LP) {\n             // Parameters of the scope function also get a BAD_PARAMETERS\n             // error.\n         } else if (isVarAssign) {\n@@ -23,7 +23,9 @@\n             // Make sure we copy over all the jsdoc and debug info.\n             Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n             NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n-            parent.getParent().addChildBefore(newDecl, parent);\n+            if (parent.getParent() != null) {\n+              parent.getParent().addChildBefore(newDecl, parent);\n+            }\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n             v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n             recordAlias(v);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            Node newNameNode = NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name);\n            v.getNameNode().getParent().replaceChild(v.getNameNode(), newNameNode);\n            // Record the new alias.\n            recordAlias(new Var(n, scope));\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -25,8 +25,10 @@\n             NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n             parent.getParent().addChildBefore(newDecl, parent);\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n-            recordAlias(v);\n+            Node newNameNode = NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name);\n+            v.getNameNode().getParent().replaceChild(v.getNameNode(), newNameNode);\n+            // Record the new alias.\n+            recordAlias(new Var(n, scope));\n         } else {\n             // Do not allow hoisted functions or other kinds of local symbols.\n             report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(newDecl.getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().replaceWith(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -22,10 +22,10 @@\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n             Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+            NodeUtil.setDebugInformation(newDecl.getFirstChild(), n, name);\n             parent.getParent().addChildBefore(newDecl, parent);\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            v.getNameNode().replaceWith(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n             recordAlias(v);\n         } else {\n             // Do not allow hoisted functions or other kinds of local symbols.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n            // Rewrite \"var name = EXPR;\" to \"name = $jscomp.scope.name;\"\n            Node newNameNode = NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name);\n            Node noVarNameNode = new Node(Token.NAME, name);\n            newNode.useSourceInfoIfMissingFromForTree(v.getNameNode());\n            v.getNameNode().replaceChild(noVarNameNode, newNameNode);\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -24,8 +24,11 @@\n             Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n             NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n             parent.getParent().addChildBefore(newDecl, parent);\n-            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            // Rewrite \"var name = EXPR;\" to \"name = $jscomp.scope.name;\"\n+            Node newNameNode = NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name);\n+            Node noVarNameNode = new Node(Token.NAME, name);\n+            newNode.useSourceInfoIfMissingFromForTree(v.getNameNode());\n+            v.getNameNode().replaceChild(noVarNameNode, newNameNode);\n             recordAlias(v);\n         } else {\n             // Do not allow hoisted functions or other kinds of local symbols.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(newDecl.getFirstFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().replaceChild(n, NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -22,10 +22,10 @@\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n             Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+            NodeUtil.setDebugInformation(newDecl.getFirstFirstChild(), n, name);\n             parent.getParent().addChildBefore(newDecl, parent);\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            v.getNameNode().replaceChild(n, NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n             recordAlias(v);\n         } else {\n             // Do not allow hoisted functions or other kinds of local symbols.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQNameDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQName(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -21,11 +21,11 @@\n             compiler.ensureLibraryInjected(\"base\");\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n-            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n+            Node newDecl = NodeUtil.newQNameDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n             NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n             parent.getParent().addChildBefore(newDecl, parent);\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            v.getNameNode().addChildToFront(NodeUtil.newQName(compiler.getCodingConvention(), globalName, n, name));\n             recordAlias(v);\n         } else {\n             // Do not allow hoisted functions or other kinds of local symbols.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP || parent.getType() == Token.PARAM_LIST) { // added check for Token.PARAM_LIST\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -9,7 +9,7 @@\n         } else if (v.isBleedingFunction()) {\n             // Bleeding functions already get a BAD_PARAMETERS error, so just\n             // do nothing.\n-        } else if (parent.getType() == Token.LP) {\n+        } else if (parent.getType() == Token.LP || parent.getType() == Token.PARAM_LIST) { // added check for Token.PARAM_LIST\n             // Parameters of the scope function also get a BAD_PARAMETERS\n             // error.\n         } else if (isVarAssign) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).copyTypeFrom(n);\n            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n            n.replaceWith(newDecl.getFirstChild());\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            Node nameNode = n.getFirstChild();\n            NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, nameNode, name).useSourceInfoFromForTree(nameNode);\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -21,11 +21,12 @@\n             compiler.ensureLibraryInjected(\"base\");\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n-            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n+            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).copyTypeFrom(n);\n             NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n-            parent.getParent().addChildBefore(newDecl, parent);\n+            n.replaceWith(newDecl.getFirstChild());\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            Node nameNode = n.getFirstChild();\n+            NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, nameNode, name).useSourceInfoFromForTree(nameNode);\n             recordAlias(v);\n         } else {\n             // Do not allow hoisted functions or other kinds of local symbols.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent != null && parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()\n                || parent != null && parent.getType() == Token.PARAM_LIST) {\n            // Bleeding functions and parameters of the scope function\n            // already get a BAD_PARAMETERS error, so just do nothing.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -3,15 +3,13 @@\n     for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         Node parent = n.getParent();\n-        boolean isVarAssign = parent.isVar() && n.hasChildren();\n+        boolean isVarAssign = parent != null && parent.isVar() && n.hasChildren();\n         if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n             recordAlias(v);\n-        } else if (v.isBleedingFunction()) {\n-            // Bleeding functions already get a BAD_PARAMETERS error, so just\n-            // do nothing.\n-        } else if (parent.getType() == Token.LP) {\n-            // Parameters of the scope function also get a BAD_PARAMETERS\n-            // error.\n+        } else if (v.isBleedingFunction()\n+                || parent != null && parent.getType() == Token.PARAM_LIST) {\n+            // Bleeding functions and parameters of the scope function\n+            // already get a BAD_PARAMETERS error, so just do nothing.\n         } else if (isVarAssign) {\n             Node value = v.getInitialValue().detachFromParent();\n             String name = n.getString();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQName(compiler.getCodingConvention(), globalName).srcref(n);\n            // Add const modifier to the newDecl node\n            newDecl.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n            newDecl.addChildToFront(value);\n            JSDocInfo info = v.getJSDocInfo();\n            if(info != null) {\n                newDecl.setJSDocInfo(info);\n            }\n            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            Node qName = NodeUtil.newQName(compiler.getCodingConvention(), globalName).srcref(n);\n            v.getNameNode().replaceAll(qName);\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -21,11 +21,20 @@\n             compiler.ensureLibraryInjected(\"base\");\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n-            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n+            Node newDecl = NodeUtil.newQName(compiler.getCodingConvention(), globalName).srcref(n);\n+            // Add const modifier to the newDecl node\n+            newDecl.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+            newDecl.addChildToFront(value);\n+            JSDocInfo info = v.getJSDocInfo();\n+            if(info != null) {\n+                newDecl.setJSDocInfo(info);\n+            }\n             NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n             parent.getParent().addChildBefore(newDecl, parent);\n+\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            Node qName = NodeUtil.newQName(compiler.getCodingConvention(), globalName).srcref(n);\n+            v.getNameNode().replaceAll(qName);\n             recordAlias(v);\n         } else {\n             // Do not allow hoisted functions or other kinds of local symbols.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo());\n            newDecl = newDecl.useSourceInfoFromForTree(n);\n            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            Node qNameNode = NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name);\n            NodeUtil.copyNameAnnotations(n, qNameNode);\n            v.getNameNode().replaceWith(qNameNode);\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -21,11 +21,14 @@\n             compiler.ensureLibraryInjected(\"base\");\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n-            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n+            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo());\n+            newDecl = newDecl.useSourceInfoFromForTree(n);\n             NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n             parent.getParent().addChildBefore(newDecl, parent);\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            Node qNameNode = NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name);\n+            NodeUtil.copyNameAnnotations(n, qNameNode);\n+            v.getNameNode().replaceWith(qNameNode);\n             recordAlias(v);\n         } else {\n             // Do not allow hoisted functions or other kinds of local symbols.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQNameDeclarationNode(globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(newDecl.getFirstFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().replaceChild(n, NodeUtil.newQNameNode(globalName, n));\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -21,11 +21,11 @@\n             compiler.ensureLibraryInjected(\"base\");\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n-            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+            Node newDecl = NodeUtil.newQNameDeclarationNode(globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n+            NodeUtil.setDebugInformation(newDecl.getFirstFirstChild(), n, name);\n             parent.getParent().addChildBefore(newDecl, parent);\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            v.getNameNode().replaceChild(n, NodeUtil.newQNameNode(globalName, n));\n             recordAlias(v);\n         } else {\n             // Do not allow hoisted functions or other kinds of local symbols.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newVarNode(name, NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()));\n            newDecl.useSourceInfoIfMissingFromForTree(n);\n            parent.getParent().addChildBefore(newDecl, parent);\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -21,8 +21,8 @@\n             compiler.ensureLibraryInjected(\"base\");\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n-            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+            Node newDecl = NodeUtil.newVarNode(name, NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()));\n+            newDecl.useSourceInfoIfMissingFromForTree(n);\n             parent.getParent().addChildBefore(newDecl, parent);\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n             v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVarAssign = parent.isVar() && n.hasChildren();\n        if (isVarAssign && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVarAssign) {\n            Node value = v.getInitialValue().detachFromParent();\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                    compiler.getCodingConvention(),\n                    globalName,\n                    value.detachFromParent(), // detach value node to fix the position bug\n                    v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n            NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n            parent.getParent().addChildBefore(newDecl, parent);\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(\n                    compiler.getCodingConvention(),\n                    globalName,\n                    n, // change `n`\n                    name // change `name`\n            ));\n            recordAlias(v);\n        } else {\n            // Do not allow hoisted functions or other kinds of local symbols.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -21,11 +21,20 @@\n             compiler.ensureLibraryInjected(\"base\");\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n-            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n+            Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n+                    compiler.getCodingConvention(),\n+                    globalName,\n+                    value.detachFromParent(), // detach value node to fix the position bug\n+                    v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n             NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n             parent.getParent().addChildBefore(newDecl, parent);\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(\n+                    compiler.getCodingConvention(),\n+                    globalName,\n+                    n, // change `n`\n+                    name // change `name`\n+            ));\n             recordAlias(v);\n         } else {\n             // Do not allow hoisted functions or other kinds of local symbols.\n", "finish_reason": "stop", "valid": false, "num": 1}]