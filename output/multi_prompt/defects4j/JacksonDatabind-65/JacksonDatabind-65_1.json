[{"output": "@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            if (am.getParameterCount() == 1) {\n                Class<?> actualArgType = am.getRawParameterType(0);\n                for (Class<?> expArgType : expArgTypes) {\n                    // And one that matches what we would pass in\n                    if (actualArgType.isAssignableFrom(expArgType)) {\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,20 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public Method findFactoryMethod(Class<?>... expArgTypes) {\n+    // So, of all single-arg static methods:\n+    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n+        if (isFactoryMethod(am)) {\n+            // And must take one of expected arg types (or supertype)\n+            if (am.getParameterCount() == 1) {\n+                Class<?> actualArgType = am.getRawParameterType(0);\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (actualArgType.isAssignableFrom(expArgType)) {\n+                        return am.getAnnotated();\n+                    }\n+                }\n+            }\n+        }\n     }\n-    try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n-    }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -5,11 +5,13 @@\n         // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n         if (isFactoryMethod(am)) {\n             // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n+            if (am.getParameterCount() == 1) {\n+                Class<?> actualArgType = am.getRawParameterType(0);\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (actualArgType.isAssignableFrom(expArgType)) {\n+                        return am.getAnnotated();\n+                    }\n                 }\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?>[] actualArgTypes = am.getRawParameterTypes();\n            if (actualArgTypes.length == 1) {\n                for (Class<?> expArgType : expArgTypes) {\n                    // And one that matches what we would pass in\n                    if (actualArgTypes[0].isAssignableFrom(expArgType)) {\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,20 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public Method findFactoryMethod(Class<?>... expArgTypes) {\n+    // So, of all single-arg static methods:\n+    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n+        if (isFactoryMethod(am)) {\n+            // And must take one of expected arg types (or supertype)\n+            Class<?>[] actualArgTypes = am.getRawParameterTypes();\n+            if (actualArgTypes.length == 1) {\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (actualArgTypes[0].isAssignableFrom(expArgType)) {\n+                        return am.getAnnotated();\n+                    }\n+                }\n+            }\n+        }\n     }\n-    try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n-    }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -5,11 +5,13 @@\n         // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n         if (isFactoryMethod(am)) {\n             // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n+            Class<?>[] actualArgTypes = am.getRawParameterTypes();\n+            if (actualArgTypes.length == 1) {\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (actualArgTypes[0].isAssignableFrom(expArgType)) {\n+                        return am.getAnnotated();\n+                    }\n                 }\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            if(am.getParameterCount() == 1) {\n                Class<?> actualArgType = am.getRawParameterType(0);\n                for (Class<?> expArgType : expArgTypes) {\n                    // And one that matches what we would pass in\n                    if (expArgType.isAssignableFrom(actualArgType)) {\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,20 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public Method findFactoryMethod(Class<?>... expArgTypes) {\n+    // So, of all single-arg static methods:\n+    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n+        if (isFactoryMethod(am)) {\n+            // And must take one of expected arg types (or supertype)\n+            if(am.getParameterCount() == 1) {\n+                Class<?> actualArgType = am.getRawParameterType(0);\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (expArgType.isAssignableFrom(actualArgType)) {\n+                        return am.getAnnotated();\n+                    }\n+                }\n+            }\n+        }\n     }\n-    try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n-    }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -5,11 +5,13 @@\n         // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n         if (isFactoryMethod(am)) {\n             // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n+            if(am.getParameterCount() == 1) {\n+                Class<?> actualArgType = am.getRawParameterType(0);\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (expArgType.isAssignableFrom(actualArgType)) {\n+                        return am.getAnnotated();\n+                    }\n                 }\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?>[] parameterTypes = am.getRawParameterTypes();\n            if (parameterTypes.length != 1) {\n                continue;\n            }\n            Class<?> actualArgType = parameterTypes[0];\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (expArgType.isAssignableFrom(actualArgType)) {\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,22 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public Method findFactoryMethod(Class<?>... expArgTypes) {\n+    // So, of all single-arg static methods:\n+    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n+        if (isFactoryMethod(am)) {\n+            // And must take one of expected arg types (or supertype)\n+            Class<?>[] parameterTypes = am.getRawParameterTypes();\n+            if (parameterTypes.length != 1) {\n+                continue;\n+            }\n+            Class<?> actualArgType = parameterTypes[0];\n+            for (Class<?> expArgType : expArgTypes) {\n+                // And one that matches what we would pass in\n+                if (expArgType.isAssignableFrom(actualArgType)) {\n+                    return am.getAnnotated();\n+                }\n+            }\n+        }\n     }\n-    try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n-    }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -5,10 +5,14 @@\n         // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n         if (isFactoryMethod(am)) {\n             // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n+            Class<?>[] parameterTypes = am.getRawParameterTypes();\n+            if (parameterTypes.length != 1) {\n+                continue;\n+            }\n+            Class<?> actualArgType = parameterTypes[0];\n             for (Class<?> expArgType : expArgTypes) {\n                 // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n+                if (expArgType.isAssignableFrom(actualArgType)) {\n                     return am.getAnnotated();\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            if (am.getParameterCount() != 1) {\n                continue;\n            }\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (actualArgType.isAssignableFrom(expArgType)) {\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,21 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public Method findFactoryMethod(Class<?>... expArgTypes) {\n+    // So, of all single-arg static methods:\n+    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n+        if (isFactoryMethod(am)) {\n+            // And must take one of expected arg types (or supertype)\n+            if (am.getParameterCount() != 1) {\n+                continue;\n+            }\n+            Class<?> actualArgType = am.getRawParameterType(0);\n+            for (Class<?> expArgType : expArgTypes) {\n+                // And one that matches what we would pass in\n+                if (actualArgType.isAssignableFrom(expArgType)) {\n+                    return am.getAnnotated();\n+                }\n+            }\n+        }\n     }\n-    try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n-    }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -5,6 +5,9 @@\n         // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n         if (isFactoryMethod(am)) {\n             // And must take one of expected arg types (or supertype)\n+            if (am.getParameterCount() != 1) {\n+                continue;\n+            }\n             Class<?> actualArgType = am.getRawParameterType(0);\n             for (Class<?> expArgType : expArgTypes) {\n                 // And one that matches what we would pass in\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            List<Class<?>> actualArgTypes = Arrays.asList(am.getRawParameterTypes());\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (actualArgTypes.contains(expArgType) || expArgType.isAssignableFrom(actualArgTypes.get(0))) {\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,18 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public Method findFactoryMethod(Class<?>... expArgTypes) {\n+    // So, of all single-arg static methods:\n+    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n+        if (isFactoryMethod(am)) {\n+            // And must take one of expected arg types (or supertype)\n+            List<Class<?>> actualArgTypes = Arrays.asList(am.getRawParameterTypes());\n+            for (Class<?> expArgType : expArgTypes) {\n+                // And one that matches what we would pass in\n+                if (actualArgTypes.contains(expArgType) || expArgType.isAssignableFrom(actualArgTypes.get(0))) {\n+                    return am.getAnnotated();\n+                }\n+            }\n+        }\n     }\n-    try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n-    }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -5,10 +5,10 @@\n         // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n         if (isFactoryMethod(am)) {\n             // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n+            List<Class<?>> actualArgTypes = Arrays.asList(am.getRawParameterTypes());\n             for (Class<?> expArgType : expArgTypes) {\n                 // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n+                if (actualArgTypes.contains(expArgType) || expArgType.isAssignableFrom(actualArgTypes.get(0))) {\n                     return am.getAnnotated();\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (expArgType.isAssignableFrom(actualArgType)) {\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,18 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public Method findFactoryMethod(Class<?>... expArgTypes) {\n+    // So, of all single-arg static methods:\n+    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n+        if (isFactoryMethod(am)) {\n+            // And must take one of expected arg types (or supertype)\n+            Class<?> actualArgType = am.getRawParameterType(0);\n+            for (Class<?> expArgType : expArgTypes) {\n+                // And one that matches what we would pass in\n+                if (expArgType.isAssignableFrom(actualArgType)) {\n+                    return am.getAnnotated();\n+                }\n+            }\n+        }\n     }\n-    try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n-    }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -8,7 +8,7 @@\n             Class<?> actualArgType = am.getRawParameterType(0);\n             for (Class<?> expArgType : expArgTypes) {\n                 // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n+                if (expArgType.isAssignableFrom(actualArgType)) {\n                     return am.getAnnotated();\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?>[] parameterTypes = am.getRawParameterTypes();\n            if (parameterTypes.length == 1 && parameterTypes[0].isAssignableFrom(expArgTypes[0])) {\n                return am.getAnnotated();\n            }\n        }\n    }\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,15 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public Method findFactoryMethod(Class<?>... expArgTypes) {\n+    // So, of all single-arg static methods:\n+    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n+        if (isFactoryMethod(am)) {\n+            // And must take one of expected arg types (or supertype)\n+            Class<?>[] parameterTypes = am.getRawParameterTypes();\n+            if (parameterTypes.length == 1 && parameterTypes[0].isAssignableFrom(expArgTypes[0])) {\n+                return am.getAnnotated();\n+            }\n+        }\n     }\n-    try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n-    }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -5,12 +5,9 @@\n         // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n         if (isFactoryMethod(am)) {\n             // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n-                }\n+            Class<?>[] parameterTypes = am.getRawParameterTypes();\n+            if (parameterTypes.length == 1 && parameterTypes[0].isAssignableFrom(expArgTypes[0])) {\n+                return am.getAnnotated();\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?>[] actualArgTypes = am.getRawParameterTypes(); // Fix: get all parameter types\n            if (actualArgTypes.length != 1) {\n                continue; // Fix: skip if more than 1 parameter\n            }\n            Class<?> actualArgType = actualArgTypes[0];\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (expArgType.isAssignableFrom(actualArgType)) { // Fix: swap isAssignableFrom arguments\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,22 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public Method findFactoryMethod(Class<?>... expArgTypes) {\n+    // So, of all single-arg static methods:\n+    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n+        if (isFactoryMethod(am)) {\n+            // And must take one of expected arg types (or supertype)\n+            Class<?>[] actualArgTypes = am.getRawParameterTypes(); // Fix: get all parameter types\n+            if (actualArgTypes.length != 1) {\n+                continue; // Fix: skip if more than 1 parameter\n+            }\n+            Class<?> actualArgType = actualArgTypes[0];\n+            for (Class<?> expArgType : expArgTypes) {\n+                // And one that matches what we would pass in\n+                if (expArgType.isAssignableFrom(actualArgType)) { // Fix: swap isAssignableFrom arguments\n+                    return am.getAnnotated();\n+                }\n+            }\n+        }\n     }\n-    try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n-    }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -5,10 +5,14 @@\n         // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n         if (isFactoryMethod(am)) {\n             // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n+            Class<?>[] actualArgTypes = am.getRawParameterTypes(); // Fix: get all parameter types\n+            if (actualArgTypes.length != 1) {\n+                continue; // Fix: skip if more than 1 parameter\n+            }\n+            Class<?> actualArgType = actualArgTypes[0];\n             for (Class<?> expArgType : expArgTypes) {\n                 // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n+                if (expArgType.isAssignableFrom(actualArgType)) { // Fix: swap isAssignableFrom arguments\n                     return am.getAnnotated();\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?>[] actualArgTypes = am.getRawParameterTypes(); // get all parameter types\n            if (actualArgTypes.length == 1) { // check number of parameters\n                Class<?> actualArgType = actualArgTypes[0];\n                for (Class<?> expArgType : expArgTypes) {\n                    // And one that matches what we would pass in\n                    if (actualArgType.isAssignableFrom(expArgType)) {\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,21 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public Method findFactoryMethod(Class<?>... expArgTypes) {\n+    // So, of all single-arg static methods:\n+    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n+        if (isFactoryMethod(am)) {\n+            // And must take one of expected arg types (or supertype)\n+            Class<?>[] actualArgTypes = am.getRawParameterTypes(); // get all parameter types\n+            if (actualArgTypes.length == 1) { // check number of parameters\n+                Class<?> actualArgType = actualArgTypes[0];\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (actualArgType.isAssignableFrom(expArgType)) {\n+                        return am.getAnnotated();\n+                    }\n+                }\n+            }\n+        }\n     }\n-    try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n-    }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -5,11 +5,14 @@\n         // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n         if (isFactoryMethod(am)) {\n             // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n+            Class<?>[] actualArgTypes = am.getRawParameterTypes(); // get all parameter types\n+            if (actualArgTypes.length == 1) { // check number of parameters\n+                Class<?> actualArgType = actualArgTypes[0];\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (actualArgType.isAssignableFrom(expArgType)) {\n+                        return am.getAnnotated();\n+                    }\n                 }\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?>[] actualArgTypes = am.getRawParameterTypes();\n            if (actualArgTypes.length == 1 && actualArgTypes[0] != null) {\n                for (Class<?> expArgType : expArgTypes) {\n                    // And one that matches what we would pass in\n                    if (actualArgTypes[0].isAssignableFrom(expArgType)) {\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,20 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public Method findFactoryMethod(Class<?>... expArgTypes) {\n+    // So, of all single-arg static methods:\n+    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n+        if (isFactoryMethod(am)) {\n+            // And must take one of expected arg types (or supertype)\n+            Class<?>[] actualArgTypes = am.getRawParameterTypes();\n+            if (actualArgTypes.length == 1 && actualArgTypes[0] != null) {\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (actualArgTypes[0].isAssignableFrom(expArgType)) {\n+                        return am.getAnnotated();\n+                    }\n+                }\n+            }\n+        }\n     }\n-    try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n-    }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -5,11 +5,13 @@\n         // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n         if (isFactoryMethod(am)) {\n             // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n+            Class<?>[] actualArgTypes = am.getRawParameterTypes();\n+            if (actualArgTypes.length == 1 && actualArgTypes[0] != null) {\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (actualArgTypes[0].isAssignableFrom(expArgType)) {\n+                        return am.getAnnotated();\n+                    }\n                 }\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?>[] actualArgTypes = am.getRawParameterTypes(); // get all parameter types\n            if (actualArgTypes.length == 1) { // ensure only one param\n                for (Class<?> expArgType : expArgTypes) {\n                    // And one that matches what we would pass in\n                    if (actualArgTypes[0].isAssignableFrom(expArgType)) {\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,20 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public Method findFactoryMethod(Class<?>... expArgTypes) {\n+    // So, of all single-arg static methods:\n+    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n+        if (isFactoryMethod(am)) {\n+            // And must take one of expected arg types (or supertype)\n+            Class<?>[] actualArgTypes = am.getRawParameterTypes(); // get all parameter types\n+            if (actualArgTypes.length == 1) { // ensure only one param\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (actualArgTypes[0].isAssignableFrom(expArgType)) {\n+                        return am.getAnnotated();\n+                    }\n+                }\n+            }\n+        }\n     }\n-    try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n-    }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -5,11 +5,13 @@\n         // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n         if (isFactoryMethod(am)) {\n             // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n+            Class<?>[] actualArgTypes = am.getRawParameterTypes(); // get all parameter types\n+            if (actualArgTypes.length == 1) { // ensure only one param\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (actualArgTypes[0].isAssignableFrom(expArgType)) {\n+                        return am.getAnnotated();\n+                    }\n                 }\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?>[] actualArgTypes = am.getRawParameterTypes(); // change to getRawParameterTypes() to get array of parameter types\n            if (actualArgTypes.length != 1) { // check if it takes exactly one argument\n                continue;\n            }\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (actualArgTypes[0].isAssignableFrom(expArgType)) { // use the first (and only) parameter type for comparison\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,21 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public Method findFactoryMethod(Class<?>... expArgTypes) {\n+    // So, of all single-arg static methods:\n+    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n+        if (isFactoryMethod(am)) {\n+            // And must take one of expected arg types (or supertype)\n+            Class<?>[] actualArgTypes = am.getRawParameterTypes(); // change to getRawParameterTypes() to get array of parameter types\n+            if (actualArgTypes.length != 1) { // check if it takes exactly one argument\n+                continue;\n+            }\n+            for (Class<?> expArgType : expArgTypes) {\n+                // And one that matches what we would pass in\n+                if (actualArgTypes[0].isAssignableFrom(expArgType)) { // use the first (and only) parameter type for comparison\n+                    return am.getAnnotated();\n+                }\n+            }\n+        }\n     }\n-    try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n-    }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -5,10 +5,13 @@\n         // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n         if (isFactoryMethod(am)) {\n             // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n+            Class<?>[] actualArgTypes = am.getRawParameterTypes(); // change to getRawParameterTypes() to get array of parameter types\n+            if (actualArgTypes.length != 1) { // check if it takes exactly one argument\n+                continue;\n+            }\n             for (Class<?> expArgType : expArgTypes) {\n                 // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n+                if (actualArgTypes[0].isAssignableFrom(expArgType)) { // use the first (and only) parameter type for comparison\n                     return am.getAnnotated();\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?>[] actualArgTypes = am.getRawParameterTypes(); //get all parameter types\n            if (actualArgTypes.length == 1) {\n                Class<?> actualArgType = actualArgTypes[0];\n                for (Class<?> expArgType : expArgTypes) {\n                    // And one that matches what we would pass in\n                    if (expArgType.isAssignableFrom(actualArgType)) { //reverse the order of comparison\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,21 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public Method findFactoryMethod(Class<?>... expArgTypes) {\n+    // So, of all single-arg static methods:\n+    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n+        if (isFactoryMethod(am)) {\n+            // And must take one of expected arg types (or supertype)\n+            Class<?>[] actualArgTypes = am.getRawParameterTypes(); //get all parameter types\n+            if (actualArgTypes.length == 1) {\n+                Class<?> actualArgType = actualArgTypes[0];\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (expArgType.isAssignableFrom(actualArgType)) { //reverse the order of comparison\n+                        return am.getAnnotated();\n+                    }\n+                }\n+            }\n+        }\n     }\n-    try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n-    }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -5,11 +5,14 @@\n         // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n         if (isFactoryMethod(am)) {\n             // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n+            Class<?>[] actualArgTypes = am.getRawParameterTypes(); //get all parameter types\n+            if (actualArgTypes.length == 1) {\n+                Class<?> actualArgType = actualArgTypes[0];\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (expArgType.isAssignableFrom(actualArgType)) { //reverse the order of comparison\n+                        return am.getAnnotated();\n+                    }\n                 }\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        if (isFactoryMethod(am) && am.getParameterCount() == 1) {\n            // And must take one of expected arg types (or supertype)\n            Class<?> actualArgType = am.getRawParameterType(0);\n            for (Class<?> expArgType : expArgTypes) {\n                // And one that matches what we would pass in\n                if (actualArgType.isAssignableFrom(expArgType)) {\n                    return am.getAnnotated();\n                }\n            }\n        }\n    }\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,17 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public Method findFactoryMethod(Class<?>... expArgTypes) {\n+    // So, of all single-arg static methods:\n+    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+        if (isFactoryMethod(am) && am.getParameterCount() == 1) {\n+            // And must take one of expected arg types (or supertype)\n+            Class<?> actualArgType = am.getRawParameterType(0);\n+            for (Class<?> expArgType : expArgTypes) {\n+                // And one that matches what we would pass in\n+                if (actualArgType.isAssignableFrom(expArgType)) {\n+                    return am.getAnnotated();\n+                }\n+            }\n+        }\n     }\n-    try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n-    }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -2,8 +2,7 @@\n public Method findFactoryMethod(Class<?>... expArgTypes) {\n     // So, of all single-arg static methods:\n     for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n-        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n-        if (isFactoryMethod(am)) {\n+        if (isFactoryMethod(am) && am.getParameterCount() == 1) {\n             // And must take one of expected arg types (or supertype)\n             Class<?> actualArgType = am.getRawParameterType(0);\n             for (Class<?> expArgType : expArgTypes) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?>[] actualArgTypes = am.getRawParameterTypes(); //get all parameter types\n            if(actualArgTypes.length == 1){ //if there is only one parameter\n                Class<?> actualArgType = actualArgTypes[0];\n                for (Class<?> expArgType : expArgTypes) {\n                    // And one that matches what we would pass in\n                    if (actualArgType.isAssignableFrom(expArgType)) {\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,21 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public Method findFactoryMethod(Class<?>... expArgTypes) {\n+    // So, of all single-arg static methods:\n+    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n+        if (isFactoryMethod(am)) {\n+            // And must take one of expected arg types (or supertype)\n+            Class<?>[] actualArgTypes = am.getRawParameterTypes(); //get all parameter types\n+            if(actualArgTypes.length == 1){ //if there is only one parameter\n+                Class<?> actualArgType = actualArgTypes[0];\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (actualArgType.isAssignableFrom(expArgType)) {\n+                        return am.getAnnotated();\n+                    }\n+                }\n+            }\n+        }\n     }\n-    try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n-    }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -5,11 +5,14 @@\n         // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n         if (isFactoryMethod(am)) {\n             // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n+            Class<?>[] actualArgTypes = am.getRawParameterTypes(); //get all parameter types\n+            if(actualArgTypes.length == 1){ //if there is only one parameter\n+                Class<?> actualArgType = actualArgTypes[0];\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (actualArgType.isAssignableFrom(expArgType)) {\n+                        return am.getAnnotated();\n+                    }\n                 }\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Method findFactoryMethod(Class<?>... expArgTypes) {\n    // So, of all single-arg static methods:\n    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n        if (isFactoryMethod(am)) {\n            // And must take one of expected arg types (or supertype)\n            Class<?>[] actualArgTypes = am.getRawParameterTypes(); // Fix: use getRawParameterTypes() instead of getRawParameterType(0)\n            if (actualArgTypes.length == 1) { // Fix: check that there is only 1 parameter\n                for (Class<?> expArgType : expArgTypes) {\n                    // And one that matches what we would pass in\n                    if (actualArgTypes[0].isAssignableFrom(expArgType)) { // Fix: use actualArgTypes[0]\n                        return am.getAnnotated();\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,20 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public Method findFactoryMethod(Class<?>... expArgTypes) {\n+    // So, of all single-arg static methods:\n+    for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+        // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n+        if (isFactoryMethod(am)) {\n+            // And must take one of expected arg types (or supertype)\n+            Class<?>[] actualArgTypes = am.getRawParameterTypes(); // Fix: use getRawParameterTypes() instead of getRawParameterType(0)\n+            if (actualArgTypes.length == 1) { // Fix: check that there is only 1 parameter\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (actualArgTypes[0].isAssignableFrom(expArgType)) { // Fix: use actualArgTypes[0]\n+                        return am.getAnnotated();\n+                    }\n+                }\n+            }\n+        }\n     }\n-    try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: %s\", re.getMessage());\n-    }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@findFactoryMethod\n@@ -5,11 +5,13 @@\n         // 24-Oct-2016, tatu: Better ensure it only takes 1 arg, no matter what\n         if (isFactoryMethod(am)) {\n             // And must take one of expected arg types (or supertype)\n-            Class<?> actualArgType = am.getRawParameterType(0);\n-            for (Class<?> expArgType : expArgTypes) {\n-                // And one that matches what we would pass in\n-                if (actualArgType.isAssignableFrom(expArgType)) {\n-                    return am.getAnnotated();\n+            Class<?>[] actualArgTypes = am.getRawParameterTypes(); // Fix: use getRawParameterTypes() instead of getRawParameterType(0)\n+            if (actualArgTypes.length == 1) { // Fix: check that there is only 1 parameter\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (actualArgTypes[0].isAssignableFrom(expArgType)) { // Fix: use actualArgTypes[0]\n+                        return am.getAnnotated();\n+                    }\n                 }\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}]