[{"output": "// Prevent the creation of unnecessary temporary strings for often\n// repeated values.\nvoid appendLineMappings() throws IOException {\n    Preconditions.checkState(!mappings.isEmpty());\n    // Start the first line.\n    openLine();\n    // And close the final line.\n    // The last line and column written\n    // Append the line mapping entries.\n    // The mapping list is ordered as a pre-order traversal. The mapping\n    // positions give us enough information to rebuild the stack and this\n    // allows the building of the source map in O(n) time.\n    Deque<Mapping> stack = new ArrayDeque<Mapping>();\n    for (Mapping m : mappings) {\n        // Find the closest ancestor of the current mapping:\n        // An overlapping mapping is an ancestor of the current mapping, any\n        // non-overlapping mappings are siblings (or cousins) and must be\n        // closed in the reverse order of when they were encountered.\n        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n            Mapping previous = stack.pop();\n            writeClosedMapping(previous);\n        }\n        // Any gaps between the current line position and the start of the\n        // current mapping belong to the parent.\n        Mapping parent = stack.peek();\n        writeCharsBetween(parent, m);\n        stack.push(m);\n    }\n    // There are no more children to be had, simply close the remaining\n    // mappings in the reverse order of when they were encountered.\n    while (!stack.isEmpty()) {\n        Mapping m = stack.pop();\n        writeClosedMapping(m);\n    }\n    closeLine();\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 8}, {"output": "// Prevent the creation of unnecessary temporary stings for often\n// repeated values.\nvoid appendLineMappings() throws IOException {\n    Preconditions.checkState(!mappings.isEmpty());\n    // Start the first line.\n    openLine();\n    // And close the final line.\n    closeLine(mappingIterator.peek().endLine());\n    // Append the line mapping entries.\n    // The mapping list is ordered as a pre-order traversal.  The mapping\n    // positions give us enough information to rebuild the stack and this\n    // allows the building of the source map in O(n) time.\n    Deque<Mapping> stack = new ArrayDeque<Mapping>();\n    for (Mapping m : mappings) {\n        // Find the closest ancestor of the current mapping:\n        // An overlapping mapping is an ancestor of the current mapping, any\n        // non-overlapping mappings are siblings (or cousins) and must be\n        // closed in the reverse order of when they encountered.\n        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n            Mapping previous = stack.pop();\n            writeClosedMapping(previous);\n        }\n        // Any gaps between the current line position and the start of the\n        // current mapping belong to the parent.\n        Mapping parent = stack.peek();\n        writeCharsBetween(parent, m);\n        stack.push(m);\n    }\n    // There are no more children to be had, simply close the remaining\n    // mappings in the reverse order of when they encountered.\n    while (!stack.isEmpty()) {\n        Mapping m = stack.pop();\n        writeClosedMapping(m);\n    }\n}", "diff": "--- com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n+++ com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n@@ -5,7 +5,7 @@\n     // Start the first line.\n     openLine();\n     // And close the final line.\n-                                // The last line and column written\n+    closeLine(mappingIterator.peek().endLine());\n     // Append the line mapping entries.\n     // The mapping list is ordered as a pre-order traversal.  The mapping\n     // positions give us enough information to rebuild the stack and this\n@@ -32,5 +32,4 @@\n         Mapping m = stack.pop();\n         writeClosedMapping(m);\n     }\n-    closeLine();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// Prevent the creation of unnecessary temporary stings for often\n// repeated values.\nvoid appendLineMappings() throws IOException {\n    Preconditions.checkState(!mappings.isEmpty());\n    // Start the first line.\n    openLine();\n    // And close the final line.\n                                // The last line and column written\n    // Append the line mapping entries.\n    // The mapping list is ordered as a pre-order traversal.  The mapping\n    // positions give us enough information to rebuild the stack and this\n    // allows the building of the source map in O(n) time.\n    Deque<Mapping> stack = new ArrayDeque<Mapping>();\n    for (Mapping m : mappings) {\n        // Find the closest ancestor of the current mapping:\n        // An overlapping mapping is an ancestor of the current mapping, any\n        // non-overlapping mappings are siblings (or cousins) and must be\n        // closed in the reverse order of when they encountered.\n        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n            Mapping previous = stack.pop();\n            writeClosedMapping(previous);\n        }\n        // Check if the stack is empty after the while loop i.e. root node, there is no need for parent\n        Mapping parent = stack.isEmpty() ? null : stack.peek();\n        // Any gaps between the current line position and the start of the\n        // current mapping belong to the parent.\n        writeCharsBetween(parent, m);\n        stack.push(m);\n    }\n    // There are no more children to be had, simply close the remaining\n    // mappings in the reverse order of when they encountered.\n    while (!stack.isEmpty()) {\n        Mapping m = stack.pop();\n        writeClosedMapping(m);\n    }\n    closeLine();\n}", "diff": "--- com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n+++ com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n@@ -20,9 +20,10 @@\n             Mapping previous = stack.pop();\n             writeClosedMapping(previous);\n         }\n+        // Check if the stack is empty after the while loop i.e. root node, there is no need for parent\n+        Mapping parent = stack.isEmpty() ? null : stack.peek();\n         // Any gaps between the current line position and the start of the\n         // current mapping belong to the parent.\n-        Mapping parent = stack.peek();\n         writeCharsBetween(parent, m);\n         stack.push(m);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// Prevent the creation of unnecessary temporary stings for often\n// repeated values.\nvoid appendLineMappings() throws IOException {\n    Preconditions.checkState(!mappings.isEmpty());\n    // Start the first line.\n    openLine();\n    // And close the final line.\n                                // The last line and column written\n    // Append the line mapping entries.\n    // The mapping list is ordered as a pre-order traversal.  The mapping\n    // positions give us enough information to rebuild the stack and this\n    // allows the building of the source map in O(n) time.\n    Deque<Mapping> stack = new ArrayDeque<Mapping>();\n    for (Mapping m : mappings) {\n        // Find the closest ancestor of the current mapping:\n        // An overlapping mapping is an ancestor of the current mapping, any\n        // non-overlapping mappings are siblings (or cousins) and must be\n        // closed in the reverse order of when they encountered.\n        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n            Mapping previous = stack.pop();\n            if (previous.isClosed()) {\n                // Check if the mapping is already closed to avoid writing it twice.\n                continue;\n            }\n            writeClosedMapping(previous);\n        }\n        // Any gaps between the current line position and the start of the\n        // current mapping belong to the parent.\n        Mapping parent = stack.peek();\n        writeCharsBetween(parent, m);\n        stack.push(m);\n    }\n    // There are no more children to be had, simply close the remaining\n    // mappings in the reverse order of when they encountered.\n    while (!stack.isEmpty()) {\n        Mapping m = stack.pop();\n        if (!m.isClosed()) {\n            // Check if the mapping is already closed to avoid writing it twice.\n            writeClosedMapping(m);\n        }\n    }\n    closeLine();\n}", "diff": "--- com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n+++ com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n@@ -18,6 +18,10 @@\n         // closed in the reverse order of when they encountered.\n         while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n             Mapping previous = stack.pop();\n+            if (previous.isClosed()) {\n+                // Check if the mapping is already closed to avoid writing it twice.\n+                continue;\n+            }\n             writeClosedMapping(previous);\n         }\n         // Any gaps between the current line position and the start of the\n@@ -30,7 +34,10 @@\n     // mappings in the reverse order of when they encountered.\n     while (!stack.isEmpty()) {\n         Mapping m = stack.pop();\n-        writeClosedMapping(m);\n+        if (!m.isClosed()) {\n+            // Check if the mapping is already closed to avoid writing it twice.\n+            writeClosedMapping(m);\n+        }\n     }\n     closeLine();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// Prevent the creation of unnecessary temporary stings for often\n// repeated values.\nvoid appendLineMappings() throws IOException {\n    Preconditions.checkState(!mappings.isEmpty());\n    // Start the first line.\n    openLine();\n    // And close the final line.\n    // The last line and column written\n    // Append the line mapping entries.\n    // The mapping list is ordered as a pre-order traversal.  The mapping\n    // positions give us enough information to rebuild the stack and this\n    // allows the building of the source map in O(n) time.\n    Deque<Mapping> stack = new ArrayDeque<Mapping>();\n    for (Mapping m : mappings) {\n        // Find the closest ancestor of the current mapping:\n        // An overlapping mapping is an ancestor of the current mapping, any\n        // non-overlapping mappings are siblings (or cousins) and must be\n        // closed in the reverse order of when they encountered.\n        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n            Mapping previous = stack.pop();\n            writeClosedMapping(previous);\n        }\n        // Any gaps between the current line position and the start of the\n        // current mapping belong to the parent.\n        Mapping parent = stack.peek();\n        writeCharsBetween(parent, m);\n        stack.push(m);\n    }\n    // There are no more children to be had, simply close the remaining\n    // mappings in the reverse order of when they encountered.\n    while (!stack.isEmpty()) {\n        Mapping m = stack.pop();\n        writeClosedMapping(m);\n    }\n    closeLine();\n}", "diff": "--- com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n+++ com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n@@ -5,7 +5,7 @@\n     // Start the first line.\n     openLine();\n     // And close the final line.\n-                                // The last line and column written\n+    // The last line and column written\n     // Append the line mapping entries.\n     // The mapping list is ordered as a pre-order traversal.  The mapping\n     // positions give us enough information to rebuild the stack and this\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "// Prevent the creation of unnecessary temporary stings for often\n// repeated values.\nvoid appendLineMappings() throws IOException {\n    Preconditions.checkState(!mappings.isEmpty());\n    // Start the first line.\n    openLine();\n    // And close the final line.\n    // The last line and column written\n    // Append the line mapping entries.\n    // The mapping list is ordered as a pre-order traversal.  The mapping\n    // positions give us enough information to rebuild the stack and this\n    // allows the building of the source map in O(n) time.\n    Deque<Mapping> stack = new ArrayDeque<>();\n    Mapping previous = null; // Track previous mapping for closing non-overlapping mappings\n    for (Mapping m : mappings) {\n        // Find the closest ancestor of the current mapping:\n        // An overlapping mapping is an ancestor of the current mapping, any\n        // non-overlapping mappings are siblings (or cousins) and must be\n        // closed in the reverse order of when they encountered.\n        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n            previous = stack.pop();\n            writeClosedMapping(previous);\n        }\n        // Any gaps between the current line position and the start of the\n        // current mapping belong to the parent.\n        Mapping parent = !stack.isEmpty() ? stack.peek() : null;\n        writeCharsBetween(parent, m);\n        stack.push(m);\n    }\n    // Close any remaining non-overlapping mappings\n    while (previous != null) {\n        writeClosedMapping(previous);\n        previous = stack.isEmpty() || isOverlapped(stack.peek(), previous) ? null : stack.pop();\n    }\n    // There are no more children to be had, simply close the remaining\n    // mappings in the reverse order of when they encountered.\n    while (!stack.isEmpty()) {\n        writeClosedMapping(stack.pop());\n    }\n    closeLine();\n}", "diff": "--- com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n+++ com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n@@ -5,32 +5,37 @@\n     // Start the first line.\n     openLine();\n     // And close the final line.\n-                                // The last line and column written\n+    // The last line and column written\n     // Append the line mapping entries.\n     // The mapping list is ordered as a pre-order traversal.  The mapping\n     // positions give us enough information to rebuild the stack and this\n     // allows the building of the source map in O(n) time.\n-    Deque<Mapping> stack = new ArrayDeque<Mapping>();\n+    Deque<Mapping> stack = new ArrayDeque<>();\n+    Mapping previous = null; // Track previous mapping for closing non-overlapping mappings\n     for (Mapping m : mappings) {\n         // Find the closest ancestor of the current mapping:\n         // An overlapping mapping is an ancestor of the current mapping, any\n         // non-overlapping mappings are siblings (or cousins) and must be\n         // closed in the reverse order of when they encountered.\n         while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n-            Mapping previous = stack.pop();\n+            previous = stack.pop();\n             writeClosedMapping(previous);\n         }\n         // Any gaps between the current line position and the start of the\n         // current mapping belong to the parent.\n-        Mapping parent = stack.peek();\n+        Mapping parent = !stack.isEmpty() ? stack.peek() : null;\n         writeCharsBetween(parent, m);\n         stack.push(m);\n+    }\n+    // Close any remaining non-overlapping mappings\n+    while (previous != null) {\n+        writeClosedMapping(previous);\n+        previous = stack.isEmpty() || isOverlapped(stack.peek(), previous) ? null : stack.pop();\n     }\n     // There are no more children to be had, simply close the remaining\n     // mappings in the reverse order of when they encountered.\n     while (!stack.isEmpty()) {\n-        Mapping m = stack.pop();\n-        writeClosedMapping(m);\n+        writeClosedMapping(stack.pop());\n     }\n     closeLine();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// Prevent the creation of unnecessary temporary stings for often\n// repeated values.\nvoid appendLineMappings() throws IOException {\n    Preconditions.checkState(!mappings.isEmpty());\n    // Start the first line.\n    openLine();\n    // And close the final line.\n    closeLine(); // moved this line to be after the loop below\n    // Append the line mapping entries.\n    // The mapping list is ordered as a pre-order traversal.  The mapping\n    // positions give us enough information to rebuild the stack and this\n    // allows the building of the source map in O(n) time.\n    Deque<Mapping> stack = new ArrayDeque<Mapping>();\n    for (Mapping m : mappings) {\n        // Find the closest ancestor of the current mapping:\n        // An overlapping mapping is an ancestor of the current mapping, any\n        // non-overlapping mappings are siblings (or cousins) and must be\n        // closed in the reverse order of when they encountered.\n        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n            Mapping previous = stack.pop();\n            writeClosedMapping(previous);\n        }\n        // Any gaps between the current line position and the start of the\n        // current mapping belong to the parent.\n        Mapping parent = stack.peek();\n        writeCharsBetween(parent, m);\n        stack.push(m);\n    }\n    // There are no more children to be had, simply close the remaining\n    // mappings in the reverse order of when they encountered.\n    while (!stack.isEmpty()) {\n        Mapping m = stack.pop();\n        writeClosedMapping(m);\n    }\n}", "diff": "--- com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n+++ com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n@@ -5,7 +5,7 @@\n     // Start the first line.\n     openLine();\n     // And close the final line.\n-                                // The last line and column written\n+    closeLine(); // moved this line to be after the loop below\n     // Append the line mapping entries.\n     // The mapping list is ordered as a pre-order traversal.  The mapping\n     // positions give us enough information to rebuild the stack and this\n@@ -32,5 +32,4 @@\n         Mapping m = stack.pop();\n         writeClosedMapping(m);\n     }\n-    closeLine();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// Prevent the creation of unnecessary temporary stings for often\n// repeated values.\nvoid appendLineMappings() throws IOException {\n    Preconditions.checkState(!mappings.isEmpty());\n    // Start the first line.\n    openLine();\n    // And close the final line.\n                                // The last line and column written\n    // Append the line mapping entries.\n    // The mapping list is ordered as a pre-order traversal.  The mapping\n    // positions give us enough information to rebuild the stack and this\n    // allows the building of the source map in O(n) time.\n    Deque<Mapping> stack = new ArrayDeque<Mapping>();\n    for (Mapping m : mappings) {\n        // Find the closest ancestor of the current mapping:\n        // An overlapping mapping is an ancestor of the current mapping, any\n        // non-overlapping mappings are siblings (or cousins) and must be\n        // closed in the reverse order of when they encountered.\n        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n            Mapping previous = stack.pop();\n            writeClosedMapping(previous);\n        }\n        // Any gaps between the current line position and the start of the\n        // current mapping belong to the parent.\n        Mapping parent = stack.isEmpty() ? null : stack.peek();\n        writeCharsBetween(parent, m);\n        stack.push(m);\n    }\n    // There are no more children to be had, simply close the remaining\n    // mappings in the reverse order of when they encountered.\n    while (!stack.isEmpty()) {\n        Mapping m = stack.pop();\n        writeClosedMapping(m);\n    }\n    closeLine();\n}", "diff": "--- com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n+++ com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n@@ -22,7 +22,7 @@\n         }\n         // Any gaps between the current line position and the start of the\n         // current mapping belong to the parent.\n-        Mapping parent = stack.peek();\n+        Mapping parent = stack.isEmpty() ? null : stack.peek();\n         writeCharsBetween(parent, m);\n         stack.push(m);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// Prevent the creation of unnecessary temporary stings for often\n// repeated values.\nvoid appendLineMappings() throws IOException {\n    Preconditions.checkState(!mappings.isEmpty());\n    // Start the first line.\n    openLine();\n    // And close the final line.\n                                // The last line and column written\n    // Append the line mapping entries.\n    // The mapping list is ordered as a pre-order traversal.  The mapping\n    // positions give us enough information to rebuild the stack and this\n    // allows the building of the source map in O(n) time.\n    Deque<Mapping> stack = new ArrayDeque<Mapping>();\n    for (Mapping m : mappings) {\n        // Find the closest ancestor of the current mapping:\n        // An overlapping mapping is an ancestor of the current mapping, any\n        // non-overlapping mappings are siblings (or cousins) and must be\n        // closed in the reverse order of when they encountered.\n        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n            Mapping previous = stack.pop();\n            writeClosedMapping(previous);\n        }\n        // Any gaps between the current line position and the start of the\n        // current mapping belong to the parent.\n        Mapping parent = stack.peek();\n        writeCharsBetween(parent, m);\n        stack.push(m);\n    }\n    // There are no more children to be had, simply close the remaining\n    // mappings in the reverse order of when they encountered.\n    while (!stack.isEmpty()) { \n        // Added a null check to prevent NullPointerExceptions.\n        Mapping m = stack.pop();\n        if (m != null) writeClosedMapping(m);\n    }\n    closeLine();\n}", "diff": "--- com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n+++ com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n@@ -28,9 +28,10 @@\n     }\n     // There are no more children to be had, simply close the remaining\n     // mappings in the reverse order of when they encountered.\n-    while (!stack.isEmpty()) {\n+    while (!stack.isEmpty()) { \n+        // Added a null check to prevent NullPointerExceptions.\n         Mapping m = stack.pop();\n-        writeClosedMapping(m);\n+        if (m != null) writeClosedMapping(m);\n     }\n     closeLine();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// Prevent the creation of unnecessary temporary stings for often\n// repeated values.\nvoid appendLineMappings() throws IOException {\n    Preconditions.checkState(!mappings.isEmpty());\n    // Start the first line.\n    openLine();\n    // And close the final line.\n                                // The last line and column written\n    // Append the line mapping entries.\n    // The mapping list is ordered as a pre-order traversal.  The mapping\n    // positions give us enough information to rebuild the stack and this\n    // allows the building of the source map in O(n) time.\n    Deque<Mapping> stack = new ArrayDeque<Mapping>();\n    for (Mapping m : mappings) {\n        // Find the closest ancestor of the current mapping:\n        // An overlapping mapping is an ancestor of the current mapping, any\n        // non-overlapping mappings are siblings (or cousins) and must be\n        // closed in the reverse order of when they were encountered. // Corrected the typo\n        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n            Mapping previous = stack.pop();\n            writeClosedMapping(previous);\n        }\n        // Any gaps between the current line position and the start of the\n        // current mapping belong to the parent.\n        Mapping parent = stack.peek();\n        writeCharsBetween(parent, m);\n        stack.push(m);\n    }\n    // There are no more children to be had, simply close the remaining\n    // mappings in the reverse order of when they were encountered. // Corrected the typo\n    while (!stack.isEmpty()) {\n        Mapping m = stack.pop();\n        writeClosedMapping(m);\n    }\n    closeLine();\n}", "diff": "--- com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n+++ com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n@@ -15,7 +15,7 @@\n         // Find the closest ancestor of the current mapping:\n         // An overlapping mapping is an ancestor of the current mapping, any\n         // non-overlapping mappings are siblings (or cousins) and must be\n-        // closed in the reverse order of when they encountered.\n+        // closed in the reverse order of when they were encountered. // Corrected the typo\n         while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n             Mapping previous = stack.pop();\n             writeClosedMapping(previous);\n@@ -27,7 +27,7 @@\n         stack.push(m);\n     }\n     // There are no more children to be had, simply close the remaining\n-    // mappings in the reverse order of when they encountered.\n+    // mappings in the reverse order of when they were encountered. // Corrected the typo\n     while (!stack.isEmpty()) {\n         Mapping m = stack.pop();\n         writeClosedMapping(m);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// Prevent the creation of unnecessary temporary stings for often\n// repeated values.\nvoid appendLineMappings() throws IOException {\n    Preconditions.checkState(!mappings.isEmpty());\n    // Start the first line.\n    openLine();\n    // And close the final line.\n    // The last line and column written\n    // Append the line mapping entries.\n    // The mapping list is ordered as a pre-order traversal.  The mapping\n    // positions give us enough information to rebuild the stack and this\n    // allows the building of the source map in O(n) time.\n    Deque<Mapping> stack = new ArrayDeque<Mapping>();\n    Mapping previous = null;\n    for (Mapping m : mappings) {\n        // Find the closest ancestor of the current mapping:\n        // An overlapping mapping is an ancestor of the current mapping, any\n        // non-overlapping mappings are siblings (or cousins) and must be\n        // closed in the reverse order of when they encountered.\n        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n            previous = stack.pop();\n            writeClosedMapping(previous);\n        }\n        // Any gaps between the current line position and the start of the\n        // current mapping belong to the parent.\n        Mapping parent = stack.peek();\n        writeCharsBetween(parent, m);\n        stack.push(m);\n    }\n    // There are no more children to be had, simply close the remaining\n    // mappings in the reverse order in which they were originally pushed.\n    ArrayList<Mapping> closedMappings = new ArrayList<Mapping>();\n    while (!stack.isEmpty()) {\n        Mapping m = stack.pop();\n        closedMappings.add(m);\n    }\n    for (int i = closedMappings.size() - 1; i >= 0; i--) {\n        Mapping m = closedMappings.get(i);\n        writeClosedMapping(m);\n    }\n    closeLine();\n}", "diff": "--- com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n+++ com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n@@ -5,19 +5,20 @@\n     // Start the first line.\n     openLine();\n     // And close the final line.\n-                                // The last line and column written\n+    // The last line and column written\n     // Append the line mapping entries.\n     // The mapping list is ordered as a pre-order traversal.  The mapping\n     // positions give us enough information to rebuild the stack and this\n     // allows the building of the source map in O(n) time.\n     Deque<Mapping> stack = new ArrayDeque<Mapping>();\n+    Mapping previous = null;\n     for (Mapping m : mappings) {\n         // Find the closest ancestor of the current mapping:\n         // An overlapping mapping is an ancestor of the current mapping, any\n         // non-overlapping mappings are siblings (or cousins) and must be\n         // closed in the reverse order of when they encountered.\n         while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n-            Mapping previous = stack.pop();\n+            previous = stack.pop();\n             writeClosedMapping(previous);\n         }\n         // Any gaps between the current line position and the start of the\n@@ -27,9 +28,14 @@\n         stack.push(m);\n     }\n     // There are no more children to be had, simply close the remaining\n-    // mappings in the reverse order of when they encountered.\n+    // mappings in the reverse order in which they were originally pushed.\n+    ArrayList<Mapping> closedMappings = new ArrayList<Mapping>();\n     while (!stack.isEmpty()) {\n         Mapping m = stack.pop();\n+        closedMappings.add(m);\n+    }\n+    for (int i = closedMappings.size() - 1; i >= 0; i--) {\n+        Mapping m = closedMappings.get(i);\n         writeClosedMapping(m);\n     }\n     closeLine();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// Prevent the creation of unnecessary temporary stings for often\n// repeated values.\nvoid appendLineMappings() throws IOException {\n    Preconditions.checkState(!mappings.isEmpty());\n    // Start the first line.\n    openLine();\n    // And close the final line.\n    // The last line and column written\n    // Append the line mapping entries.\n    // The mapping list is ordered as a pre-order traversal.  The mapping\n    // positions give us enough information to rebuild the stack and this\n    // allows the building of the source map in O(n) time.\n    Deque<Mapping> stack = new ArrayDeque<Mapping>();\n    for (Mapping m : mappings) {\n        // Find the closest ancestor of the current mapping:\n        // An overlapping mapping is an ancestor of the current mapping, any\n        // non-overlapping mappings are siblings (or cousins) and must be\n        // closed in the reverse order of when they were encountered.\n        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n            Mapping previous = stack.pop();\n            writeClosedMapping(previous);\n        }\n        // Any gaps between the current line position and the start of the\n        // current mapping belong to the parent.\n        Mapping parent = stack.peek();\n        writeCharsBetween(parent, m);\n        stack.push(m);\n    }\n    // There are no more children to be had, simply close the remaining\n    // mappings in the reverse order of when they were encountered.\n    while (!stack.isEmpty()) {\n        Mapping m = stack.pop();\n        writeClosedMapping(m);\n    }\n    closeLine();\n}", "diff": "--- com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n+++ com/google/javascript/jscomp/SourceMap.java@appendLineMappings\n@@ -5,7 +5,7 @@\n     // Start the first line.\n     openLine();\n     // And close the final line.\n-                                // The last line and column written\n+    // The last line and column written\n     // Append the line mapping entries.\n     // The mapping list is ordered as a pre-order traversal.  The mapping\n     // positions give us enough information to rebuild the stack and this\n@@ -15,7 +15,7 @@\n         // Find the closest ancestor of the current mapping:\n         // An overlapping mapping is an ancestor of the current mapping, any\n         // non-overlapping mappings are siblings (or cousins) and must be\n-        // closed in the reverse order of when they encountered.\n+        // closed in the reverse order of when they were encountered.\n         while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n             Mapping previous = stack.pop();\n             writeClosedMapping(previous);\n@@ -27,7 +27,7 @@\n         stack.push(m);\n     }\n     // There are no more children to be had, simply close the remaining\n-    // mappings in the reverse order of when they encountered.\n+    // mappings in the reverse order of when they were encountered.\n     while (!stack.isEmpty()) {\n         Mapping m = stack.pop();\n         writeClosedMapping(m);\n", "finish_reason": "stop", "valid": false, "num": 1}]