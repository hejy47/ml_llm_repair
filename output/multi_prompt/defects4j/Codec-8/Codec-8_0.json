[{"output": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset > b.length || offset + len > b.length) { //combine two checks into one\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n                while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,9 +1,7 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset > b.length || offset + len > b.length) { //combine two checks into one\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n                while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,9 +1,7 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) { // Fix: Adding additional check\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,15 +1,13 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) { // Fix: Adding additional check\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) { //fixed conditions\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,15 +1,13 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) { //fixed conditions\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,15 +1,13 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0 && len > 0) { // fixed condition to check for len > 0\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -9,7 +9,7 @@\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0 && len > 0) { // fixed condition to check for len > 0\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        //merge the second and third checks\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,15 +1,14 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n+        //merge the second and third checks\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset >= b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n                while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -3,7 +3,7 @@\n         throw new NullPointerException();\n     } else if (offset < 0 || len < 0) {\n         throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset >= b.length || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length || offset + len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen;\n\n        while (true) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c == -1) {\n                    break;\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n            if (readLen != 0) {\n                break;\n            } else if (base64.hasData()) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        if (readLen == 0) {\n            return -1;\n        }\n        return readLen;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -3,18 +3,19 @@\n         throw new NullPointerException();\n     } else if (offset < 0 || len < 0) {\n         throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset > b.length || offset + len > b.length || offset + len < 0) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n-        int readLen = 0;\n-                while (readLen == 0) {\n+        int readLen;\n+\n+        while (true) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n-                if (c > 0 && b.length == len) {\n-                    base64.setInitialBuffer(b, offset, len);\n+                if (c == -1) {\n+                    break;\n                 }\n                 if (doEncode) {\n                     base64.encode(buf, 0, c);\n@@ -23,6 +24,16 @@\n                 }\n             }\n             readLen = base64.readResults(b, offset, len);\n+            if (readLen != 0) {\n+                break;\n+            } else if (base64.hasData()) {\n+                continue;\n+            } else {\n+                break;\n+            }\n+        }\n+        if (readLen == 0) {\n+            return -1;\n         }\n         return readLen;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) { // Changed condition to check for buffer overflow\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,15 +1,13 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) { // Changed condition to check for buffer overflow\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n                while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == offset+len) { // Check that b has enough space\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,9 +1,7 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n@@ -13,7 +11,7 @@\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n-                if (c > 0 && b.length == len) {\n+                if (c > 0 && b.length == offset+len) { // Check that b has enough space\n                     base64.setInitialBuffer(b, offset, len);\n                 }\n                 if (doEncode) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) { // fix: check if offset + len exceed the array length\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,15 +1,13 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) { // fix: check if offset + len exceed the array length\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n                while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && len == b.length) {\n                    base64.setInitialBuffer(b, 0, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n            offset += readLen;\n            len -= readLen;\n        }\n        return readLen;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,9 +1,7 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n@@ -13,8 +11,8 @@\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n-                if (c > 0 && b.length == len) {\n-                    base64.setInitialBuffer(b, offset, len);\n+                if (c > 0 && len == b.length) {\n+                    base64.setInitialBuffer(b, 0, len);\n                 }\n                 if (doEncode) {\n                     base64.encode(buf, 0, c);\n@@ -23,6 +21,8 @@\n                 }\n             }\n             readLen = base64.readResults(b, offset, len);\n+            offset += readLen;\n+            len -= readLen;\n         }\n         return readLen;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n            offset += readLen;\n            len -= readLen;\n        }\n        return readLen;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,15 +1,13 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n@@ -23,6 +21,8 @@\n                 }\n             }\n             readLen = base64.readResults(b, offset, len);\n+            offset += readLen;\n+            len -= readLen;\n         }\n         return readLen;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset + readLen, len - readLen);\n        }\n        return readLen;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,15 +1,13 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n@@ -22,7 +20,7 @@\n                     base64.decode(buf, 0, c);\n                 }\n             }\n-            readLen = base64.readResults(b, offset, len);\n+            readLen = base64.readResults(b, offset + readLen, len - readLen);\n         }\n         return readLen;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public int read(byte[] b, int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                if (c > 0 && len >= c) {\n                    base64.setInitialBuffer(b, offset, len);\n                } else if (c > 0) {\n                    base64.setInitialBuffer(new byte[c], 0, c);\n                    if (doEncode) {\n                        base64.encode(buf, 0, c);\n                    } else {\n                        base64.decode(buf, 0, c);\n                    }\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}", "diff": "--- org/apache/commons/codec/binary/Base64InputStream.java@read\n+++ org/apache/commons/codec/binary/Base64InputStream.java@read\n@@ -1,25 +1,25 @@\n public int read(byte[] b, int offset, int len) throws IOException {\n     if (b == null) {\n         throw new NullPointerException();\n-    } else if (offset < 0 || len < 0) {\n-        throw new IndexOutOfBoundsException();\n-    } else if (offset > b.length || offset + len > b.length) {\n+    } else if (offset < 0 || len < 0 || offset + len > b.length) {\n         throw new IndexOutOfBoundsException();\n     } else if (len == 0) {\n         return 0;\n     } else {\n         int readLen = 0;\n-                while (readLen == 0) {\n+        while (readLen == 0) {\n             if (!base64.hasData()) {\n                 byte[] buf = new byte[doEncode ? 4096 : 8192];\n                 int c = in.read(buf);\n-                if (c > 0 && b.length == len) {\n+                if (c > 0 && len >= c) {\n                     base64.setInitialBuffer(b, offset, len);\n-                }\n-                if (doEncode) {\n-                    base64.encode(buf, 0, c);\n-                } else {\n-                    base64.decode(buf, 0, c);\n+                } else if (c > 0) {\n+                    base64.setInitialBuffer(new byte[c], 0, c);\n+                    if (doEncode) {\n+                        base64.encode(buf, 0, c);\n+                    } else {\n+                        base64.decode(buf, 0, c);\n+                    }\n                 }\n             }\n             readLen = base64.readResults(b, offset, len);\n", "finish_reason": "stop", "valid": false, "num": 1}]