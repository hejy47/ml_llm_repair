[{"output": "private void processPrototypeParent(Node n, CompilerInput input) {\n    switch(n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n        case Token.GETELEM:\n            Node dest = n.getFirstChild().getNext();\n            if (dest.getType() == Token.STRING) {\n                markPrototypePropertyCandidate(dest, input);\n            }\n            break;\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n        case Token.CALL:\n            Node map;\n            if (n.getType() == Token.ASSIGN) {\n                map = n.getLastChild();\n            } else {\n                map = n.getLastChild().getLastChild();\n            }\n            if (map.getType() == Token.OBJECTLIT) {\n                // Remember this node so that we can avoid processing it again when\n                // the traversal reaches it.\n                prototypeObjLits.add(map);\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n                    if (key.getType() != Token.NUMBER) {\n                        // May be STRING, GET, or SET\n                        markPrototypePropertyCandidate(key, input);\n                    }\n                }\n            }\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n+++ com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n@@ -13,9 +13,9 @@\n         case Token.CALL:\n             Node map;\n             if (n.getType() == Token.ASSIGN) {\n-                map = n.getFirstChild().getNext();\n+                map = n.getLastChild();\n             } else {\n-                map = n.getLastChild();\n+                map = n.getLastChild().getLastChild();\n             }\n             if (map.getType() == Token.OBJECTLIT) {\n                 // Remember this node so that we can avoid processing it again when\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void processPrototypeParent(Node n, CompilerInput input) {\n    switch(n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n        case Token.GETELEM:\n            Node dest = n.getFirstChild().getNext();\n            if (dest.getType() == Token.STRING) {\n                markPrototypePropertyCandidate(dest, input);\n            }\n            break;\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n            Node map = n.getLastChild();\n            if (map.getType() == Token.OBJECTLIT) {\n                // Remember this node so that we can avoid processing it again when\n                // the traversal reaches it.\n                prototypeObjLits.add(map);\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n                    if (key.getType() != Token.NUMBER) {\n                        // May be STRING, GET, or SET\n                        markPrototypePropertyCandidate(key, input);\n                    }\n                }\n            }\n            break;\n        case Token.CALL:\n            if (n.hasOneChild() && n.getFirstChild().getType() == Token.ASSIGN) {\n                // Foo.prototype = Object.create(parent.prototype)\n                Node assign = n.getFirstChild();\n                if (assign.getFirstChild().getType() == Token.GETPROP &&\n                        assign.getFirstChild().getLastChild().getString().equals(\"prototype\")) {\n                    prototypeObjLits.add(null);\n                }\n            }\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n+++ com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n@@ -10,13 +10,7 @@\n             break;\n         // Foo.prototype = { \"getBar\" : function() { ... } }\n         case Token.ASSIGN:\n-        case Token.CALL:\n-            Node map;\n-            if (n.getType() == Token.ASSIGN) {\n-                map = n.getFirstChild().getNext();\n-            } else {\n-                map = n.getLastChild();\n-            }\n+            Node map = n.getLastChild();\n             if (map.getType() == Token.OBJECTLIT) {\n                 // Remember this node so that we can avoid processing it again when\n                 // the traversal reaches it.\n@@ -29,5 +23,15 @@\n                 }\n             }\n             break;\n+        case Token.CALL:\n+            if (n.hasOneChild() && n.getFirstChild().getType() == Token.ASSIGN) {\n+                // Foo.prototype = Object.create(parent.prototype)\n+                Node assign = n.getFirstChild();\n+                if (assign.getFirstChild().getType() == Token.GETPROP &&\n+                        assign.getFirstChild().getLastChild().getString().equals(\"prototype\")) {\n+                    prototypeObjLits.add(null);\n+                }\n+            }\n+            break;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void processPrototypeParent(Node n, CompilerInput input) {\n    switch(n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n        case Token.GETELEM:\n            Node dest = n.getFirstChild().getNext();\n            if (dest.getType() == Token.STRING) {\n                markPrototypePropertyCandidate(dest, input);\n            }\n            break;\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n        case Token.CALL:\n            Node map;\n            if (n.getType() == Token.ASSIGN) {\n                map = n.getFirstChild().getNext();\n            } else {\n                map = n.getLastChild().getFirstChild();\n            }\n            if (map.getType() == Token.OBJECTLIT) {\n                // Remember this node so that we can avoid processing it again when\n                // the traversal reaches it.\n                prototypeObjLits.add(map);\n                for (Node key = map.getFirstChild().getNext(); key != null; key = key.getNext()) {\n                    if (key.getType() != Token.NUMBER) {\n                        // May be STRING, GET, or SET\n                        markPrototypePropertyCandidate(key, input);\n                    }\n                }\n            }\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n+++ com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n@@ -15,13 +15,13 @@\n             if (n.getType() == Token.ASSIGN) {\n                 map = n.getFirstChild().getNext();\n             } else {\n-                map = n.getLastChild();\n+                map = n.getLastChild().getFirstChild();\n             }\n             if (map.getType() == Token.OBJECTLIT) {\n                 // Remember this node so that we can avoid processing it again when\n                 // the traversal reaches it.\n                 prototypeObjLits.add(map);\n-                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n+                for (Node key = map.getFirstChild().getNext(); key != null; key = key.getNext()) {\n                     if (key.getType() != Token.NUMBER) {\n                         // May be STRING, GET, or SET\n                         markPrototypePropertyCandidate(key, input);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void processPrototypeParent(Node n, CompilerInput input) {\n    switch(n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n        case Token.GETELEM:\n            Node dest = n.getFirstChild().getNext();\n            if (dest != null && dest.getType() == Token.STRING) {\n                markPrototypePropertyCandidate(dest, input);\n            }\n            break;\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n        case Token.CALL:\n            Node map;\n            if (n.getType() == Token.ASSIGN) {\n                map = n.getFirstChild().getNext();\n            } else {\n                map = n.getLastChild();\n            }\n            if (map != null && map.getType() == Token.OBJECTLIT) {\n                // Remember this node so that we can avoid processing it again when\n                // the traversal reaches it.\n                prototypeObjLits.add(map);\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n                    if (key.getType() != Token.NUMBER) {\n                        // May be STRING, GET, or SET\n                        markPrototypePropertyCandidate(key, input);\n                    }\n                }\n            }\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n+++ com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n@@ -4,7 +4,7 @@\n         case Token.GETPROP:\n         case Token.GETELEM:\n             Node dest = n.getFirstChild().getNext();\n-            if (dest.getType() == Token.STRING) {\n+            if (dest != null && dest.getType() == Token.STRING) {\n                 markPrototypePropertyCandidate(dest, input);\n             }\n             break;\n@@ -17,7 +17,7 @@\n             } else {\n                 map = n.getLastChild();\n             }\n-            if (map.getType() == Token.OBJECTLIT) {\n+            if (map != null && map.getType() == Token.OBJECTLIT) {\n                 // Remember this node so that we can avoid processing it again when\n                 // the traversal reaches it.\n                 prototypeObjLits.add(map);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void processPrototypeParent(Node n, CompilerInput input) {\n    switch(n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n        case Token.GETELEM:\n            Node dest = n.getFirstChild().getNext();\n            if (dest.getType() == Token.STRING) {\n                markPrototypePropertyCandidate(dest, input);\n            }\n            break;\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n        case Token.CALL:\n            Node map;\n            if (n.getType() == Token.ASSIGN) {\n                map = n.getLastChild();\n            } else {\n                map = n.getFirstChild().getNext();\n            }\n            if (map.getType() == Token.OBJECTLIT) {\n                // Remember this node so that we can avoid processing it again when\n                // the traversal reaches it.\n                prototypeObjLits.add(map);\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n                    if (key.getType() != Token.NUMBER) {\n                        // May be STRING, GET, or SET\n                        markPrototypePropertyCandidate(key, input);\n                    }\n                }\n            }\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n+++ com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n@@ -13,9 +13,9 @@\n         case Token.CALL:\n             Node map;\n             if (n.getType() == Token.ASSIGN) {\n+                map = n.getLastChild();\n+            } else {\n                 map = n.getFirstChild().getNext();\n-            } else {\n-                map = n.getLastChild();\n             }\n             if (map.getType() == Token.OBJECTLIT) {\n                 // Remember this node so that we can avoid processing it again when\n", "finish_reason": "stop", "valid": false, "num": 5}, {"output": "private void processPrototypeParent(Node n, CompilerInput input) {\n    switch(n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n        case Token.GETELEM:\n            Node dest = n.getFirstChild().getNext();\n            if (dest.getType() == Token.STRING) {\n                markPrototypePropertyCandidate(dest, input);\n            }\n            break;\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n        case Token.CALL:\n            Node map;\n            if (n.getType() == Token.ASSIGN) {\n                map = n.getFirstChild().getNext();\n            } else {\n                map = n.getLastChild().getFirstChild();\n            }\n            if (map.getType() == Token.OBJECTLIT) {\n                // Remember this node so that we can avoid processing it again when\n                // the traversal reaches it.\n                prototypeObjLits.add(map);\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n                    if (key.getType() != Token.NUMBER) {\n                        // May be STRING, GET, or SET\n                        markPrototypePropertyCandidate(key, input);\n                    }\n                }\n            }\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n+++ com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n@@ -15,7 +15,7 @@\n             if (n.getType() == Token.ASSIGN) {\n                 map = n.getFirstChild().getNext();\n             } else {\n-                map = n.getLastChild();\n+                map = n.getLastChild().getFirstChild();\n             }\n             if (map.getType() == Token.OBJECTLIT) {\n                 // Remember this node so that we can avoid processing it again when\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private void processPrototypeParent(Node n, CompilerInput input) {\n    switch(n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n        case Token.GETELEM:\n            Node dest = n.getFirstChild().getNext();\n            if (dest.getType() == Token.STRING) {\n                markPrototypePropertyCandidate(dest, input);\n            }\n            break;\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n        case Token.CALL:\n            Node map;\n            if (n.getType() == Token.ASSIGN) {\n                map = n.getLastChild();\n            } else {\n                map = n.getFirstChild();\n            }\n            if (map.getType() == Token.OBJECTLIT) {\n                // Remember this node so that we can avoid processing it again when\n                // the traversal reaches it.\n                prototypeObjLits.add(map);\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n                    if (key.getType() != Token.NUMBER) {\n                        // May be STRING, GET, or SET\n                        markPrototypePropertyCandidate(key, input);\n                    }\n                }\n            }\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n+++ com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n@@ -13,9 +13,9 @@\n         case Token.CALL:\n             Node map;\n             if (n.getType() == Token.ASSIGN) {\n-                map = n.getFirstChild().getNext();\n+                map = n.getLastChild();\n             } else {\n-                map = n.getLastChild();\n+                map = n.getFirstChild();\n             }\n             if (map.getType() == Token.OBJECTLIT) {\n                 // Remember this node so that we can avoid processing it again when\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void processPrototypeParent(Node n, CompilerInput input) {\n    switch(n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n        case Token.GETELEM:\n            Node dest = n.getFirstChild().getNext();\n            if (dest.getType() == Token.STRING) {\n                markPrototypePropertyCandidate(dest, input);\n            }\n            break;\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n            Node map = n.getLastChild();\n            if (map.getType() == Token.OBJECTLIT) {\n                // Remember this node so that we can avoid processing it again when\n                // the traversal reaches it.\n                prototypeObjLits.add(map);\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n                    if (key.getType() != Token.NUMBER) {\n                        // May be STRING, GET, or SET\n                        markPrototypePropertyCandidate(key, input);\n                    }\n                }\n            }\n            break;\n        case Token.CALL:\n            Node callee = n.getFirstChild();\n            if (callee.getType() == Token.GETPROP && \"Object\".equals(callee.getFirstChild().getQualifiedName()) && \"defineProperties\".equals(callee.getLastChild().getString())) {\n                Node object = n.getLastChild();\n                for (Node property = object.getFirstChild(); property != null; property = property.getNext()) {\n                    Node propValue = property.getLastChild();\n                    if (propValue.getType() == Token.OBJECTLIT) {\n                        // Remember this node so that we can avoid processing it again when\n                        // the traversal reaches it.\n                        prototypeObjLits.add(propValue);\n                        for (Node key = propValue.getFirstChild(); key != null; key = key.getNext()) {\n                            if (key.getType() != Token.NUMBER) {\n                                // May be STRING, GET, or SET\n                                markPrototypePropertyCandidate(key, input);\n                            }\n                        }\n                    }\n                }\n            }\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n+++ com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n@@ -10,13 +10,7 @@\n             break;\n         // Foo.prototype = { \"getBar\" : function() { ... } }\n         case Token.ASSIGN:\n-        case Token.CALL:\n-            Node map;\n-            if (n.getType() == Token.ASSIGN) {\n-                map = n.getFirstChild().getNext();\n-            } else {\n-                map = n.getLastChild();\n-            }\n+            Node map = n.getLastChild();\n             if (map.getType() == Token.OBJECTLIT) {\n                 // Remember this node so that we can avoid processing it again when\n                 // the traversal reaches it.\n@@ -29,5 +23,25 @@\n                 }\n             }\n             break;\n+        case Token.CALL:\n+            Node callee = n.getFirstChild();\n+            if (callee.getType() == Token.GETPROP && \"Object\".equals(callee.getFirstChild().getQualifiedName()) && \"defineProperties\".equals(callee.getLastChild().getString())) {\n+                Node object = n.getLastChild();\n+                for (Node property = object.getFirstChild(); property != null; property = property.getNext()) {\n+                    Node propValue = property.getLastChild();\n+                    if (propValue.getType() == Token.OBJECTLIT) {\n+                        // Remember this node so that we can avoid processing it again when\n+                        // the traversal reaches it.\n+                        prototypeObjLits.add(propValue);\n+                        for (Node key = propValue.getFirstChild(); key != null; key = key.getNext()) {\n+                            if (key.getType() != Token.NUMBER) {\n+                                // May be STRING, GET, or SET\n+                                markPrototypePropertyCandidate(key, input);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            break;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void processPrototypeParent(Node n, CompilerInput input) {\n    switch(n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n        case Token.GETELEM:\n            Node dest = n.getFirstChild().getNext();\n            if (dest.getType() == Token.STRING) {\n                markPrototypePropertyCandidate(dest, input);\n            }\n            break;\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n        case Token.CALL:\n            Node map;\n            if (n.getType() == Token.ASSIGN) {\n                map = n.getLastChild();  // changed from getFirstChild().getNext() to getLastChild()\n            } else {\n                map = n.getLastChild();\n            }\n            if (map.getType() == Token.OBJECTLIT) {\n                // Remember this node so that we can avoid processing it again when\n                // the traversal reaches it.\n                prototypeObjLits.add(map);\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n                    if (key.getType() != Token.NUMBER) {\n                        // May be STRING, GET, or SET\n                        markPrototypePropertyCandidate(key, input);\n                    }\n                }\n            }\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n+++ com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n@@ -13,7 +13,7 @@\n         case Token.CALL:\n             Node map;\n             if (n.getType() == Token.ASSIGN) {\n-                map = n.getFirstChild().getNext();\n+                map = n.getLastChild();  // changed from getFirstChild().getNext() to getLastChild()\n             } else {\n                 map = n.getLastChild();\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void processPrototypeParent(Node n, CompilerInput input) {\n    switch(n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n        case Token.GETELEM:\n            Node dest = n.getFirstChild().getNext();\n            if (dest.getType() == Token.STRING) {\n                markPrototypePropertyCandidate(dest, input);\n            }\n            break;\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n        case Token.CALL:\n            Node map;\n            if (n.getType() == Token.ASSIGN) {\n                map = n.getFirstChild().getNext();\n            } else {\n                map = n.getLastChild().getFirstChild();\n            }\n            if (map.getType() == Token.OBJECTLIT) {\n                // Remember this node so that we can avoid processing it again when\n                // the traversal reaches it.\n                prototypeObjLits.add(map);\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n                    if (key.getType() != Token.NUMBER) {\n                        // May be STRING, GET, or SET\n                        markPrototypePropertyCandidate(key.getFirstChild(), input);\n                    }\n                }\n            }\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n+++ com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n@@ -15,7 +15,7 @@\n             if (n.getType() == Token.ASSIGN) {\n                 map = n.getFirstChild().getNext();\n             } else {\n-                map = n.getLastChild();\n+                map = n.getLastChild().getFirstChild();\n             }\n             if (map.getType() == Token.OBJECTLIT) {\n                 // Remember this node so that we can avoid processing it again when\n@@ -24,7 +24,7 @@\n                 for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n                     if (key.getType() != Token.NUMBER) {\n                         // May be STRING, GET, or SET\n-                        markPrototypePropertyCandidate(key, input);\n+                        markPrototypePropertyCandidate(key.getFirstChild(), input);\n                     }\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void processPrototypeParent(Node n, CompilerInput input) {\n    switch (n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n        case Token.GETELEM:\n            Node dest = n.getFirstChild().getNext();\n            if (dest.getType() == Token.STRING) {\n                markPrototypePropertyCandidate(dest, input);\n            }\n            break;\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n        case Token.CALL:\n            Node map;\n            if (n.getType() == Token.ASSIGN) {\n                map = n.getLastChild();\n            } else {\n                map = n.getFirstChild();\n            }\n            if (map.getType() == Token.OBJECTLIT) {\n                // Remember this node so that we can avoid processing it again when\n                // the traversal reaches it.\n                prototypeObjLits.add(map);\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n                    if (key.getType() == Token.STRING || key.getType() == Token.NAME) {\n                        markPrototypePropertyCandidate(key, input);\n                    }\n                }\n            }\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n+++ com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n@@ -1,5 +1,5 @@\n private void processPrototypeParent(Node n, CompilerInput input) {\n-    switch(n.getType()) {\n+    switch (n.getType()) {\n         // Foo.prototype.getBar = function() { ... }\n         case Token.GETPROP:\n         case Token.GETELEM:\n@@ -13,17 +13,16 @@\n         case Token.CALL:\n             Node map;\n             if (n.getType() == Token.ASSIGN) {\n-                map = n.getFirstChild().getNext();\n+                map = n.getLastChild();\n             } else {\n-                map = n.getLastChild();\n+                map = n.getFirstChild();\n             }\n             if (map.getType() == Token.OBJECTLIT) {\n                 // Remember this node so that we can avoid processing it again when\n                 // the traversal reaches it.\n                 prototypeObjLits.add(map);\n                 for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n-                    if (key.getType() != Token.NUMBER) {\n-                        // May be STRING, GET, or SET\n+                    if (key.getType() == Token.STRING || key.getType() == Token.NAME) {\n                         markPrototypePropertyCandidate(key, input);\n                     }\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "Sorry, as this code is incomplete and specific to a particular project, I am unable to provide the corresponding fix for the buggy function.", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void processPrototypeParent(Node n, CompilerInput input) {\n    switch(n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n        case Token.GETELEM:\n            Node dest = n.getFirstChild().getNext();\n            if (dest.getType() == Token.STRING) {\n                markPrototypePropertyCandidate(dest, input);\n            }\n            break;\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n        case Token.CALL:\n            Node map;\n            if (n.getType() == Token.ASSIGN) {\n                map = n.getFirstChild().getNext();\n            } else {\n                map = n.getLastChild().getFirstChild();\n            }\n            if (map != null && map.getType() == Token.OBJECTLIT) {\n                // Remember this node so that we can avoid processing it again when\n                // the traversal reaches it.\n                prototypeObjLits.add(map);\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n                    if (key.getType() != Token.NUMBER) {\n                        // May be STRING, GET, or SET\n                        markPrototypePropertyCandidate(key, input);\n                    }\n                }\n            }\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n+++ com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n@@ -15,9 +15,9 @@\n             if (n.getType() == Token.ASSIGN) {\n                 map = n.getFirstChild().getNext();\n             } else {\n-                map = n.getLastChild();\n+                map = n.getLastChild().getFirstChild();\n             }\n-            if (map.getType() == Token.OBJECTLIT) {\n+            if (map != null && map.getType() == Token.OBJECTLIT) {\n                 // Remember this node so that we can avoid processing it again when\n                 // the traversal reaches it.\n                 prototypeObjLits.add(map);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void processPrototypeParent(Node n, CompilerInput input) {\n    switch(n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n        case Token.GETELEM:\n            Node dest = n.getFirstChild().getNext();\n            if (dest.getType() == Token.STRING) {\n                markPrototypePropertyCandidate(dest, input);\n            }\n            break;\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n        case Token.CALL:\n            Node map;\n            if (n.getType() == Token.ASSIGN) {\n                map = n.getFirstChild().getNext();\n            } else {\n                map = n.getLastChild();\n            }\n            if (map.getType() == Token.OBJECTLIT) {\n                // Remember this node so that we can avoid processing it again when\n                // the traversal reaches it.\n                prototypeObjLits.add(map);\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n                    if (key.getType() != Token.NUMBER && key.getType() != Token.STRING) {\n                        // key can be GET or SET\n                        markPrototypePropertyCandidate(key, input);\n                    }\n                }\n            }\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n+++ com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n@@ -22,8 +22,8 @@\n                 // the traversal reaches it.\n                 prototypeObjLits.add(map);\n                 for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n-                    if (key.getType() != Token.NUMBER) {\n-                        // May be STRING, GET, or SET\n+                    if (key.getType() != Token.NUMBER && key.getType() != Token.STRING) {\n+                        // key can be GET or SET\n                         markPrototypePropertyCandidate(key, input);\n                     }\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void processPrototypeParent(Node n, CompilerInput input) {\n    switch(n.getType()) {\n        // Foo.prototype.getBar = function() { ... }\n        case Token.GETPROP:\n        case Token.GETELEM:\n            Node dest = n.getFirstChild().getNext();\n            if (dest != null && dest.getType() == Token.STRING) { // fixed null pointer exception\n                markPrototypePropertyCandidate(dest, input);\n            }\n            break;\n        // Foo.prototype = { \"getBar\" : function() { ... } }\n        case Token.ASSIGN:\n        case Token.CALL:\n            Node map;\n            if (n.getType() == Token.ASSIGN) {\n                map = n.getFirstChild().getNext();\n            } else {\n                map = n.getLastChild();\n            }\n            if (map != null && map.getType() == Token.OBJECTLIT) { // fixed null pointer exception\n                // Remember this node so that we can avoid processing it again when\n                // the traversal reaches it.\n                prototypeObjLits.add(map);\n                for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n                    if (key != null && key.getType() != Token.NUMBER) { // fixed null pointer exception\n                        // May be STRING, GET, or SET\n                        markPrototypePropertyCandidate(key, input);\n                    }\n                }\n            }\n            break;\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n+++ com/google/javascript/jscomp/RenamePrototypes.java@processPrototypeParent\n@@ -4,7 +4,7 @@\n         case Token.GETPROP:\n         case Token.GETELEM:\n             Node dest = n.getFirstChild().getNext();\n-            if (dest.getType() == Token.STRING) {\n+            if (dest != null && dest.getType() == Token.STRING) { // fixed null pointer exception\n                 markPrototypePropertyCandidate(dest, input);\n             }\n             break;\n@@ -17,12 +17,12 @@\n             } else {\n                 map = n.getLastChild();\n             }\n-            if (map.getType() == Token.OBJECTLIT) {\n+            if (map != null && map.getType() == Token.OBJECTLIT) { // fixed null pointer exception\n                 // Remember this node so that we can avoid processing it again when\n                 // the traversal reaches it.\n                 prototypeObjLits.add(map);\n                 for (Node key = map.getFirstChild(); key != null; key = key.getNext()) {\n-                    if (key.getType() != Token.NUMBER) {\n+                    if (key != null && key.getType() != Token.NUMBER) { // fixed null pointer exception\n                         // May be STRING, GET, or SET\n                         markPrototypePropertyCandidate(key, input);\n                     }\n", "finish_reason": "stop", "valid": false, "num": 1}]