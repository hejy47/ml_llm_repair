[{"output": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        FunctionBuilder builder = new FunctionBuilder(typeRegistry)\n            .withName(fnName)\n            .withSourceNode(sourceNode)\n            .withParamsNode(parametersNode)\n            .withReturnType(returnType)\n            .withTypeOfThis(thisType)\n            .withTemplateName(templateTypeName);\n\n        fnType = builder.build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n@@ -15,7 +15,15 @@\n         }\n         maybeSetBaseType(fnType);\n     } else {\n-        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n+        FunctionBuilder builder = new FunctionBuilder(typeRegistry)\n+            .withName(fnName)\n+            .withSourceNode(sourceNode)\n+            .withParamsNode(parametersNode)\n+            .withReturnType(returnType)\n+            .withTypeOfThis(thisType)\n+            .withTemplateName(templateTypeName);\n+\n+        fnType = builder.build();\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        FunctionBuilder builder = new FunctionBuilder(typeRegistry);\n        builder = builder.withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName);\n        fnType = builder.build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n@@ -15,7 +15,9 @@\n         }\n         maybeSetBaseType(fnType);\n     } else {\n-        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n+        FunctionBuilder builder = new FunctionBuilder(typeRegistry);\n+        builder = builder.withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName);\n+        fnType = builder.build();\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        FunctionBuilder builder = new FunctionBuilder(typeRegistry);\n        builder.withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName);\n        fnType = builder.build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n@@ -15,7 +15,9 @@\n         }\n         maybeSetBaseType(fnType);\n     } else {\n-        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n+        FunctionBuilder builder = new FunctionBuilder(typeRegistry);\n+        builder.withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName);\n+        fnType = builder.build();\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces != null) {\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (!scope.isGlobal() && !fnName.isEmpty()) { // Fixed condition\n            // Only declare type if scope is not global\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n@@ -10,7 +10,8 @@\n         fnType = getOrCreateConstructor();\n     } else if (isInterface) {\n         fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n-        if (scope.isGlobal() && !fnName.isEmpty()) {\n+        if (!scope.isGlobal() && !fnName.isEmpty()) { // Fixed condition\n+            // Only declare type if scope is not global\n             typeRegistry.declareType(fnName, fnType.getInstanceType());\n         }\n         maybeSetBaseType(fnType);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        FunctionBuilder builder = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName);\n        fnType = builder.build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n@@ -15,7 +15,8 @@\n         }\n         maybeSetBaseType(fnType);\n     } else {\n-        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n+        FunctionBuilder builder = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName);\n+        fnType = builder.build();\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces != null) {\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        FunctionBuilder fb = new FunctionBuilder(typeRegistry)\n                .withName(fnName)\n                .withSourceNode(sourceNode)\n                .withParamsNode(parametersNode)\n                .withReturnType(returnType)\n                .withTypeOfThis(thisType)\n                .withTemplateName(templateTypeName);\n                \n        if (templateTypeName != null) { // check if there is a template type\n            fb = fb.withTemplateTypeName(templateTypeName); // add the template type to the function builder\n        }\n\n        fnType = fb.build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n@@ -15,7 +15,19 @@\n         }\n         maybeSetBaseType(fnType);\n     } else {\n-        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n+        FunctionBuilder fb = new FunctionBuilder(typeRegistry)\n+                .withName(fnName)\n+                .withSourceNode(sourceNode)\n+                .withParamsNode(parametersNode)\n+                .withReturnType(returnType)\n+                .withTypeOfThis(thisType)\n+                .withTemplateName(templateTypeName);\n+                \n+        if (templateTypeName != null) { // check if there is a template type\n+            fb = fb.withTemplateTypeName(templateTypeName); // add the template type to the function builder\n+        }\n+\n+        fnType = fb.build();\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (!scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n@@ -10,7 +10,7 @@\n         fnType = getOrCreateConstructor();\n     } else if (isInterface) {\n         fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n-        if (scope.isGlobal() && !fnName.isEmpty()) {\n+        if (!scope.isGlobal() && !fnName.isEmpty()) {\n             typeRegistry.declareType(fnName, fnType.getInstanceType());\n         }\n         maybeSetBaseType(fnType);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n        if (implementedInterfaces != null) {\n            fnType.setImplementedInterfaces(implementedInterfaces);\n        }\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n@@ -17,9 +17,9 @@\n     } else {\n         fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n         maybeSetBaseType(fnType);\n-    }\n-    if (implementedInterfaces != null) {\n-        fnType.setImplementedInterfaces(implementedInterfaces);\n+        if (implementedInterfaces != null) {\n+            fnType.setImplementedInterfaces(implementedInterfaces);\n+        }\n     }\n     typeRegistry.clearTemplateTypeName();\n     return fnType;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (!fnName.isEmpty()) { // Always declare type name in interface (to support nested interfaces)\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n@@ -10,7 +10,7 @@\n         fnType = getOrCreateConstructor();\n     } else if (isInterface) {\n         fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n-        if (scope.isGlobal() && !fnName.isEmpty()) {\n+        if (!fnName.isEmpty()) { // Always declare type name in interface (to support nested interfaces)\n             typeRegistry.declareType(fnName, fnType.getInstanceType());\n         }\n         maybeSetBaseType(fnType);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        FunctionBuilder builder = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName);\n        if (implementedInterfaces != null) {\n            builder = builder.withImplementedInterfaces(implementedInterfaces);\n        }\n        fnType = builder.build();\n        maybeSetBaseType(fnType);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n@@ -15,11 +15,12 @@\n         }\n         maybeSetBaseType(fnType);\n     } else {\n-        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n+        FunctionBuilder builder = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName);\n+        if (implementedInterfaces != null) {\n+            builder = builder.withImplementedInterfaces(implementedInterfaces);\n+        }\n+        fnType = builder.build();\n         maybeSetBaseType(fnType);\n-    }\n-    if (implementedInterfaces != null) {\n-        fnType.setImplementedInterfaces(implementedInterfaces);\n     }\n     typeRegistry.clearTemplateTypeName();\n     return fnType;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        List<Parameter> parameters = ParameterUtils.parametersFromNode(parametersNode);\n        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParams(parameters).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n@@ -15,7 +15,8 @@\n         }\n         maybeSetBaseType(fnType);\n     } else {\n-        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n+        List<Parameter> parameters = ParameterUtils.parametersFromNode(parametersNode);\n+        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParams(parameters).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        FunctionBuilder builder = new FunctionBuilder(typeRegistry);\n        builder.withName(fnName);\n        builder.withSourceNode(sourceNode);\n        builder.withParamsNode(parametersNode);\n        builder.withReturnType(returnType);\n        builder.withTypeOfThis(thisType);\n        builder.withTemplateName(templateTypeName);\n        fnType = builder.build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n@@ -15,7 +15,14 @@\n         }\n         maybeSetBaseType(fnType);\n     } else {\n-        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n+        FunctionBuilder builder = new FunctionBuilder(typeRegistry);\n+        builder.withName(fnName);\n+        builder.withSourceNode(sourceNode);\n+        builder.withParamsNode(parametersNode);\n+        builder.withReturnType(returnType);\n+        builder.withTypeOfThis(thisType);\n+        builder.withTemplateName(templateTypeName);\n+        fnType = builder.build();\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionType buildAndRegister() {\n    if (returnType == null || returnType.getKind() == TypeKind.UNKNOWN_TYPE) { // Fixed - checking for null or unknown type\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n@@ -1,5 +1,5 @@\n FunctionType buildAndRegister() {\n-    if (returnType == null) {\n+    if (returnType == null || returnType.getKind() == TypeKind.UNKNOWN_TYPE) { // Fixed - checking for null or unknown type\n         returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n     }\n     if (parametersNode == null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null || returnType == null) { // Adding check for null returnType\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n@@ -2,7 +2,7 @@\n     if (returnType == null) {\n         returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n     }\n-    if (parametersNode == null) {\n+    if (parametersNode == null || returnType == null) { // Adding check for null returnType\n         throw new IllegalStateException(\"All Function types must have params and a return type\");\n     }\n     FunctionType fnType;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateName(); //fixed wrong method call\n    return fnType;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n@@ -21,6 +21,6 @@\n     if (implementedInterfaces != null) {\n         fnType.setImplementedInterfaces(implementedInterfaces);\n     }\n-    typeRegistry.clearTemplateTypeName();\n+    typeRegistry.clearTemplateName(); //fixed wrong method call\n     return fnType;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        fnType = new FunctionBuilder(typeRegistry)\n                    .withName(fnName)\n                    .withSourceNode(sourceNode)\n                    .withParamsNode(parametersNode)\n                    .withReturnType(returnType)\n                    .withTypeOfThis(thisType)\n                    .withTemplateName(templateTypeName)\n                    .withScope(scope) // Add this line to fix the issue\n                    .build();\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n@@ -15,7 +15,15 @@\n         }\n         maybeSetBaseType(fnType);\n     } else {\n-        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n+        fnType = new FunctionBuilder(typeRegistry)\n+                    .withName(fnName)\n+                    .withSourceNode(sourceNode)\n+                    .withParamsNode(parametersNode)\n+                    .withReturnType(returnType)\n+                    .withTypeOfThis(thisType)\n+                    .withTemplateName(templateTypeName)\n+                    .withScope(scope) // Add this line to fix the issue\n+                    .build();\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionType buildAndRegister() {\n    if (returnType == null) {\n        returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n    if (parametersNode == null) {\n        throw new IllegalStateException(\"All Function types must have params and a return type\");\n    }\n    FunctionType fnType;\n    if (isConstructor) {\n        fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n        fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n        if (scope.isGlobal() && !fnName.isEmpty()) {\n            typeRegistry.declareType(fnName, fnType.getInstanceType());\n        }\n        maybeSetBaseType(fnType);\n    } else {\n        FunctionBuilder builder = new FunctionBuilder(typeRegistry)\n                .withName(fnName)\n                .withSourceNode(sourceNode)\n                .withParamsNode(parametersNode)\n                .withReturnType(returnType)\n                .withTypeOfThis(thisType)\n                .withTemplateName(templateTypeName);\n        fnType = builder.build(); // build the function type only once\n        maybeSetBaseType(fnType);\n    }\n    if (implementedInterfaces != null) {\n        fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n    typeRegistry.clearTemplateTypeName();\n    return fnType;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@buildAndRegister\n@@ -15,7 +15,14 @@\n         }\n         maybeSetBaseType(fnType);\n     } else {\n-        fnType = new FunctionBuilder(typeRegistry).withName(fnName).withSourceNode(sourceNode).withParamsNode(parametersNode).withReturnType(returnType).withTypeOfThis(thisType).withTemplateName(templateTypeName).build();\n+        FunctionBuilder builder = new FunctionBuilder(typeRegistry)\n+                .withName(fnName)\n+                .withSourceNode(sourceNode)\n+                .withParamsNode(parametersNode)\n+                .withReturnType(returnType)\n+                .withTypeOfThis(thisType)\n+                .withTemplateName(templateTypeName);\n+        fnType = builder.build(); // build the function type only once\n         maybeSetBaseType(fnType);\n     }\n     if (implementedInterfaces != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}]