[{"output": "private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType = null;\n    // Handle function aliases.\n    if (rValue != null && rValue.isQualifiedName()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n            functionType = (FunctionType) var.getType();\n            if (functionType != null && functionType.isConstructor()) {\n                typeRegistry.declareType(name, functionType.getInstanceType());\n            }\n        }\n        return functionType;\n    }\n    Node owner = null;\n    if (lvalueNode != null) {\n        owner = getPrototypePropertyOwner(lvalueNode);\n    }\n    Node errorRoot = rValue == null ? lvalueNode : rValue;\n    boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;\n    Node fnRoot = isFnLiteral ? rValue : null;\n    Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;\n    if (info != null && info.hasType()) {\n        JSType type = info.getType().evaluate(scope, typeRegistry);\n        // Known to be not null since we have the FUNCTION token there.\n        type = type.restrictByNotNullOrUndefined();\n        if (type.isFunctionType()) {\n            functionType = (FunctionType) type;\n            functionType.setJSDocInfo(info);\n        }\n    }\n    if (functionType == null) {\n        if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n            // We don't really have any type information in the annotation.\n            // Before we give up on this function, look at the object we're\n            // assigning it to. For example, if the function looks like this:\n            // SubFoo.prototype.bar = function() { ... };\n            // We can use type information on Foo.prototype.bar and apply it\n            // to this function.\n            if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) {\n                Var var = scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n                if (var != null) {\n                    ObjectType ownerType = ObjectType.cast(var.getType());\n                    FunctionType propType = null;\n                    if (ownerType != null) {\n                        String propName = lvalueNode.getLastChild().getString();\n                        propType = findOverriddenFunction(ownerType, propName);\n                    }\n                    if (propType != null) {\n                        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(propType, parametersNode).inferThisType(info, owner).buildAndRegister();\n                    }\n                }\n            }\n        }\n    }\n    // end if (functionType == null)\n    if (functionType == null) {\n        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info).inferThisType(info, owner).inferParameterTypes(parametersNode, info).buildAndRegister();\n    }\n    // assigning the function type to the function node\n    if (rValue != null) {\n        setDeferredType(rValue, functionType);\n    }\n    // all done\n    return functionType;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@getFunctionType\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@getFunctionType\n@@ -19,7 +19,7 @@\n     boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;\n     Node fnRoot = isFnLiteral ? rValue : null;\n     Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;\n-    if (functionType == null && info != null && info.hasType()) {\n+    if (info != null && info.hasType()) {\n         JSType type = info.getType().evaluate(scope, typeRegistry);\n         // Known to be not null since we have the FUNCTION token there.\n         type = type.restrictByNotNullOrUndefined();\n", "finish_reason": "stop", "valid": false, "num": 13}, {"output": "private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType = null;\n    // Handle function aliases.\n    if (rValue != null && rValue.isQualifiedName()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n            functionType = (FunctionType) var.getType();\n            if (functionType != null && functionType.isConstructor()) {\n                typeRegistry.declareType(name, functionType.getInstanceType());\n            }\n        }\n        return functionType;\n    }\n    Node owner = null;\n    if (lvalueNode != null) {\n        owner = getPrototypePropertyOwner(lvalueNode);\n    }\n    Node errorRoot = rValue == null ? lvalueNode : rValue;\n    boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;\n    Node fnRoot = isFnLiteral ? rValue : null;\n    Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;\n    if (info != null && info.hasType()) {\n        JSType type = info.getType().evaluate(scope, typeRegistry);\n        type = type.restrictByNotNullOrUndefined();\n        if (type.isFunctionType()) {\n            functionType = (FunctionType) type;\n            functionType.setJSDocInfo(info);\n        }\n    }\n    if (functionType == null) {\n        if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n            // We don't really have any type information in the annotation.\n            // Before we give up on this function, look at the object we're\n            // assigning it to. For example, if the function looks like this:\n            // SubFoo.prototype.bar = function() { ... };\n            // We can use type information on Foo.prototype.bar and apply it\n            // to this function.\n            if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) {\n                Var var = scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n                if (var != null) {\n                    ObjectType ownerType = ObjectType.cast(var.getType());\n                    FunctionType propType = null;\n                    if (ownerType != null) {\n                        String propName = lvalueNode.getLastChild().getString();\n                        propType = findOverriddenFunction(ownerType, propName);\n                    }\n                    if (propType != null) {\n                        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(propType, parametersNode).inferThisType(info, owner).buildAndRegister();\n                    }\n                }\n            }\n        }\n    }\n    // end if (functionType == null)\n    if (functionType == null) {\n        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info).inferThisType(info, owner).inferParameterTypes(parametersNode, info).buildAndRegister();\n    }\n    // assigning the function type to the function node\n    if (rValue != null) {\n        setDeferredType(rValue, functionType);\n    }\n    // all done\n    return functionType;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@getFunctionType\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@getFunctionType\n@@ -19,9 +19,8 @@\n     boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;\n     Node fnRoot = isFnLiteral ? rValue : null;\n     Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;\n-    if (functionType == null && info != null && info.hasType()) {\n+    if (info != null && info.hasType()) {\n         JSType type = info.getType().evaluate(scope, typeRegistry);\n-        // Known to be not null since we have the FUNCTION token there.\n         type = type.restrictByNotNullOrUndefined();\n         if (type.isFunctionType()) {\n             functionType = (FunctionType) type;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType = null;\n    // Handle function aliases.\n    if (rValue != null && rValue.isQualifiedName()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n            functionType = (FunctionType) var.getType();\n            if (functionType != null && functionType.isConstructor()) {\n                typeRegistry.declareType(name, functionType.getInstanceType());\n            }\n        }\n        return functionType;\n    }\n    Node owner = null;\n    if (lvalueNode != null) {\n        owner = getPrototypePropertyOwner(lvalueNode);\n    }\n    Node errorRoot = rValue == null ? lvalueNode : rValue;\n    boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;\n    Node fnRoot = isFnLiteral ? rValue : null;\n    Node parametersNode = isFnLiteral ? rValue.getFirstFirstChild() : null;  // changed to get the correct node\n    if (functionType == null && info != null && info.hasType()) {\n        JSType type = info.getType().evaluate(scope, typeRegistry);\n        // Known to be not null since we have the FUNCTION token there.\n        type = type.restrictByNotNullOrUndefined();\n        if (type.isFunctionType()) {\n            functionType = (FunctionType) type;\n            functionType.setJSDocInfo(info);\n        }\n    }\n    if (functionType == null) {\n        if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n            // We don't really have any type information in the annotation.\n            // Before we give up on this function, look at the object we're\n            // assigning it to. For example, if the function looks like this:\n            // SubFoo.prototype.bar = function() { ... };\n            // We can use type information on Foo.prototype.bar and apply it\n            // to this function.\n            if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) {\n                Var var = scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n                if (var != null) {\n                    ObjectType ownerType = ObjectType.cast(var.getType());\n                    FunctionType propType = null;\n                    if (ownerType != null) {\n                        String propName = lvalueNode.getLastChild().getString();\n                        propType = findOverriddenFunction(ownerType, propName);\n                    }\n                    if (propType != null) {\n                        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(propType, parametersNode).inferThisType(info, owner).buildAndRegister();\n                    }\n                }\n            }\n        }\n    }\n    // end if (functionType == null)\n    if (functionType == null) {\n        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info).inferThisType(info, owner).inferParameterTypes(parametersNode, info).buildAndRegister();\n    }\n    // assigning the function type to the function node\n    if (rValue != null) {\n        setDeferredType(rValue, functionType);\n    }\n    // all done\n    return functionType;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@getFunctionType\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@getFunctionType\n@@ -18,7 +18,7 @@\n     Node errorRoot = rValue == null ? lvalueNode : rValue;\n     boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;\n     Node fnRoot = isFnLiteral ? rValue : null;\n-    Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;\n+    Node parametersNode = isFnLiteral ? rValue.getFirstFirstChild() : null;  // changed to get the correct node\n     if (functionType == null && info != null && info.hasType()) {\n         JSType type = info.getType().evaluate(scope, typeRegistry);\n         // Known to be not null since we have the FUNCTION token there.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType = null;\n    // Handle function aliases.\n    if (rValue != null && rValue.isQualifiedName()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n            functionType = (FunctionType) var.getType();\n            if (functionType != null && functionType.isConstructor()) {\n                typeRegistry.declareType(name, functionType.getInstanceType());\n            }\n        }\n        return functionType;\n    }\n    Node owner = null;\n    if (lvalueNode != null) {\n        owner = getPrototypePropertyOwner(lvalueNode);\n    }\n    Node errorRoot = rValue == null ? lvalueNode : rValue;\n    boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;\n    Node fnRoot = isFnLiteral ? rValue : null;\n    Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;\n    if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n        // We don't really have any type information in the annotation.\n        // Before we give up on this function, look at the object we're\n        // assigning it to. For example, if the function looks like this:\n        // SubFoo.prototype.bar = function() { ... };\n        // We can use type information on Foo.prototype.bar and apply it\n        // to this function.\n        if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) {\n            Var var = scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n            if (var != null) {\n                ObjectType ownerType = ObjectType.cast(var.getType());\n                FunctionType propType = null;\n                if (ownerType != null) {\n                    String propName = lvalueNode.getLastChild().getString();\n                    propType = findOverriddenFunction(ownerType, propName);\n                }\n                if (propType != null) {\n                    functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(propType, parametersNode).inferThisType(info, owner).buildAndRegister();\n                }\n            }\n        }\n    }\n    if (functionType == null) {\n        if (info != null && info.hasType()) {\n            JSType type = info.getType().evaluate(scope, typeRegistry);\n            // Known to be not null since we have the FUNCTION token there.\n            type = type.restrictByNotNullOrUndefined();\n            if (type.isFunctionType()) {\n                functionType = (FunctionType) type;\n                functionType.setJSDocInfo(info);\n            }\n        }\n    }\n    if (functionType == null) {\n        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info).inferThisType(info, owner).inferParameterTypes(parametersNode, info).buildAndRegister();\n    }\n    // assigning the function type to the function node\n    if (rValue != null) {\n        setDeferredType(rValue, functionType);\n    }\n    // all done\n    return functionType;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@getFunctionType\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@getFunctionType\n@@ -19,40 +19,39 @@\n     boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;\n     Node fnRoot = isFnLiteral ? rValue : null;\n     Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;\n-    if (functionType == null && info != null && info.hasType()) {\n-        JSType type = info.getType().evaluate(scope, typeRegistry);\n-        // Known to be not null since we have the FUNCTION token there.\n-        type = type.restrictByNotNullOrUndefined();\n-        if (type.isFunctionType()) {\n-            functionType = (FunctionType) type;\n-            functionType.setJSDocInfo(info);\n-        }\n-    }\n-    if (functionType == null) {\n-        if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n-            // We don't really have any type information in the annotation.\n-            // Before we give up on this function, look at the object we're\n-            // assigning it to. For example, if the function looks like this:\n-            // SubFoo.prototype.bar = function() { ... };\n-            // We can use type information on Foo.prototype.bar and apply it\n-            // to this function.\n-            if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) {\n-                Var var = scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n-                if (var != null) {\n-                    ObjectType ownerType = ObjectType.cast(var.getType());\n-                    FunctionType propType = null;\n-                    if (ownerType != null) {\n-                        String propName = lvalueNode.getLastChild().getString();\n-                        propType = findOverriddenFunction(ownerType, propName);\n-                    }\n-                    if (propType != null) {\n-                        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(propType, parametersNode).inferThisType(info, owner).buildAndRegister();\n-                    }\n+    if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n+        // We don't really have any type information in the annotation.\n+        // Before we give up on this function, look at the object we're\n+        // assigning it to. For example, if the function looks like this:\n+        // SubFoo.prototype.bar = function() { ... };\n+        // We can use type information on Foo.prototype.bar and apply it\n+        // to this function.\n+        if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) {\n+            Var var = scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n+            if (var != null) {\n+                ObjectType ownerType = ObjectType.cast(var.getType());\n+                FunctionType propType = null;\n+                if (ownerType != null) {\n+                    String propName = lvalueNode.getLastChild().getString();\n+                    propType = findOverriddenFunction(ownerType, propName);\n+                }\n+                if (propType != null) {\n+                    functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(propType, parametersNode).inferThisType(info, owner).buildAndRegister();\n                 }\n             }\n         }\n     }\n-    // end if (functionType == null)\n+    if (functionType == null) {\n+        if (info != null && info.hasType()) {\n+            JSType type = info.getType().evaluate(scope, typeRegistry);\n+            // Known to be not null since we have the FUNCTION token there.\n+            type = type.restrictByNotNullOrUndefined();\n+            if (type.isFunctionType()) {\n+                functionType = (FunctionType) type;\n+                functionType.setJSDocInfo(info);\n+            }\n+        }\n+    }\n     if (functionType == null) {\n         functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info).inferThisType(info, owner).inferParameterTypes(parametersNode, info).buildAndRegister();\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType = null;\n    // Handle function aliases.\n    if (rValue != null && rValue.isQualifiedName()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n            functionType = (FunctionType) var.getType();\n            if (functionType != null && functionType.isConstructor()) {\n                typeRegistry.declareType(name, functionType.getInstanceType());\n            }\n        }\n        return functionType;\n    }\n    Node owner = null;\n    if (lvalueNode != null) {\n        owner = getPrototypePropertyOwner(lvalueNode);\n    }\n    Node errorRoot = rValue == null ? lvalueNode : rValue;\n    boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;\n    Node fnRoot = isFnLiteral ? rValue : null;\n    Node parametersNode = isFnLiteral ? rValue.getFirstFirstChild() : null; // Fixed here\n\n    if (functionType == null && info != null && info.hasType()) {\n        JSType type = info.getType().evaluate(scope, typeRegistry);\n        // Known to be not null since we have the FUNCTION token there.\n        type = type.restrictByNotNullOrUndefined();\n        if (type.isFunctionType()) {\n            functionType = (FunctionType) type;\n            functionType.setJSDocInfo(info);\n        }\n    }\n    if (functionType == null) {\n        if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n            // We don't really have any type information in the annotation.\n            // Before we give up on this function, look at the object we're\n            // assigning it to. For example, if the function looks like this:\n            // SubFoo.prototype.bar = function() { ... };\n            // We can use type information on Foo.prototype.bar and apply it\n            // to this function.\n            if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) {\n                Var var = scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n                if (var != null) {\n                    ObjectType ownerType = ObjectType.cast(var.getType());\n                    FunctionType propType = null;\n                    if (ownerType != null) {\n                        String propName = lvalueNode.getLastChild().getString();\n                        propType = findOverriddenFunction(ownerType, propName);\n                    }\n                    if (propType != null) {\n                        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(propType, parametersNode).inferThisType(info, owner).buildAndRegister();\n                    }\n                }\n            }\n        }\n    }\n    // end if (functionType == null)\n    if (functionType == null) {\n        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info).inferThisType(info, owner).inferParameterTypes(parametersNode, info).buildAndRegister();\n    }\n    // assigning the function type to the function node\n    if (rValue != null) {\n        setDeferredType(rValue, functionType);\n    }\n    // all done\n    return functionType;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@getFunctionType\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@getFunctionType\n@@ -18,7 +18,8 @@\n     Node errorRoot = rValue == null ? lvalueNode : rValue;\n     boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;\n     Node fnRoot = isFnLiteral ? rValue : null;\n-    Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;\n+    Node parametersNode = isFnLiteral ? rValue.getFirstFirstChild() : null; // Fixed here\n+\n     if (functionType == null && info != null && info.hasType()) {\n         JSType type = info.getType().evaluate(scope, typeRegistry);\n         // Known to be not null since we have the FUNCTION token there.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "Unfortunately, the provided code excerpt is incomplete and the specific error is not specified. Can you please provide the missing information?", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType = null;\n    // Handle function aliases.\n    if (rValue != null && rValue.isQualifiedName()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n            functionType = (FunctionType) var.getType();\n            if (functionType != null && functionType.isConstructor()) {\n                typeRegistry.declareType(name, functionType.getInstanceType());\n            }\n        }\n        return functionType;\n    }\n    Node owner = null;\n    if (lvalueNode != null) {\n        owner = getPrototypePropertyOwner(lvalueNode);\n    }\n    Node errorRoot = rValue == null ? lvalueNode : rValue;\n    boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;\n    Node fnRoot = isFnLiteral ? rValue : null;\n    Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;\n    if (info != null && info.hasType()) {\n        JSType type = info.getType().evaluate(scope, typeRegistry);\n        // Known to be not null since we have the FUNCTION token there.\n        type = type.restrictByNotNullOrUndefined();\n        if (type.isFunctionType()) {\n            functionType = (FunctionType) type;\n            functionType.setJSDocInfo(info);\n        }\n    }\n    if (functionType == null && owner != null) {\n        FunctionType propType = null;\n        String propName = lvalueNode.getLastChild().getString();\n        if (propName != null && !propName.isEmpty()) {\n            propType = findOverriddenFunction(owner, propName);\n        }\n        if (propType != null) {\n            functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(propType, parametersNode).inferThisType(info, owner).buildAndRegister();\n        }\n    }\n    // end if (functionType == null)\n    if (functionType == null) {\n        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info).inferThisType(info, owner).inferParameterTypes(parametersNode, info).buildAndRegister();\n    }\n    // assigning the function type to the function node\n    if (rValue != null) {\n        setDeferredType(rValue, functionType);\n    }\n    // all done\n    return functionType;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@getFunctionType\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@getFunctionType\n@@ -19,7 +19,7 @@\n     boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;\n     Node fnRoot = isFnLiteral ? rValue : null;\n     Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;\n-    if (functionType == null && info != null && info.hasType()) {\n+    if (info != null && info.hasType()) {\n         JSType type = info.getType().evaluate(scope, typeRegistry);\n         // Known to be not null since we have the FUNCTION token there.\n         type = type.restrictByNotNullOrUndefined();\n@@ -28,28 +28,14 @@\n             functionType.setJSDocInfo(info);\n         }\n     }\n-    if (functionType == null) {\n-        if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n-            // We don't really have any type information in the annotation.\n-            // Before we give up on this function, look at the object we're\n-            // assigning it to. For example, if the function looks like this:\n-            // SubFoo.prototype.bar = function() { ... };\n-            // We can use type information on Foo.prototype.bar and apply it\n-            // to this function.\n-            if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) {\n-                Var var = scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n-                if (var != null) {\n-                    ObjectType ownerType = ObjectType.cast(var.getType());\n-                    FunctionType propType = null;\n-                    if (ownerType != null) {\n-                        String propName = lvalueNode.getLastChild().getString();\n-                        propType = findOverriddenFunction(ownerType, propName);\n-                    }\n-                    if (propType != null) {\n-                        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(propType, parametersNode).inferThisType(info, owner).buildAndRegister();\n-                    }\n-                }\n-            }\n+    if (functionType == null && owner != null) {\n+        FunctionType propType = null;\n+        String propName = lvalueNode.getLastChild().getString();\n+        if (propName != null && !propName.isEmpty()) {\n+            propType = findOverriddenFunction(owner, propName);\n+        }\n+        if (propType != null) {\n+            functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(propType, parametersNode).inferThisType(info, owner).buildAndRegister();\n         }\n     }\n     // end if (functionType == null)\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private FunctionType getFunctionType(String name, Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n    FunctionType functionType = null;\n    // Handle function aliases.\n    if (rValue != null && rValue.isQualifiedName()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n            functionType = (FunctionType) var.getType();\n            if (functionType != null && functionType.isConstructor()) {\n                typeRegistry.declareType(name, functionType.getInstanceType());\n            }\n        }\n        return functionType;\n    }\n    Node owner = null;\n    if (lvalueNode != null) {\n        owner = getPrototypePropertyOwner(lvalueNode);\n    }\n    Node errorRoot = rValue == null ? lvalueNode : rValue;\n    boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;\n    Node fnRoot = isFnLiteral ? rValue : null;\n    Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;\n    if (info != null && info.hasType()) {\n        JSType type = info.getType().evaluate(scope, typeRegistry);\n        type = type.restrictByNotNullOrUndefined();\n        if (type.isFunctionType()) {\n            functionType = (FunctionType) type;\n            functionType.setJSDocInfo(info);\n        }\n    }\n    if (functionType == null) {\n        if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n            if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) {\n                Var var = scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n                if (var != null) {\n                    ObjectType ownerType = ObjectType.cast(var.getType());\n                    if (ownerType != null) {\n                        String propName = lvalueNode.getLastChild().getString();\n                        functionType = findOverriddenFunction(ownerType, propName);\n                    }\n                }\n            }\n        }\n    }\n    if (functionType == null) {\n        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info).inferThisType(info, owner).inferParameterTypes(parametersNode, info).buildAndRegister();\n    }\n    if (rValue != null) {\n        setDeferredType(rValue, functionType);\n    }\n    return functionType;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.java@getFunctionType\n+++ com/google/javascript/jscomp/TypedScopeCreator.java@getFunctionType\n@@ -19,9 +19,8 @@\n     boolean isFnLiteral = rValue != null && rValue.getType() == Token.FUNCTION;\n     Node fnRoot = isFnLiteral ? rValue : null;\n     Node parametersNode = isFnLiteral ? rValue.getFirstChild().getNext() : null;\n-    if (functionType == null && info != null && info.hasType()) {\n+    if (info != null && info.hasType()) {\n         JSType type = info.getType().evaluate(scope, typeRegistry);\n-        // Known to be not null since we have the FUNCTION token there.\n         type = type.restrictByNotNullOrUndefined();\n         if (type.isFunctionType()) {\n             functionType = (FunctionType) type;\n@@ -30,36 +29,23 @@\n     }\n     if (functionType == null) {\n         if (info == null || !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n-            // We don't really have any type information in the annotation.\n-            // Before we give up on this function, look at the object we're\n-            // assigning it to. For example, if the function looks like this:\n-            // SubFoo.prototype.bar = function() { ... };\n-            // We can use type information on Foo.prototype.bar and apply it\n-            // to this function.\n             if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP && lvalueNode.isQualifiedName()) {\n                 Var var = scope.getVar(lvalueNode.getFirstChild().getQualifiedName());\n                 if (var != null) {\n                     ObjectType ownerType = ObjectType.cast(var.getType());\n-                    FunctionType propType = null;\n                     if (ownerType != null) {\n                         String propName = lvalueNode.getLastChild().getString();\n-                        propType = findOverriddenFunction(ownerType, propName);\n-                    }\n-                    if (propType != null) {\n-                        functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferFromOverriddenFunction(propType, parametersNode).inferThisType(info, owner).buildAndRegister();\n+                        functionType = findOverriddenFunction(ownerType, propName);\n                     }\n                 }\n             }\n         }\n     }\n-    // end if (functionType == null)\n     if (functionType == null) {\n         functionType = new FunctionTypeBuilder(name, compiler, errorRoot, sourceName, scope).setSourceNode(fnRoot).inferTemplateTypeName(info).inferReturnType(info).inferInheritance(info).inferThisType(info, owner).inferParameterTypes(parametersNode, info).buildAndRegister();\n     }\n-    // assigning the function type to the function node\n     if (rValue != null) {\n         setDeferredType(rValue, functionType);\n     }\n-    // all done\n     return functionType;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]