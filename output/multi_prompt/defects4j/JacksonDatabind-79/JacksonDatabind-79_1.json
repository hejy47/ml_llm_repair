[{"output": "Sorry, as an AI language model, I cannot interpret the expected fix to the function without the specific problem description. Can you please provide more information?", "diff": "", "finish_reason": "stop", "valid": false, "num": 10}, {"output": "@SuppressWarnings(\"incomplete-switch\")\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n    final SerializationConfig config = provider.getConfig();\n    // Let's start with one big transmutation: Enums that are annotated\n    // to serialize as Objects may want to revert\n    JsonFormat.Shape shape = null;\n    if (accessor != null) {\n        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n        if (format != null) {\n            shape = format.getShape();\n            // or, alternatively, asked to revert \"back to\" other representations...\n            if (shape != _serializationShape) {\n                if (_handledType.isEnum()) {\n                    switch(shape) {\n                        case STRING:\n                        case NUMBER:\n                        case NUMBER_INT:\n                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n                            //   for now, just do class ones\n                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n                            return provider.handlePrimaryContextualization(ser, property);\n                    }\n                }\n            }\n        }\n    }\n    ObjectIdWriter oiw = _objectIdWriter;\n    String[] ignorals = null;\n    Object newFilterId = null;\n    // Then we may have an override for Object Id\n    if (accessor != null) {\n        ignorals = intr.findPropertiesToIgnore(accessor, true);\n        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n        if (objectIdInfo == null) {\n            // no ObjectId override, but maybe ObjectIdRef?\n            if (oiw != null) {\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n                oiw = oiw.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n            }\n        } else {\n            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n            // to be able to move to SerializerProvider (where it really belongs)\n            // 2.1: allow modifications by \"id ref\" annotations as well:\n            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n            ObjectIdGenerator<?> gen;\n            Class<?> implClass = objectIdInfo.getGeneratorType();\n            JavaType type = provider.getTypeFactory().constructType(implClass);\n            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n            // Property-based generator is trickier\n            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n                // most special one, needs extra work\n                String propName = objectIdInfo.getPropertyName().getSimpleName();\n                BeanPropertyWriter idProp = null;\n                for (int i = 0, len = _props.length; ; ++i) {\n                    if (i == len) {\n                        throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n                    }\n                    BeanPropertyWriter prop = _props[i];\n                    if (propName.equals(prop.getName())) {\n                        idProp = prop;\n                                                if (i > 0) {\n                            // note: must shuffle both regular properties and filtered\n                            System.arraycopy(_props, 0, _props, 1, i);\n                            _props[0] = idProp;\n                            if (_filteredProps != null) {\n                                BeanPropertyWriter fp = _filteredProps[i];\n                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                _filteredProps[0] = fp;\n                            }\n                        }\n                        break;\n                    }\n                }\n                idType = idProp.getType();\n                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n            } else {\n                // other types need to be simpler\n                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n            }\n        }\n        // Or change Filter Id in use?\n        Object filterId = intr.findFilterId(accessor);\n        if (filterId != null) {\n            // but only consider case of adding a new filter id (no removal via annotation)\n            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n                newFilterId = filterId;\n            }\n        }\n    }\n    // either way, need to resolve serializer:\n    BeanSerializerBase contextual = this;\n    if (oiw != null) {\n        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n        oiw = oiw.withSerializer(ser);\n        if (oiw != _objectIdWriter) {\n            contextual = contextual.withObjectIdWriter(oiw);\n        }\n    }\n    // And possibly add more properties to ignore\n    if (ignorals != null && ignorals.length != 0) {\n        contextual = contextual.withIgnorals(ignorals);\n    }\n    if (newFilterId != null) {\n        contextual = contextual.withFilterId(newFilterId);\n    }\n    if (shape == null) {\n        shape = _serializationShape;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return contextual.asArraySerializer();\n    }\n    return contextual;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n@@ -1,8 +1,118 @@\n @Override\n-public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n-    JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n-    if (ref != null) {\n-        objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n+public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n+    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n+    final SerializationConfig config = provider.getConfig();\n+    // Let's start with one big transmutation: Enums that are annotated\n+    // to serialize as Objects may want to revert\n+    JsonFormat.Shape shape = null;\n+    if (accessor != null) {\n+        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n+        if (format != null) {\n+            shape = format.getShape();\n+            // or, alternatively, asked to revert \"back to\" other representations...\n+            if (shape != _serializationShape) {\n+                if (_handledType.isEnum()) {\n+                    switch(shape) {\n+                        case STRING:\n+                        case NUMBER:\n+                        case NUMBER_INT:\n+                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n+                            //   for now, just do class ones\n+                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n+                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n+                            return provider.handlePrimaryContextualization(ser, property);\n+                    }\n+                }\n+            }\n+        }\n     }\n-    return objectIdInfo;\n+    ObjectIdWriter oiw = _objectIdWriter;\n+    String[] ignorals = null;\n+    Object newFilterId = null;\n+    // Then we may have an override for Object Id\n+    if (accessor != null) {\n+        ignorals = intr.findPropertiesToIgnore(accessor, true);\n+        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n+        if (objectIdInfo == null) {\n+            // no ObjectId override, but maybe ObjectIdRef?\n+            if (oiw != null) {\n+                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n+                oiw = oiw.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n+            }\n+        } else {\n+            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n+            // to be able to move to SerializerProvider (where it really belongs)\n+            // 2.1: allow modifications by \"id ref\" annotations as well:\n+            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n+            ObjectIdGenerator<?> gen;\n+            Class<?> implClass = objectIdInfo.getGeneratorType();\n+            JavaType type = provider.getTypeFactory().constructType(implClass);\n+            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n+            // Property-based generator is trickier\n+            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n+                // most special one, needs extra work\n+                String propName = objectIdInfo.getPropertyName().getSimpleName();\n+                BeanPropertyWriter idProp = null;\n+                for (int i = 0, len = _props.length; ; ++i) {\n+                    if (i == len) {\n+                        throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n+                    }\n+                    BeanPropertyWriter prop = _props[i];\n+                    if (propName.equals(prop.getName())) {\n+                        idProp = prop;\n+                                                if (i > 0) {\n+                            // note: must shuffle both regular properties and filtered\n+                            System.arraycopy(_props, 0, _props, 1, i);\n+                            _props[0] = idProp;\n+                            if (_filteredProps != null) {\n+                                BeanPropertyWriter fp = _filteredProps[i];\n+                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n+                                _filteredProps[0] = fp;\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+                idType = idProp.getType();\n+                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n+                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n+            } else {\n+                // other types need to be simpler\n+                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n+                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n+            }\n+        }\n+        // Or change Filter Id in use?\n+        Object filterId = intr.findFilterId(accessor);\n+        if (filterId != null) {\n+            // but only consider case of adding a new filter id (no removal via annotation)\n+            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n+                newFilterId = filterId;\n+            }\n+        }\n+    }\n+    // either way, need to resolve serializer:\n+    BeanSerializerBase contextual = this;\n+    if (oiw != null) {\n+        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n+        oiw = oiw.withSerializer(ser);\n+        if (oiw != _objectIdWriter) {\n+            contextual = contextual.withObjectIdWriter(oiw);\n+        }\n+    }\n+    // And possibly add more properties to ignore\n+    if (ignorals != null && ignorals.length != 0) {\n+        contextual = contextual.withIgnorals(ignorals);\n+    }\n+    if (newFilterId != null) {\n+        contextual = contextual.withFilterId(newFilterId);\n+    }\n+    if (shape == null) {\n+        shape = _serializationShape;\n+    }\n+    if (shape == JsonFormat.Shape.ARRAY) {\n+        return contextual.asArraySerializer();\n+    }\n+    return contextual;\n }\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@createContextual\n@@ -39,7 +39,7 @@\n             // no ObjectId override, but maybe ObjectIdRef?\n             if (oiw != null) {\n                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n-                oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n+                oiw = oiw.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n             }\n         } else {\n             // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n@@ -48,7 +48,7 @@\n             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n             ObjectIdGenerator<?> gen;\n             Class<?> implClass = objectIdInfo.getGeneratorType();\n-            JavaType type = provider.constructType(implClass);\n+            JavaType type = provider.getTypeFactory().constructType(implClass);\n             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n             // Property-based generator is trickier\n             if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"incomplete-switch\")\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n    final SerializationConfig config = provider.getConfig();\n    // Let's start with one big transmutation: Enums that are annotated\n    // to serialize as Objects may want to revert\n    JsonFormat.Shape shape = null;\n    if (accessor != null) {\n        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n        if (format != null) {\n            shape = format.getShape();\n            // or, alternatively, asked to revert \"back to\" other representations...\n            if (shape != _serializationShape) {\n                if (_handledType.isEnum()) {\n                    switch(shape) {\n                        case STRING:\n                        case NUMBER:\n                        case NUMBER_INT:\n                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n                            //   for now, just do class ones\n                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n                            return provider.handlePrimaryContextualization(ser, property);\n                            default:\n                            break; // added for robustness\n                    }\n                }\n            }\n        }\n    }\n    ObjectIdWriter oiw = _objectIdWriter;\n    String[] ignorals = null;\n    Object newFilterId = null;\n    // Then we may have an override for Object Id\n    if (accessor != null) {\n        ignorals = intr.findPropertiesToIgnore(accessor, true); // CHANGED: added second parameter\n        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n        if (objectIdInfo == null) {\n            // no ObjectId override, but maybe ObjectIdRef?\n            if (oiw != null) {\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n                oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n            }\n        } else {\n            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n            // to be able to move to SerializerProvider (where it really belongs)\n            // 2.1: allow modifications by \"id ref\" annotations as well:\n            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n            ObjectIdGenerator<?> gen;\n            Class<?> implClass = objectIdInfo.getGeneratorType();\n            JavaType type = provider.constructType(implClass);\n            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n            // Property-based generator is trickier\n            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n                // most special one, needs extra work\n                String propName = objectIdInfo.getPropertyName().getSimpleName();\n                BeanPropertyWriter idProp = null;\n                for (int i = 0, len = _props.length; ; ++i) {\n                    if (i == len) {\n                        throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n                    }\n                    BeanPropertyWriter prop = _props[i];\n                    if (propName.equals(prop.getName())) {\n                        idProp = prop;\n                                                if (i > 0) {\n                            // note: must shuffle both regular properties and filtered\n                            System.arraycopy(_props, 0, _props, 1, i);\n                            _props[0] = idProp;\n                            if (_filteredProps != null) {\n                                BeanPropertyWriter fp = _filteredProps[i];\n                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                _filteredProps[0] = fp;\n                            }\n                        }\n                        break;\n                    }\n                }\n                idType = idProp.getType();\n                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n            } else {\n                // other types need to be simpler\n                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n            }\n        }\n        // Or change Filter Id in use?\n        Object filterId = intr.findFilterId(accessor);\n        if (filterId != null) {\n            // but only consider case of adding a new filter id (no removal via annotation)\n            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n                newFilterId = filterId;\n            }\n        }\n    }\n    // either way, need to resolve serializer:\n    BeanSerializerBase contextual = this;\n    if (oiw != null) {\n        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n        oiw = oiw.withSerializer(ser);\n        if (oiw != _objectIdWriter) {\n            contextual = contextual.withObjectIdWriter(oiw);\n        }\n    }\n    // And possibly add more properties to ignore\n    if (ignorals != null && ignorals.length != 0) {\n        contextual = contextual.withIgnorals(ignorals);\n    }\n    if (newFilterId != null) {\n        contextual = contextual.withFilterId(newFilterId);\n    }\n    if (shape == null) {\n        shape = _serializationShape;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return contextual.asArraySerializer();\n    }\n    return contextual;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n@@ -1,8 +1,120 @@\n @Override\n-public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n-    JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n-    if (ref != null) {\n-        objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n+public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n+    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n+    final SerializationConfig config = provider.getConfig();\n+    // Let's start with one big transmutation: Enums that are annotated\n+    // to serialize as Objects may want to revert\n+    JsonFormat.Shape shape = null;\n+    if (accessor != null) {\n+        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n+        if (format != null) {\n+            shape = format.getShape();\n+            // or, alternatively, asked to revert \"back to\" other representations...\n+            if (shape != _serializationShape) {\n+                if (_handledType.isEnum()) {\n+                    switch(shape) {\n+                        case STRING:\n+                        case NUMBER:\n+                        case NUMBER_INT:\n+                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n+                            //   for now, just do class ones\n+                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n+                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n+                            return provider.handlePrimaryContextualization(ser, property);\n+                            default:\n+                            break; // added for robustness\n+                    }\n+                }\n+            }\n+        }\n     }\n-    return objectIdInfo;\n+    ObjectIdWriter oiw = _objectIdWriter;\n+    String[] ignorals = null;\n+    Object newFilterId = null;\n+    // Then we may have an override for Object Id\n+    if (accessor != null) {\n+        ignorals = intr.findPropertiesToIgnore(accessor, true); // CHANGED: added second parameter\n+        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n+        if (objectIdInfo == null) {\n+            // no ObjectId override, but maybe ObjectIdRef?\n+            if (oiw != null) {\n+                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n+                oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n+            }\n+        } else {\n+            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n+            // to be able to move to SerializerProvider (where it really belongs)\n+            // 2.1: allow modifications by \"id ref\" annotations as well:\n+            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n+            ObjectIdGenerator<?> gen;\n+            Class<?> implClass = objectIdInfo.getGeneratorType();\n+            JavaType type = provider.constructType(implClass);\n+            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n+            // Property-based generator is trickier\n+            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n+                // most special one, needs extra work\n+                String propName = objectIdInfo.getPropertyName().getSimpleName();\n+                BeanPropertyWriter idProp = null;\n+                for (int i = 0, len = _props.length; ; ++i) {\n+                    if (i == len) {\n+                        throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n+                    }\n+                    BeanPropertyWriter prop = _props[i];\n+                    if (propName.equals(prop.getName())) {\n+                        idProp = prop;\n+                                                if (i > 0) {\n+                            // note: must shuffle both regular properties and filtered\n+                            System.arraycopy(_props, 0, _props, 1, i);\n+                            _props[0] = idProp;\n+                            if (_filteredProps != null) {\n+                                BeanPropertyWriter fp = _filteredProps[i];\n+                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n+                                _filteredProps[0] = fp;\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+                idType = idProp.getType();\n+                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n+                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n+            } else {\n+                // other types need to be simpler\n+                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n+                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n+            }\n+        }\n+        // Or change Filter Id in use?\n+        Object filterId = intr.findFilterId(accessor);\n+        if (filterId != null) {\n+            // but only consider case of adding a new filter id (no removal via annotation)\n+            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n+                newFilterId = filterId;\n+            }\n+        }\n+    }\n+    // either way, need to resolve serializer:\n+    BeanSerializerBase contextual = this;\n+    if (oiw != null) {\n+        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n+        oiw = oiw.withSerializer(ser);\n+        if (oiw != _objectIdWriter) {\n+            contextual = contextual.withObjectIdWriter(oiw);\n+        }\n+    }\n+    // And possibly add more properties to ignore\n+    if (ignorals != null && ignorals.length != 0) {\n+        contextual = contextual.withIgnorals(ignorals);\n+    }\n+    if (newFilterId != null) {\n+        contextual = contextual.withFilterId(newFilterId);\n+    }\n+    if (shape == null) {\n+        shape = _serializationShape;\n+    }\n+    if (shape == JsonFormat.Shape.ARRAY) {\n+        return contextual.asArraySerializer();\n+    }\n+    return contextual;\n }\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@createContextual\n@@ -23,6 +23,8 @@\n                             BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                             JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n                             return provider.handlePrimaryContextualization(ser, property);\n+                            default:\n+                            break; // added for robustness\n                     }\n                 }\n             }\n@@ -33,7 +35,7 @@\n     Object newFilterId = null;\n     // Then we may have an override for Object Id\n     if (accessor != null) {\n-        ignorals = intr.findPropertiesToIgnore(accessor, true);\n+        ignorals = intr.findPropertiesToIgnore(accessor, true); // CHANGED: added second parameter\n         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n         if (objectIdInfo == null) {\n             // no ObjectId override, but maybe ObjectIdRef?\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"incomplete-switch\")\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n    final SerializationConfig config = provider.getConfig();\n    // Let's start with one big transmutation: Enums that are annotated\n    // to serialize as Objects may want to revert\n    JsonFormat.Shape shape = null;\n    if (accessor != null) {\n        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n        if (format != null) {\n            shape = format.getShape();\n            // or, alternatively, asked to revert \"back to\" other representations...\n            if (shape != _serializationShape) {\n                if (_handledType.isEnum()) {\n                    switch(shape) {\n                        case STRING:\n                        case NUMBER:\n                        case NUMBER_INT:\n                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n                            //   for now, just do class ones\n                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n                            return provider.handlePrimaryContextualization(ser, property);\n                        default:\n                            break; // need to add this for correctness, even though it is a no-op\n                    }\n                }\n            }\n        }\n    }\n    ObjectIdWriter oiw = _objectIdWriter;\n    String[] ignorals = null;\n    Object newFilterId = null;\n    // Then we may have an override for Object Id\n    if (accessor != null) {\n        ignorals = intr.findPropertiesToIgnore(accessor, true);\n        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n        if (objectIdInfo == null) {\n            // no ObjectId override, but maybe ObjectIdRef?\n            if (oiw != null) {\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n                oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n            }\n        } else {\n            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n            // to be able to move to SerializerProvider (where it really belongs)\n            // 2.1: allow modifications by \"id ref\" annotations as well:\n            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n            ObjectIdGenerator<?> gen;\n            Class<?> implClass = objectIdInfo.getGeneratorType();\n            JavaType type = provider.constructType(implClass);\n            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n            // Property-based generator is trickier\n            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n                // most special one, needs extra work\n                String propName = objectIdInfo.getPropertyName().getSimpleName();\n                BeanPropertyWriter idProp = null;\n                for (int i = 0, len = _props.length; ; ++i) {\n                    if (i == len) {\n                        throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n                    }\n                    BeanPropertyWriter prop = _props[i];\n                    if (propName.equals(prop.getName())) {\n                        idProp = prop;\n                        if (i > 0) {\n                            // note: must shuffle both regular properties and filtered\n                            System.arraycopy(_props, 0, _props, 1, i);\n                            _props[0] = idProp;\n                            if (_filteredProps != null) {\n                                BeanPropertyWriter fp = _filteredProps[i];\n                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                _filteredProps[0] = fp;\n                            }\n                        }\n                        break;\n                    }\n                }\n                idType = idProp.getType();\n                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n            } else {\n                // other types need to be simpler\n                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n            }\n        }\n        // Or change Filter Id in use?\n        Object filterId = intr.findFilterId(accessor);\n        if (filterId != null) {\n            // but only consider case of adding a new filter id (no removal via annotation)\n            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n                newFilterId = filterId;\n            }\n        }\n    }\n    // either way, need to resolve serializer:\n    BeanSerializerBase contextual = this;\n    if (oiw != null) {\n        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n        oiw = oiw.withSerializer(ser);\n        if (oiw != _objectIdWriter) {\n            contextual = contextual.withObjectIdWriter(oiw);\n        }\n    }\n    // And possibly add more properties to ignore\n    if (ignorals != null && ignorals.length != 0) {\n        contextual = contextual.withIgnorals(ignorals);\n    }\n    if (newFilterId != null) {\n        contextual = contextual.withFilterId(newFilterId);\n    }\n    if (shape == null) {\n        shape = _serializationShape;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return contextual.asArraySerializer();\n    }\n    return contextual;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n@@ -1,8 +1,120 @@\n @Override\n-public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n-    JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n-    if (ref != null) {\n-        objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n+public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n+    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n+    final SerializationConfig config = provider.getConfig();\n+    // Let's start with one big transmutation: Enums that are annotated\n+    // to serialize as Objects may want to revert\n+    JsonFormat.Shape shape = null;\n+    if (accessor != null) {\n+        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n+        if (format != null) {\n+            shape = format.getShape();\n+            // or, alternatively, asked to revert \"back to\" other representations...\n+            if (shape != _serializationShape) {\n+                if (_handledType.isEnum()) {\n+                    switch(shape) {\n+                        case STRING:\n+                        case NUMBER:\n+                        case NUMBER_INT:\n+                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n+                            //   for now, just do class ones\n+                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n+                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n+                            return provider.handlePrimaryContextualization(ser, property);\n+                        default:\n+                            break; // need to add this for correctness, even though it is a no-op\n+                    }\n+                }\n+            }\n+        }\n     }\n-    return objectIdInfo;\n+    ObjectIdWriter oiw = _objectIdWriter;\n+    String[] ignorals = null;\n+    Object newFilterId = null;\n+    // Then we may have an override for Object Id\n+    if (accessor != null) {\n+        ignorals = intr.findPropertiesToIgnore(accessor, true);\n+        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n+        if (objectIdInfo == null) {\n+            // no ObjectId override, but maybe ObjectIdRef?\n+            if (oiw != null) {\n+                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n+                oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n+            }\n+        } else {\n+            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n+            // to be able to move to SerializerProvider (where it really belongs)\n+            // 2.1: allow modifications by \"id ref\" annotations as well:\n+            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n+            ObjectIdGenerator<?> gen;\n+            Class<?> implClass = objectIdInfo.getGeneratorType();\n+            JavaType type = provider.constructType(implClass);\n+            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n+            // Property-based generator is trickier\n+            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n+                // most special one, needs extra work\n+                String propName = objectIdInfo.getPropertyName().getSimpleName();\n+                BeanPropertyWriter idProp = null;\n+                for (int i = 0, len = _props.length; ; ++i) {\n+                    if (i == len) {\n+                        throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n+                    }\n+                    BeanPropertyWriter prop = _props[i];\n+                    if (propName.equals(prop.getName())) {\n+                        idProp = prop;\n+                        if (i > 0) {\n+                            // note: must shuffle both regular properties and filtered\n+                            System.arraycopy(_props, 0, _props, 1, i);\n+                            _props[0] = idProp;\n+                            if (_filteredProps != null) {\n+                                BeanPropertyWriter fp = _filteredProps[i];\n+                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n+                                _filteredProps[0] = fp;\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+                idType = idProp.getType();\n+                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n+                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n+            } else {\n+                // other types need to be simpler\n+                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n+                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n+            }\n+        }\n+        // Or change Filter Id in use?\n+        Object filterId = intr.findFilterId(accessor);\n+        if (filterId != null) {\n+            // but only consider case of adding a new filter id (no removal via annotation)\n+            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n+                newFilterId = filterId;\n+            }\n+        }\n+    }\n+    // either way, need to resolve serializer:\n+    BeanSerializerBase contextual = this;\n+    if (oiw != null) {\n+        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n+        oiw = oiw.withSerializer(ser);\n+        if (oiw != _objectIdWriter) {\n+            contextual = contextual.withObjectIdWriter(oiw);\n+        }\n+    }\n+    // And possibly add more properties to ignore\n+    if (ignorals != null && ignorals.length != 0) {\n+        contextual = contextual.withIgnorals(ignorals);\n+    }\n+    if (newFilterId != null) {\n+        contextual = contextual.withFilterId(newFilterId);\n+    }\n+    if (shape == null) {\n+        shape = _serializationShape;\n+    }\n+    if (shape == JsonFormat.Shape.ARRAY) {\n+        return contextual.asArraySerializer();\n+    }\n+    return contextual;\n }\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@createContextual\n@@ -23,6 +23,8 @@\n                             BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                             JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n                             return provider.handlePrimaryContextualization(ser, property);\n+                        default:\n+                            break; // need to add this for correctness, even though it is a no-op\n                     }\n                 }\n             }\n@@ -62,7 +64,7 @@\n                     BeanPropertyWriter prop = _props[i];\n                     if (propName.equals(prop.getName())) {\n                         idProp = prop;\n-                                                if (i > 0) {\n+                        if (i > 0) {\n                             // note: must shuffle both regular properties and filtered\n                             System.arraycopy(_props, 0, _props, 1, i);\n                             _props[0] = idProp;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"incomplete-switch\")\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n    final SerializationConfig config = provider.getConfig();\n    // Let's start with one big transmutation: Enums that are annotated\n    // to serialize as Objects may want to revert\n    JsonFormat.Shape shape = null;\n    if (accessor != null) {\n        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n        if (format != null) {\n            shape = format.getShape();\n            // or, alternatively, asked to revert \"back to\" other representations...\n            if (shape != _serializationShape) {\n                if (_handledType.isEnum()) {\n                    switch(shape) {\n                        case STRING:\n                        case NUMBER:\n                        case NUMBER_INT:\n                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n                            //   for now, just do class ones\n                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n                            return provider.handlePrimaryContextualization(ser, property);\n                    }\n                }\n            }\n        }\n    }\n    ObjectIdWriter oiw = _objectIdWriter;\n    String[] ignorals = null;\n    Object newFilterId = null;\n    // Then we may have an override for Object Id\n    if (accessor != null) {\n        ignorals = intr.findPropertiesToIgnore(accessor, true);\n\n        if (_objectIdWriter != null && _objectIdWriter == oiw.withAlwaysAsId(true)) {\n            ObjectIdGenerator<?> gen = _objectIdWriter.getGenerator();\n            oiw = oiw.withAlwaysAsId(false).withSerializer(provider.findValueSerializer(gen.generateId(null), _objectIdWriter.property));\n        }\n\n        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n        if (objectIdInfo == null) {\n            // no ObjectId override, but maybe ObjectIdRef?\n            if (oiw != null) {\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n                oiw = oiw.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n            }\n        } else {\n            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n            // to be able to move to SerializerProvider (where it really belongs)\n            // 2.1: allow modifications by \"id ref\" annotations as well:\n            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n            ObjectIdGenerator<?> gen;\n            Class<?> implClass = objectIdInfo.getGeneratorType();\n            JavaType type = provider.constructType(implClass);\n            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n            // Property-based generator is trickier\n            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n                // most special one, needs extra work\n                String propName = objectIdInfo.getPropertyName().getSimpleName();\n                BeanPropertyWriter idProp = null;\n                for (int i = 0, len = _props.length; ; ++i) {\n                    if (i == len) {\n                        throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n                    }\n                    BeanPropertyWriter prop = _props[i];\n                    if (propName.equals(prop.getName())) {\n                        idProp = prop;\n                                                if (i > 0) {\n                            // note: must shuffle both regular properties and filtered\n                            System.arraycopy(_props, 0, _props, 1, i);\n                            _props[0] = idProp;\n                            if (_filteredProps != null) {\n                                BeanPropertyWriter fp = _filteredProps[i];\n                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                _filteredProps[0] = fp;\n                            }\n                        }\n                        break;\n                    }\n                }\n                idType = idProp.getType();\n                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n            } else {\n                // other types need to be simpler\n                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n            }\n        }\n        // Or change Filter Id in use?\n        Object filterId = intr.findFilterId(accessor);\n        if (filterId != null) {\n            // but only consider case of adding a new filter id (no removal via annotation)\n            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n                newFilterId = filterId;\n            }\n        }\n    }\n    // either way, need to resolve serializer:\n    BeanSerializerBase contextual = this;\n    if (oiw != null) {\n        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n        oiw = oiw.withSerializer(ser);\n        if (oiw != _objectIdWriter) {\n            contextual = contextual.withObjectIdWriter(oiw);\n        }\n    }\n    // And possibly add more properties to ignore\n    if (ignorals != null && ignorals.length != 0) {\n        contextual = contextual.withIgnorals(ignorals);\n    }\n    if (newFilterId != null) {\n        contextual = contextual.withFilterId(newFilterId);\n    }\n    if (shape == null) {\n        shape = _serializationShape;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return contextual.asArraySerializer();\n    }\n    return contextual;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n@@ -1,8 +1,124 @@\n @Override\n-public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n-    JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n-    if (ref != null) {\n-        objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n+public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n+    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n+    final SerializationConfig config = provider.getConfig();\n+    // Let's start with one big transmutation: Enums that are annotated\n+    // to serialize as Objects may want to revert\n+    JsonFormat.Shape shape = null;\n+    if (accessor != null) {\n+        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n+        if (format != null) {\n+            shape = format.getShape();\n+            // or, alternatively, asked to revert \"back to\" other representations...\n+            if (shape != _serializationShape) {\n+                if (_handledType.isEnum()) {\n+                    switch(shape) {\n+                        case STRING:\n+                        case NUMBER:\n+                        case NUMBER_INT:\n+                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n+                            //   for now, just do class ones\n+                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n+                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n+                            return provider.handlePrimaryContextualization(ser, property);\n+                    }\n+                }\n+            }\n+        }\n     }\n-    return objectIdInfo;\n+    ObjectIdWriter oiw = _objectIdWriter;\n+    String[] ignorals = null;\n+    Object newFilterId = null;\n+    // Then we may have an override for Object Id\n+    if (accessor != null) {\n+        ignorals = intr.findPropertiesToIgnore(accessor, true);\n+\n+        if (_objectIdWriter != null && _objectIdWriter == oiw.withAlwaysAsId(true)) {\n+            ObjectIdGenerator<?> gen = _objectIdWriter.getGenerator();\n+            oiw = oiw.withAlwaysAsId(false).withSerializer(provider.findValueSerializer(gen.generateId(null), _objectIdWriter.property));\n+        }\n+\n+        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n+        if (objectIdInfo == null) {\n+            // no ObjectId override, but maybe ObjectIdRef?\n+            if (oiw != null) {\n+                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n+                oiw = oiw.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n+            }\n+        } else {\n+            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n+            // to be able to move to SerializerProvider (where it really belongs)\n+            // 2.1: allow modifications by \"id ref\" annotations as well:\n+            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n+            ObjectIdGenerator<?> gen;\n+            Class<?> implClass = objectIdInfo.getGeneratorType();\n+            JavaType type = provider.constructType(implClass);\n+            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n+            // Property-based generator is trickier\n+            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n+                // most special one, needs extra work\n+                String propName = objectIdInfo.getPropertyName().getSimpleName();\n+                BeanPropertyWriter idProp = null;\n+                for (int i = 0, len = _props.length; ; ++i) {\n+                    if (i == len) {\n+                        throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n+                    }\n+                    BeanPropertyWriter prop = _props[i];\n+                    if (propName.equals(prop.getName())) {\n+                        idProp = prop;\n+                                                if (i > 0) {\n+                            // note: must shuffle both regular properties and filtered\n+                            System.arraycopy(_props, 0, _props, 1, i);\n+                            _props[0] = idProp;\n+                            if (_filteredProps != null) {\n+                                BeanPropertyWriter fp = _filteredProps[i];\n+                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n+                                _filteredProps[0] = fp;\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+                idType = idProp.getType();\n+                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n+                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n+            } else {\n+                // other types need to be simpler\n+                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n+                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n+            }\n+        }\n+        // Or change Filter Id in use?\n+        Object filterId = intr.findFilterId(accessor);\n+        if (filterId != null) {\n+            // but only consider case of adding a new filter id (no removal via annotation)\n+            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n+                newFilterId = filterId;\n+            }\n+        }\n+    }\n+    // either way, need to resolve serializer:\n+    BeanSerializerBase contextual = this;\n+    if (oiw != null) {\n+        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n+        oiw = oiw.withSerializer(ser);\n+        if (oiw != _objectIdWriter) {\n+            contextual = contextual.withObjectIdWriter(oiw);\n+        }\n+    }\n+    // And possibly add more properties to ignore\n+    if (ignorals != null && ignorals.length != 0) {\n+        contextual = contextual.withIgnorals(ignorals);\n+    }\n+    if (newFilterId != null) {\n+        contextual = contextual.withFilterId(newFilterId);\n+    }\n+    if (shape == null) {\n+        shape = _serializationShape;\n+    }\n+    if (shape == JsonFormat.Shape.ARRAY) {\n+        return contextual.asArraySerializer();\n+    }\n+    return contextual;\n }\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@createContextual\n@@ -34,12 +34,18 @@\n     // Then we may have an override for Object Id\n     if (accessor != null) {\n         ignorals = intr.findPropertiesToIgnore(accessor, true);\n+\n+        if (_objectIdWriter != null && _objectIdWriter == oiw.withAlwaysAsId(true)) {\n+            ObjectIdGenerator<?> gen = _objectIdWriter.getGenerator();\n+            oiw = oiw.withAlwaysAsId(false).withSerializer(provider.findValueSerializer(gen.generateId(null), _objectIdWriter.property));\n+        }\n+\n         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n         if (objectIdInfo == null) {\n             // no ObjectId override, but maybe ObjectIdRef?\n             if (oiw != null) {\n                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n-                oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n+                oiw = oiw.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n             }\n         } else {\n             // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"incomplete-switch\")\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n    final SerializationConfig config = provider.getConfig();\n    // Let's start with one big transmutation: Enums that are annotated\n    // to serialize as Objects may want to revert\n    JsonFormat.Shape shape = null;\n    if (accessor != null) {\n        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n        if (format != null) {\n            shape = format.getShape();\n            // or, alternatively, asked to revert \"back to\" other representations...\n            if (shape != _serializationShape) {\n                if (_handledType.isEnum()) {\n                    switch(shape) {\n                        case STRING:\n                        case NUMBER:\n                        case NUMBER_INT:\n                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n                            //   for now, just do class ones\n                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n                            return provider.handlePrimaryContextualization(ser, property);\n                        default:\n                            break;\n                    }\n                }\n            }\n        }\n    }\n    ObjectIdWriter oiw = _objectIdWriter;\n    String[] ignorals = null;\n    Object newFilterId = null;\n    // Then we may have an override for Object Id\n    if (accessor != null) {\n        ignorals = intr.findPropertiesToIgnore(accessor, true);\n        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n        if (objectIdInfo != null) {\n            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n            // to be able to move to SerializerProvider (where it really belongs)\n            // 2.1: allow modifications by \"id ref\" annotations as well:\n            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n            ObjectIdGenerator<?> gen;\n            Class<?> implClass = objectIdInfo.getGeneratorType();\n            JavaType type = provider.constructType(implClass);\n            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n            // Property-based generator is trickier\n            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n                // most special one, needs extra work\n                String propName = objectIdInfo.getPropertyName().getSimpleName();\n                BeanPropertyWriter idProp = null;\n                for (int i = 0, len = _props.length; ; ++i) {\n                    if (i == len) {\n                        throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n                    }\n                    BeanPropertyWriter prop = _props[i];\n                    if (propName.equals(prop.getName())) {\n                        idProp = prop;\n                                                if (i > 0) {\n                            // note: must shuffle both regular properties and filtered\n                            System.arraycopy(_props, 0, _props, 1, i);\n                            _props[0] = idProp;\n                            if (_filteredProps != null) {\n                                BeanPropertyWriter fp = _filteredProps[i];\n                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                _filteredProps[0] = fp;\n                            }\n                        }\n                        break;\n                    }\n                }\n                idType = idProp.getType();\n                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n            } else {\n                // other types need to be simpler\n                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n            }\n        }\n        // Or change Filter Id in use?\n        Object filterId = intr.findFilterId(accessor);\n        if (filterId != null) {\n            // but only consider case of adding a new filter id (no removal via annotation)\n            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n                newFilterId = filterId;\n            }\n        }\n    }\n    // either way, need to resolve serializer:\n    BeanSerializerBase contextual = this;\n    if (oiw != null) {\n        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n        oiw = oiw.withSerializer(ser);\n        if (oiw != _objectIdWriter) {\n            contextual = contextual.withObjectIdWriter(oiw);\n        }\n    }\n    // And possibly add more properties to ignore\n    if (ignorals != null && ignorals.length != 0) {\n        contextual = contextual.withIgnorals(ignorals);\n    }\n    if (newFilterId != null) {\n        contextual = contextual.withFilterId(newFilterId);\n    }\n    if (shape == null) {\n        shape = _serializationShape;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return contextual.asArraySerializer();\n    }\n    return contextual;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n@@ -1,8 +1,114 @@\n @Override\n-public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n-    JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n-    if (ref != null) {\n-        objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n+public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n+    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n+    final SerializationConfig config = provider.getConfig();\n+    // Let's start with one big transmutation: Enums that are annotated\n+    // to serialize as Objects may want to revert\n+    JsonFormat.Shape shape = null;\n+    if (accessor != null) {\n+        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n+        if (format != null) {\n+            shape = format.getShape();\n+            // or, alternatively, asked to revert \"back to\" other representations...\n+            if (shape != _serializationShape) {\n+                if (_handledType.isEnum()) {\n+                    switch(shape) {\n+                        case STRING:\n+                        case NUMBER:\n+                        case NUMBER_INT:\n+                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n+                            //   for now, just do class ones\n+                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n+                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n+                            return provider.handlePrimaryContextualization(ser, property);\n+                        default:\n+                            break;\n+                    }\n+                }\n+            }\n+        }\n     }\n-    return objectIdInfo;\n+    ObjectIdWriter oiw = _objectIdWriter;\n+    String[] ignorals = null;\n+    Object newFilterId = null;\n+    // Then we may have an override for Object Id\n+    if (accessor != null) {\n+        ignorals = intr.findPropertiesToIgnore(accessor, true);\n+        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n+        if (objectIdInfo != null) {\n+            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n+            // to be able to move to SerializerProvider (where it really belongs)\n+            // 2.1: allow modifications by \"id ref\" annotations as well:\n+            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n+            ObjectIdGenerator<?> gen;\n+            Class<?> implClass = objectIdInfo.getGeneratorType();\n+            JavaType type = provider.constructType(implClass);\n+            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n+            // Property-based generator is trickier\n+            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n+                // most special one, needs extra work\n+                String propName = objectIdInfo.getPropertyName().getSimpleName();\n+                BeanPropertyWriter idProp = null;\n+                for (int i = 0, len = _props.length; ; ++i) {\n+                    if (i == len) {\n+                        throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n+                    }\n+                    BeanPropertyWriter prop = _props[i];\n+                    if (propName.equals(prop.getName())) {\n+                        idProp = prop;\n+                                                if (i > 0) {\n+                            // note: must shuffle both regular properties and filtered\n+                            System.arraycopy(_props, 0, _props, 1, i);\n+                            _props[0] = idProp;\n+                            if (_filteredProps != null) {\n+                                BeanPropertyWriter fp = _filteredProps[i];\n+                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n+                                _filteredProps[0] = fp;\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+                idType = idProp.getType();\n+                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n+                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n+            } else {\n+                // other types need to be simpler\n+                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n+                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n+            }\n+        }\n+        // Or change Filter Id in use?\n+        Object filterId = intr.findFilterId(accessor);\n+        if (filterId != null) {\n+            // but only consider case of adding a new filter id (no removal via annotation)\n+            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n+                newFilterId = filterId;\n+            }\n+        }\n+    }\n+    // either way, need to resolve serializer:\n+    BeanSerializerBase contextual = this;\n+    if (oiw != null) {\n+        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n+        oiw = oiw.withSerializer(ser);\n+        if (oiw != _objectIdWriter) {\n+            contextual = contextual.withObjectIdWriter(oiw);\n+        }\n+    }\n+    // And possibly add more properties to ignore\n+    if (ignorals != null && ignorals.length != 0) {\n+        contextual = contextual.withIgnorals(ignorals);\n+    }\n+    if (newFilterId != null) {\n+        contextual = contextual.withFilterId(newFilterId);\n+    }\n+    if (shape == null) {\n+        shape = _serializationShape;\n+    }\n+    if (shape == JsonFormat.Shape.ARRAY) {\n+        return contextual.asArraySerializer();\n+    }\n+    return contextual;\n }\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@createContextual\n@@ -23,6 +23,8 @@\n                             BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                             JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n                             return provider.handlePrimaryContextualization(ser, property);\n+                        default:\n+                            break;\n                     }\n                 }\n             }\n@@ -35,13 +37,7 @@\n     if (accessor != null) {\n         ignorals = intr.findPropertiesToIgnore(accessor, true);\n         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n-        if (objectIdInfo == null) {\n-            // no ObjectId override, but maybe ObjectIdRef?\n-            if (oiw != null) {\n-                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n-                oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n-            }\n-        } else {\n+        if (objectIdInfo != null) {\n             // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n             // to be able to move to SerializerProvider (where it really belongs)\n             // 2.1: allow modifications by \"id ref\" annotations as well:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"incomplete-switch\")\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n    final SerializationConfig config = provider.getConfig();\n    // Let's start with one big transmutation: Enums that are annotated\n    // to serialize as Objects may want to revert\n    JsonFormat.Shape shape = null;\n    if (accessor != null) {\n        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n        if (format != null) {\n            shape = format.getShape();\n            // or, alternatively, asked to revert \"back to\" other representations...\n            if (shape != _serializationShape) {\n                if (_handledType.isEnum()) {\n                    switch(shape) {\n                        case STRING:\n                        case NUMBER:\n                        case NUMBER_INT:\n                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n                            //   for now, just do class ones\n                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n                            return provider.handlePrimaryContextualization(ser, property);\n                        default:\n                            break; // no fix needed\n                    }\n                }\n            }\n        }\n    }\n    ObjectIdWriter oiw = _objectIdWriter;\n    String[] ignorals = null;\n    Object newFilterId = null;\n    // Then we may have an override for Object Id\n    if (accessor != null) {\n        ignorals = intr.findPropertiesToIgnore(accessor, true);\n        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n        if (objectIdInfo == null) {\n            // no ObjectId override, but maybe ObjectIdRef?\n            if (oiw != null) {\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n                oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n            }\n        } else {\n            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n            // to be able to move to SerializerProvider (where it really belongs)\n            // 2.1: allow modifications by \"id ref\" annotations as well:\n            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n            ObjectIdGenerator<?> gen;\n            Class<?> implClass = objectIdInfo.getGeneratorType();\n            JavaType type = provider.constructType(implClass);\n            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n            // Property-based generator is trickier\n            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n                // most special one, needs extra work\n                String propName = objectIdInfo.getPropertyName().getSimpleName();\n                BeanPropertyWriter idProp = null;\n                for (int i = 0, len = _props.length; ; ++i) {\n                    if (i == len) {\n                        throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n                    }\n                    BeanPropertyWriter prop = _props[i];\n                    if (propName.equals(prop.getName())) {\n                        idProp = prop;\n                        if (i > 0) {\n                            // note: must shuffle both regular properties and filtered\n                            System.arraycopy(_props, 0, _props, 1, i);\n                            _props[0] = idProp;\n                            if (_filteredProps != null) {\n                                BeanPropertyWriter fp = _filteredProps[i];\n                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                _filteredProps[0] = fp;\n                            }\n                        }\n                        break;\n                    }\n                }\n                if (idProp != null) { // fixed potential null pointer\n                    idType = idProp.getType();\n                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                    oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n                }\n            } else {\n                // other types need to be simpler\n                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n            }\n        }\n        // Or change Filter Id in use?\n        Object filterId = intr.findFilterId(accessor);\n        if (filterId != null) {\n            // but only consider case of adding a new filter id (no removal via annotation)\n            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n                newFilterId = filterId;\n            }\n        }\n    }\n    // either way, need to resolve serializer:\n    BeanSerializerBase contextual = this;\n    if (oiw != null) {\n        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n        oiw = oiw.withSerializer(ser);\n        if (oiw != _objectIdWriter) {\n            contextual = contextual.withObjectIdWriter(oiw);\n        }\n    }\n    // And possibly add more properties to ignore\n    if (ignorals != null && ignorals.length > 0) { // fixed comparison\n        contextual = contextual.withIgnorals(ignorals);\n    }\n    if (newFilterId != null) {\n        contextual = contextual.withFilterId(newFilterId);\n    }\n    if (shape == null) {\n        shape = _serializationShape;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return contextual.asArraySerializer();\n    }\n    return contextual;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n@@ -1,8 +1,122 @@\n @Override\n-public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n-    JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n-    if (ref != null) {\n-        objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n+public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n+    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n+    final SerializationConfig config = provider.getConfig();\n+    // Let's start with one big transmutation: Enums that are annotated\n+    // to serialize as Objects may want to revert\n+    JsonFormat.Shape shape = null;\n+    if (accessor != null) {\n+        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n+        if (format != null) {\n+            shape = format.getShape();\n+            // or, alternatively, asked to revert \"back to\" other representations...\n+            if (shape != _serializationShape) {\n+                if (_handledType.isEnum()) {\n+                    switch(shape) {\n+                        case STRING:\n+                        case NUMBER:\n+                        case NUMBER_INT:\n+                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n+                            //   for now, just do class ones\n+                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n+                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n+                            return provider.handlePrimaryContextualization(ser, property);\n+                        default:\n+                            break; // no fix needed\n+                    }\n+                }\n+            }\n+        }\n     }\n-    return objectIdInfo;\n+    ObjectIdWriter oiw = _objectIdWriter;\n+    String[] ignorals = null;\n+    Object newFilterId = null;\n+    // Then we may have an override for Object Id\n+    if (accessor != null) {\n+        ignorals = intr.findPropertiesToIgnore(accessor, true);\n+        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n+        if (objectIdInfo == null) {\n+            // no ObjectId override, but maybe ObjectIdRef?\n+            if (oiw != null) {\n+                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n+                oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n+            }\n+        } else {\n+            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n+            // to be able to move to SerializerProvider (where it really belongs)\n+            // 2.1: allow modifications by \"id ref\" annotations as well:\n+            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n+            ObjectIdGenerator<?> gen;\n+            Class<?> implClass = objectIdInfo.getGeneratorType();\n+            JavaType type = provider.constructType(implClass);\n+            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n+            // Property-based generator is trickier\n+            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n+                // most special one, needs extra work\n+                String propName = objectIdInfo.getPropertyName().getSimpleName();\n+                BeanPropertyWriter idProp = null;\n+                for (int i = 0, len = _props.length; ; ++i) {\n+                    if (i == len) {\n+                        throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n+                    }\n+                    BeanPropertyWriter prop = _props[i];\n+                    if (propName.equals(prop.getName())) {\n+                        idProp = prop;\n+                        if (i > 0) {\n+                            // note: must shuffle both regular properties and filtered\n+                            System.arraycopy(_props, 0, _props, 1, i);\n+                            _props[0] = idProp;\n+                            if (_filteredProps != null) {\n+                                BeanPropertyWriter fp = _filteredProps[i];\n+                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n+                                _filteredProps[0] = fp;\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+                if (idProp != null) { // fixed potential null pointer\n+                    idType = idProp.getType();\n+                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n+                    oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n+                }\n+            } else {\n+                // other types need to be simpler\n+                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n+                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n+            }\n+        }\n+        // Or change Filter Id in use?\n+        Object filterId = intr.findFilterId(accessor);\n+        if (filterId != null) {\n+            // but only consider case of adding a new filter id (no removal via annotation)\n+            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n+                newFilterId = filterId;\n+            }\n+        }\n+    }\n+    // either way, need to resolve serializer:\n+    BeanSerializerBase contextual = this;\n+    if (oiw != null) {\n+        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n+        oiw = oiw.withSerializer(ser);\n+        if (oiw != _objectIdWriter) {\n+            contextual = contextual.withObjectIdWriter(oiw);\n+        }\n+    }\n+    // And possibly add more properties to ignore\n+    if (ignorals != null && ignorals.length > 0) { // fixed comparison\n+        contextual = contextual.withIgnorals(ignorals);\n+    }\n+    if (newFilterId != null) {\n+        contextual = contextual.withFilterId(newFilterId);\n+    }\n+    if (shape == null) {\n+        shape = _serializationShape;\n+    }\n+    if (shape == JsonFormat.Shape.ARRAY) {\n+        return contextual.asArraySerializer();\n+    }\n+    return contextual;\n }\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@createContextual\n@@ -23,6 +23,8 @@\n                             BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                             JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n                             return provider.handlePrimaryContextualization(ser, property);\n+                        default:\n+                            break; // no fix needed\n                     }\n                 }\n             }\n@@ -62,7 +64,7 @@\n                     BeanPropertyWriter prop = _props[i];\n                     if (propName.equals(prop.getName())) {\n                         idProp = prop;\n-                                                if (i > 0) {\n+                        if (i > 0) {\n                             // note: must shuffle both regular properties and filtered\n                             System.arraycopy(_props, 0, _props, 1, i);\n                             _props[0] = idProp;\n@@ -75,9 +77,11 @@\n                         break;\n                     }\n                 }\n-                idType = idProp.getType();\n-                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n-                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n+                if (idProp != null) { // fixed potential null pointer\n+                    idType = idProp.getType();\n+                    gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n+                    oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n+                }\n             } else {\n                 // other types need to be simpler\n                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n@@ -103,7 +107,7 @@\n         }\n     }\n     // And possibly add more properties to ignore\n-    if (ignorals != null && ignorals.length != 0) {\n+    if (ignorals != null && ignorals.length > 0) { // fixed comparison\n         contextual = contextual.withIgnorals(ignorals);\n     }\n     if (newFilterId != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"incomplete-switch\")\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n    final SerializationConfig config = provider.getConfig();\n    // Let's start with one big transmutation: Enums that are annotated\n    // to serialize as Objects may want to revert\n    JsonFormat.Shape shape = null;\n    if (accessor != null) {\n        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n        if (format != null) {\n            shape = format.getShape();\n            // or, alternatively, asked to revert \"back to\" other representations...\n            if (shape != _serializationShape) {\n                if (_handledType.isEnum()) {\n                    switch(shape) {\n                        case STRING:\n                        case NUMBER:\n                        case NUMBER_INT:\n                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n                            //   for now, just do class ones\n                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n                            return provider.handlePrimaryContextualization(ser, property);\n                    }\n                }\n            }\n        }\n    }\n    ObjectIdWriter oiw = _objectIdWriter;\n    String[] ignorals = null;\n    Object newFilterId = null;\n    // Then we may have an override for Object Id\n    if (accessor != null) {\n        ignorals = intr.findPropertiesToIgnore(accessor, true);\n        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n        if (objectIdInfo == null) {\n            // no ObjectId override, but maybe ObjectIdRef?\n            if (oiw != null) {\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n                oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n            }\n        } else {\n            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n            // to be able to move to SerializerProvider (where it really belongs)\n            // 2.1: allow modifications by \"id ref\" annotations as well:\n            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n            ObjectIdGenerator<?> gen;\n            Class<?> implClass = objectIdInfo.getGeneratorType();\n            JavaType type = provider.constructType(implClass);\n            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n            // Property-based generator is trickier\n            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n                // most special one, needs extra work\n                String propName = objectIdInfo.getPropertyName().getSimpleName();\n                BeanPropertyWriter idProp = null;\n                for (int i = 0, len = _props.length; i < len; ++i) {\n                    BeanPropertyWriter prop = _props[i];\n                    if (propName.equals(prop.getName())) {\n                        idProp = prop;\n                        if (i > 0) {\n                            // note: must shuffle both regular properties and filtered\n                            System.arraycopy(_props, 0, _props, 1, i);\n                            _props[0] = idProp;\n                            if (_filteredProps != null) {\n                                BeanPropertyWriter fp = _filteredProps[i];\n                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                _filteredProps[0] = fp;\n                            }\n                        }\n                        break;\n                    }\n                }\n                if (idProp == null) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n                }\n                idType = idProp.getType();\n                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n            } else {\n                // other types need to be simpler\n                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n            }\n        }\n        // Or change Filter Id in use?\n        Object filterId = intr.findFilterId(accessor);\n        if (filterId != null) {\n            // but only consider case of adding a new filter id (no removal via annotation)\n            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n                newFilterId = filterId;\n            }\n        }\n    }\n    // either way, need to resolve serializer:\n    BeanSerializerBase contextual = this;\n    if (oiw != null) {\n        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n        oiw = oiw.withSerializer(ser);\n        if (oiw != _objectIdWriter) {\n            contextual = contextual.withObjectIdWriter(oiw);\n        }\n    }\n    // And possibly add more properties to ignore\n    if (ignorals != null && ignorals.length != 0) {\n        contextual = contextual.withIgnorals(ignorals);\n    }\n    if (newFilterId != null) {\n        contextual = contextual.withFilterId(newFilterId);\n    }\n    if (shape == null) {\n        shape = _serializationShape;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return contextual.asArraySerializer();\n    }\n    return contextual;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n@@ -1,8 +1,118 @@\n @Override\n-public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n-    JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n-    if (ref != null) {\n-        objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n+public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n+    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n+    final SerializationConfig config = provider.getConfig();\n+    // Let's start with one big transmutation: Enums that are annotated\n+    // to serialize as Objects may want to revert\n+    JsonFormat.Shape shape = null;\n+    if (accessor != null) {\n+        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n+        if (format != null) {\n+            shape = format.getShape();\n+            // or, alternatively, asked to revert \"back to\" other representations...\n+            if (shape != _serializationShape) {\n+                if (_handledType.isEnum()) {\n+                    switch(shape) {\n+                        case STRING:\n+                        case NUMBER:\n+                        case NUMBER_INT:\n+                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n+                            //   for now, just do class ones\n+                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n+                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n+                            return provider.handlePrimaryContextualization(ser, property);\n+                    }\n+                }\n+            }\n+        }\n     }\n-    return objectIdInfo;\n+    ObjectIdWriter oiw = _objectIdWriter;\n+    String[] ignorals = null;\n+    Object newFilterId = null;\n+    // Then we may have an override for Object Id\n+    if (accessor != null) {\n+        ignorals = intr.findPropertiesToIgnore(accessor, true);\n+        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n+        if (objectIdInfo == null) {\n+            // no ObjectId override, but maybe ObjectIdRef?\n+            if (oiw != null) {\n+                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n+                oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n+            }\n+        } else {\n+            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n+            // to be able to move to SerializerProvider (where it really belongs)\n+            // 2.1: allow modifications by \"id ref\" annotations as well:\n+            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n+            ObjectIdGenerator<?> gen;\n+            Class<?> implClass = objectIdInfo.getGeneratorType();\n+            JavaType type = provider.constructType(implClass);\n+            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n+            // Property-based generator is trickier\n+            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n+                // most special one, needs extra work\n+                String propName = objectIdInfo.getPropertyName().getSimpleName();\n+                BeanPropertyWriter idProp = null;\n+                for (int i = 0, len = _props.length; i < len; ++i) {\n+                    BeanPropertyWriter prop = _props[i];\n+                    if (propName.equals(prop.getName())) {\n+                        idProp = prop;\n+                        if (i > 0) {\n+                            // note: must shuffle both regular properties and filtered\n+                            System.arraycopy(_props, 0, _props, 1, i);\n+                            _props[0] = idProp;\n+                            if (_filteredProps != null) {\n+                                BeanPropertyWriter fp = _filteredProps[i];\n+                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n+                                _filteredProps[0] = fp;\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+                if (idProp == null) {\n+                    throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n+                }\n+                idType = idProp.getType();\n+                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n+                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n+            } else {\n+                // other types need to be simpler\n+                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n+                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n+            }\n+        }\n+        // Or change Filter Id in use?\n+        Object filterId = intr.findFilterId(accessor);\n+        if (filterId != null) {\n+            // but only consider case of adding a new filter id (no removal via annotation)\n+            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n+                newFilterId = filterId;\n+            }\n+        }\n+    }\n+    // either way, need to resolve serializer:\n+    BeanSerializerBase contextual = this;\n+    if (oiw != null) {\n+        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n+        oiw = oiw.withSerializer(ser);\n+        if (oiw != _objectIdWriter) {\n+            contextual = contextual.withObjectIdWriter(oiw);\n+        }\n+    }\n+    // And possibly add more properties to ignore\n+    if (ignorals != null && ignorals.length != 0) {\n+        contextual = contextual.withIgnorals(ignorals);\n+    }\n+    if (newFilterId != null) {\n+        contextual = contextual.withFilterId(newFilterId);\n+    }\n+    if (shape == null) {\n+        shape = _serializationShape;\n+    }\n+    if (shape == JsonFormat.Shape.ARRAY) {\n+        return contextual.asArraySerializer();\n+    }\n+    return contextual;\n }\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@createContextual\n@@ -55,14 +55,11 @@\n                 // most special one, needs extra work\n                 String propName = objectIdInfo.getPropertyName().getSimpleName();\n                 BeanPropertyWriter idProp = null;\n-                for (int i = 0, len = _props.length; ; ++i) {\n-                    if (i == len) {\n-                        throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n-                    }\n+                for (int i = 0, len = _props.length; i < len; ++i) {\n                     BeanPropertyWriter prop = _props[i];\n                     if (propName.equals(prop.getName())) {\n                         idProp = prop;\n-                                                if (i > 0) {\n+                        if (i > 0) {\n                             // note: must shuffle both regular properties and filtered\n                             System.arraycopy(_props, 0, _props, 1, i);\n                             _props[0] = idProp;\n@@ -74,6 +71,9 @@\n                         }\n                         break;\n                     }\n+                }\n+                if (idProp == null) {\n+                    throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n                 }\n                 idType = idProp.getType();\n                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"incomplete-switch\")\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n    final SerializationConfig config = provider.getConfig();\n    // Let's start with one big transmutation: Enums that are annotated\n    // to serialize as Objects may want to revert\n    JsonFormat.Shape shape = null;\n    if (accessor != null) {\n        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n        if (format != null) {\n            shape = format.getShape();\n            // or, alternatively, asked to revert \"back to\" other representations...\n            if (shape != _serializationShape) {\n                if (_handledType.isEnum()) {\n                    switch(shape) {\n                        case STRING:\n                        case NUMBER:\n                        case NUMBER_INT:\n                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n                            //   for now, just do class ones\n                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n                            return provider.handlePrimaryContextualization(ser, property);\n                        default:\n                            // Fixed missing default case\n                            break;\n                    }\n                }\n            }\n        }\n    }\n    ObjectIdWriter oiw = _objectIdWriter;\n    String[] ignorals = null;\n    Object newFilterId = null;\n    // Then we may have an override for Object Id\n    if (accessor != null) {\n        ignorals = intr.findPropertiesToIgnore(accessor, true);\n        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n        if (objectIdInfo == null) {\n            // no ObjectId override, but maybe ObjectIdRef?\n            if (oiw != null) {\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n                oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n            }\n        } else {\n            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n            // to be able to move to SerializerProvider (where it really belongs)\n            // 2.1: allow modifications by \"id ref\" annotations as well:\n            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n            ObjectIdGenerator<?> gen;\n            Class<?> implClass = objectIdInfo.getGeneratorType();\n            JavaType type = provider.constructType(implClass);\n            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n            // Property-based generator is trickier\n            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n                // most special one, needs extra work\n                String propName = objectIdInfo.getPropertyName().getSimpleName();\n                BeanPropertyWriter idProp = null;\n                for (int i = 0, len = _props.length; ; ++i) {\n                    if (i == len) {\n                        throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n                    }\n                    BeanPropertyWriter prop = _props[i];\n                    if (propName.equals(prop.getName())) {\n                        idProp = prop;\n                        if (i > 0) {\n                            // note: must shuffle both regular properties and filtered\n                            System.arraycopy(_props, 0, _props, 1, i);\n                            _props[0] = idProp;\n                            if (_filteredProps != null) {\n                                BeanPropertyWriter fp = _filteredProps[i];\n                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                _filteredProps[0] = fp;\n                            }\n                        }\n                        break;\n                    }\n                }\n                idType = idProp.getType();\n                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n            } else {\n                // other types need to be simpler\n                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n            }\n        }\n        // Or change Filter Id in use?\n        Object filterId = intr.findFilterId(accessor);\n        if (filterId != null) {\n            // but only consider case of adding a new filter id (no removal via annotation)\n            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n                newFilterId = filterId;\n            }\n        }\n    }\n    // either way, need to resolve serializer:\n    BeanSerializerBase contextual = this;\n    if (oiw != null) {\n        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n        oiw = oiw.withSerializer(ser);\n        if (oiw != _objectIdWriter) {\n            contextual = contextual.withObjectIdWriter(oiw);\n        }\n    }\n    // And possibly add more properties to ignore\n    if (ignorals != null && ignorals.length != 0) {\n        contextual = contextual.withIgnorals(ignorals);\n    }\n    if (newFilterId != null) {\n        contextual = contextual.withFilterId(newFilterId);\n    }\n    if (shape == null) {\n        shape = _serializationShape;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return contextual.asArraySerializer();\n    }\n    return contextual;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n@@ -1,8 +1,121 @@\n @Override\n-public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n-    JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n-    if (ref != null) {\n-        objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n+public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n+    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n+    final SerializationConfig config = provider.getConfig();\n+    // Let's start with one big transmutation: Enums that are annotated\n+    // to serialize as Objects may want to revert\n+    JsonFormat.Shape shape = null;\n+    if (accessor != null) {\n+        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n+        if (format != null) {\n+            shape = format.getShape();\n+            // or, alternatively, asked to revert \"back to\" other representations...\n+            if (shape != _serializationShape) {\n+                if (_handledType.isEnum()) {\n+                    switch(shape) {\n+                        case STRING:\n+                        case NUMBER:\n+                        case NUMBER_INT:\n+                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n+                            //   for now, just do class ones\n+                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n+                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n+                            return provider.handlePrimaryContextualization(ser, property);\n+                        default:\n+                            // Fixed missing default case\n+                            break;\n+                    }\n+                }\n+            }\n+        }\n     }\n-    return objectIdInfo;\n+    ObjectIdWriter oiw = _objectIdWriter;\n+    String[] ignorals = null;\n+    Object newFilterId = null;\n+    // Then we may have an override for Object Id\n+    if (accessor != null) {\n+        ignorals = intr.findPropertiesToIgnore(accessor, true);\n+        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n+        if (objectIdInfo == null) {\n+            // no ObjectId override, but maybe ObjectIdRef?\n+            if (oiw != null) {\n+                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n+                oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n+            }\n+        } else {\n+            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n+            // to be able to move to SerializerProvider (where it really belongs)\n+            // 2.1: allow modifications by \"id ref\" annotations as well:\n+            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n+            ObjectIdGenerator<?> gen;\n+            Class<?> implClass = objectIdInfo.getGeneratorType();\n+            JavaType type = provider.constructType(implClass);\n+            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n+            // Property-based generator is trickier\n+            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n+                // most special one, needs extra work\n+                String propName = objectIdInfo.getPropertyName().getSimpleName();\n+                BeanPropertyWriter idProp = null;\n+                for (int i = 0, len = _props.length; ; ++i) {\n+                    if (i == len) {\n+                        throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n+                    }\n+                    BeanPropertyWriter prop = _props[i];\n+                    if (propName.equals(prop.getName())) {\n+                        idProp = prop;\n+                        if (i > 0) {\n+                            // note: must shuffle both regular properties and filtered\n+                            System.arraycopy(_props, 0, _props, 1, i);\n+                            _props[0] = idProp;\n+                            if (_filteredProps != null) {\n+                                BeanPropertyWriter fp = _filteredProps[i];\n+                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n+                                _filteredProps[0] = fp;\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+                idType = idProp.getType();\n+                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n+                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n+            } else {\n+                // other types need to be simpler\n+                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n+                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n+            }\n+        }\n+        // Or change Filter Id in use?\n+        Object filterId = intr.findFilterId(accessor);\n+        if (filterId != null) {\n+            // but only consider case of adding a new filter id (no removal via annotation)\n+            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n+                newFilterId = filterId;\n+            }\n+        }\n+    }\n+    // either way, need to resolve serializer:\n+    BeanSerializerBase contextual = this;\n+    if (oiw != null) {\n+        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n+        oiw = oiw.withSerializer(ser);\n+        if (oiw != _objectIdWriter) {\n+            contextual = contextual.withObjectIdWriter(oiw);\n+        }\n+    }\n+    // And possibly add more properties to ignore\n+    if (ignorals != null && ignorals.length != 0) {\n+        contextual = contextual.withIgnorals(ignorals);\n+    }\n+    if (newFilterId != null) {\n+        contextual = contextual.withFilterId(newFilterId);\n+    }\n+    if (shape == null) {\n+        shape = _serializationShape;\n+    }\n+    if (shape == JsonFormat.Shape.ARRAY) {\n+        return contextual.asArraySerializer();\n+    }\n+    return contextual;\n }\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@createContextual\n@@ -23,6 +23,9 @@\n                             BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                             JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n                             return provider.handlePrimaryContextualization(ser, property);\n+                        default:\n+                            // Fixed missing default case\n+                            break;\n                     }\n                 }\n             }\n@@ -62,7 +65,7 @@\n                     BeanPropertyWriter prop = _props[i];\n                     if (propName.equals(prop.getName())) {\n                         idProp = prop;\n-                                                if (i > 0) {\n+                        if (i > 0) {\n                             // note: must shuffle both regular properties and filtered\n                             System.arraycopy(_props, 0, _props, 1, i);\n                             _props[0] = idProp;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n    final SerializationConfig config = provider.getConfig();\n    // Let's start with one big transmutation: Enums that are annotated\n    // to serialize as Objects may want to revert\n    JsonFormat.Shape shape = null;\n    if (accessor != null) {\n        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n        if (format != null) {\n            shape = format.getShape();\n            // or, alternatively, asked to revert \"back to\" other representations...\n            if (shape != _serializationShape) {\n                if (_handledType.isEnum()) {\n                    switch(shape) {\n                        case STRING:\n                        case NUMBER:\n                        case NUMBER_INT:\n                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n                            //   for now, just do class ones\n                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n                            return provider.handlePrimaryContextualization(ser, property);\n                    }\n                }\n            }\n        }\n    }\n    ObjectIdWriter oiw = _objectIdWriter;\n    String[] ignorals = null;\n    Object newFilterId = null;\n    // Then we may have an override for Object Id\n    if (accessor != null) {\n        ignorals = intr.findPropertiesToIgnore(accessor, true);\n        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n        if (objectIdInfo == null) {\n            // no ObjectId override, but maybe ObjectIdRef?\n            if (oiw != null) {\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n                oiw = oiw.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n            }\n        } else {\n            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n            // to be able to move to SerializerProvider (where it really belongs)\n            // 2.1: allow modifications by \"id ref\" annotations as well:\n            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n            ObjectIdGenerator<?> gen;\n            Class<?> implClass = objectIdInfo.getGeneratorType();\n            JavaType type = provider.constructType(implClass);\n            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n            // Property-based generator is trickier\n            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n                // most special one, needs extra work\n                String propName = objectIdInfo.getPropertyName().getSimpleName();\n                BeanPropertyWriter idProp = null;\n                for (int i = 0, len = _props.length; i < len; ++i) {\n                    BeanPropertyWriter prop = _props[i];\n                    if (propName.equals(prop.getName())) {\n                        idProp = prop;\n                        if (i > 0) {\n                            // note: must shuffle both regular properties and filtered\n                            System.arraycopy(_props, 0, _props, 1, i);\n                            _props[0] = idProp;\n                            if (_filteredProps != null) {\n                                BeanPropertyWriter fp = _filteredProps[i];\n                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                _filteredProps[0] = fp;\n                            }\n                        }\n                        break;\n                    }\n                }\n                if(idProp == null){\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n                }\n                idType = idProp.getType();\n                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n            } else {\n                // other types need to be simpler\n                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n            }\n        }\n        // Or change Filter Id in use?\n        Object filterId = intr.findFilterId(accessor);\n        if (filterId != null) {\n            // but only consider case of adding a new filter id (no removal via annotation)\n            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n                newFilterId = filterId;\n            }\n        }\n    }\n    // either way, need to resolve serializer:\n    BeanSerializerBase contextual = this;\n    if (oiw != null) {\n        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n        oiw = oiw.withSerializer(ser);\n        if (oiw != _objectIdWriter) {\n            contextual = contextual.withObjectIdWriter(oiw);\n        }\n    }\n    // And possibly add more properties to ignore\n    if (ignorals != null && ignorals.length != 0) {\n        contextual = contextual.withIgnorals(ignorals);\n    }\n    if (newFilterId != null) {\n        contextual = contextual.withFilterId(newFilterId);\n    }\n    if (shape == null) {\n        shape = _serializationShape;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return contextual.asArraySerializer();\n    }\n    return contextual;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n@@ -1,8 +1,118 @@\n @Override\n-public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n-    JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n-    if (ref != null) {\n-        objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n+public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n+    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n+    final SerializationConfig config = provider.getConfig();\n+    // Let's start with one big transmutation: Enums that are annotated\n+    // to serialize as Objects may want to revert\n+    JsonFormat.Shape shape = null;\n+    if (accessor != null) {\n+        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n+        if (format != null) {\n+            shape = format.getShape();\n+            // or, alternatively, asked to revert \"back to\" other representations...\n+            if (shape != _serializationShape) {\n+                if (_handledType.isEnum()) {\n+                    switch(shape) {\n+                        case STRING:\n+                        case NUMBER:\n+                        case NUMBER_INT:\n+                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n+                            //   for now, just do class ones\n+                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n+                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n+                            return provider.handlePrimaryContextualization(ser, property);\n+                    }\n+                }\n+            }\n+        }\n     }\n-    return objectIdInfo;\n+    ObjectIdWriter oiw = _objectIdWriter;\n+    String[] ignorals = null;\n+    Object newFilterId = null;\n+    // Then we may have an override for Object Id\n+    if (accessor != null) {\n+        ignorals = intr.findPropertiesToIgnore(accessor, true);\n+        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n+        if (objectIdInfo == null) {\n+            // no ObjectId override, but maybe ObjectIdRef?\n+            if (oiw != null) {\n+                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n+                oiw = oiw.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n+            }\n+        } else {\n+            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n+            // to be able to move to SerializerProvider (where it really belongs)\n+            // 2.1: allow modifications by \"id ref\" annotations as well:\n+            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n+            ObjectIdGenerator<?> gen;\n+            Class<?> implClass = objectIdInfo.getGeneratorType();\n+            JavaType type = provider.constructType(implClass);\n+            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n+            // Property-based generator is trickier\n+            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n+                // most special one, needs extra work\n+                String propName = objectIdInfo.getPropertyName().getSimpleName();\n+                BeanPropertyWriter idProp = null;\n+                for (int i = 0, len = _props.length; i < len; ++i) {\n+                    BeanPropertyWriter prop = _props[i];\n+                    if (propName.equals(prop.getName())) {\n+                        idProp = prop;\n+                        if (i > 0) {\n+                            // note: must shuffle both regular properties and filtered\n+                            System.arraycopy(_props, 0, _props, 1, i);\n+                            _props[0] = idProp;\n+                            if (_filteredProps != null) {\n+                                BeanPropertyWriter fp = _filteredProps[i];\n+                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n+                                _filteredProps[0] = fp;\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+                if(idProp == null){\n+                    throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n+                }\n+                idType = idProp.getType();\n+                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n+                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n+            } else {\n+                // other types need to be simpler\n+                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n+                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n+            }\n+        }\n+        // Or change Filter Id in use?\n+        Object filterId = intr.findFilterId(accessor);\n+        if (filterId != null) {\n+            // but only consider case of adding a new filter id (no removal via annotation)\n+            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n+                newFilterId = filterId;\n+            }\n+        }\n+    }\n+    // either way, need to resolve serializer:\n+    BeanSerializerBase contextual = this;\n+    if (oiw != null) {\n+        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n+        oiw = oiw.withSerializer(ser);\n+        if (oiw != _objectIdWriter) {\n+            contextual = contextual.withObjectIdWriter(oiw);\n+        }\n+    }\n+    // And possibly add more properties to ignore\n+    if (ignorals != null && ignorals.length != 0) {\n+        contextual = contextual.withIgnorals(ignorals);\n+    }\n+    if (newFilterId != null) {\n+        contextual = contextual.withFilterId(newFilterId);\n+    }\n+    if (shape == null) {\n+        shape = _serializationShape;\n+    }\n+    if (shape == JsonFormat.Shape.ARRAY) {\n+        return contextual.asArraySerializer();\n+    }\n+    return contextual;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"incomplete-switch\")\n@Override\npublic JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n    final SerializationConfig config = provider.getConfig();\n    // Let's start with one big transmutation: Enums that are annotated\n    // to serialize as Objects may want to revert\n    JsonFormat.Shape shape = null;\n    if (accessor != null) {\n        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n        if (format != null) {\n            shape = format.getShape();\n            // or, alternatively, asked to revert \"back to\" other representations...\n            if (shape != _serializationShape) {\n                if (_handledType.isEnum()) {\n                    switch(shape) {\n                        case STRING:\n                        case NUMBER:\n                        case NUMBER_INT:\n                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n                            //   for now, just do class ones\n                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n                            return provider.handlePrimaryContextualization(ser, property);\n                    }\n                }\n            }\n        }\n    }\n    ObjectIdWriter oiw = _objectIdWriter;\n    String[] ignorals = null;\n    Object newFilterId = null;\n    // Then we may have an override for Object Id\n    if (accessor != null) {\n        ignorals = intr.findPropertiesToIgnore(accessor, true);\n        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n        if (objectIdInfo == null) {\n            // no ObjectId override, but maybe ObjectIdRef?\n            if (oiw != null) {\n                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n                oiw = oiw.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n            }\n        } else {\n            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n            // to be able to move to SerializerProvider (where it really belongs)\n            // 2.1: allow modifications by \"id ref\" annotations as well:\n            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n            ObjectIdGenerator<?> gen;\n            Class<?> implClass = objectIdInfo.getGeneratorType();\n            JavaType type = provider.constructType(implClass);\n            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n            // Property-based generator is trickier\n            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n                // most special one, needs extra work\n                String propName = objectIdInfo.getPropertyName().getSimpleName();\n                BeanPropertyWriter idProp = null;\n                for (int i = 0, len = _props.length; i < len; ++i) {\n                    BeanPropertyWriter prop = _props[i];\n                    if (propName.equals(prop.getName())) {\n                        idProp = prop;\n                                                if (i > 0) {\n                            // note: must shuffle both regular properties and filtered\n                            System.arraycopy(_props, 0, _props, 1, i);\n                            _props[0] = idProp;\n                            if (_filteredProps != null) {\n                                BeanPropertyWriter fp = _filteredProps[i];\n                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n                                _filteredProps[0] = fp;\n                            }\n                        }\n                        break;\n                    }\n                }\n                if (idProp == null) {\n                    throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n                }\n                idType = idProp.getType();\n                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n            } else {\n                // other types need to be simpler\n                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n            }\n        }\n        // Or change Filter Id in use?\n        Object filterId = intr.findFilterId(accessor);\n        if (filterId != null) {\n            // but only consider case of adding a new filter id (no removal via annotation)\n            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n                newFilterId = filterId;\n            }\n        }\n    }\n    // either way, need to resolve serializer:\n    BeanSerializerBase contextual = this;\n    if (oiw != null) {\n        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n        oiw = oiw.withSerializer(ser);\n        if (oiw != _objectIdWriter) {\n            contextual = contextual.withObjectIdWriter(oiw);\n        }\n    }\n    // And possibly add more properties to ignore\n    if (ignorals != null && ignorals.length != 0) {\n        contextual = contextual.withIgnorals(ignorals);\n    }\n    if (newFilterId != null) {\n        contextual = contextual.withFilterId(newFilterId);\n    }\n    if (shape == null) {\n        shape = _serializationShape;\n    }\n    if (shape == JsonFormat.Shape.ARRAY) {\n        return contextual.asArraySerializer();\n    }\n    return contextual;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@findObjectReferenceInfo\n@@ -1,8 +1,118 @@\n @Override\n-public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n-    JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n-    if (ref != null) {\n-        objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n+public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException {\n+    final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+    final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember();\n+    final SerializationConfig config = provider.getConfig();\n+    // Let's start with one big transmutation: Enums that are annotated\n+    // to serialize as Objects may want to revert\n+    JsonFormat.Shape shape = null;\n+    if (accessor != null) {\n+        JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n+        if (format != null) {\n+            shape = format.getShape();\n+            // or, alternatively, asked to revert \"back to\" other representations...\n+            if (shape != _serializationShape) {\n+                if (_handledType.isEnum()) {\n+                    switch(shape) {\n+                        case STRING:\n+                        case NUMBER:\n+                        case NUMBER_INT:\n+                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n+                            //   for now, just do class ones\n+                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n+                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType, provider.getConfig(), desc, format);\n+                            return provider.handlePrimaryContextualization(ser, property);\n+                    }\n+                }\n+            }\n+        }\n     }\n-    return objectIdInfo;\n+    ObjectIdWriter oiw = _objectIdWriter;\n+    String[] ignorals = null;\n+    Object newFilterId = null;\n+    // Then we may have an override for Object Id\n+    if (accessor != null) {\n+        ignorals = intr.findPropertiesToIgnore(accessor, true);\n+        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n+        if (objectIdInfo == null) {\n+            // no ObjectId override, but maybe ObjectIdRef?\n+            if (oiw != null) {\n+                objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n+                oiw = oiw.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n+            }\n+        } else {\n+            // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n+            // to be able to move to SerializerProvider (where it really belongs)\n+            // 2.1: allow modifications by \"id ref\" annotations as well:\n+            objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo);\n+            ObjectIdGenerator<?> gen;\n+            Class<?> implClass = objectIdInfo.getGeneratorType();\n+            JavaType type = provider.constructType(implClass);\n+            JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n+            // Property-based generator is trickier\n+            if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n+                // most special one, needs extra work\n+                String propName = objectIdInfo.getPropertyName().getSimpleName();\n+                BeanPropertyWriter idProp = null;\n+                for (int i = 0, len = _props.length; i < len; ++i) {\n+                    BeanPropertyWriter prop = _props[i];\n+                    if (propName.equals(prop.getName())) {\n+                        idProp = prop;\n+                                                if (i > 0) {\n+                            // note: must shuffle both regular properties and filtered\n+                            System.arraycopy(_props, 0, _props, 1, i);\n+                            _props[0] = idProp;\n+                            if (_filteredProps != null) {\n+                                BeanPropertyWriter fp = _filteredProps[i];\n+                                System.arraycopy(_filteredProps, 0, _filteredProps, 1, i);\n+                                _filteredProps[0] = fp;\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+                if (idProp == null) {\n+                    throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n+                }\n+                idType = idProp.getType();\n+                gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n+                oiw = ObjectIdWriter.construct(idType, (PropertyName) null, gen, objectIdInfo.getAlwaysAsId());\n+            } else {\n+                // other types need to be simpler\n+                gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo);\n+                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId());\n+            }\n+        }\n+        // Or change Filter Id in use?\n+        Object filterId = intr.findFilterId(accessor);\n+        if (filterId != null) {\n+            // but only consider case of adding a new filter id (no removal via annotation)\n+            if (_propertyFilterId == null || !filterId.equals(_propertyFilterId)) {\n+                newFilterId = filterId;\n+            }\n+        }\n+    }\n+    // either way, need to resolve serializer:\n+    BeanSerializerBase contextual = this;\n+    if (oiw != null) {\n+        JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n+        oiw = oiw.withSerializer(ser);\n+        if (oiw != _objectIdWriter) {\n+            contextual = contextual.withObjectIdWriter(oiw);\n+        }\n+    }\n+    // And possibly add more properties to ignore\n+    if (ignorals != null && ignorals.length != 0) {\n+        contextual = contextual.withIgnorals(ignorals);\n+    }\n+    if (newFilterId != null) {\n+        contextual = contextual.withFilterId(newFilterId);\n+    }\n+    if (shape == null) {\n+        shape = _serializationShape;\n+    }\n+    if (shape == JsonFormat.Shape.ARRAY) {\n+        return contextual.asArraySerializer();\n+    }\n+    return contextual;\n }\n--- com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@createContextual\n+++ com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java@createContextual\n@@ -39,7 +39,7 @@\n             // no ObjectId override, but maybe ObjectIdRef?\n             if (oiw != null) {\n                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo(NAME_FOR_OBJECT_REF, null, null, null));\n-                oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n+                oiw = oiw.withAlwaysAsId(objectIdInfo.getAlwaysAsId());\n             }\n         } else {\n             // Ugh: mostly copied from BeanDeserializerBase: but can't easily change it\n@@ -55,10 +55,7 @@\n                 // most special one, needs extra work\n                 String propName = objectIdInfo.getPropertyName().getSimpleName();\n                 BeanPropertyWriter idProp = null;\n-                for (int i = 0, len = _props.length; ; ++i) {\n-                    if (i == len) {\n-                        throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n-                    }\n+                for (int i = 0, len = _props.length; i < len; ++i) {\n                     BeanPropertyWriter prop = _props[i];\n                     if (propName.equals(prop.getName())) {\n                         idProp = prop;\n@@ -74,6 +71,9 @@\n                         }\n                         break;\n                     }\n+                }\n+                if (idProp == null) {\n+                    throw new IllegalArgumentException(\"Invalid Object Id definition for \" + _handledType.getName() + \": can not find property with name '\" + propName + \"'\");\n                 }\n                 idType = idProp.getType();\n                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp);\n", "finish_reason": "stop", "valid": false, "num": 1}]