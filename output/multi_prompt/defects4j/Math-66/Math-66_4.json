[{"output": "private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (eps <= 0) {\n        throw new NotStrictlyPositiveException(eps);\n    }\n    if (t <= 0) {\n        throw new NotStrictlyPositiveException(t);\n    }\n    double a, b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(f, x);\n    if (goalType == GoalType.MAXIMIZE) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    int count = 0;\n    final int maximalIterationCount = 100;\n    while (count < maximalIterationCount) {\n        double m = 0.5 * (a + b);\n        final double tol1 = eps * Math.abs(x) + t;\n        final double tol2 = 2 * tol1;\n        // Check stopping criterion.\n        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (Math.abs(e) > tol1) {\n                // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                        u = x + d;\n                        if (Math.abs(d) < eps) {\n                            d = Math.signum(d) * eps;\n                            u = x + d;\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n            // Update by at least \"tol1\".\n            if (Math.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n            double fu = computeObjectiveValue(f, u);\n            if (goalType == GoalType.MAXIMIZE) {\n                fu = -fu;\n            }\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || w == x) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || v == x || v == w) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n            // termination\n            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n            return x;\n        }\n        ++count;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}", "diff": "--- org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n+++ org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n@@ -25,6 +25,7 @@\n     double fv = fx;\n     double fw = fx;\n     int count = 0;\n+    final int maximalIterationCount = 100;\n     while (count < maximalIterationCount) {\n         double m = 0.5 * (a + b);\n         final double tol1 = eps * Math.abs(x) + t;\n@@ -58,6 +59,11 @@\n                             d = tol1;\n                         } else {\n                             d = -tol1;\n+                        }\n+                        u = x + d;\n+                        if (Math.abs(d) < eps) {\n+                            d = Math.signum(d) * eps;\n+                            u = x + d;\n                         }\n                     }\n                 } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (eps <= 0) {\n        throw new NotStrictlyPositiveException(eps);\n    }\n    if (t <= 0) {\n        throw new NotStrictlyPositiveException(t);\n    }\n    double a, b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(f, x);\n    if (goalType == GoalType.MAXIMIZE) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    int count = 0;\n    while (count < maximalIterationCount) {\n        double m = 0.5 * (a + b);\n        final double tol1 = eps * Math.abs(x) + t;\n        final double tol2 = 2 * tol1;\n        // Check stopping criterion.\n        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (Math.abs(e) > tol1) {\n                // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n            // Update by at least \"tol1\".\n            if (Math.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n            double fu = computeObjectiveValue(f, u);\n            if (goalType == GoalType.MAXIMIZE) {\n                fu = -fu;\n            }\n            // Update a, b, v, w and x.\n            if (fu < fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu < fw) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu < fv) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n            // termination\n            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n            return x;\n        }\n        ++count;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}", "diff": "--- org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n+++ org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n@@ -93,7 +93,7 @@\n                 fu = -fu;\n             }\n             // Update a, b, v, w and x.\n-            if (fu <= fx) {\n+            if (fu < fx) {\n                 if (u < x) {\n                     b = x;\n                 } else {\n@@ -111,12 +111,12 @@\n                 } else {\n                     b = u;\n                 }\n-                if (fu <= fw || w == x) {\n+                if (fu < fw) {\n                     v = w;\n                     fv = fw;\n                     w = u;\n                     fw = fu;\n-                } else if (fu <= fv || v == x || v == w) {\n+                } else if (fu < fv) {\n                     v = u;\n                     fv = fu;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (eps <= 0) {\n        throw new NotStrictlyPositiveException(eps);\n    }\n    if (t <= 0) {\n        throw new NotStrictlyPositiveException(t);\n    }\n    double a, b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(f, x);\n    if (goalType == GoalType.MAXIMIZE) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    int count = 0;\n    while (count < maximalIterationCount) {\n        double m = 0.5 * (a + b);\n        final double tol1 = eps * Math.abs(x) + t;\n        final double tol2 = 2 * tol1;\n        // Check stopping criterion.\n        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (Math.abs(e) > tol1) {\n                // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n                    // f must not be evaluated too close to a or b.\n                    if (Math.abs(u - x) < tol1) {\n                        if (u >= x) {\n                            u = x + tol1;\n                        } else {\n                            u = x - tol1;\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n            // Update by at least \"tol1\".\n            if (Math.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            }\n            double fu = computeObjectiveValue(f, u);\n            if (goalType == GoalType.MAXIMIZE) {\n                fu = -fu;\n            }\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || w == x) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || v == x || v == w) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n            // termination\n            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n            return x;\n        }\n        ++count;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}", "diff": "--- org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n+++ org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n@@ -53,11 +53,11 @@\n                     d = p / q;\n                     u = x + d;\n                     // f must not be evaluated too close to a or b.\n-                    if (u - a < tol2 || b - u < tol2) {\n-                        if (x <= m) {\n-                            d = tol1;\n+                    if (Math.abs(u - x) < tol1) {\n+                        if (u >= x) {\n+                            u = x + tol1;\n                         } else {\n-                            d = -tol1;\n+                            u = x - tol1;\n                         }\n                     }\n                 } else {\n@@ -85,8 +85,6 @@\n                 } else {\n                     u = x - tol1;\n                 }\n-            } else {\n-                u = x + d;\n             }\n             double fu = computeObjectiveValue(f, u);\n             if (goalType == GoalType.MAXIMIZE) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (eps <= 0) {\n        throw new NotStrictlyPositiveException(eps);\n    }\n    if (t <= 0) {\n        throw new NotStrictlyPositiveException(t);\n    }\n    double a, b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(f, x);\n    if (goalType == GoalType.MAXIMIZE) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    int count = 0;\n    final int maximalIterationCount = 100; // Define maximalIterationCount and set it to 100.\n    while (count < maximalIterationCount) {\n        double m = 0.5 * (a + b);\n        final double tol1 = eps * Math.abs(x) + t;\n        final double tol2 = 2 * tol1;\n        // Check stopping criterion.\n        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (Math.abs(e) > tol1) {\n                // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n            // Update by at least \"tol1\".\n            if (Math.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n            double fu = computeObjectiveValue(f, u);\n            if (goalType == GoalType.MAXIMIZE) {\n                fu = -fu;\n            }\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || w == x) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || v == x || v == w) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n            // termination\n            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n            return x;\n        }\n        ++count;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}", "diff": "--- org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n+++ org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n@@ -25,6 +25,7 @@\n     double fv = fx;\n     double fw = fx;\n     int count = 0;\n+    final int maximalIterationCount = 100; // Define maximalIterationCount and set it to 100.\n     while (count < maximalIterationCount) {\n         double m = 0.5 * (a + b);\n         final double tol1 = eps * Math.abs(x) + t;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (eps <= 0) {\n        throw new NotStrictlyPositiveException(eps);\n    }\n    if (t <= 0) {\n        throw new NotStrictlyPositiveException(t);\n    }\n    double a, b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(f, x);\n    if (goalType == GoalType.MAXIMIZE) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    int count = 0;\n    while (count < maximalIterationCount) {\n        double m = 0.5 * (a + b);\n        final double tol1 = eps * Math.abs(x) + t;\n        final double tol2 = 2 * tol1;\n        // Check stopping criterion.\n        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (Math.abs(e) > tol1) {\n                // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n                    // f must not be evaluated too close to a or b.\n                    double fu = computeObjectiveValue(f, u);\n                    if (goalType == GoalType.MAXIMIZE) {\n                        fu = -fu;\n                    }\n                    if (u - a < tol2 || b - u < tol2 || fu >= fx) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n            // Update by at least \"tol1\".\n            if (Math.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n            double fu = computeObjectiveValue(f, u);\n            if (goalType == GoalType.MAXIMIZE) {\n                fu = -fu;\n            }\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || w == x) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || v == x || v == w) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n            // termination\n            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n            return x;\n        }\n        ++count;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}", "diff": "--- org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n+++ org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n@@ -53,7 +53,11 @@\n                     d = p / q;\n                     u = x + d;\n                     // f must not be evaluated too close to a or b.\n-                    if (u - a < tol2 || b - u < tol2) {\n+                    double fu = computeObjectiveValue(f, u);\n+                    if (goalType == GoalType.MAXIMIZE) {\n+                        fu = -fu;\n+                    }\n+                    if (u - a < tol2 || b - u < tol2 || fu >= fx) {\n                         if (x <= m) {\n                             d = tol1;\n                         } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (eps <= 0) {\n        throw new NotStrictlyPositiveException(eps);\n    }\n    if (t <= 0) {\n        throw new NotStrictlyPositiveException(t);\n    }\n    double a, b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(f, x);\n    if (goalType == GoalType.MAXIMIZE) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    int count = 0;\n    while (count < maximalIterationCount) {\n        double m = 0.5 * (a + b);\n        final double tol1 = eps * Math.abs(x) + t;\n        final double tol2 = 2 * tol1;\n        // Check stopping criterion.\n        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (Math.abs(e) > tol1) {\n                // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                        u = x + d;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n            // Update by at least \"tol1\".\n            if (Math.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            }\n            double fu = computeObjectiveValue(f, u);\n            if (goalType == GoalType.MAXIMIZE) {\n                fu = -fu;\n            }\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || w == x) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || v == x || v == w) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n            // termination\n            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n            return x;\n        }\n        ++count;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}", "diff": "--- org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n+++ org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n@@ -43,7 +43,6 @@\n                 q = 2 * (q - r);\n                 if (q > 0) {\n                     p = -p;\n-                } else {\n                     q = -q;\n                 }\n                 r = e;\n@@ -59,6 +58,7 @@\n                         } else {\n                             d = -tol1;\n                         }\n+                        u = x + d;\n                     }\n                 } else {\n                     // Golden section step.\n@@ -85,8 +85,6 @@\n                 } else {\n                     u = x - tol1;\n                 }\n-            } else {\n-                u = x + d;\n             }\n             double fu = computeObjectiveValue(f, u);\n             if (goalType == GoalType.MAXIMIZE) {\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (eps <= 0) {\n        throw new NotStrictlyPositiveException(eps);\n    }\n    if (t <= 0) {\n        throw new NotStrictlyPositiveException(t);\n    }\n    double a, b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(f, x);\n    if (goalType == GoalType.MAXIMIZE) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    int count = 0;\n    while (count < maximalIterationCount) {\n        double m = 0.5 * (a + b);\n        final double tol1 = eps;\n        final double tol2 = t;\n        // Check stopping criterion.\n        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (Math.abs(e) > tol1) {\n                // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n            // Update by at least \"tol1\".\n            if (Math.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n            double fu = computeObjectiveValue(f, u);\n            if (goalType == GoalType.MAXIMIZE) {\n                fu = -fu;\n            }\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || w == x) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || v == x || v == w) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n            // termination\n            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n            return x;\n        }\n        ++count;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}", "diff": "--- org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n+++ org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n@@ -27,8 +27,8 @@\n     int count = 0;\n     while (count < maximalIterationCount) {\n         double m = 0.5 * (a + b);\n-        final double tol1 = eps * Math.abs(x) + t;\n-        final double tol2 = 2 * tol1;\n+        final double tol1 = eps;\n+        final double tol2 = t;\n         // Check stopping criterion.\n         if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n             double p = 0;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "Unfortunately, without additional context or information, it is not possible to fix the buggy function in the Math project.", "diff": "", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (eps <= 0) {\n        throw new NotStrictlyPositiveException(eps);\n    }\n    if (t <= 0) {\n        throw new NotStrictlyPositiveException(t);\n    }\n    double a, b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(f, x);\n    if (goalType == GoalType.MAXIMIZE) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    int count = 0;\n    final int maximalIterationCount2 = maximalIterationCount; /* added this line */\n    while (count < maximalIterationCount2) { /* modified this line */\n        double m = 0.5 * (a + b);\n        final double tol1 = eps * Math.abs(x) + t;\n        final double tol2 = 2 * tol1;\n        // Check stopping criterion.\n        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (Math.abs(e) > tol1) {\n                // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n            // Update by at least \"tol1\".\n            if (Math.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n            double fu = computeObjectiveValue(f, u);\n            if (goalType == GoalType.MAXIMIZE) {\n                fu = -fu;\n            }\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || w == x) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || v == x || v == w) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n            // termination\n            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n            return x;\n        }\n        ++count;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}", "diff": "--- org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n+++ org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n@@ -25,7 +25,8 @@\n     double fv = fx;\n     double fw = fx;\n     int count = 0;\n-    while (count < maximalIterationCount) {\n+    final int maximalIterationCount2 = maximalIterationCount; /* added this line */\n+    while (count < maximalIterationCount2) { /* modified this line */\n         double m = 0.5 * (a + b);\n         final double tol1 = eps * Math.abs(x) + t;\n         final double tol2 = 2 * tol1;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (eps <= 0) {\n        throw new NotStrictlyPositiveException(eps);\n    }\n    if (t <= 0) {\n        throw new NotStrictlyPositiveException(t);\n    }\n    double a, b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(f, x);\n    if (goalType == GoalType.MAXIMIZE) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    int count = 0;\n    // Define a new variable \"tol\" to improve readability and simplify the expression of \"tol1\" and \"tol2\"\n    double tol = eps * Math.abs(x) + t;\n    double tol1 = tol;\n    double tol2 = 2 * tol;\n    while (count < maximalIterationCount) {\n        double m = 0.5 * (a + b);\n        // Check stopping criterion.\n        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (Math.abs(e) > tol1) {\n                // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                        u = x + d;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n            // Update by at least \"tol1\".\n            if (Math.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            }\n            fu = computeObjectiveValue(f, u);\n            if (goalType == GoalType.MAXIMIZE) {\n                fu = -fu;\n            }\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || w == x) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || v == x || v == w) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n            // termination\n            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n            return x;\n        }\n        ++count;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}", "diff": "--- org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n+++ org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n@@ -25,10 +25,12 @@\n     double fv = fx;\n     double fw = fx;\n     int count = 0;\n+    // Define a new variable \"tol\" to improve readability and simplify the expression of \"tol1\" and \"tol2\"\n+    double tol = eps * Math.abs(x) + t;\n+    double tol1 = tol;\n+    double tol2 = 2 * tol;\n     while (count < maximalIterationCount) {\n         double m = 0.5 * (a + b);\n-        final double tol1 = eps * Math.abs(x) + t;\n-        final double tol2 = 2 * tol1;\n         // Check stopping criterion.\n         if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n             double p = 0;\n@@ -59,6 +61,7 @@\n                         } else {\n                             d = -tol1;\n                         }\n+                        u = x + d;\n                     }\n                 } else {\n                     // Golden section step.\n@@ -85,10 +88,8 @@\n                 } else {\n                     u = x - tol1;\n                 }\n-            } else {\n-                u = x + d;\n             }\n-            double fu = computeObjectiveValue(f, u);\n+            fu = computeObjectiveValue(f, u);\n             if (goalType == GoalType.MAXIMIZE) {\n                 fu = -fu;\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (eps <= 0) {\n        throw new NotStrictlyPositiveException(eps);\n    }\n    if (t <= 0) {\n        throw new NotStrictlyPositiveException(t);\n    }\n    double a, b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(f, x);\n    if (goalType == GoalType.MAXIMIZE) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    int count = 0;\n    while (count < maximalIterationCount) {\n        double m = 0.5 * (a + b);\n        final double tol1 = eps * Math.abs(x) + t;\n        final double tol2 = 2 * tol1;\n        // Check stopping criterion.\n        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (Math.abs(e) > tol1) {\n                // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                        u = x + d;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                    u = x + d;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n                u = x + d;\n            }\n            double fu = computeObjectiveValue(f, u);\n            if (goalType == GoalType.MAXIMIZE) {\n                fu = -fu;\n            }\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || w == x) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || v == x || v == w) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n            // termination\n            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n            return x;\n        }\n        ++count;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}", "diff": "--- org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n+++ org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n@@ -59,6 +59,7 @@\n                         } else {\n                             d = -tol1;\n                         }\n+                        u = x + d;\n                     }\n                 } else {\n                     // Golden section step.\n@@ -68,6 +69,7 @@\n                         e = a - x;\n                     }\n                     d = GOLDEN_SECTION * e;\n+                    u = x + d;\n                 }\n             } else {\n                 // Golden section step.\n@@ -77,15 +79,6 @@\n                     e = a - x;\n                 }\n                 d = GOLDEN_SECTION * e;\n-            }\n-            // Update by at least \"tol1\".\n-            if (Math.abs(d) < tol1) {\n-                if (d >= 0) {\n-                    u = x + tol1;\n-                } else {\n-                    u = x - tol1;\n-                }\n-            } else {\n                 u = x + d;\n             }\n             double fu = computeObjectiveValue(f, u);\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (eps <= 0) {\n        throw new NotStrictlyPositiveException(eps);\n    }\n    if (t <= 0) {\n        throw new NotStrictlyPositiveException(t);\n    }\n    double a, b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(f, x);\n    if (goalType == GoalType.MAXIMIZE) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    int count = 0;\n    while (count < maximalIterationCount) {\n        double m = 0.5 * (a + b);\n        final double tol1 = eps * Math.abs(x) + t;\n        final double tol2 = 2 * tol1;\n        // Check stopping criterion.\n        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (Math.abs(e) > tol1) {\n                // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                    q = -q;  // Fix for bug\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                        u = x + d;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n            // Update by at least \"tol1\".\n            if (Math.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            }\n            double fu = computeObjectiveValue(f, u);\n            if (goalType == GoalType.MAXIMIZE) {\n                fu = -fu;\n            }\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || w == x) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || v == x || v == w) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n            // termination\n            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n            return x;\n        }\n        ++count;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}", "diff": "--- org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n+++ org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n@@ -43,6 +43,7 @@\n                 q = 2 * (q - r);\n                 if (q > 0) {\n                     p = -p;\n+                    q = -q;  // Fix for bug\n                 } else {\n                     q = -q;\n                 }\n@@ -59,6 +60,7 @@\n                         } else {\n                             d = -tol1;\n                         }\n+                        u = x + d;\n                     }\n                 } else {\n                     // Golden section step.\n@@ -85,8 +87,6 @@\n                 } else {\n                     u = x - tol1;\n                 }\n-            } else {\n-                u = x + d;\n             }\n             double fu = computeObjectiveValue(f, u);\n             if (goalType == GoalType.MAXIMIZE) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (eps <= 0) {\n        throw new NotStrictlyPositiveException(eps);\n    }\n    if (t <= 0) {\n        throw new NotStrictlyPositiveException(t);\n    }\n    double a, b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(f, x);\n    if (goalType == GoalType.MAXIMIZE) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    int count = 0;\n    double m = 0.5 * (a + b);\n    final double tol1 = eps * Math.abs(x) + t;\n    final double tol2 = 2 * tol1;\n    while (Math.abs(x - m) > tol2 - 0.5 * (b - a) && count < maximalIterationCount) {\n        if (Math.abs(e) > tol1) {\n            // Fit parabola.\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            q = (x - v) * (fx - fw);\n            p = (x - v) * q - (x - w) * (fx - fv);\n            q = 2 * (q - (fx - fv));\n            if (q > 0) {\n                p = -p;\n            } else {\n                q = -q;\n            }\n            r = e;\n            e = d;\n            if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                // Parabolic interpolation step.\n                d = p / q;\n                double u = x + d;\n                // f must not be evaluated too close to a or b.\n                if (u - a < tol2 || b - u < tol2) {\n                    if (x >= m) {\n                        d = a - x;\n                    } else {\n                        d = b - x;\n                    }\n                }\n            } else {\n                // Golden section step.\n                if (x >= m) {\n                    e = a - x;\n                } else {\n                    e = b - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n        } else {\n            // Golden section step.\n            if (x >= m) {\n                e = a - x;\n            } else {\n                e = b - x;\n            }\n            d = GOLDEN_SECTION * e;\n        }\n        // Update the step.\n        double u;\n        if (Math.abs(d) >= tol1) {\n            u = x + d;\n        } else if (d > 0) {\n            u = x + tol1;\n        } else {\n            u = x - tol1;\n        }\n        // Compute the objective function at u.\n        double fu = computeObjectiveValue(f, u);\n        if (goalType == GoalType.MAXIMIZE) {\n            fu = -fu;\n        }\n        // Update a, b, v, w, x.\n        if (fu <= fx) {\n            if (u >= x) {\n                a = x;\n            } else {\n                b = x;\n            }\n            v = w;\n            fv = fw;\n            w = x;\n            fw = fx;\n            x = u;\n            fx = fu;\n        } else {\n            if (u < x) {\n                a = u;\n            } else {\n                b = u;\n            }\n            if (fu <= fw || w == x) {\n                v = w;\n                fv = fw;\n                w = u;\n                fw = fu;\n            } else if (fu <= fv || v == x || v == w) {\n                v = u;\n                fv = fu;\n            }\n        }\n        count++;\n    }\n    setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n    return x;\n}", "diff": "--- org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n+++ org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n@@ -25,108 +25,100 @@\n     double fv = fx;\n     double fw = fx;\n     int count = 0;\n-    while (count < maximalIterationCount) {\n-        double m = 0.5 * (a + b);\n-        final double tol1 = eps * Math.abs(x) + t;\n-        final double tol2 = 2 * tol1;\n-        // Check stopping criterion.\n-        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n+    double m = 0.5 * (a + b);\n+    final double tol1 = eps * Math.abs(x) + t;\n+    final double tol2 = 2 * tol1;\n+    while (Math.abs(x - m) > tol2 - 0.5 * (b - a) && count < maximalIterationCount) {\n+        if (Math.abs(e) > tol1) {\n+            // Fit parabola.\n             double p = 0;\n             double q = 0;\n             double r = 0;\n-            double u = 0;\n-            if (Math.abs(e) > tol1) {\n-                // Fit parabola.\n-                r = (x - w) * (fx - fv);\n-                q = (x - v) * (fx - fw);\n-                p = (x - v) * q - (x - w) * r;\n-                q = 2 * (q - r);\n-                if (q > 0) {\n-                    p = -p;\n-                } else {\n-                    q = -q;\n-                }\n-                r = e;\n-                e = d;\n-                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n-                    // Parabolic interpolation step.\n-                    d = p / q;\n-                    u = x + d;\n-                    // f must not be evaluated too close to a or b.\n-                    if (u - a < tol2 || b - u < tol2) {\n-                        if (x <= m) {\n-                            d = tol1;\n-                        } else {\n-                            d = -tol1;\n-                        }\n+            q = (x - v) * (fx - fw);\n+            p = (x - v) * q - (x - w) * (fx - fv);\n+            q = 2 * (q - (fx - fv));\n+            if (q > 0) {\n+                p = -p;\n+            } else {\n+                q = -q;\n+            }\n+            r = e;\n+            e = d;\n+            if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n+                // Parabolic interpolation step.\n+                d = p / q;\n+                double u = x + d;\n+                // f must not be evaluated too close to a or b.\n+                if (u - a < tol2 || b - u < tol2) {\n+                    if (x >= m) {\n+                        d = a - x;\n+                    } else {\n+                        d = b - x;\n                     }\n-                } else {\n-                    // Golden section step.\n-                    if (x < m) {\n-                        e = b - x;\n-                    } else {\n-                        e = a - x;\n-                    }\n-                    d = GOLDEN_SECTION * e;\n                 }\n             } else {\n                 // Golden section step.\n-                if (x < m) {\n+                if (x >= m) {\n+                    e = a - x;\n+                } else {\n                     e = b - x;\n-                } else {\n-                    e = a - x;\n                 }\n                 d = GOLDEN_SECTION * e;\n             }\n-            // Update by at least \"tol1\".\n-            if (Math.abs(d) < tol1) {\n-                if (d >= 0) {\n-                    u = x + tol1;\n-                } else {\n-                    u = x - tol1;\n-                }\n+        } else {\n+            // Golden section step.\n+            if (x >= m) {\n+                e = a - x;\n             } else {\n-                u = x + d;\n+                e = b - x;\n             }\n-            double fu = computeObjectiveValue(f, u);\n-            if (goalType == GoalType.MAXIMIZE) {\n-                fu = -fu;\n+            d = GOLDEN_SECTION * e;\n+        }\n+        // Update the step.\n+        double u;\n+        if (Math.abs(d) >= tol1) {\n+            u = x + d;\n+        } else if (d > 0) {\n+            u = x + tol1;\n+        } else {\n+            u = x - tol1;\n+        }\n+        // Compute the objective function at u.\n+        double fu = computeObjectiveValue(f, u);\n+        if (goalType == GoalType.MAXIMIZE) {\n+            fu = -fu;\n+        }\n+        // Update a, b, v, w, x.\n+        if (fu <= fx) {\n+            if (u >= x) {\n+                a = x;\n+            } else {\n+                b = x;\n             }\n-            // Update a, b, v, w and x.\n-            if (fu <= fx) {\n-                if (u < x) {\n-                    b = x;\n-                } else {\n-                    a = x;\n-                }\n+            v = w;\n+            fv = fw;\n+            w = x;\n+            fw = fx;\n+            x = u;\n+            fx = fu;\n+        } else {\n+            if (u < x) {\n+                a = u;\n+            } else {\n+                b = u;\n+            }\n+            if (fu <= fw || w == x) {\n                 v = w;\n                 fv = fw;\n-                w = x;\n-                fw = fx;\n-                x = u;\n-                fx = fu;\n-            } else {\n-                if (u < x) {\n-                    a = u;\n-                } else {\n-                    b = u;\n-                }\n-                if (fu <= fw || w == x) {\n-                    v = w;\n-                    fv = fw;\n-                    w = u;\n-                    fw = fu;\n-                } else if (fu <= fv || v == x || v == w) {\n-                    v = u;\n-                    fv = fu;\n-                }\n+                w = u;\n+                fw = fu;\n+            } else if (fu <= fv || v == x || v == w) {\n+                v = u;\n+                fv = fu;\n             }\n-        } else {\n-            // termination\n-            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n-            return x;\n         }\n-        ++count;\n+        count++;\n     }\n-    throw new MaxIterationsExceededException(maximalIterationCount);\n+    setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n+    return x;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    if (eps <= 0) {\n        throw new NotStrictlyPositiveException(eps);\n    }\n\n    if (t <= 0) {\n        throw new NotStrictlyPositiveException(t);\n    }\n\n    double a, b;\n\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n\n    double fx = computeObjectiveValue(f, x);\n\n    if (goalType == GoalType.MAXIMIZE) {\n        fx = -fx;\n    }\n\n    double fv = fx;\n    double fw = fx;\n\n    int count = 0;\n\n    double tol1, tol2, p, q, r, u, fu;\n\n    while (count < maximalIterationCount) {\n\n        double m = 0.5 * (a + b);\n\n        tol1 = eps * Math.abs(x) + t;\n        tol2 = 2 * tol1;\n\n        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n\n            p = 0;\n            q = 0;\n            r = 0;\n            u = 0;\n\n            if (Math.abs(e) > tol1) {\n\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n\n                q = 2 * (q - r);\n\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n\n                r = e;\n                e = d;\n\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                    d = p / q;\n                    u = x + d;\n                    if (u - a < tol2 || b - u < tol2) {\n                        d = x < m ? tol1 : -tol1;\n                    }\n                } else {\n                    d = GOLDEN_SECTION * (x < m ? b - x : a - x);\n                    e = d;\n                }\n\n            } else {\n                d = GOLDEN_SECTION * (x < m ? b - x : a - x);\n                e = d;\n            }\n\n            if (Math.abs(d) < tol1) {\n                u = x + (d > 0 ? tol1 : -tol1);\n            } else {\n                u = x + d;\n            }\n\n            fu = computeObjectiveValue(f, u);\n\n            if (goalType == GoalType.MAXIMIZE) {\n                fu = -fu;\n            }\n\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || w == x) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || v == x || v == w) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n\n        } else {\n            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n            return x;\n        }\n\n        ++count;\n\n    }\n\n    throw new MaxIterationsExceededException(maximalIterationCount);\n\n}", "diff": "--- org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n+++ org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n@@ -1,11 +1,15 @@\n private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n     if (eps <= 0) {\n         throw new NotStrictlyPositiveException(eps);\n     }\n+\n     if (t <= 0) {\n         throw new NotStrictlyPositiveException(t);\n     }\n+\n     double a, b;\n+\n     if (lo < hi) {\n         a = lo;\n         b = hi;\n@@ -13,86 +17,85 @@\n         a = hi;\n         b = lo;\n     }\n+\n     double x = mid;\n     double v = x;\n     double w = x;\n     double d = 0;\n     double e = 0;\n+\n     double fx = computeObjectiveValue(f, x);\n+\n     if (goalType == GoalType.MAXIMIZE) {\n         fx = -fx;\n     }\n+\n     double fv = fx;\n     double fw = fx;\n+\n     int count = 0;\n+\n+    double tol1, tol2, p, q, r, u, fu;\n+\n     while (count < maximalIterationCount) {\n+\n         double m = 0.5 * (a + b);\n-        final double tol1 = eps * Math.abs(x) + t;\n-        final double tol2 = 2 * tol1;\n-        // Check stopping criterion.\n+\n+        tol1 = eps * Math.abs(x) + t;\n+        tol2 = 2 * tol1;\n+\n         if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n-            double p = 0;\n-            double q = 0;\n-            double r = 0;\n-            double u = 0;\n+\n+            p = 0;\n+            q = 0;\n+            r = 0;\n+            u = 0;\n+\n             if (Math.abs(e) > tol1) {\n-                // Fit parabola.\n+\n                 r = (x - w) * (fx - fv);\n                 q = (x - v) * (fx - fw);\n                 p = (x - v) * q - (x - w) * r;\n+\n                 q = 2 * (q - r);\n+\n                 if (q > 0) {\n                     p = -p;\n                 } else {\n                     q = -q;\n                 }\n+\n                 r = e;\n                 e = d;\n+\n                 if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n-                    // Parabolic interpolation step.\n                     d = p / q;\n                     u = x + d;\n-                    // f must not be evaluated too close to a or b.\n                     if (u - a < tol2 || b - u < tol2) {\n-                        if (x <= m) {\n-                            d = tol1;\n-                        } else {\n-                            d = -tol1;\n-                        }\n+                        d = x < m ? tol1 : -tol1;\n                     }\n                 } else {\n-                    // Golden section step.\n-                    if (x < m) {\n-                        e = b - x;\n-                    } else {\n-                        e = a - x;\n-                    }\n-                    d = GOLDEN_SECTION * e;\n+                    d = GOLDEN_SECTION * (x < m ? b - x : a - x);\n+                    e = d;\n                 }\n+\n             } else {\n-                // Golden section step.\n-                if (x < m) {\n-                    e = b - x;\n-                } else {\n-                    e = a - x;\n-                }\n-                d = GOLDEN_SECTION * e;\n+                d = GOLDEN_SECTION * (x < m ? b - x : a - x);\n+                e = d;\n             }\n-            // Update by at least \"tol1\".\n+\n             if (Math.abs(d) < tol1) {\n-                if (d >= 0) {\n-                    u = x + tol1;\n-                } else {\n-                    u = x - tol1;\n-                }\n+                u = x + (d > 0 ? tol1 : -tol1);\n             } else {\n                 u = x + d;\n             }\n-            double fu = computeObjectiveValue(f, u);\n+\n+            fu = computeObjectiveValue(f, u);\n+\n             if (goalType == GoalType.MAXIMIZE) {\n                 fu = -fu;\n             }\n-            // Update a, b, v, w and x.\n+\n             if (fu <= fx) {\n                 if (u < x) {\n                     b = x;\n@@ -121,12 +124,16 @@\n                     fv = fu;\n                 }\n             }\n+\n         } else {\n-            // termination\n             setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n             return x;\n         }\n+\n         ++count;\n+\n     }\n+\n     throw new MaxIterationsExceededException(maximalIterationCount);\n+\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (eps <= 0) {\n        throw new NotStrictlyPositiveException(eps);\n    }\n    if (t <= 0) {\n        throw new NotStrictlyPositiveException(t);\n    }\n    double a, b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(f, x);\n    if (goalType == GoalType.MAXIMIZE) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    int count = 0;\n    final int maximalIterationCount = 1000; // Added this line\n    while (count < maximalIterationCount) {\n        double m = 0.5 * (a + b);\n        final double tol1 = eps * Math.abs(x) + t;\n        final double tol2 = 2 * tol1;\n        // Check stopping criterion.\n        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (Math.abs(e) > tol1) {\n                // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n            // Update by at least \"tol1\".\n            if (Math.abs(d) < tol1) {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            } else {\n                u = x + d;\n            }\n            double fu = computeObjectiveValue(f, u);\n            if (goalType == GoalType.MAXIMIZE) {\n                fu = -fu;\n            }\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || w == x) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || v == x || v == w) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n            // termination\n            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n            return x;\n        }\n        ++count;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}", "diff": "--- org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n+++ org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n@@ -25,6 +25,7 @@\n     double fv = fx;\n     double fw = fx;\n     int count = 0;\n+    final int maximalIterationCount = 1000; // Added this line\n     while (count < maximalIterationCount) {\n         double m = 0.5 * (a + b);\n         final double tol1 = eps * Math.abs(x) + t;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private double localMin(boolean isMinim, UnivariateRealFunction f, GoalType goalType, double lo, double mid, double hi, double eps, double t) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (eps <= 0) {\n        throw new NotStrictlyPositiveException(eps);\n    }\n    if (t <= 0) {\n        throw new NotStrictlyPositiveException(t);\n    }\n    double a, b;\n    if (lo < hi) {\n        a = lo;\n        b = hi;\n    } else {\n        a = hi;\n        b = lo;\n    }\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(f, x);\n    if (goalType == GoalType.MAXIMIZE) {\n        fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n    int count = 0;\n    while (count < maximalIterationCount) {\n        double m = 0.5 * (a + b);\n        final double tol1 = eps * Math.abs(x) + t;\n        final double tol2 = 2 * tol1;\n        // Check stopping criterion.\n        if (Math.abs(x - m) > tol2 - 0.5 * (b - a)) {\n            double p = 0;\n            double q = 0;\n            double r = 0;\n            double u = 0;\n            if (Math.abs(e) > tol1) {\n                // Fit parabola.\n                r = (x - w) * (fx - fv);\n                q = (x - v) * (fx - fw);\n                p = (x - v) * q - (x - w) * r;\n                q = 2 * (q - r);\n                if (q > 0) {\n                    p = -p;\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                if (p >= q * (a - x) && p <= q * (b - x) && Math.abs(p) >= Math.abs(0.5 * q * r)) {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                } else {\n                    // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n                    // f must not be evaluated too close to a or b.\n                    if (u - a < tol2 || b - u < tol2) {\n                        if (x <= m) {\n                            d = tol1;\n                        } else {\n                            d = -tol1;\n                        }\n                        u = x + d;\n                    }\n                    if (u - x >= 0) {\n                        e = a - x;\n                    } else {\n                        e = b - x;\n                    }\n                }\n            } else {\n                // Golden section step.\n                if (x < m) {\n                    e = b - x;\n                } else {\n                    e = a - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n            // Update by at least \"tol1\".\n            if (Math.abs(d) >= tol1) {\n                u = x + d;\n            } else {\n                if (d >= 0) {\n                    u = x + tol1;\n                } else {\n                    u = x - tol1;\n                }\n            }\n            double fu = computeObjectiveValue(f, u);\n            if (goalType == GoalType.MAXIMIZE) {\n                fu = -fu;\n            }\n            // Update a, b, v, w and x.\n            if (fu <= fx) {\n                if (u < x) {\n                    b = x;\n                } else {\n                    a = x;\n                }\n                v = w;\n                fv = fw;\n                w = x;\n                fw = fx;\n                x = u;\n                fx = fu;\n            } else {\n                if (u < x) {\n                    a = u;\n                } else {\n                    b = u;\n                }\n                if (fu <= fw || w == x) {\n                    v = w;\n                    fv = fw;\n                    w = u;\n                    fw = fu;\n                } else if (fu <= fv || v == x || v == w) {\n                    v = u;\n                    fv = fu;\n                }\n            }\n        } else {\n            // termination\n            setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n            return x;\n        }\n        ++count;\n    }\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}", "diff": "--- org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n+++ org/apache/commons/math/optimization/univariate/BrentOptimizer.java@localMin\n@@ -43,12 +43,19 @@\n                 q = 2 * (q - r);\n                 if (q > 0) {\n                     p = -p;\n-                } else {\n                     q = -q;\n                 }\n                 r = e;\n                 e = d;\n-                if (p > q * (a - x) && p < q * (b - x) && Math.abs(p) < Math.abs(0.5 * q * r)) {\n+                if (p >= q * (a - x) && p <= q * (b - x) && Math.abs(p) >= Math.abs(0.5 * q * r)) {\n+                    // Golden section step.\n+                    if (x < m) {\n+                        e = b - x;\n+                    } else {\n+                        e = a - x;\n+                    }\n+                    d = GOLDEN_SECTION * e;\n+                } else {\n                     // Parabolic interpolation step.\n                     d = p / q;\n                     u = x + d;\n@@ -59,15 +66,13 @@\n                         } else {\n                             d = -tol1;\n                         }\n+                        u = x + d;\n                     }\n-                } else {\n-                    // Golden section step.\n-                    if (x < m) {\n+                    if (u - x >= 0) {\n+                        e = a - x;\n+                    } else {\n                         e = b - x;\n-                    } else {\n-                        e = a - x;\n                     }\n-                    d = GOLDEN_SECTION * e;\n                 }\n             } else {\n                 // Golden section step.\n@@ -79,14 +84,14 @@\n                 d = GOLDEN_SECTION * e;\n             }\n             // Update by at least \"tol1\".\n-            if (Math.abs(d) < tol1) {\n+            if (Math.abs(d) >= tol1) {\n+                u = x + d;\n+            } else {\n                 if (d >= 0) {\n                     u = x + tol1;\n                 } else {\n                     u = x - tol1;\n                 }\n-            } else {\n-                u = x + d;\n             }\n             double fu = computeObjectiveValue(f, u);\n             if (goalType == GoalType.MAXIMIZE) {\n", "finish_reason": "stop", "valid": false, "num": 1}]