[{"output": "@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType != null && contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -25,7 +25,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n             if (kd != null) {\n@@ -45,7 +45,7 @@\n         }\n         // ... as well as deserializer for contents:\n         JavaType contentType = type.getContentType();\n-        if (contentType.getValueHandler() == null) {\n+        if (contentType != null && contentType.getValueHandler() == null) {\n             // as with above, avoid resetting (which would trigger exception)\n             Object cdDef = intr.findContentDeserializer(a);\n             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n", "finish_reason": "stop", "valid": false, "num": 9}, {"output": "@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                // Update to pass the keyDeserializer to withKeyValueHandler instead of narrowing the key type.\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -25,10 +25,11 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n             if (kd != null) {\n+                // Update to pass the keyDeserializer to withKeyValueHandler instead of narrowing the key type.\n                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                 // just in case it's used below\n                 keyType = type.getKeyType();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings({ \"unchecked\" })\n    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n        // first: let's check class for the instance itself:\n        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n        Class<?> subclass = intr.findDeserializationType(a, type);\n        if (subclass != null) {\n            try {\n                type = (T) type.narrowBy(subclass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n            }\n        }\n        // then key class\n        if (type.isContainerType()) {\n            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n            if (keyClass != null) {\n                // illegal to use narrowKey() on non-Maps\n                if (!(type instanceof MapLikeType)) {\n                    throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n                }\n                try {\n                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n                }\n            }\n            JavaType keyType = type.getKeyType();\n            if (keyType != null && keyType.getValueHandler() == null) {\n                Object kdDef = intr.findKeyDeserializer(a);\n                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n                if (kd != null) {\n                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                    // just in case it's used below\n                    keyType = type.getKeyType();\n                }\n            }\n            // and finally content class; only applicable to structured types\n            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n            if (cc != null) {\n                try {\n                    type = (T) type.narrowContentsBy(cc);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n                }\n            }\n            // ... as well as deserializer for contents:\n            JavaType contentType = type.getContentType();\n            if (contentType != null && contentType.getValueHandler() == null) {\n                // as with above, avoid resetting (which would trigger exception)\n                Object cdDef = intr.findContentDeserializer(a);\n                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                if (cd != null) {\n                    type = (T) type.withContentValueHandler(cd);\n                }\n            }\n        }\n        return type;\n    }", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n                if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType != null && contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -45,7 +45,7 @@\n         }\n         // ... as well as deserializer for contents:\n         JavaType contentType = type.getContentType();\n-        if (contentType.getValueHandler() == null) {\n+        if (contentType != null && contentType.getValueHandler() == null) {\n             // as with above, avoid resetting (which would trigger exception)\n             Object cdDef = intr.findContentDeserializer(a);\n             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n", "finish_reason": "stop", "valid": false, "num": 4}, {"output": "@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type.getKeyType() instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -15,7 +15,7 @@\n         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n         if (keyClass != null) {\n             // illegal to use on non-Maps\n-            if (!(type instanceof MapLikeType)) {\n+            if (!(type.getKeyType() instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n             }\n             try {\n@@ -25,7 +25,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n             if (kd != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            } else {\n                try {\n                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n                }\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType != null && contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -17,15 +17,16 @@\n             // illegal to use on non-Maps\n             if (!(type instanceof MapLikeType)) {\n                 throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n-            }\n-            try {\n-                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n+            } else {\n+                try {\n+                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n+                }\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n             if (kd != null) {\n@@ -45,7 +46,7 @@\n         }\n         // ... as well as deserializer for contents:\n         JavaType contentType = type.getContentType();\n-        if (contentType.getValueHandler() == null) {\n+        if (contentType != null && contentType.getValueHandler() == null) {\n             // as with above, avoid resetting (which would trigger exception)\n             Object cdDef = intr.findContentDeserializer(a);\n             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null && !type.hasRawClass(subclass)) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null && !type.getContentType().hasRawClass(cc)) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -3,7 +3,7 @@\n     // first: let's check class for the instance itself:\n     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n     Class<?> subclass = intr.findDeserializationType(a, type);\n-    if (subclass != null) {\n+    if (subclass != null && !type.hasRawClass(subclass)) {\n         try {\n             type = (T) type.narrowBy(subclass);\n         } catch (IllegalArgumentException iae) {\n@@ -25,7 +25,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n             if (kd != null) {\n@@ -36,7 +36,7 @@\n         }\n         // and finally content class; only applicable to structured types\n         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n-        if (cc != null) {\n+        if (cc != null && !type.getContentType().hasRawClass(cc)) {\n             try {\n                 type = (T) type.narrowContentsBy(cc);\n             } catch (IllegalArgumentException iae) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType != null && contentType.getValueHandler() == null) { // content type may be null, but null value handler is legal\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -25,7 +25,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n             if (kd != null) {\n@@ -45,7 +45,7 @@\n         }\n         // ... as well as deserializer for contents:\n         JavaType contentType = type.getContentType();\n-        if (contentType.getValueHandler() == null) {\n+        if (contentType != null && contentType.getValueHandler() == null) { // content type may be null, but null value handler is legal\n             // as with above, avoid resetting (which would trigger exception)\n             Object cdDef = intr.findContentDeserializer(a);\n             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings({ \"unchecked\" })\nprotected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException {\n    // first: let's check class for the instance itself:\n    AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n    Class<?> subclass = intr.findDeserializationType(a, type);\n    if (subclass != null) {\n        try {\n            type = (T) type.narrowBy(subclass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(\"Failed to narrow type \" + type + \" with concrete-type annotation (value \" + subclass.getName() + \"), method '\" + a.getName() + \"': \" + iae.getMessage(), null, iae);\n        }\n    }\n    // then key class\n    if (type.isContainerType()) {\n        Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType());\n        if (keyClass != null) {\n            // illegal to use on non-Maps\n            if (!(type instanceof MapLikeType)) {\n                throw new JsonMappingException(\"Illegal key-type annotation: type \" + type + \" is not a Map(-like) type\");\n            }\n            try {\n                type = (T) ((MapLikeType) type).narrowKey(keyClass);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow key type \" + type + \" with key-type annotation (\" + keyClass.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        JavaType keyType = type.getKeyType();\n        if (keyType != null && keyType.getValueHandler() == null) {\n            Object kdDef = intr.findKeyDeserializer(a);\n            KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n            if (kd != null) {\n                type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                // just in case it's used below\n                keyType = type.getKeyType();\n            }\n        }\n        // and finally content class; only applicable to structured types\n        Class<?> cc = intr.findDeserializationContentType(a, type.getContentType());\n        if (cc != null) {\n            try {\n                type = (T) type.narrowContentsBy(cc);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(\"Failed to narrow content type \" + type + \" with content-type annotation (\" + cc.getName() + \"): \" + iae.getMessage(), null, iae);\n            }\n        }\n        // ... as well as deserializer for contents:\n        JavaType contentType = type.getContentType();\n        if (contentType == null) {\n            return type;\n        }\n        if (contentType.getValueHandler() == null) {\n            // as with above, avoid resetting (which would trigger exception)\n            Object cdDef = intr.findContentDeserializer(a);\n            JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n            if (cd != null) {\n                type = (T) type.withContentValueHandler(cd);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@modifyTypeByAnnotation\n@@ -25,7 +25,7 @@\n             }\n         }\n         JavaType keyType = type.getKeyType();\n-                if (keyType != null && keyType.getValueHandler() == null) {\n+        if (keyType != null && keyType.getValueHandler() == null) {\n             Object kdDef = intr.findKeyDeserializer(a);\n             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef);\n             if (kd != null) {\n@@ -45,6 +45,9 @@\n         }\n         // ... as well as deserializer for contents:\n         JavaType contentType = type.getContentType();\n+        if (contentType == null) {\n+            return type;\n+        }\n         if (contentType.getValueHandler() == null) {\n             // as with above, avoid resetting (which would trigger exception)\n             Object cdDef = intr.findContentDeserializer(a);\n", "finish_reason": "stop", "valid": false, "num": 1}]