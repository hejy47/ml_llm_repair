[{"output": "@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src)).getRawClass();\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return config.getTypeFactory().constructSpecializedType(type, dst);\n}", "diff": "--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -2,10 +2,10 @@\n public JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n     // this is the main mapping base, so let's\n     Class<?> src = type.getRawClass();\n-    Class<?> dst = _mappings.get(new ClassKey(src));\n+    Class<?> dst = _mappings.get(new ClassKey(src)).getRawClass();\n     if (dst == null) {\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return config.getTypeFactory().constructSpecializedType(type, dst);\n }\n", "finish_reason": "stop", "valid": false, "num": 12}, {"output": "@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    TypeFactory tf = config.getTypeFactory();\n    return type.narrowBy(tf.constructType(dst));\n}", "diff": "--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -7,5 +7,6 @@\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    TypeFactory tf = config.getTypeFactory();\n+    return type.narrowBy(tf.constructType(dst));\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src)).getRawClass(); // fix: added getRawClass()\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return config.getTypeFactory().constructSpecializedType(type, dst); // fix: replaced narrowBy() with constructSpecializedType()\n}", "diff": "--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -2,10 +2,10 @@\n public JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n     // this is the main mapping base, so let's\n     Class<?> src = type.getRawClass();\n-    Class<?> dst = _mappings.get(new ClassKey(src));\n+    Class<?> dst = _mappings.get(new ClassKey(src)).getRawClass(); // fix: added getRawClass()\n     if (dst == null) {\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return config.getTypeFactory().constructSpecializedType(type, dst); // fix: replaced narrowBy() with constructSpecializedType()\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return config.getTypeFactory().constructSpecializedType(type, dst);\n}", "diff": "--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -7,5 +7,5 @@\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return config.getTypeFactory().constructSpecializedType(type, dst);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    TypeFactory tf = config.getTypeFactory();\n    return tf.constructSpecializedType(type, dst);\n}", "diff": "--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -7,5 +7,6 @@\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    TypeFactory tf = config.getTypeFactory();\n+    return tf.constructSpecializedType(type, dst);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src)).getRawClass();\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return config.getTypeFactory().constructType(dst);\n}", "diff": "--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -2,10 +2,10 @@\n public JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n     // this is the main mapping base, so let's\n     Class<?> src = type.getRawClass();\n-    Class<?> dst = _mappings.get(new ClassKey(src));\n+    Class<?> dst = _mappings.get(new ClassKey(src)).getRawClass();\n     if (dst == null) {\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return config.getTypeFactory().constructType(dst);\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src)).getRawClass(); // fix: getRawClass() is needed to retrieve the actual Class object from the mapped JavaType\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    return config.getTypeFactory().constructSpecializedType(type, dst); // fix: use TypeFactory to construct the specialized JavaType\n}", "diff": "--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -2,10 +2,10 @@\n public JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n     // this is the main mapping base, so let's\n     Class<?> src = type.getRawClass();\n-    Class<?> dst = _mappings.get(new ClassKey(src));\n+    Class<?> dst = _mappings.get(new ClassKey(src)).getRawClass(); // fix: getRawClass() is needed to retrieve the actual Class object from the mapped JavaType\n     if (dst == null) {\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    return config.getTypeFactory().constructSpecializedType(type, dst); // fix: use TypeFactory to construct the specialized JavaType\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType findTypeMapping(DeserializationConfig config, JavaType type) throws JsonMappingException {\n    // this is the main mapping base, so let's\n    Class<?> src = type.getRawClass();\n    Class<?> dst = _mappings.get(new ClassKey(src));\n    if (dst == null) {\n        return null;\n    }\n    // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n    JavaType resultType = config.getTypeFactory().constructType(dst);\n    return type.narrowBy(resultType);\n}", "diff": "--- com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n+++ com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java@findTypeMapping\n@@ -1,5 +1,5 @@\n @Override\n-public JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n+public JavaType findTypeMapping(DeserializationConfig config, JavaType type) throws JsonMappingException {\n     // this is the main mapping base, so let's\n     Class<?> src = type.getRawClass();\n     Class<?> dst = _mappings.get(new ClassKey(src));\n@@ -7,5 +7,6 @@\n         return null;\n     }\n     // 09-Aug-2015, tatu: Instead of direct call via JavaType, better use TypeFactory\n-    return type.narrowBy(dst);\n+    JavaType resultType = config.getTypeFactory().constructType(dst);\n+    return type.narrowBy(resultType);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]