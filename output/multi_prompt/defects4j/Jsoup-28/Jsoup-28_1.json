[{"output": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.isEmpty()) { // changed from numRef.length() == 0\n            // didn't match anything\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.parseInt(numRef, base); // changed from Integer.valueOf\n        } catch (NumberFormatException e) {\n        }\n        // skip\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else {\n        // named\n        // get as many letters as possible, and look for matching entities.\n        String nameRef = reader.consumeLetterThenDigitSequence();\n        String origNameRef = new String(nameRef);\n        boolean looksLegit = reader.matches(';');\n        // found if a base named entity without a ;, or an extended entity with the ;.\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            reader.rewindToMark();\n            if (looksLegit) // removed unnecessary comment\n                characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n        return Entities.getCharacterByName(nameRef);\n    }\n}", "diff": "--- org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n+++ org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n@@ -10,7 +10,7 @@\n         // numbered\n         boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n         String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n-        if (numRef.length() == 0) {\n+        if (numRef.isEmpty()) { // changed from numRef.length() == 0\n             // didn't match anything\n             characterReferenceError(\"numeric reference with no numerals\");\n             reader.rewindToMark();\n@@ -22,7 +22,7 @@\n         int charval = -1;\n         try {\n             int base = isHexMode ? 16 : 10;\n-            charval = Integer.valueOf(numRef, base);\n+            charval = Integer.parseInt(numRef, base); // changed from Integer.valueOf\n         } catch (NumberFormatException e) {\n         }\n         // skip\n@@ -52,8 +52,7 @@\n         }\n         if (!found) {\n             reader.rewindToMark();\n-            if (// named with semicolon\n-            looksLegit)\n+            if (looksLegit) // removed unnecessary comment\n                 characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n             return null;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) {\n            // didn't match anything\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\")) {\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n            reader.rewindToMark();\n            return null;\n        }\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n            // invalid number\n            characterReferenceError(\"invalid numeric character reference: \" + numRef);\n            reader.rewindToMark();\n            return null;\n        }\n        if (charval == 0) {\n            // null char refs are not allowed\n            characterReferenceError(\"illegal character reference: NULL\");\n            return replacementChar;\n        }\n        if ((charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError(\"character outside of valid Unicode range: \" + numRef);\n            return replacementChar;\n        }\n        if (charval >= 0x80 && charval <= 0x9f) {\n            // check for illegal control chars\n            if (charval == 0x80 || charval == 0x8f || charval == 0x9f) {\n                characterReferenceError(\n                        \"illegal character reference: control character without leading zero\");\n                charval = Entities.getCharacterByName(new String(new char[] { (char) charval }));\n                if (charval == (int) replacementChar)\n                    characterReferenceError(\"unknown entity: \" + numRef);\n                return (char) charval;\n            } else {\n                characterReferenceError(\"illegal character reference: control character\");\n                return (char) charval;\n            }\n        }\n        // todo: implement number replacement table\n        // todo: check for extra illegal unicode points as parse errors\n        return (char) charval;\n    } else {\n        // named\n        // get as many letters as possible, and look for matching entities.\n        String nameRef = reader.consumeLetterThenDigitSequence();\n        String origNameRef = new String(nameRef);\n        boolean looksLegit = reader.matches(';');\n        // found if a base named entity without a ;, or an extended entity with the ;.\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            reader.rewindToMark();\n            if (// named with semicolon\n            looksLegit)\n                characterReferenceError(String.format(\"invalid named reference '%s'\", origNameRef));\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\")) {\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n            reader.rewindToMark();\n            return null;\n        }\n        return Entities.getCharacterByName(nameRef);\n    }\n}", "diff": "--- org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n+++ org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n@@ -16,24 +16,48 @@\n             reader.rewindToMark();\n             return null;\n         }\n-        if (!reader.matchConsume(\";\"))\n+        if (!reader.matchConsume(\";\")) {\n             // missing semi\n             characterReferenceError(\"missing semicolon\");\n+            reader.rewindToMark();\n+            return null;\n+        }\n         int charval = -1;\n         try {\n             int base = isHexMode ? 16 : 10;\n             charval = Integer.valueOf(numRef, base);\n         } catch (NumberFormatException e) {\n+            // invalid number\n+            characterReferenceError(\"invalid numeric character reference: \" + numRef);\n+            reader.rewindToMark();\n+            return null;\n         }\n-        // skip\n-        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n-            characterReferenceError(\"character outside of valid range\");\n+        if (charval == 0) {\n+            // null char refs are not allowed\n+            characterReferenceError(\"illegal character reference: NULL\");\n             return replacementChar;\n-        } else {\n-            // todo: implement number replacement table\n-            // todo: check for extra illegal unicode points as parse errors\n-            return (char) charval;\n         }\n+        if ((charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n+            characterReferenceError(\"character outside of valid Unicode range: \" + numRef);\n+            return replacementChar;\n+        }\n+        if (charval >= 0x80 && charval <= 0x9f) {\n+            // check for illegal control chars\n+            if (charval == 0x80 || charval == 0x8f || charval == 0x9f) {\n+                characterReferenceError(\n+                        \"illegal character reference: control character without leading zero\");\n+                charval = Entities.getCharacterByName(new String(new char[] { (char) charval }));\n+                if (charval == (int) replacementChar)\n+                    characterReferenceError(\"unknown entity: \" + numRef);\n+                return (char) charval;\n+            } else {\n+                characterReferenceError(\"illegal character reference: control character\");\n+                return (char) charval;\n+            }\n+        }\n+        // todo: implement number replacement table\n+        // todo: check for extra illegal unicode points as parse errors\n+        return (char) charval;\n     } else {\n         // named\n         // get as many letters as possible, and look for matching entities.\n@@ -54,7 +78,7 @@\n             reader.rewindToMark();\n             if (// named with semicolon\n             looksLegit)\n-                characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n+                characterReferenceError(String.format(\"invalid named reference '%s'\", origNameRef));\n             return null;\n         }\n         if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n@@ -62,9 +86,12 @@\n             reader.rewindToMark();\n             return null;\n         }\n-        if (!reader.matchConsume(\";\"))\n+        if (!reader.matchConsume(\";\")) {\n             // missing semi\n             characterReferenceError(\"missing semicolon\");\n+            reader.rewindToMark();\n+            return null;\n+        }\n         return Entities.getCharacterByName(nameRef);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) {\n            // didn't match anything\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\")) {\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n            reader.rewindToMark();\n            return null;\n        }\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.parseInt(numRef, base);\n        } catch (NumberFormatException e) {\n            characterReferenceError(\"invalid numeric character reference\");\n            reader.rewindToMark();\n            return null;\n        }\n        if ((charval >= 0 && charval <= 8)\n                || (charval >= 11 && charval <= 12)\n                || (charval >= 14 && charval <= 31)\n                || (charval >= 127 && charval <= 159)\n                || charval > 0x10FFFF\n                || (charval >= 0xD800 && charval <= 0xDFFF)) {\n            characterReferenceError(\"character outside of valid range\");\n            return replacementChar;\n        }\n        return (char) charval;\n    } else {\n        // named\n        // get as many letters as possible, and look for matching entities.\n        String nameRef = reader.consumeLetterThenDigitSequence();\n        String origNameRef = new String(nameRef);\n        boolean looksLegit = reader.matches(';');\n        // found if a base named entity without a ;, or an extended entity with the ;.\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            reader.rewindToMark();\n            if (// named with semicolon\n                    looksLegit)\n                characterReferenceError(String.format(\"invalid named reference '%s'\", origNameRef));\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\")) {\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n            reader.rewindToMark();\n            return null;\n        }\n        return Entities.getCharacterByName(nameRef);\n    }\n}", "diff": "--- org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n+++ org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n@@ -16,24 +16,31 @@\n             reader.rewindToMark();\n             return null;\n         }\n-        if (!reader.matchConsume(\";\"))\n+        if (!reader.matchConsume(\";\")) {\n             // missing semi\n             characterReferenceError(\"missing semicolon\");\n+            reader.rewindToMark();\n+            return null;\n+        }\n         int charval = -1;\n         try {\n             int base = isHexMode ? 16 : 10;\n-            charval = Integer.valueOf(numRef, base);\n+            charval = Integer.parseInt(numRef, base);\n         } catch (NumberFormatException e) {\n+            characterReferenceError(\"invalid numeric character reference\");\n+            reader.rewindToMark();\n+            return null;\n         }\n-        // skip\n-        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n+        if ((charval >= 0 && charval <= 8)\n+                || (charval >= 11 && charval <= 12)\n+                || (charval >= 14 && charval <= 31)\n+                || (charval >= 127 && charval <= 159)\n+                || charval > 0x10FFFF\n+                || (charval >= 0xD800 && charval <= 0xDFFF)) {\n             characterReferenceError(\"character outside of valid range\");\n             return replacementChar;\n-        } else {\n-            // todo: implement number replacement table\n-            // todo: check for extra illegal unicode points as parse errors\n-            return (char) charval;\n         }\n+        return (char) charval;\n     } else {\n         // named\n         // get as many letters as possible, and look for matching entities.\n@@ -53,8 +60,8 @@\n         if (!found) {\n             reader.rewindToMark();\n             if (// named with semicolon\n-            looksLegit)\n-                characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n+                    looksLegit)\n+                characterReferenceError(String.format(\"invalid named reference '%s'\", origNameRef));\n             return null;\n         }\n         if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n@@ -62,9 +69,12 @@\n             reader.rewindToMark();\n             return null;\n         }\n-        if (!reader.matchConsume(\";\"))\n+        if (!reader.matchConsume(\";\")) {\n             // missing semi\n             characterReferenceError(\"missing semicolon\");\n+            reader.rewindToMark();\n+            return null;\n+        }\n         return Entities.getCharacterByName(nameRef);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) {\n            // didn't match anything\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.parseInt(numRef, base);\n        } catch (NumberFormatException e) {\n        }\n        // skip\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else {\n        // named\n        // get as many letters as possible, and look for matching entities.\n        String nameRef = reader.consumeLetterThenDigitSequence();\n        String origNameRef = new String(nameRef);\n        boolean looksLegit = reader.matches(';');\n        // found if a base named entity without a ;, or an extended entity with the ;.\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            reader.rewindToMark();\n            if (// named with semicolon\n            looksLegit)\n                characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n        return Entities.getCharacterByName(nameRef);\n    }\n}", "diff": "--- org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n+++ org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n@@ -22,7 +22,7 @@\n         int charval = -1;\n         try {\n             int base = isHexMode ? 16 : 10;\n-            charval = Integer.valueOf(numRef, base);\n+            charval = Integer.parseInt(numRef, base);\n         } catch (NumberFormatException e) {\n         }\n         // skip\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) {\n            // didn't match anything\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.parseInt(numRef, base);\n        } catch (NumberFormatException e) {\n        }\n        // skip\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else {\n        // named\n        // get as many letters as possible, and look for matching entities.\n        String nameRef = reader.consumeLetterThenDigitSequence();\n        String origNameRef = new String(nameRef);\n        boolean looksLegit = reader.matches(';');\n        // found if a base named entity without a ;, or an extended entity with the ;.\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length() - 1);\n                reader.rewind();\n            }\n        }\n        if (!found) {\n            reader.rewindToMark();\n            if (looksLegit)\n                characterReferenceError(String.format(\"invalid named reference '%s'\", origNameRef));\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n        return Entities.getCharacterByName(nameRef);\n    }\n}", "diff": "--- org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n+++ org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n@@ -22,7 +22,7 @@\n         int charval = -1;\n         try {\n             int base = isHexMode ? 16 : 10;\n-            charval = Integer.valueOf(numRef, base);\n+            charval = Integer.parseInt(numRef, base);\n         } catch (NumberFormatException e) {\n         }\n         // skip\n@@ -47,14 +47,13 @@\n                 found = true;\n             else {\n                 nameRef = nameRef.substring(0, nameRef.length() - 1);\n-                reader.unconsume();\n+                reader.rewind();\n             }\n         }\n         if (!found) {\n             reader.rewindToMark();\n-            if (// named with semicolon\n-            looksLegit)\n-                characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n+            if (looksLegit)\n+                characterReferenceError(String.format(\"invalid named reference '%s'\", origNameRef));\n             return null;\n         }\n         if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) {\n            // didn't match anything\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\")) {\n            // missing semicolon\n            characterReferenceError(\"missing semicolon\");\n            reader.rewindToMark();\n            return null;\n        }\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.parseInt(numRef, base);\n        } catch (NumberFormatException e) {\n            characterReferenceError(\"invalid numeric character reference\");\n            reader.rewindToMark();\n            return null;\n        }\n        // skip\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else {\n        // named\n        // get as many letters as possible, we don't care about digits for named references\n        String nameRef = reader.consumeLetterThenDigitSequence();\n        String origNameRef = new String(nameRef);\n        boolean looksLegit = reader.matches(';');\n        // found if a base named entity without a ;, or an extended entity with the ;.\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (found) {\n            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_', ':'))) {\n                // don't want that to match\n                reader.rewindToMark();\n                return null;\n            }\n            if (!reader.matchConsume(\";\")) {\n                // missing semicolon\n                characterReferenceError(\"missing semicolon\");\n                reader.rewindToMark();\n                return null;\n            } else {\n                return Entities.getCharacterByName(nameRef);\n            }\n        } else {\n            reader.rewindToMark();\n            if (looksLegit)\n                characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n            return null;\n        }\n    }\n}", "diff": "--- org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n+++ org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n@@ -16,14 +16,20 @@\n             reader.rewindToMark();\n             return null;\n         }\n-        if (!reader.matchConsume(\";\"))\n-            // missing semi\n+        if (!reader.matchConsume(\";\")) {\n+            // missing semicolon\n             characterReferenceError(\"missing semicolon\");\n+            reader.rewindToMark();\n+            return null;\n+        }\n         int charval = -1;\n         try {\n             int base = isHexMode ? 16 : 10;\n-            charval = Integer.valueOf(numRef, base);\n+            charval = Integer.parseInt(numRef, base);\n         } catch (NumberFormatException e) {\n+            characterReferenceError(\"invalid numeric character reference\");\n+            reader.rewindToMark();\n+            return null;\n         }\n         // skip\n         if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n@@ -36,7 +42,7 @@\n         }\n     } else {\n         // named\n-        // get as many letters as possible, and look for matching entities.\n+        // get as many letters as possible, we don't care about digits for named references\n         String nameRef = reader.consumeLetterThenDigitSequence();\n         String origNameRef = new String(nameRef);\n         boolean looksLegit = reader.matches(';');\n@@ -50,21 +56,25 @@\n                 reader.unconsume();\n             }\n         }\n-        if (!found) {\n+        if (found) {\n+            if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_', ':'))) {\n+                // don't want that to match\n+                reader.rewindToMark();\n+                return null;\n+            }\n+            if (!reader.matchConsume(\";\")) {\n+                // missing semicolon\n+                characterReferenceError(\"missing semicolon\");\n+                reader.rewindToMark();\n+                return null;\n+            } else {\n+                return Entities.getCharacterByName(nameRef);\n+            }\n+        } else {\n             reader.rewindToMark();\n-            if (// named with semicolon\n-            looksLegit)\n+            if (looksLegit)\n                 characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n             return null;\n         }\n-        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n-            // don't want that to match\n-            reader.rewindToMark();\n-            return null;\n-        }\n-        if (!reader.matchConsume(\";\"))\n-            // missing semi\n-            characterReferenceError(\"missing semicolon\");\n-        return Entities.getCharacterByName(nameRef);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) {\n            // didn't match anything\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.parseInt(numRef, base);\n        } catch (NumberFormatException e) {\n        }\n        // skip\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else {\n        // named\n        // get as many letters as possible, and look for matching entities.\n        String nameRef = reader.consumeLetterThenDigitSequence();\n        String origNameRef = new String(nameRef);\n        boolean looksLegit = reader.matches(';');\n        // found if a base named entity without a ;, or an extended entity with the ;.\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            reader.rewindToMark();\n            if (looksLegit)\n                characterReferenceError(String.format(\"invalid named reference '%s'\", origNameRef));\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n        return Entities.getCharacterByName(nameRef);\n    }\n}", "diff": "--- org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n+++ org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n@@ -22,7 +22,7 @@\n         int charval = -1;\n         try {\n             int base = isHexMode ? 16 : 10;\n-            charval = Integer.valueOf(numRef, base);\n+            charval = Integer.parseInt(numRef, base);\n         } catch (NumberFormatException e) {\n         }\n         // skip\n@@ -52,9 +52,8 @@\n         }\n         if (!found) {\n             reader.rewindToMark();\n-            if (// named with semicolon\n-            looksLegit)\n-                characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n+            if (looksLegit)\n+                characterReferenceError(String.format(\"invalid named reference '%s'\", origNameRef));\n             return null;\n         }\n         if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) {\n            // didn't match anything\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\")) {\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n            reader.rewindToMark();\n            return null;\n        }\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.parseInt(numRef, base);\n        } catch (NumberFormatException e) {\n            // catch parsing exceptions\n            reader.rewindToMark();\n            return null;\n        }\n        // skip\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else {\n        // named\n        // get as many letters as possible, and look for matching entities.\n        String nameRef = reader.consumeLetterThenDigitSequence();\n        String origNameRef = new String(nameRef);\n        boolean looksLegit = reader.matches(';');\n        // found if a base named entity without a ;, or an extended entity with the ;.\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            reader.rewindToMark();\n            if (looksLegit)\n                characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\")) {\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n            reader.rewindToMark();\n            return null;\n        }\n        return Entities.getCharacterByName(nameRef);\n    }\n}", "diff": "--- org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n+++ org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n@@ -16,14 +16,20 @@\n             reader.rewindToMark();\n             return null;\n         }\n-        if (!reader.matchConsume(\";\"))\n+        if (!reader.matchConsume(\";\")) {\n             // missing semi\n             characterReferenceError(\"missing semicolon\");\n+            reader.rewindToMark();\n+            return null;\n+        }\n         int charval = -1;\n         try {\n             int base = isHexMode ? 16 : 10;\n-            charval = Integer.valueOf(numRef, base);\n+            charval = Integer.parseInt(numRef, base);\n         } catch (NumberFormatException e) {\n+            // catch parsing exceptions\n+            reader.rewindToMark();\n+            return null;\n         }\n         // skip\n         if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n@@ -52,8 +58,7 @@\n         }\n         if (!found) {\n             reader.rewindToMark();\n-            if (// named with semicolon\n-            looksLegit)\n+            if (looksLegit)\n                 characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n             return null;\n         }\n@@ -62,9 +67,12 @@\n             reader.rewindToMark();\n             return null;\n         }\n-        if (!reader.matchConsume(\";\"))\n+        if (!reader.matchConsume(\";\")) {\n             // missing semi\n             characterReferenceError(\"missing semicolon\");\n+            reader.rewindToMark();\n+            return null;\n+        }\n         return Entities.getCharacterByName(nameRef);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) {\n            // didn't match anything\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\")) {\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n            reader.rewindToMark();\n            return null;\n        }\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.parseInt(numRef, base);\n        } catch (NumberFormatException e) {\n            characterReferenceError(\"Invalid numeric character reference: \" + numRef);\n            reader.rewindToMark();\n            return null;\n        }\n        if (charval == 0) {\n            characterReferenceError(\"Null character in numeric character reference\");\n            return replacementChar;\n        }\n        if ((charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError(\"Character outside of valid Unicode range in numeric character reference\");\n            return replacementChar;\n        }\n        if (charval >= 0x80 && charval <= 0x9F &&\n                !Entities.isNamedEntity(Character.toString((char) charval))) {\n            characterReferenceError(\"Invalid numeric character reference: \" + numRef);\n            return replacementChar;\n        }\n        return (char) charval;\n\n    } else {\n        // named\n        // get as many letters as possible, and look for matching entities.\n        String nameRef = reader.consumeLetterThenDigitSequence();\n        boolean looksLegit = reader.matches(';');\n        if (Entities.isNamedEntity(nameRef)) {\n            if (!reader.matchConsume(\";\")) {\n                // missing semi, return null\n                reader.rewindToMark();\n                return null;\n            }\n            return Entities.getCharacterByName(nameRef);\n        } else if (looksLegit) {\n            // e.g. &notin;, with a typo\n            characterReferenceError(String.format(\"Invalid named referenece '%s'\", nameRef));\n            return null;\n        } else {\n            reader.rewindToMark(); // unconsume & consume next\n            return null;\n        }\n    }\n}", "diff": "--- org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n+++ org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n@@ -16,55 +16,55 @@\n             reader.rewindToMark();\n             return null;\n         }\n-        if (!reader.matchConsume(\";\"))\n+        if (!reader.matchConsume(\";\")) {\n             // missing semi\n             characterReferenceError(\"missing semicolon\");\n+            reader.rewindToMark();\n+            return null;\n+        }\n         int charval = -1;\n         try {\n             int base = isHexMode ? 16 : 10;\n-            charval = Integer.valueOf(numRef, base);\n+            charval = Integer.parseInt(numRef, base);\n         } catch (NumberFormatException e) {\n+            characterReferenceError(\"Invalid numeric character reference: \" + numRef);\n+            reader.rewindToMark();\n+            return null;\n         }\n-        // skip\n-        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n-            characterReferenceError(\"character outside of valid range\");\n+        if (charval == 0) {\n+            characterReferenceError(\"Null character in numeric character reference\");\n             return replacementChar;\n-        } else {\n-            // todo: implement number replacement table\n-            // todo: check for extra illegal unicode points as parse errors\n-            return (char) charval;\n         }\n+        if ((charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n+            characterReferenceError(\"Character outside of valid Unicode range in numeric character reference\");\n+            return replacementChar;\n+        }\n+        if (charval >= 0x80 && charval <= 0x9F &&\n+                !Entities.isNamedEntity(Character.toString((char) charval))) {\n+            characterReferenceError(\"Invalid numeric character reference: \" + numRef);\n+            return replacementChar;\n+        }\n+        return (char) charval;\n+\n     } else {\n         // named\n         // get as many letters as possible, and look for matching entities.\n         String nameRef = reader.consumeLetterThenDigitSequence();\n-        String origNameRef = new String(nameRef);\n         boolean looksLegit = reader.matches(';');\n-        // found if a base named entity without a ;, or an extended entity with the ;.\n-        boolean found = false;\n-        while (nameRef.length() > 0 && !found) {\n-            if (Entities.isNamedEntity(nameRef))\n-                found = true;\n-            else {\n-                nameRef = nameRef.substring(0, nameRef.length() - 1);\n-                reader.unconsume();\n+        if (Entities.isNamedEntity(nameRef)) {\n+            if (!reader.matchConsume(\";\")) {\n+                // missing semi, return null\n+                reader.rewindToMark();\n+                return null;\n             }\n-        }\n-        if (!found) {\n-            reader.rewindToMark();\n-            if (// named with semicolon\n-            looksLegit)\n-                characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n+            return Entities.getCharacterByName(nameRef);\n+        } else if (looksLegit) {\n+            // e.g. &notin;, with a typo\n+            characterReferenceError(String.format(\"Invalid named referenece '%s'\", nameRef));\n+            return null;\n+        } else {\n+            reader.rewindToMark(); // unconsume & consume next\n             return null;\n         }\n-        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n-            // don't want that to match\n-            reader.rewindToMark();\n-            return null;\n-        }\n-        if (!reader.matchConsume(\";\"))\n-            // missing semi\n-            characterReferenceError(\"missing semicolon\");\n-        return Entities.getCharacterByName(nameRef);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) {\n            // didn't match anything\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.parseInt(numRef, base);\n        } catch (NumberFormatException e) {\n        }\n        // skip\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else {\n        // named\n        // get as many letters as possible, and look for matching entities.\n        String nameRef = reader.consumeLetterThenDigitSequence();\n        String origNameRef = new String(nameRef);\n        boolean looksLegit = reader.matches(';');\n        // found if a base named entity without a ;, or an extended entity with the ;.\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            reader.rewindToMark();\n            if (// named with semicolon\n            looksLegit)\n                characterReferenceError(String.format(\"invalid named reference '%s'\", origNameRef));\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n        return Entities.getCharacterByName(nameRef);\n    }\n}", "diff": "--- org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n+++ org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n@@ -22,7 +22,7 @@\n         int charval = -1;\n         try {\n             int base = isHexMode ? 16 : 10;\n-            charval = Integer.valueOf(numRef, base);\n+            charval = Integer.parseInt(numRef, base);\n         } catch (NumberFormatException e) {\n         }\n         // skip\n@@ -54,7 +54,7 @@\n             reader.rewindToMark();\n             if (// named with semicolon\n             looksLegit)\n-                characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n+                characterReferenceError(String.format(\"invalid named reference '%s'\", origNameRef));\n             return null;\n         }\n         if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) {\n            // didn't match anything\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\")) {\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n            reader.rewindToMark();\n            return null;\n        }\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.parseInt(numRef, base);\n        } catch (NumberFormatException e) {\n            reader.rewindToMark();\n            return null;\n        }\n        // skip\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else {\n        // named\n        // get as many letters as possible, and look for matching entities.\n        String nameRef = reader.consumeLetterThenDigitSequence();\n        String origNameRef = new String(nameRef);\n        boolean looksLegit = reader.matches(';');\n        // found if a base named entity without a ;, or an extended entity with the ;.\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef)) {\n                found = true;\n            } else {\n                nameRef = nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            reader.rewindToMark();\n            if (// named with semicolon\n                    looksLegit) {\n                characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n            }\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\")) {\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n            reader.rewindToMark();\n            return null;\n        }\n        return Entities.getCharacterByName(nameRef);\n    }\n}", "diff": "--- org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n+++ org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n@@ -16,14 +16,19 @@\n             reader.rewindToMark();\n             return null;\n         }\n-        if (!reader.matchConsume(\";\"))\n+        if (!reader.matchConsume(\";\")) {\n             // missing semi\n             characterReferenceError(\"missing semicolon\");\n+            reader.rewindToMark();\n+            return null;\n+        }\n         int charval = -1;\n         try {\n             int base = isHexMode ? 16 : 10;\n-            charval = Integer.valueOf(numRef, base);\n+            charval = Integer.parseInt(numRef, base);\n         } catch (NumberFormatException e) {\n+            reader.rewindToMark();\n+            return null;\n         }\n         // skip\n         if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n@@ -43,9 +48,9 @@\n         // found if a base named entity without a ;, or an extended entity with the ;.\n         boolean found = false;\n         while (nameRef.length() > 0 && !found) {\n-            if (Entities.isNamedEntity(nameRef))\n+            if (Entities.isNamedEntity(nameRef)) {\n                 found = true;\n-            else {\n+            } else {\n                 nameRef = nameRef.substring(0, nameRef.length() - 1);\n                 reader.unconsume();\n             }\n@@ -53,8 +58,9 @@\n         if (!found) {\n             reader.rewindToMark();\n             if (// named with semicolon\n-            looksLegit)\n+                    looksLegit) {\n                 characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n+            }\n             return null;\n         }\n         if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n@@ -62,9 +68,12 @@\n             reader.rewindToMark();\n             return null;\n         }\n-        if (!reader.matchConsume(\";\"))\n+        if (!reader.matchConsume(\";\")) {\n             // missing semi\n             characterReferenceError(\"missing semicolon\");\n+            reader.rewindToMark();\n+            return null;\n+        }\n         return Entities.getCharacterByName(nameRef);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0 || !reader.matchConsume(\";\")) {\n            // didn't match anything or missing semicolon\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.parseInt(numRef, base);\n        } catch (NumberFormatException e) {\n            // parsing exception\n            characterReferenceError(\"Invalid numeric reference\");\n            reader.rewindToMark();\n            return null;\n        }\n        // skip\n        if ((charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            // character outside of valid range or low-surrogate/high-surrogate\n            characterReferenceError(\"character outside of valid range\");\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else {\n        // named\n        // get as many letters as possible, and look for matching entities.\n        String nameRef = reader.consumeLetterThenDigitSequence();\n        String origNameRef = nameRef;\n        boolean looksLegit = reader.matches(';');\n        // found if a base named entity without a ;, or an extended entity with the ;.\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found && looksLegit) {\n            // cannot find the entity, but it looks legit\n            characterReferenceError(String.format(\"entity '%s' does not exist\", origNameRef));\n            reader.rewindToMark();\n            return null;\n        } else if (!found) {\n            // cannot find the entity, and not looks legit\n            reader.rewindToMark();\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_', ':'))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\")) {\n            // missing semicolon\n            characterReferenceError(\"missing semicolon\");\n            reader.rewindToMark();\n            return null;\n        }\n        return Entities.getCharacterByName(nameRef);\n    }\n}", "diff": "--- org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n+++ org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n@@ -10,23 +10,25 @@\n         // numbered\n         boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n         String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n-        if (numRef.length() == 0) {\n-            // didn't match anything\n+        if (numRef.length() == 0 || !reader.matchConsume(\";\")) {\n+            // didn't match anything or missing semicolon\n             characterReferenceError(\"numeric reference with no numerals\");\n             reader.rewindToMark();\n             return null;\n         }\n-        if (!reader.matchConsume(\";\"))\n-            // missing semi\n-            characterReferenceError(\"missing semicolon\");\n         int charval = -1;\n         try {\n             int base = isHexMode ? 16 : 10;\n-            charval = Integer.valueOf(numRef, base);\n+            charval = Integer.parseInt(numRef, base);\n         } catch (NumberFormatException e) {\n+            // parsing exception\n+            characterReferenceError(\"Invalid numeric reference\");\n+            reader.rewindToMark();\n+            return null;\n         }\n         // skip\n-        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n+        if ((charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n+            // character outside of valid range or low-surrogate/high-surrogate\n             characterReferenceError(\"character outside of valid range\");\n             return replacementChar;\n         } else {\n@@ -38,7 +40,7 @@\n         // named\n         // get as many letters as possible, and look for matching entities.\n         String nameRef = reader.consumeLetterThenDigitSequence();\n-        String origNameRef = new String(nameRef);\n+        String origNameRef = nameRef;\n         boolean looksLegit = reader.matches(';');\n         // found if a base named entity without a ;, or an extended entity with the ;.\n         boolean found = false;\n@@ -50,21 +52,27 @@\n                 reader.unconsume();\n             }\n         }\n-        if (!found) {\n+        if (!found && looksLegit) {\n+            // cannot find the entity, but it looks legit\n+            characterReferenceError(String.format(\"entity '%s' does not exist\", origNameRef));\n             reader.rewindToMark();\n-            if (// named with semicolon\n-            looksLegit)\n-                characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n+            return null;\n+        } else if (!found) {\n+            // cannot find the entity, and not looks legit\n+            reader.rewindToMark();\n             return null;\n         }\n-        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n+        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_', ':'))) {\n             // don't want that to match\n             reader.rewindToMark();\n             return null;\n         }\n-        if (!reader.matchConsume(\";\"))\n-            // missing semi\n+        if (!reader.matchConsume(\";\")) {\n+            // missing semicolon\n             characterReferenceError(\"missing semicolon\");\n+            reader.rewindToMark();\n+            return null;\n+        }\n         return Entities.getCharacterByName(nameRef);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) {\n            // didn't match anything\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\")) {\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n            reader.rewindToMark();\n            return null;\n        }\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.parseInt(numRef, base);\n        } catch (NumberFormatException e) {\n            // invalid number\n            characterReferenceError(\"Invalid numeric character reference: \" + numRef);\n            return replacementChar;\n        }\n        // skip\n        if (CharUtils.isBmpCodePoint(charval)) {  // check if character is within the basic multilingual plane\n            if (CharUtils.isHtmlSpace(ch)) { // check if character is a HTML space character\n                return (char) ch;\n            } else if (ch == '\\n') { // check if character is a line feed\n                return null;\n            } else {\n                // todo: implement number replacement table\n                // todo: check for extra illegal unicode points as parse errors\n                return (char) ch;\n            }\n        } else {\n            characterReferenceError(\"Numeric character reference '%s' refers to a character outside the \" +\n                    \"encoding's range. The reference will be ignored.\");\n            return replacementChar;\n        }\n    } else {\n        // named\n        // get as many letters as possible, and look for matching entities.\n        String nameRef = reader.consumeLetterThenDigitSequence();\n        String origNameRef = new String(nameRef);\n        boolean looksLegit = reader.matches(';');\n        // found if a base named entity without a ;, or an extended entity with the ;.\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef)) {\n                found = true;\n            } else {\n                nameRef = nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            reader.rewindToMark();\n            if (looksLegit) {\n                characterReferenceError(String.format(\"invalid named reference '%s'\", origNameRef));\n            }\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\")) {\n            // missing semicolon\n            characterReferenceError(\"missing semicolon\");\n            reader.rewindToMark();\n            return null;\n        }\n        int charval = Entities.getCharacterByName(nameRef);\n        if (charval == -1) {\n            characterReferenceError(\"Unrecognized named entity: '%s'\",origNameRef);\n            return replacementChar;\n        } else {\n            if (CharUtils.isHtmlSpace(charval)) { // check if character is a HTML space character\n                return (char) charval;\n            } else if (charval == '\\n') { // check if character is a line feed\n                return null;\n            } else if (CharUtils.isBmpCodePoint(charval)) { // check if character is within the basic multilingual plane\n                return (char) charval;\n            } else {\n                characterReferenceError(\"Named character reference '%s' refers to a character outside the \" +\n                        \"encoding's range. The reference will be ignored.\");\n                return replacementChar;\n            }\n        }\n    }\n}", "diff": "--- org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n+++ org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n@@ -16,23 +16,36 @@\n             reader.rewindToMark();\n             return null;\n         }\n-        if (!reader.matchConsume(\";\"))\n+        if (!reader.matchConsume(\";\")) {\n             // missing semi\n             characterReferenceError(\"missing semicolon\");\n+            reader.rewindToMark();\n+            return null;\n+        }\n         int charval = -1;\n         try {\n             int base = isHexMode ? 16 : 10;\n-            charval = Integer.valueOf(numRef, base);\n+            charval = Integer.parseInt(numRef, base);\n         } catch (NumberFormatException e) {\n+            // invalid number\n+            characterReferenceError(\"Invalid numeric character reference: \" + numRef);\n+            return replacementChar;\n         }\n         // skip\n-        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n-            characterReferenceError(\"character outside of valid range\");\n+        if (CharUtils.isBmpCodePoint(charval)) {  // check if character is within the basic multilingual plane\n+            if (CharUtils.isHtmlSpace(ch)) { // check if character is a HTML space character\n+                return (char) ch;\n+            } else if (ch == '\\n') { // check if character is a line feed\n+                return null;\n+            } else {\n+                // todo: implement number replacement table\n+                // todo: check for extra illegal unicode points as parse errors\n+                return (char) ch;\n+            }\n+        } else {\n+            characterReferenceError(\"Numeric character reference '%s' refers to a character outside the \" +\n+                    \"encoding's range. The reference will be ignored.\");\n             return replacementChar;\n-        } else {\n-            // todo: implement number replacement table\n-            // todo: check for extra illegal unicode points as parse errors\n-            return (char) charval;\n         }\n     } else {\n         // named\n@@ -43,18 +56,18 @@\n         // found if a base named entity without a ;, or an extended entity with the ;.\n         boolean found = false;\n         while (nameRef.length() > 0 && !found) {\n-            if (Entities.isNamedEntity(nameRef))\n+            if (Entities.isNamedEntity(nameRef)) {\n                 found = true;\n-            else {\n+            } else {\n                 nameRef = nameRef.substring(0, nameRef.length() - 1);\n                 reader.unconsume();\n             }\n         }\n         if (!found) {\n             reader.rewindToMark();\n-            if (// named with semicolon\n-            looksLegit)\n-                characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n+            if (looksLegit) {\n+                characterReferenceError(String.format(\"invalid named reference '%s'\", origNameRef));\n+            }\n             return null;\n         }\n         if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n@@ -62,9 +75,28 @@\n             reader.rewindToMark();\n             return null;\n         }\n-        if (!reader.matchConsume(\";\"))\n-            // missing semi\n+        if (!reader.matchConsume(\";\")) {\n+            // missing semicolon\n             characterReferenceError(\"missing semicolon\");\n-        return Entities.getCharacterByName(nameRef);\n+            reader.rewindToMark();\n+            return null;\n+        }\n+        int charval = Entities.getCharacterByName(nameRef);\n+        if (charval == -1) {\n+            characterReferenceError(\"Unrecognized named entity: '%s'\",origNameRef);\n+            return replacementChar;\n+        } else {\n+            if (CharUtils.isHtmlSpace(charval)) { // check if character is a HTML space character\n+                return (char) charval;\n+            } else if (charval == '\\n') { // check if character is a line feed\n+                return null;\n+            } else if (CharUtils.isBmpCodePoint(charval)) { // check if character is within the basic multilingual plane\n+                return (char) charval;\n+            } else {\n+                characterReferenceError(\"Named character reference '%s' refers to a character outside the \" +\n+                        \"encoding's range. The reference will be ignored.\");\n+                return replacementChar;\n+            }\n+        }\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) {\n            // didn't match anything\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\"))\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.parseInt(numRef, base);\n        } catch (NumberFormatException e) {\n        }\n        // skip\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else {\n        // named\n        // get as many letters as possible, and look for matching entities.\n        String nameRef = reader.consumeLetterThenDigitSequence();\n        boolean looksLegit = reader.matches(';');\n        if (Entities.isNamedEntity(nameRef)) {\n            if (!reader.matchConsume(\";\")) {\n                // missing semi\n                characterReferenceError(\"missing semicolon\");\n            }\n            return Entities.getCharacterByName(nameRef);\n        } else {\n            reader.rewindToMark();\n            if (looksLegit) {\n                // named with semicolon\n                characterReferenceError(\"invalid named reference\");\n            }\n            return null;\n        }\n    }\n}", "diff": "--- org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n+++ org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n@@ -22,7 +22,7 @@\n         int charval = -1;\n         try {\n             int base = isHexMode ? 16 : 10;\n-            charval = Integer.valueOf(numRef, base);\n+            charval = Integer.parseInt(numRef, base);\n         } catch (NumberFormatException e) {\n         }\n         // skip\n@@ -38,33 +38,20 @@\n         // named\n         // get as many letters as possible, and look for matching entities.\n         String nameRef = reader.consumeLetterThenDigitSequence();\n-        String origNameRef = new String(nameRef);\n         boolean looksLegit = reader.matches(';');\n-        // found if a base named entity without a ;, or an extended entity with the ;.\n-        boolean found = false;\n-        while (nameRef.length() > 0 && !found) {\n-            if (Entities.isNamedEntity(nameRef))\n-                found = true;\n-            else {\n-                nameRef = nameRef.substring(0, nameRef.length() - 1);\n-                reader.unconsume();\n+        if (Entities.isNamedEntity(nameRef)) {\n+            if (!reader.matchConsume(\";\")) {\n+                // missing semi\n+                characterReferenceError(\"missing semicolon\");\n             }\n-        }\n-        if (!found) {\n+            return Entities.getCharacterByName(nameRef);\n+        } else {\n             reader.rewindToMark();\n-            if (// named with semicolon\n-            looksLegit)\n-                characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n+            if (looksLegit) {\n+                // named with semicolon\n+                characterReferenceError(\"invalid named reference\");\n+            }\n             return null;\n         }\n-        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n-            // don't want that to match\n-            reader.rewindToMark();\n-            return null;\n-        }\n-        if (!reader.matchConsume(\";\"))\n-            // missing semi\n-            characterReferenceError(\"missing semicolon\");\n-        return Entities.getCharacterByName(nameRef);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n        return null;\n    reader.mark();\n    if (reader.matchConsume(\"#\")) {\n        // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) {\n            // didn't match anything\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\")) {\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n            reader.rewindToMark();\n            return null;\n        }\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n        }\n        // skip\n        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError(\"character outside of valid range\");\n            return replacementChar;\n        } else {\n            // todo: implement number replacement table\n            // todo: check for extra illegal unicode points as parse errors\n            return (char) charval;\n        }\n    } else {\n        // named\n        // get as many letters as possible, and look for matching entities.\n        String nameRef = reader.consumeLetterThenDigitSequence();\n        String origNameRef = new String(nameRef);\n        boolean looksLegit = reader.matches(';');\n        // found if a base named entity without a ;, or an extended entity with the ;.\n        boolean found = false;\n        while (nameRef.length() > 0 && !found) {\n            if (Entities.isNamedEntity(nameRef))\n                found = true;\n            else {\n                nameRef = nameRef.substring(0, nameRef.length() - 1);\n                reader.unconsume();\n            }\n        }\n        if (!found) {\n            reader.rewindToMark();\n            if (// named with semicolon\n            looksLegit)\n                characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n            return null;\n        }\n        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n            // don't want that to match\n            reader.rewindToMark();\n            return null;\n        }\n        if (!reader.matchConsume(\";\")) {\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n            reader.rewindToMark();\n            return null;\n        }\n        return Entities.getCharacterByName(nameRef);\n    }\n}", "diff": "--- org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n+++ org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n@@ -16,9 +16,12 @@\n             reader.rewindToMark();\n             return null;\n         }\n-        if (!reader.matchConsume(\";\"))\n+        if (!reader.matchConsume(\";\")) {\n             // missing semi\n             characterReferenceError(\"missing semicolon\");\n+            reader.rewindToMark();\n+            return null;\n+        }\n         int charval = -1;\n         try {\n             int base = isHexMode ? 16 : 10;\n@@ -62,9 +65,12 @@\n             reader.rewindToMark();\n             return null;\n         }\n-        if (!reader.matchConsume(\";\"))\n+        if (!reader.matchConsume(\";\")) {\n             // missing semi\n             characterReferenceError(\"missing semicolon\");\n+            reader.rewindToMark();\n+            return null;\n+        }\n         return Entities.getCharacterByName(nameRef);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n    if (reader.isEmpty())\n        return null;\n    if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n        return null;\n    if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n        return null;\n    reader.mark();\n\n    if (reader.matchConsume(\"#\")) {\n        // numbered\n        boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n        String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n        if (numRef.length() == 0) {\n            // didn't match anything\n            characterReferenceError(\"numeric reference with no numerals\");\n            reader.rewindToMark();\n            return null;\n        }\n\n        // check for missing semicolon before trying to parse Charval\n        if (!reader.matchConsume(\";\"))\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n\n        int charval = -1;\n        try {\n            int base = isHexMode ? 16 : 10;\n            charval = Integer.valueOf(numRef, base);\n        } catch (NumberFormatException e) {\n            characterReferenceError(\"invalid numeric character reference: \" + numRef);\n            reader.rewindToMark();\n            return null;\n        }\n        if ((charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n            characterReferenceError(\"invalid numeric character reference\");\n            return replacementChar;\n        } else {\n            return (char) charval;\n        }\n    } else {\n        // named\n        // get as many letters as possible, and look for matching entities.\n        String nameRef = reader.consumeLetterThenDigitSequence();\n        String origNameRef = new String(nameRef);\n\n        // check for missing semicolon before checking named entity\n        if (!reader.matchConsume(\";\")) {\n            // missing semi\n            characterReferenceError(\"missing semicolon\");\n            reader.rewindToMark();\n            return null;\n        }\n\n        if (Entities.isNamedEntity(nameRef)) {\n            return Entities.getCharacterByName(nameRef);\n        } else {\n            reader.rewindToMark();\n            if (inAttribute) {\n                return null;\n            } else {\n                characterReferenceError(String.format(\"unknown entity %s\", origNameRef));\n                return null;\n            }\n        }\n    }\n}", "diff": "--- org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n+++ org/jsoup/parser/Tokeniser.java@consumeCharacterReference\n@@ -6,6 +6,7 @@\n     if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n         return null;\n     reader.mark();\n+\n     if (reader.matchConsume(\"#\")) {\n         // numbered\n         boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n@@ -16,22 +17,25 @@\n             reader.rewindToMark();\n             return null;\n         }\n+\n+        // check for missing semicolon before trying to parse Charval\n         if (!reader.matchConsume(\";\"))\n             // missing semi\n             characterReferenceError(\"missing semicolon\");\n+\n         int charval = -1;\n         try {\n             int base = isHexMode ? 16 : 10;\n             charval = Integer.valueOf(numRef, base);\n         } catch (NumberFormatException e) {\n+            characterReferenceError(\"invalid numeric character reference: \" + numRef);\n+            reader.rewindToMark();\n+            return null;\n         }\n-        // skip\n-        if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n-            characterReferenceError(\"character outside of valid range\");\n+        if ((charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n+            characterReferenceError(\"invalid numeric character reference\");\n             return replacementChar;\n         } else {\n-            // todo: implement number replacement table\n-            // todo: check for extra illegal unicode points as parse errors\n             return (char) charval;\n         }\n     } else {\n@@ -39,32 +43,25 @@\n         // get as many letters as possible, and look for matching entities.\n         String nameRef = reader.consumeLetterThenDigitSequence();\n         String origNameRef = new String(nameRef);\n-        boolean looksLegit = reader.matches(';');\n-        // found if a base named entity without a ;, or an extended entity with the ;.\n-        boolean found = false;\n-        while (nameRef.length() > 0 && !found) {\n-            if (Entities.isNamedEntity(nameRef))\n-                found = true;\n-            else {\n-                nameRef = nameRef.substring(0, nameRef.length() - 1);\n-                reader.unconsume();\n-            }\n-        }\n-        if (!found) {\n-            reader.rewindToMark();\n-            if (// named with semicolon\n-            looksLegit)\n-                characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n-            return null;\n-        }\n-        if (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n-            // don't want that to match\n+\n+        // check for missing semicolon before checking named entity\n+        if (!reader.matchConsume(\";\")) {\n+            // missing semi\n+            characterReferenceError(\"missing semicolon\");\n             reader.rewindToMark();\n             return null;\n         }\n-        if (!reader.matchConsume(\";\"))\n-            // missing semi\n-            characterReferenceError(\"missing semicolon\");\n-        return Entities.getCharacterByName(nameRef);\n+\n+        if (Entities.isNamedEntity(nameRef)) {\n+            return Entities.getCharacterByName(nameRef);\n+        } else {\n+            reader.rewindToMark();\n+            if (inAttribute) {\n+                return null;\n+            } else {\n+                characterReferenceError(String.format(\"unknown entity %s\", origNameRef));\n+                return null;\n+            }\n+        }\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]