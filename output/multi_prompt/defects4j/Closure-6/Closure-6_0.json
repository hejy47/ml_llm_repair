[{"output": "boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -1,6 +1,6 @@\n boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) {\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 10}, {"output": "boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            JSType ownerType = getJSType(owner);\n            if (ownerType != null && ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn != null && ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -1,22 +1,18 @@\n boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n-    // The NoType check is a hack to make typedefs work OK.\n     if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n-            // Do not type-check interface methods, because we expect that\n-            // they will have dummy implementations that do not match the type\n-            // annotations.\n             JSType ownerType = getJSType(owner);\n-            if (ownerType.isFunctionPrototypeType()) {\n+            if (ownerType != null && ownerType.isFunctionPrototypeType()) {\n                 FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n-                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n+                if (ownerFn != null && ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                     return true;\n                 }\n             }\n             mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n+            return false;\n         }\n-        return false;\n     }\n     return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isAssignableTo(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -1,6 +1,6 @@\n boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+    if (!leftType.isNoType() && !rightType.isAssignableTo(leftType)) {\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 4}, {"output": "boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            FunctionType ownerFn = null;\n            if (ownerType.isFunctionType()) {\n                ownerFn = ownerType.toMaybeFunctionType();\n            } else if (ownerType.isFunctionPrototypeType()) {\n                ownerFn = ownerType.toObjectType().getOwnerFunction();\n            }\n            if (ownerFn != null && ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                return true;\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -8,11 +8,14 @@\n             // they will have dummy implementations that do not match the type\n             // annotations.\n             JSType ownerType = getJSType(owner);\n-            if (ownerType.isFunctionPrototypeType()) {\n-                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n-                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n-                    return true;\n-                }\n+            FunctionType ownerFn = null;\n+            if (ownerType.isFunctionType()) {\n+                ownerFn = ownerType.toMaybeFunctionType();\n+            } else if (ownerType.isFunctionPrototypeType()) {\n+                ownerFn = ownerType.toObjectType().getOwnerFunction();\n+            }\n+            if (ownerFn != null && ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n+                return true;\n             }\n             mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { // Changed canAssignTo to isSubtypeOf\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -1,6 +1,6 @@\n boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { // Changed canAssignTo to isSubtypeOf\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isAssignableTo(leftType)) { // fixed method call from canAssignTo to isAssignableTo\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -1,6 +1,6 @@\n boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+    if (!leftType.isNoType() && !rightType.isAssignableTo(leftType)) { // fixed method call from canAssignTo to isAssignableTo\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { // changed canAssignTo to isSubtypeOf\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -1,6 +1,6 @@\n boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { // changed canAssignTo to isSubtypeOf\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if ((!leftType.isNoType() || propName.equals(\"length\")) && !rightType.canAssignTo(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.java@expectCanAssignToPropertyOf\n@@ -1,6 +1,6 @@\n boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n     // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+    if ((!leftType.isNoType() || propName.equals(\"length\")) && !rightType.canAssignTo(leftType)) {\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n", "finish_reason": "stop", "valid": false, "num": 1}]