[{"output": "private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass, Map<TypeVariable<?>, Type> subtypeVarAssigns) {\n    // make sure they're assignable\n    if (!isAssignable(cls, toClass)) {\n        return null;\n    }\n    // can't work with primitives\n    if (cls.isPrimitive()) {\n        // both classes are primitives?\n        if (toClass.isPrimitive()) {\n            // dealing with widening here. No type arguments to be\n            // harvested with these two types.\n            return new HashMap<TypeVariable<?>, Type>();\n        }\n        // work with wrapper the wrapper class instead of the primitive\n        cls = ClassUtils.primitiveToWrapper(cls);\n    }\n    // create a copy of the incoming map, or an empty one if it's null\n    HashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>() : new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n    // has target class been reached?\n    if (toClass.equals(cls)) {\n        return typeVarAssigns;\n    }\n    // walk the inheritance hierarchy until the target class is reached\n    return getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 20}]