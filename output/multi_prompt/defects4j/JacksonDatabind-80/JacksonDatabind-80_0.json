[{"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolve(curr, subtype, config, ai, collected);\n            }\n        }\n    }\n    // then annotated types for property itself\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolve(ac, nt, config, ai, collected);\n        }\n    }\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected);\n    return collected.values(); // corrected - no need to create ArrayList\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -27,5 +27,5 @@\n     AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n     // and finally subtypes via annotations from base type (recursively)\n     _collectAndResolve(ac, rootType, config, ai, collected);\n-    return new ArrayList<NamedType>(collected.values());\n+    return collected.values(); // corrected - no need to create ArrayList\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,32 +1,31 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    Class<?> rawBase = baseType.getRawClass();\n-    // Need to keep track of classes that have been handled already\n-    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n-    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n-    // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n-    // then with definitions from property\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n-        }\n-    }\n-    // and finally explicit type registrations (highest precedence)\n+    // for backwards compatibility, must allow null here:\n+    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                _collectAndResolve(curr, subtype, config, ai, collected);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    // then annotated types for property itself\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolve(ac, nt, config, ai, collected);\n+        }\n+    }\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    // and finally subtypes via annotations from base type (recursively)\n+    _collectAndResolve(ac, rootType, config, ai, collected);\n+    return collected.values(); // corrected - no need to create ArrayList\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolve(curr, subtype, config, ai, collected);\n            }\n        }\n    }\n    // then annotated types for property itself\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolve(ac, nt, config, ai, collected);\n        }\n    }\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected);\n    return new ArrayList<NamedType>(new HashSet<NamedType>(collected.values()));\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -27,5 +27,5 @@\n     AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n     // and finally subtypes via annotations from base type (recursively)\n     _collectAndResolve(ac, rootType, config, ai, collected);\n-    return new ArrayList<NamedType>(collected.values());\n+    return new ArrayList<NamedType>(new HashSet<NamedType>(collected.values()));\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,32 +1,31 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    Class<?> rawBase = baseType.getRawClass();\n-    // Need to keep track of classes that have been handled already\n-    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n-    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n-    // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n-    // then with definitions from property\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n-        }\n-    }\n-    // and finally explicit type registrations (highest precedence)\n+    // for backwards compatibility, must allow null here:\n+    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                _collectAndResolve(curr, subtype, config, ai, collected);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    // then annotated types for property itself\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolve(ac, nt, config, ai, collected);\n+        }\n+    }\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    // and finally subtypes via annotations from base type (recursively)\n+    _collectAndResolve(ac, rootType, config, ai, collected);\n+    return new ArrayList<NamedType>(new HashSet<NamedType>(collected.values()));\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolve(curr, subtype, config, ai, collected);\n            }\n        }\n    }\n    // then annotated types for property itself\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolve(ac, nt, config, ai, collected);\n        }\n    }\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected, new HashSet<Class<?>>());\n    return new ArrayList<NamedType>(collected.values());\n}\n\nprivate void _collectAndResolve(AnnotatedClass annotatedClass, NamedType namedType, MapperConfig<?> config,\n        AnnotationIntrospector annotationIntrospector, HashMap<NamedType, NamedType> collectedSubtypes,\n        HashSet<Class<?>> visited) {\n    if (!visited.add(annotatedClass.getRawType())) {\n        return;\n    }\n    List<NamedType> st = annotationIntrospector.findSubtypes(annotatedClass);\n    if (st != null && !st.isEmpty()) {\n        for (NamedType subtype : st) {\n            _collectAndResolve(AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType()), subtype,\n                    config, annotationIntrospector, collectedSubtypes, visited);\n        }\n    }\n    // first, add this type if we haven't seen it before:\n    if (collectedSubtypes.containsKey(namedType)) {\n        // Already seen it, but there may be more information, so:\n        // NOTE: should we try to merge annotations?\n        NamedType prev = collectedSubtypes.get(namedType);\n        if (prev.isAlphabetic()) { // has name, but only use if non-empty\n            if (!prev.hasName()) {\n                collectedSubtypes.put(namedType, namedType);\n            }\n        } else { // otherwise just use it as is\n            collectedSubtypes.put(namedType, namedType);\n        }\n    } else {\n        collectedSubtypes.put(namedType, namedType);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -26,6 +26,6 @@\n     NamedType rootType = new NamedType(rawBase, null);\n     AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n     // and finally subtypes via annotations from base type (recursively)\n-    _collectAndResolve(ac, rootType, config, ai, collected);\n+    _collectAndResolve(ac, rootType, config, ai, collected, new HashSet<Class<?>>());\n     return new ArrayList<NamedType>(collected.values());\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,32 +1,31 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    Class<?> rawBase = baseType.getRawClass();\n-    // Need to keep track of classes that have been handled already\n-    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n-    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n-    // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n-    // then with definitions from property\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n-        }\n-    }\n-    // and finally explicit type registrations (highest precedence)\n+    // for backwards compatibility, must allow null here:\n+    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                _collectAndResolve(curr, subtype, config, ai, collected);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    // then annotated types for property itself\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolve(ac, nt, config, ai, collected);\n+        }\n+    }\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    // and finally subtypes via annotations from base type (recursively)\n+    _collectAndResolve(ac, rootType, config, ai, collected, new HashSet<Class<?>>());\n+    return new ArrayList<NamedType>(collected.values());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n    Map<NamedType, NamedType> collected = new HashMap<>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolve(curr, subtype, config, ai, collected);\n            }\n        }\n    }\n    // then annotated types for property itself\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolve(ac, nt, config, ai, collected);\n        }\n    }\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected);\n    return new ArrayList<>(collected.values());\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -3,7 +3,7 @@\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n     // for backwards compatibility, must allow null here:\n     Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n-    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    Map<NamedType, NamedType> collected = new HashMap<>();\n     // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n@@ -27,5 +27,5 @@\n     AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n     // and finally subtypes via annotations from base type (recursively)\n     _collectAndResolve(ac, rootType, config, ai, collected);\n-    return new ArrayList<NamedType>(collected.values());\n+    return new ArrayList<>(collected.values());\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,32 +1,31 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    Class<?> rawBase = baseType.getRawClass();\n-    // Need to keep track of classes that have been handled already\n-    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n-    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n-    // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n-    // then with definitions from property\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n-        }\n-    }\n-    // and finally explicit type registrations (highest precedence)\n+    // for backwards compatibility, must allow null here:\n+    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+    Map<NamedType, NamedType> collected = new HashMap<>();\n+    // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                _collectAndResolve(curr, subtype, config, ai, collected);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    // then annotated types for property itself\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolve(ac, nt, config, ai, collected);\n+        }\n+    }\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    // and finally subtypes via annotations from base type (recursively)\n+    _collectAndResolve(ac, rootType, config, ai, collected);\n+    return new ArrayList<>(collected.values());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType().getRawClass() : baseType.getRawClass();\n    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolve(curr, subtype, config, ai, collected);\n            }\n        }\n    }\n    // then annotated types for property itself\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolve(ac, nt, config, ai, collected);\n        }\n    }\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected);\n    return new ArrayList<NamedType>(collected.values());\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -2,7 +2,7 @@\n public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n     // for backwards compatibility, must allow null here:\n-    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+    Class<?> rawBase = (baseType == null) ? property.getRawType().getRawClass() : baseType.getRawClass();\n     HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n     // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,32 +1,31 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    Class<?> rawBase = baseType.getRawClass();\n-    // Need to keep track of classes that have been handled already\n-    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n-    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n-    // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n-    // then with definitions from property\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n-        }\n-    }\n-    // and finally explicit type registrations (highest precedence)\n+    // for backwards compatibility, must allow null here:\n+    Class<?> rawBase = (baseType == null) ? property.getRawType().getRawClass() : baseType.getRawClass();\n+    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                _collectAndResolve(curr, subtype, config, ai, collected);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    // then annotated types for property itself\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolve(ac, nt, config, ai, collected);\n+        }\n+    }\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    // and finally subtypes via annotations from base type (recursively)\n+    _collectAndResolve(ac, rootType, config, ai, collected);\n+    return new ArrayList<NamedType>(collected.values());\n }\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                // Change the following line:\n                // AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                // to:\n                AnnotatedClass curr = AnnotatedClassResolver.resolve(config, subtype, config.getMapperConfig().getSubtypeResolver(), config.getAnnotationIntrospector());\n                _collectAndResolve(curr, subtype, config, ai, collected);\n            }\n        }\n    }\n    // then annotated types for property itself\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            AnnotatedClass ac = AnnotatedClassResolver.resolve(config, nt, config.getMapperConfig().getSubtypeResolver(), config.getAnnotationIntrospector());\n            _collectAndResolve(ac, nt, config, ai, collected);\n        }\n    }\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolve(config, rootType, config.getMapperConfig().getSubtypeResolver(), config.getAnnotationIntrospector());\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected);\n    return new ArrayList<NamedType>(collected.values());\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -10,7 +10,10 @@\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n-                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n+                // Change the following line:\n+                // AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n+                // to:\n+                AnnotatedClass curr = AnnotatedClassResolver.resolve(config, subtype, config.getMapperConfig().getSubtypeResolver(), config.getAnnotationIntrospector());\n                 _collectAndResolve(curr, subtype, config, ai, collected);\n             }\n         }\n@@ -19,12 +22,12 @@\n     Collection<NamedType> st = ai.findSubtypes(property);\n     if (st != null) {\n         for (NamedType nt : st) {\n-            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            AnnotatedClass ac = AnnotatedClassResolver.resolve(config, nt, config.getMapperConfig().getSubtypeResolver(), config.getAnnotationIntrospector());\n             _collectAndResolve(ac, nt, config, ai, collected);\n         }\n     }\n     NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolve(config, rootType, config.getMapperConfig().getSubtypeResolver(), config.getAnnotationIntrospector());\n     // and finally subtypes via annotations from base type (recursively)\n     _collectAndResolve(ac, rootType, config, ai, collected);\n     return new ArrayList<NamedType>(collected.values());\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,32 +1,34 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    Class<?> rawBase = baseType.getRawClass();\n-    // Need to keep track of classes that have been handled already\n-    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n-    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n-    // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n-    // then with definitions from property\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n-        }\n-    }\n-    // and finally explicit type registrations (highest precedence)\n+    // for backwards compatibility, must allow null here:\n+    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n-                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                // Change the following line:\n+                // AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n+                // to:\n+                AnnotatedClass curr = AnnotatedClassResolver.resolve(config, subtype, config.getMapperConfig().getSubtypeResolver(), config.getAnnotationIntrospector());\n+                _collectAndResolve(curr, subtype, config, ai, collected);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    // then annotated types for property itself\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            AnnotatedClass ac = AnnotatedClassResolver.resolve(config, nt, config.getMapperConfig().getSubtypeResolver(), config.getAnnotationIntrospector());\n+            _collectAndResolve(ac, nt, config, ai, collected);\n+        }\n+    }\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolve(config, rootType, config.getMapperConfig().getSubtypeResolver(), config.getAnnotationIntrospector());\n+    // and finally subtypes via annotations from base type (recursively)\n+    _collectAndResolve(ac, rootType, config, ai, collected);\n+    return new ArrayList<NamedType>(collected.values());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType().getRawClass() : baseType.getRawClass();\n    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolve(curr, subtype, config, ai, collected);\n            }\n        }\n    }\n    // then annotated types for property itself\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolve(ac, nt, config, ai, collected);\n        }\n    }\n    NamedType rootType = new NamedType(rawBase, TypeBindings.emptyBindings(), null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected, new HashSet<String>());\n    return new ArrayList<NamedType>(collected.values());\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -2,7 +2,7 @@\n public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n     // for backwards compatibility, must allow null here:\n-    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+    Class<?> rawBase = (baseType == null) ? property.getRawType().getRawClass() : baseType.getRawClass();\n     HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n     // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n@@ -23,9 +23,9 @@\n             _collectAndResolve(ac, nt, config, ai, collected);\n         }\n     }\n-    NamedType rootType = new NamedType(rawBase, null);\n+    NamedType rootType = new NamedType(rawBase, TypeBindings.emptyBindings(), null);\n     AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n     // and finally subtypes via annotations from base type (recursively)\n-    _collectAndResolve(ac, rootType, config, ai, collected);\n+    _collectAndResolve(ac, rootType, config, ai, collected, new HashSet<String>());\n     return new ArrayList<NamedType>(collected.values());\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,32 +1,31 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    Class<?> rawBase = baseType.getRawClass();\n-    // Need to keep track of classes that have been handled already\n-    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n-    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n-    // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n-    // then with definitions from property\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n-        }\n-    }\n-    // and finally explicit type registrations (highest precedence)\n+    // for backwards compatibility, must allow null here:\n+    Class<?> rawBase = (baseType == null) ? property.getRawType().getRawClass() : baseType.getRawClass();\n+    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                _collectAndResolve(curr, subtype, config, ai, collected);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    // then annotated types for property itself\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolve(ac, nt, config, ai, collected);\n+        }\n+    }\n+    NamedType rootType = new NamedType(rawBase, TypeBindings.emptyBindings(), null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    // and finally subtypes via annotations from base type (recursively)\n+    _collectAndResolve(ac, rootType, config, ai, collected, new HashSet<String>());\n+    return new ArrayList<NamedType>(collected.values());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType().getRawClass() : baseType.getRawClass();\n    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolve(curr, subtype, config, ai, collected);\n            }\n        }\n    }\n    // then annotated types for property itself\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolve(ac, nt, config, ai, collected);\n        }\n    }\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected);\n    return new ArrayList<>(collected.values());\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -2,7 +2,7 @@\n public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n     // for backwards compatibility, must allow null here:\n-    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+    Class<?> rawBase = (baseType == null) ? property.getRawType().getRawClass() : baseType.getRawClass();\n     HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n     // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n@@ -27,5 +27,5 @@\n     AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n     // and finally subtypes via annotations from base type (recursively)\n     _collectAndResolve(ac, rootType, config, ai, collected);\n-    return new ArrayList<NamedType>(collected.values());\n+    return new ArrayList<>(collected.values());\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,32 +1,31 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    Class<?> rawBase = baseType.getRawClass();\n-    // Need to keep track of classes that have been handled already\n-    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n-    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n-    // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n-    // then with definitions from property\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n-        }\n-    }\n-    // and finally explicit type registrations (highest precedence)\n+    // for backwards compatibility, must allow null here:\n+    Class<?> rawBase = (baseType == null) ? property.getRawType().getRawClass() : baseType.getRawClass();\n+    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                _collectAndResolve(curr, subtype, config, ai, collected);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    // then annotated types for property itself\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolve(ac, nt, config, ai, collected);\n+        }\n+    }\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    // and finally subtypes via annotations from base type (recursively)\n+    _collectAndResolve(ac, rootType, config, ai, collected);\n+    return new ArrayList<>(collected.values());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolve(curr, subtype, config, ai, collected);\n            }\n        }\n    }\n    // then annotated types for property itself\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolve(ac, nt, config, ai, collected);\n        }\n    }\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected);\n    return collected.values(); // Use the values of the map directly instead of creating a new ArrayList\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -27,5 +27,5 @@\n     AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n     // and finally subtypes via annotations from base type (recursively)\n     _collectAndResolve(ac, rootType, config, ai, collected);\n-    return new ArrayList<NamedType>(collected.values());\n+    return collected.values(); // Use the values of the map directly instead of creating a new ArrayList\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,32 +1,31 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    Class<?> rawBase = baseType.getRawClass();\n-    // Need to keep track of classes that have been handled already\n-    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n-    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n-    // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n-    // then with definitions from property\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n-        }\n-    }\n-    // and finally explicit type registrations (highest precedence)\n+    // for backwards compatibility, must allow null here:\n+    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                _collectAndResolve(curr, subtype, config, ai, collected);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    // then annotated types for property itself\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolve(ac, nt, config, ai, collected);\n+        }\n+    }\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    // and finally subtypes via annotations from base type (recursively)\n+    _collectAndResolve(ac, rootType, config, ai, collected);\n+    return collected.values(); // Use the values of the map directly instead of creating a new ArrayList\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolve(curr, subtype, config, ai, collected);\n            }\n        }\n    }\n    // then annotated types for property itself\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolve(ac, nt, config, ai, collected);\n        }\n    }\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected);\n    return collected.values();\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -27,5 +27,5 @@\n     AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n     // and finally subtypes via annotations from base type (recursively)\n     _collectAndResolve(ac, rootType, config, ai, collected);\n-    return new ArrayList<NamedType>(collected.values());\n+    return collected.values();\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,32 +1,31 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    Class<?> rawBase = baseType.getRawClass();\n-    // Need to keep track of classes that have been handled already\n-    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n-    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n-    // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n-    // then with definitions from property\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n-        }\n-    }\n-    // and finally explicit type registrations (highest precedence)\n+    // for backwards compatibility, must allow null here:\n+    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                _collectAndResolve(curr, subtype, config, ai, collected);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    // then annotated types for property itself\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolve(ac, nt, config, ai, collected);\n+        }\n+    }\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    // and finally subtypes via annotations from base type (recursively)\n+    _collectAndResolve(ac, rootType, config, ai, collected);\n+    return collected.values();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolve(curr, subtype, config, ai, collected);\n            }\n        }\n    }\n    // then annotated types for property itself\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            if (rawBase.isAssignableFrom(nt.getType())) {\n                _collectAndResolve(ac, nt, config, ai, collected);\n            }\n        }\n    }\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected);\n    return new ArrayList<NamedType>(collected.values());\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -20,7 +20,9 @@\n     if (st != null) {\n         for (NamedType nt : st) {\n             AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolve(ac, nt, config, ai, collected);\n+            if (rawBase.isAssignableFrom(nt.getType())) {\n+                _collectAndResolve(ac, nt, config, ai, collected);\n+            }\n         }\n     }\n     NamedType rootType = new NamedType(rawBase, null);\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,32 +1,33 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    Class<?> rawBase = baseType.getRawClass();\n-    // Need to keep track of classes that have been handled already\n-    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n-    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n-    // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n-    // then with definitions from property\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n-        }\n-    }\n-    // and finally explicit type registrations (highest precedence)\n+    // for backwards compatibility, must allow null here:\n+    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                _collectAndResolve(curr, subtype, config, ai, collected);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    // then annotated types for property itself\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            if (rawBase.isAssignableFrom(nt.getType())) {\n+                _collectAndResolve(ac, nt, config, ai, collected);\n+            }\n+        }\n+    }\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    // and finally subtypes via annotations from base type (recursively)\n+    _collectAndResolve(ac, rootType, config, ai, collected);\n+    return new ArrayList<NamedType>(collected.values());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolve(curr, subtype, config, ai, collected);\n            }\n        }\n    }\n    // then annotated types for property itself\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolve(ac, nt, config, ai, collected);\n        }\n    }\n    NamedType rootType = new NamedType(rawBase);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rootType.getType());\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected);\n    return new ArrayList<NamedType>(collected.values());\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -23,8 +23,8 @@\n             _collectAndResolve(ac, nt, config, ai, collected);\n         }\n     }\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    NamedType rootType = new NamedType(rawBase);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rootType.getType());\n     // and finally subtypes via annotations from base type (recursively)\n     _collectAndResolve(ac, rootType, config, ai, collected);\n     return new ArrayList<NamedType>(collected.values());\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,32 +1,31 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    Class<?> rawBase = baseType.getRawClass();\n-    // Need to keep track of classes that have been handled already\n-    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n-    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n-    // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n-    // then with definitions from property\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n-        }\n-    }\n-    // and finally explicit type registrations (highest precedence)\n+    // for backwards compatibility, must allow null here:\n+    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                _collectAndResolve(curr, subtype, config, ai, collected);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    // then annotated types for property itself\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolve(ac, nt, config, ai, collected);\n+        }\n+    }\n+    NamedType rootType = new NamedType(rawBase);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rootType.getType());\n+    // and finally subtypes via annotations from base type (recursively)\n+    _collectAndResolve(ac, rootType, config, ai, collected);\n+    return new ArrayList<NamedType>(collected.values());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n    Map<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolve(curr, subtype, config, ai, collected);\n            }\n        }\n    }\n    // then annotated types for property itself\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolve(ac, nt, config, ai, collected);\n        }\n    }\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected);\n    return new ArrayList<NamedType>(collected.values());\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -3,7 +3,7 @@\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n     // for backwards compatibility, must allow null here:\n     Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n-    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    Map<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n     // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,32 +1,31 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    Class<?> rawBase = baseType.getRawClass();\n-    // Need to keep track of classes that have been handled already\n-    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n-    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n-    // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n-    // then with definitions from property\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n-        }\n-    }\n-    // and finally explicit type registrations (highest precedence)\n+    // for backwards compatibility, must allow null here:\n+    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+    Map<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                _collectAndResolve(curr, subtype, config, ai, collected);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    // then annotated types for property itself\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolve(ac, nt, config, ai, collected);\n+        }\n+    }\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    // and finally subtypes via annotations from base type (recursively)\n+    _collectAndResolve(ac, rootType, config, ai, collected);\n+    return new ArrayList<NamedType>(collected.values());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolve(curr, subtype, config, ai, collected);\n            }\n        }\n    }\n    // then annotated types for property itself\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolve(ac, nt, config, ai, collected);\n        }\n    }\n    NamedType rootType = new NamedType(rawBase, null, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected);\n    return new ArrayList<NamedType>(collected.values());\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -23,7 +23,7 @@\n             _collectAndResolve(ac, nt, config, ai, collected);\n         }\n     }\n-    NamedType rootType = new NamedType(rawBase, null);\n+    NamedType rootType = new NamedType(rawBase, null, null);\n     AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n     // and finally subtypes via annotations from base type (recursively)\n     _collectAndResolve(ac, rootType, config, ai, collected);\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,32 +1,31 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    Class<?> rawBase = baseType.getRawClass();\n-    // Need to keep track of classes that have been handled already\n-    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n-    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n-    // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n-    // then with definitions from property\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n-        }\n-    }\n-    // and finally explicit type registrations (highest precedence)\n+    // for backwards compatibility, must allow null here:\n+    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                _collectAndResolve(curr, subtype, config, ai, collected);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    // then annotated types for property itself\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolve(ac, nt, config, ai, collected);\n+        }\n+    }\n+    NamedType rootType = new NamedType(rawBase, null, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    // and finally subtypes via annotations from base type (recursively)\n+    _collectAndResolve(ac, rootType, config, ai, collected);\n+    return new ArrayList<NamedType>(collected.values());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                collected.putIfAbsent(subtype, subtype);\n            }\n        }\n    }\n    // then annotated types for property itself\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            collected.putIfAbsent(nt, nt);\n        }\n    }\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected);\n    return new ArrayList<NamedType>(collected.values());\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -11,7 +11,7 @@\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolve(curr, subtype, config, ai, collected);\n+                collected.putIfAbsent(subtype, subtype);\n             }\n         }\n     }\n@@ -20,7 +20,7 @@\n     if (st != null) {\n         for (NamedType nt : st) {\n             AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolve(ac, nt, config, ai, collected);\n+            collected.putIfAbsent(nt, nt);\n         }\n     }\n     NamedType rootType = new NamedType(rawBase, null);\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,32 +1,31 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    Class<?> rawBase = baseType.getRawClass();\n-    // Need to keep track of classes that have been handled already\n-    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n-    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n-    // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n-    // then with definitions from property\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n-        }\n-    }\n-    // and finally explicit type registrations (highest precedence)\n+    // for backwards compatibility, must allow null here:\n+    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                collected.putIfAbsent(subtype, subtype);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    // then annotated types for property itself\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            collected.putIfAbsent(nt, nt);\n+        }\n+    }\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    // and finally subtypes via annotations from base type (recursively)\n+    _collectAndResolve(ac, rootType, config, ai, collected);\n+    return new ArrayList<NamedType>(collected.values());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolve(curr, subtype, config, ai, collected);\n            }\n        }\n    }\n    // then annotated types for property itself\n    Collection<NamedType> st = ai.findSubtypes(property.getType());\n    if (st != null) {\n        for (NamedType nt : st) {\n            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolve(ac, nt, config, ai, collected);\n        }\n    }\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected);\n    return new ArrayList<NamedType>(collected.values());\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -16,7 +16,7 @@\n         }\n     }\n     // then annotated types for property itself\n-    Collection<NamedType> st = ai.findSubtypes(property);\n+    Collection<NamedType> st = ai.findSubtypes(property.getType());\n     if (st != null) {\n         for (NamedType nt : st) {\n             AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,32 +1,31 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    Class<?> rawBase = baseType.getRawClass();\n-    // Need to keep track of classes that have been handled already\n-    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n-    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n-    // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n-    // then with definitions from property\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n-        }\n-    }\n-    // and finally explicit type registrations (highest precedence)\n+    // for backwards compatibility, must allow null here:\n+    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                _collectAndResolve(curr, subtype, config, ai, collected);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    // then annotated types for property itself\n+    Collection<NamedType> st = ai.findSubtypes(property.getType());\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolve(ac, nt, config, ai, collected);\n+        }\n+    }\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    // and finally subtypes via annotations from base type (recursively)\n+    _collectAndResolve(ac, rootType, config, ai, collected);\n+    return new ArrayList<NamedType>(collected.values());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolve(curr, subtype, config, ai, collected);\n            }\n        }\n    }\n    // then annotated types for property itself\n    if (property != null) {\n        Collection<NamedType> st = ai.findSubtypes(property);\n        if (st != null) {\n            for (NamedType nt : st) {\n                AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n                _collectAndResolve(ac, nt, config, ai, collected);\n            }\n        }\n    }\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected);\n    return new ArrayList<NamedType>(collected.values());\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -16,11 +16,13 @@\n         }\n     }\n     // then annotated types for property itself\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolve(ac, nt, config, ai, collected);\n+    if (property != null) {\n+        Collection<NamedType> st = ai.findSubtypes(property);\n+        if (st != null) {\n+            for (NamedType nt : st) {\n+                AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+                _collectAndResolve(ac, nt, config, ai, collected);\n+            }\n         }\n     }\n     NamedType rootType = new NamedType(rawBase, null);\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,32 +1,33 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    Class<?> rawBase = baseType.getRawClass();\n-    // Need to keep track of classes that have been handled already\n-    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n-    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n-    // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n-    // then with definitions from property\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n-        }\n-    }\n-    // and finally explicit type registrations (highest precedence)\n+    // for backwards compatibility, must allow null here:\n+    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                _collectAndResolve(curr, subtype, config, ai, collected);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    // then annotated types for property itself\n+    if (property != null) {\n+        Collection<NamedType> st = ai.findSubtypes(property);\n+        if (st != null) {\n+            for (NamedType nt : st) {\n+                AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+                _collectAndResolve(ac, nt, config, ai, collected);\n+            }\n+        }\n+    }\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    // and finally subtypes via annotations from base type (recursively)\n+    _collectAndResolve(ac, rootType, config, ai, collected);\n+    return new ArrayList<NamedType>(collected.values());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    // for backwards compatibility, must allow null here:\n    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n    // start with registered subtypes (which have precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolve(curr, subtype, config, ai, collected);\n            }\n        }\n    }\n    // then annotated types for property itself\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            if (rawBase.isAssignableFrom(nt.getType())) {\n                // avoid resolving the same type multiple times\n                continue;\n            }\n            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolve(ac, nt, config, ai, collected);\n        }\n    }\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    // and finally subtypes via annotations from base type (recursively)\n    _collectAndResolve(ac, rootType, config, ai, collected);\n    return new ArrayList<NamedType>(collected.values());\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -19,6 +19,10 @@\n     Collection<NamedType> st = ai.findSubtypes(property);\n     if (st != null) {\n         for (NamedType nt : st) {\n+            if (rawBase.isAssignableFrom(nt.getType())) {\n+                // avoid resolving the same type multiple times\n+                continue;\n+            }\n             AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n             _collectAndResolve(ac, nt, config, ai, collected);\n         }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,32 +1,35 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    Class<?> rawBase = baseType.getRawClass();\n-    // Need to keep track of classes that have been handled already\n-    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n-    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n-    // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n-    // then with definitions from property\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n-        }\n-    }\n-    // and finally explicit type registrations (highest precedence)\n+    // for backwards compatibility, must allow null here:\n+    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n+    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+    // start with registered subtypes (which have precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                _collectAndResolve(curr, subtype, config, ai, collected);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    // then annotated types for property itself\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            if (rawBase.isAssignableFrom(nt.getType())) {\n+                // avoid resolving the same type multiple times\n+                continue;\n+            }\n+            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolve(ac, nt, config, ai, collected);\n+        }\n+    }\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    // and finally subtypes via annotations from base type (recursively)\n+    _collectAndResolve(ac, rootType, config, ai, collected);\n+    return new ArrayList<NamedType>(collected.values());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]