[{"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    Class<?> rawBase = baseType.getRawClass();\n    // Need to keep track of classes that have been handled already\n    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n    // start with lowest-precedence, which is from type hierarchy\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolve(config, rawBase, config);\n    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n    // then with definitions from property\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            ac = AnnotatedClassResolver.resolve(config, nt.getType(), config);\n            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n        }\n    }\n    // and finally explicit type registrations (highest precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                ac = AnnotatedClassResolver.resolve(config, subtype.getType(), config);\n                _collectAndResolveByTypeId(ac, subtype, config, typesHandled, byName);\n            }\n        }\n    }\n    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -1,31 +1,32 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    // for backwards compatibility, must allow null here:\n-    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n-    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n-    // start with registered subtypes (which have precedence)\n+    Class<?> rawBase = baseType.getRawClass();\n+    // Need to keep track of classes that have been handled already\n+    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n+    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n+    // start with lowest-precedence, which is from type hierarchy\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolve(config, rawBase, config);\n+    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n+    // then with definitions from property\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            ac = AnnotatedClassResolver.resolve(config, nt.getType(), config);\n+            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n+        }\n+    }\n+    // and finally explicit type registrations (highest precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n-                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolve(curr, subtype, config, ai, collected);\n+                ac = AnnotatedClassResolver.resolve(config, subtype.getType(), config);\n+                _collectAndResolveByTypeId(ac, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n-    // then annotated types for property itself\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolve(ac, nt, config, ai, collected);\n-        }\n-    }\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    // and finally subtypes via annotations from base type (recursively)\n-    _collectAndResolve(ac, rootType, config, ai, collected);\n-    return new ArrayList<NamedType>(collected.values());\n+    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -7,13 +7,13 @@\n     Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n     // start with lowest-precedence, which is from type hierarchy\n     NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolve(config, rawBase, config);\n     _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n     // then with definitions from property\n     Collection<NamedType> st = ai.findSubtypes(property);\n     if (st != null) {\n         for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            ac = AnnotatedClassResolver.resolve(config, nt.getType(), config);\n             _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n         }\n     }\n@@ -23,8 +23,8 @@\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n-                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                ac = AnnotatedClassResolver.resolve(config, subtype.getType(), config);\n+                _collectAndResolveByTypeId(ac, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    Class<?> rawBase = baseType.getRawClass();\n    // Need to keep track of classes that have been handled already\n    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n    // start with lowest-precedence, which is from type hierarchy\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n    // then with definitions from property\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n        }\n    }\n    // and finally explicit type registrations (highest precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolveByTypeId(ac, subtype, config, typesHandled, byName);\n            }\n        }\n    }\n    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -1,31 +1,32 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    // for backwards compatibility, must allow null here:\n-    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n-    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n-    // start with registered subtypes (which have precedence)\n+    Class<?> rawBase = baseType.getRawClass();\n+    // Need to keep track of classes that have been handled already\n+    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n+    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n+    // start with lowest-precedence, which is from type hierarchy\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n+    // then with definitions from property\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n+        }\n+    }\n+    // and finally explicit type registrations (highest precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n-                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolve(curr, subtype, config, ai, collected);\n+                ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n+                _collectAndResolveByTypeId(ac, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n-    // then annotated types for property itself\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolve(ac, nt, config, ai, collected);\n-        }\n-    }\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    // and finally subtypes via annotations from base type (recursively)\n-    _collectAndResolve(ac, rootType, config, ai, collected);\n-    return new ArrayList<NamedType>(collected.values());\n+    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -23,8 +23,8 @@\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n-                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n+                _collectAndResolveByTypeId(ac, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 8}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    Class<?> rawBase = baseType.getRawClass();\n    // Need to keep track of classes that have been handled already\n    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n    // start with lowest-precedence, which is from type hierarchy\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, baseType);\n    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n    // then with definitions from property\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n        }\n    }\n    // and finally explicit type registrations (highest precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolveByTypeId(ac, subtype, config, typesHandled, byName);\n            }\n        }\n    }\n    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -1,31 +1,32 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    // for backwards compatibility, must allow null here:\n-    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n-    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n-    // start with registered subtypes (which have precedence)\n+    Class<?> rawBase = baseType.getRawClass();\n+    // Need to keep track of classes that have been handled already\n+    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n+    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n+    // start with lowest-precedence, which is from type hierarchy\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, baseType);\n+    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n+    // then with definitions from property\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n+        }\n+    }\n+    // and finally explicit type registrations (highest precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n-                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolve(curr, subtype, config, ai, collected);\n+                ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n+                _collectAndResolveByTypeId(ac, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n-    // then annotated types for property itself\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolve(ac, nt, config, ai, collected);\n-        }\n-    }\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    // and finally subtypes via annotations from base type (recursively)\n-    _collectAndResolve(ac, rootType, config, ai, collected);\n-    return new ArrayList<NamedType>(collected.values());\n+    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -7,7 +7,7 @@\n     Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n     // start with lowest-precedence, which is from type hierarchy\n     NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, baseType);\n     _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n     // then with definitions from property\n     Collection<NamedType> st = ai.findSubtypes(property);\n@@ -23,8 +23,8 @@\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n-                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n+                ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n+                _collectAndResolveByTypeId(ac, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    Class<?> rawBase = baseType.getRawClass();\n    // Need to keep track of classes that have been handled already\n    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n    // start with lowest-precedence, which is from type hierarchy\n    NamedType rootType = new NamedType(rawBase, null);\n    // UPDATED LINE: use resolveFully instead of resolveWithoutSuperTypes to include all super types\n    AnnotatedClass ac = config.introspectClassAnnotations(rawBase).resolveFully(config);\n    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n    // then with definitions from property\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            // UPDATED LINE: use resolveFully instead of resolveWithoutSuperTypes to include all super types\n            ac = config.introspectClassAnnotations(nt.getType()).resolveFully(config);\n            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n        }\n    }\n    // and finally explicit type registrations (highest precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                // UPDATED LINE: use resolveFully instead of resolveWithoutSuperTypes to include all super types\n                AnnotatedClass curr = config.introspectClassAnnotations(subtype.getType()).resolveFully(config);\n                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n            }\n        }\n    }\n    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -1,31 +1,35 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    // for backwards compatibility, must allow null here:\n-    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n-    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n-    // start with registered subtypes (which have precedence)\n+    Class<?> rawBase = baseType.getRawClass();\n+    // Need to keep track of classes that have been handled already\n+    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n+    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n+    // start with lowest-precedence, which is from type hierarchy\n+    NamedType rootType = new NamedType(rawBase, null);\n+    // UPDATED LINE: use resolveFully instead of resolveWithoutSuperTypes to include all super types\n+    AnnotatedClass ac = config.introspectClassAnnotations(rawBase).resolveFully(config);\n+    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n+    // then with definitions from property\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            // UPDATED LINE: use resolveFully instead of resolveWithoutSuperTypes to include all super types\n+            ac = config.introspectClassAnnotations(nt.getType()).resolveFully(config);\n+            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n+        }\n+    }\n+    // and finally explicit type registrations (highest precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n-                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolve(curr, subtype, config, ai, collected);\n+                // UPDATED LINE: use resolveFully instead of resolveWithoutSuperTypes to include all super types\n+                AnnotatedClass curr = config.introspectClassAnnotations(subtype.getType()).resolveFully(config);\n+                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n-    // then annotated types for property itself\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolve(ac, nt, config, ai, collected);\n-        }\n-    }\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    // and finally subtypes via annotations from base type (recursively)\n-    _collectAndResolve(ac, rootType, config, ai, collected);\n-    return new ArrayList<NamedType>(collected.values());\n+    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -7,13 +7,15 @@\n     Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n     // start with lowest-precedence, which is from type hierarchy\n     NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    // UPDATED LINE: use resolveFully instead of resolveWithoutSuperTypes to include all super types\n+    AnnotatedClass ac = config.introspectClassAnnotations(rawBase).resolveFully(config);\n     _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n     // then with definitions from property\n     Collection<NamedType> st = ai.findSubtypes(property);\n     if (st != null) {\n         for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            // UPDATED LINE: use resolveFully instead of resolveWithoutSuperTypes to include all super types\n+            ac = config.introspectClassAnnotations(nt.getType()).resolveFully(config);\n             _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n         }\n     }\n@@ -23,7 +25,8 @@\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n-                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n+                // UPDATED LINE: use resolveFully instead of resolveWithoutSuperTypes to include all super types\n+                AnnotatedClass curr = config.introspectClassAnnotations(subtype.getType()).resolveFully(config);\n                 _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    Class<?> rawBase = baseType.getRawClass();\n    // Need to keep track of classes that have been handled already\n    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n    // start with lowest-precedence, which is from type hierarchy\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n    // then with definitions from property\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType().getRawClass());\n            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n        }\n    }\n    // and finally explicit type registrations (highest precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType().getRawClass());\n                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n            }\n        }\n    }\n    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -1,31 +1,32 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    // for backwards compatibility, must allow null here:\n-    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n-    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n-    // start with registered subtypes (which have precedence)\n+    Class<?> rawBase = baseType.getRawClass();\n+    // Need to keep track of classes that have been handled already\n+    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n+    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n+    // start with lowest-precedence, which is from type hierarchy\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n+    // then with definitions from property\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType().getRawClass());\n+            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n+        }\n+    }\n+    // and finally explicit type registrations (highest precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n-                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolve(curr, subtype, config, ai, collected);\n+                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType().getRawClass());\n+                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n-    // then annotated types for property itself\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolve(ac, nt, config, ai, collected);\n-        }\n-    }\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    // and finally subtypes via annotations from base type (recursively)\n-    _collectAndResolve(ac, rootType, config, ai, collected);\n-    return new ArrayList<NamedType>(collected.values());\n+    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -13,7 +13,7 @@\n     Collection<NamedType> st = ai.findSubtypes(property);\n     if (st != null) {\n         for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType().getRawClass());\n             _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n         }\n     }\n@@ -23,7 +23,7 @@\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n-                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n+                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType().getRawClass());\n                 _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    Class<?> rawBase = baseType.getRawClass();\n    // Need to keep track of classes that have been handled already\n    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n    // start with lowest-precedence, which is from type hierarchy\n    NamedType rootType = new NamedType(baseType, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n    // then with definitions from property\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n        }\n    }\n    // and finally explicit type registrations (highest precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n            }\n        }\n    }\n    return _combineNamedAndUnnamed(baseType, typesHandled, byName);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -1,31 +1,32 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    // for backwards compatibility, must allow null here:\n-    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n-    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n-    // start with registered subtypes (which have precedence)\n+    Class<?> rawBase = baseType.getRawClass();\n+    // Need to keep track of classes that have been handled already\n+    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n+    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n+    // start with lowest-precedence, which is from type hierarchy\n+    NamedType rootType = new NamedType(baseType, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n+    // then with definitions from property\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n+        }\n+    }\n+    // and finally explicit type registrations (highest precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolve(curr, subtype, config, ai, collected);\n+                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n-    // then annotated types for property itself\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolve(ac, nt, config, ai, collected);\n-        }\n-    }\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    // and finally subtypes via annotations from base type (recursively)\n-    _collectAndResolve(ac, rootType, config, ai, collected);\n-    return new ArrayList<NamedType>(collected.values());\n+    return _combineNamedAndUnnamed(baseType, typesHandled, byName);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -6,7 +6,7 @@\n     Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n     Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n     // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n+    NamedType rootType = new NamedType(baseType, null);\n     AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n     _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n     // then with definitions from property\n@@ -28,5 +28,5 @@\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    return _combineNamedAndUnnamed(baseType, typesHandled, byName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    Class<?> rawBase = baseType.getRawClass();\n    // Need to keep track of classes that have been handled already\n    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n    // start with lowest-precedence, which is from type hierarchy\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n    // then with definitions from property\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            if (nt.hasName()) {\n                byName.putIfAbsent(nt.getName(), nt);\n            } else {\n                _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n            }\n        }\n    }\n    // and finally explicit type registrations (highest precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n            }\n        }\n    }\n    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -1,31 +1,36 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    // for backwards compatibility, must allow null here:\n-    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n-    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n-    // start with registered subtypes (which have precedence)\n+    Class<?> rawBase = baseType.getRawClass();\n+    // Need to keep track of classes that have been handled already\n+    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n+    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n+    // start with lowest-precedence, which is from type hierarchy\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n+    // then with definitions from property\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            if (nt.hasName()) {\n+                byName.putIfAbsent(nt.getName(), nt);\n+            } else {\n+                _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n+            }\n+        }\n+    }\n+    // and finally explicit type registrations (highest precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolve(curr, subtype, config, ai, collected);\n+                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n-    // then annotated types for property itself\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolve(ac, nt, config, ai, collected);\n-        }\n-    }\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    // and finally subtypes via annotations from base type (recursively)\n-    _collectAndResolve(ac, rootType, config, ai, collected);\n-    return new ArrayList<NamedType>(collected.values());\n+    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -14,7 +14,11 @@\n     if (st != null) {\n         for (NamedType nt : st) {\n             ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n+            if (nt.hasName()) {\n+                byName.putIfAbsent(nt.getName(), nt);\n+            } else {\n+                _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n+            }\n         }\n     }\n     // and finally explicit type registrations (highest precedence)\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    Class<?> rawBase = baseType.getRawClass();\n\n    // Need to keep track of classes that have been handled already\n    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n\n    // Use LinkedHashMap to ensure consistent ordering of the registered subtypes\n    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n\n    // start with lowest-precedence, which is from type hierarchy\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n\n    // then with definitions from property\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n        }\n    }\n\n    // and finally explicit type registrations (highest precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType()) && !typesHandled.contains(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n            }\n        }\n    }\n\n    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -1,31 +1,40 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    // for backwards compatibility, must allow null here:\n-    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n-    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n-    // start with registered subtypes (which have precedence)\n+    Class<?> rawBase = baseType.getRawClass();\n+\n+    // Need to keep track of classes that have been handled already\n+    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n+\n+    // Use LinkedHashMap to ensure consistent ordering of the registered subtypes\n+    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n+\n+    // start with lowest-precedence, which is from type hierarchy\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n+\n+    // then with definitions from property\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n+        }\n+    }\n+\n+    // and finally explicit type registrations (highest precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n-            if (rawBase.isAssignableFrom(subtype.getType())) {\n+            if (rawBase.isAssignableFrom(subtype.getType()) && !typesHandled.contains(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolve(curr, subtype, config, ai, collected);\n+                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n-    // then annotated types for property itself\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolve(ac, nt, config, ai, collected);\n-        }\n-    }\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    // and finally subtypes via annotations from base type (recursively)\n-    _collectAndResolve(ac, rootType, config, ai, collected);\n-    return new ArrayList<NamedType>(collected.values());\n+\n+    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -1,14 +1,20 @@\n @Override\n public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n     Class<?> rawBase = baseType.getRawClass();\n+\n     // Need to keep track of classes that have been handled already\n     Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n+\n+    // Use LinkedHashMap to ensure consistent ordering of the registered subtypes\n     Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n+\n     // start with lowest-precedence, which is from type hierarchy\n     NamedType rootType = new NamedType(rawBase, null);\n     AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n     _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n+\n     // then with definitions from property\n     Collection<NamedType> st = ai.findSubtypes(property);\n     if (st != null) {\n@@ -17,16 +23,18 @@\n             _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n         }\n     }\n+\n     // and finally explicit type registrations (highest precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n-            if (rawBase.isAssignableFrom(subtype.getType())) {\n+            if (rawBase.isAssignableFrom(subtype.getType()) && !typesHandled.contains(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                 _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n+\n     return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "It is not clear what the bug is without additional information or context. Please provide more details.", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    Class<?> rawBase = baseType.getRawClass();\n    // Need to keep track of classes that have been handled already\n    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n    // start with lowest-precedence, which is from type hierarchy\n    NamedType rootType = new NamedType(baseType, null); // Changed from rawBase to baseType\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n    // then with definitions from property\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n        }\n    }\n    // and finally explicit type registrations (highest precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (baseType.isTypeOrSubTypeOf(subtype.getType())) { // Changed from rawBase to baseType\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n            }\n        }\n    }\n    return _combineNamedAndUnnamed(baseType, typesHandled, byName); // Changed from rawBase to baseType\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -1,31 +1,32 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    // for backwards compatibility, must allow null here:\n-    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n-    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n-    // start with registered subtypes (which have precedence)\n+    Class<?> rawBase = baseType.getRawClass();\n+    // Need to keep track of classes that have been handled already\n+    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n+    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n+    // start with lowest-precedence, which is from type hierarchy\n+    NamedType rootType = new NamedType(baseType, null); // Changed from rawBase to baseType\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n+    // then with definitions from property\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n+        }\n+    }\n+    // and finally explicit type registrations (highest precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n-            if (rawBase.isAssignableFrom(subtype.getType())) {\n+            if (baseType.isTypeOrSubTypeOf(subtype.getType())) { // Changed from rawBase to baseType\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolve(curr, subtype, config, ai, collected);\n+                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n-    // then annotated types for property itself\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolve(ac, nt, config, ai, collected);\n-        }\n-    }\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    // and finally subtypes via annotations from base type (recursively)\n-    _collectAndResolve(ac, rootType, config, ai, collected);\n-    return new ArrayList<NamedType>(collected.values());\n+    return _combineNamedAndUnnamed(baseType, typesHandled, byName); // Changed from rawBase to baseType\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -6,7 +6,7 @@\n     Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n     Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n     // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n+    NamedType rootType = new NamedType(baseType, null); // Changed from rawBase to baseType\n     AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n     _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n     // then with definitions from property\n@@ -21,12 +21,12 @@\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n-            if (rawBase.isAssignableFrom(subtype.getType())) {\n+            if (baseType.isTypeOrSubTypeOf(subtype.getType())) { // Changed from rawBase to baseType\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                 _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    return _combineNamedAndUnnamed(baseType, typesHandled, byName); // Changed from rawBase to baseType\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    Class<?> rawBase = baseType.getRawClass();\n    // Need to keep track of classes that have been handled already\n    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n    // start with lowest-precedence, which is from type hierarchy\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n    // then with definitions from property\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            // fix bug here: use nt.getRawType instead of nt.getType to get the raw class\n            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getRawType());\n            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n        }\n    }\n    // and finally explicit type registrations (highest precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (rawBase.isAssignableFrom(subtype.getType())) {\n                // yes\n                // fix bug here: use subtype.getRawType instead of subtype.getType to get the raw class\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getRawType());\n                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n            }\n        }\n    }\n    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -1,31 +1,34 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    // for backwards compatibility, must allow null here:\n-    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n-    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n-    // start with registered subtypes (which have precedence)\n+    Class<?> rawBase = baseType.getRawClass();\n+    // Need to keep track of classes that have been handled already\n+    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n+    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n+    // start with lowest-precedence, which is from type hierarchy\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n+    // then with definitions from property\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            // fix bug here: use nt.getRawType instead of nt.getType to get the raw class\n+            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getRawType());\n+            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n+        }\n+    }\n+    // and finally explicit type registrations (highest precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n-                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolve(curr, subtype, config, ai, collected);\n+                // fix bug here: use subtype.getRawType instead of subtype.getType to get the raw class\n+                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getRawType());\n+                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n-    // then annotated types for property itself\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolve(ac, nt, config, ai, collected);\n-        }\n-    }\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    // and finally subtypes via annotations from base type (recursively)\n-    _collectAndResolve(ac, rootType, config, ai, collected);\n-    return new ArrayList<NamedType>(collected.values());\n+    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -13,7 +13,8 @@\n     Collection<NamedType> st = ai.findSubtypes(property);\n     if (st != null) {\n         for (NamedType nt : st) {\n-            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            // fix bug here: use nt.getRawType instead of nt.getType to get the raw class\n+            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getRawType());\n             _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n         }\n     }\n@@ -23,7 +24,8 @@\n             // is it a subtype of root type?\n             if (rawBase.isAssignableFrom(subtype.getType())) {\n                 // yes\n-                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n+                // fix bug here: use subtype.getRawType instead of subtype.getType to get the raw class\n+                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getRawType());\n                 _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    Class<?> rawBase = baseType.getRawClass();\n    // Need to keep track of classes that have been handled already\n    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n    // start with lowest-precedence, which is from type hierarchy\n    NamedType rootType = new NamedType(baseType, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n    // then with definitions from property\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n        }\n    }\n    // and finally explicit type registrations (highest precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (baseType.isTypeOrSubTypeOf(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n            }\n        }\n    }\n    return _combineNamedAndUnnamed(baseType, typesHandled, byName);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -1,31 +1,32 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    // for backwards compatibility, must allow null here:\n-    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n-    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n-    // start with registered subtypes (which have precedence)\n+    Class<?> rawBase = baseType.getRawClass();\n+    // Need to keep track of classes that have been handled already\n+    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n+    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n+    // start with lowest-precedence, which is from type hierarchy\n+    NamedType rootType = new NamedType(baseType, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n+    // then with definitions from property\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n+        }\n+    }\n+    // and finally explicit type registrations (highest precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n-            if (rawBase.isAssignableFrom(subtype.getType())) {\n+            if (baseType.isTypeOrSubTypeOf(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolve(curr, subtype, config, ai, collected);\n+                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n-    // then annotated types for property itself\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolve(ac, nt, config, ai, collected);\n-        }\n-    }\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    // and finally subtypes via annotations from base type (recursively)\n-    _collectAndResolve(ac, rootType, config, ai, collected);\n-    return new ArrayList<NamedType>(collected.values());\n+    return _combineNamedAndUnnamed(baseType, typesHandled, byName);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -6,7 +6,7 @@\n     Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n     Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n     // start with lowest-precedence, which is from type hierarchy\n-    NamedType rootType = new NamedType(rawBase, null);\n+    NamedType rootType = new NamedType(baseType, null);\n     AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n     _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n     // then with definitions from property\n@@ -21,12 +21,12 @@\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n-            if (rawBase.isAssignableFrom(subtype.getType())) {\n+            if (baseType.isTypeOrSubTypeOf(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                 _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    return _combineNamedAndUnnamed(baseType, typesHandled, byName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n    final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    Class<?> rawBase = baseType.getRawClass();\n    // Need to keep track of classes that have been handled already\n    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n    // start with lowest-precedence, which is from type hierarchy\n    NamedType rootType = new NamedType(rawBase, null);\n    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, baseType);\n    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n    // then with definitions from property\n    Collection<NamedType> st = ai.findSubtypes(property);\n    if (st != null) {\n        for (NamedType nt : st) {\n            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n        }\n    }\n    // and finally explicit type registrations (highest precedence)\n    if (_registeredSubtypes != null) {\n        for (NamedType subtype : _registeredSubtypes) {\n            // is it a subtype of root type?\n            if (baseType.hasRawClass(subtype.getType())) {\n                // yes\n                AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n            }\n        }\n    }\n    return _combineNamedAndUnnamed(baseType, typesHandled, byName);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByClass\n@@ -1,31 +1,32 @@\n @Override\n-public Collection<NamedType> collectAndResolveSubtypesByClass(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n+public Collection<NamedType> collectAndResolveSubtypesByTypeId(MapperConfig<?> config, AnnotatedMember property, JavaType baseType) {\n     final AnnotationIntrospector ai = config.getAnnotationIntrospector();\n-    // for backwards compatibility, must allow null here:\n-    Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass();\n-    HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n-    // start with registered subtypes (which have precedence)\n+    Class<?> rawBase = baseType.getRawClass();\n+    // Need to keep track of classes that have been handled already\n+    Set<Class<?>> typesHandled = new HashSet<Class<?>>();\n+    Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n+    // start with lowest-precedence, which is from type hierarchy\n+    NamedType rootType = new NamedType(rawBase, null);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, baseType);\n+    _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n+    // then with definitions from property\n+    Collection<NamedType> st = ai.findSubtypes(property);\n+    if (st != null) {\n+        for (NamedType nt : st) {\n+            ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n+            _collectAndResolveByTypeId(ac, nt, config, typesHandled, byName);\n+        }\n+    }\n+    // and finally explicit type registrations (highest precedence)\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n-            if (rawBase.isAssignableFrom(subtype.getType())) {\n+            if (baseType.hasRawClass(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n-                _collectAndResolve(curr, subtype, config, ai, collected);\n+                _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n-    // then annotated types for property itself\n-    Collection<NamedType> st = ai.findSubtypes(property);\n-    if (st != null) {\n-        for (NamedType nt : st) {\n-            AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, nt.getType());\n-            _collectAndResolve(ac, nt, config, ai, collected);\n-        }\n-    }\n-    NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n-    // and finally subtypes via annotations from base type (recursively)\n-    _collectAndResolve(ac, rootType, config, ai, collected);\n-    return new ArrayList<NamedType>(collected.values());\n+    return _combineNamedAndUnnamed(baseType, typesHandled, byName);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java@collectAndResolveSubtypesByTypeId\n@@ -7,7 +7,7 @@\n     Map<String, NamedType> byName = new LinkedHashMap<String, NamedType>();\n     // start with lowest-precedence, which is from type hierarchy\n     NamedType rootType = new NamedType(rawBase, null);\n-    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, rawBase);\n+    AnnotatedClass ac = AnnotatedClassResolver.resolveWithoutSuperTypes(config, baseType);\n     _collectAndResolveByTypeId(ac, rootType, config, typesHandled, byName);\n     // then with definitions from property\n     Collection<NamedType> st = ai.findSubtypes(property);\n@@ -21,12 +21,12 @@\n     if (_registeredSubtypes != null) {\n         for (NamedType subtype : _registeredSubtypes) {\n             // is it a subtype of root type?\n-            if (rawBase.isAssignableFrom(subtype.getType())) {\n+            if (baseType.hasRawClass(subtype.getType())) {\n                 // yes\n                 AnnotatedClass curr = AnnotatedClassResolver.resolveWithoutSuperTypes(config, subtype.getType());\n                 _collectAndResolveByTypeId(curr, subtype, config, typesHandled, byName);\n             }\n         }\n     }\n-    return _combineNamedAndUnnamed(rawBase, typesHandled, byName);\n+    return _combineNamedAndUnnamed(baseType, typesHandled, byName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]