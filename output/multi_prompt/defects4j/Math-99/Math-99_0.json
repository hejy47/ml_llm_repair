[{"output": "public static int gcd(final int p, final int q) {\n    int u = p;\n    int v = q;\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    if (u > 0) {\n        u = -u;\n    }\n    // make u negative\n    if (v > 0) {\n        v = -v;\n    }\n    // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while (((u & 1) == 0 || (v & 1) == 0) && k < 31) {\n        // while u and v are both even...\n        u /= 2;\n        v /= 2;\n        // cast out twos.\n        k++;\n    }\n    if (k == 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least one is odd.\n    int t = ((u & 1) == 1) ? u : v;\n    // t positive: u was odd, v may be even (t replaces u)\n    // t negative: u was even, v is odd (t replaces v)\n    do {\n        // B3.\n        while ((t & 1) == 0) {\n            // cast out twos\n            t /= 2;\n        }\n        if (t > 0) {\n            u = t;\n        } else {\n            v = -t;\n        }\n        // B4.\n        t = v - u;\n    } while (t != 0);\n    // gcd is u*2^k\n    return -u * (1 << k);\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -8,7 +8,7 @@\n     // -2^31, while positive numbers can only be as large as 2^31-1\n     // (i.e. we can't necessarily negate a negative number without\n     // overflow)\n-        if (u > 0) {\n+    if (u > 0) {\n         u = -u;\n     }\n     // make u negative\n@@ -18,9 +18,8 @@\n     // make v negative\n     // B1. [Find power of 2]\n     int k = 0;\n-    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n-        // while u and v are\n-        // both even...\n+    while (((u & 1) == 0 || (v & 1) == 0) && k < 31) {\n+        // while u and v are both even...\n         u /= 2;\n         v /= 2;\n         // cast out twos.\n@@ -29,28 +28,23 @@\n     if (k == 31) {\n         throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n     }\n-    // B2. Initialize: u and v have been divided by 2^k and at least\n-    // one is odd.\n-    int t = ((u & 1) == 1) ? v : -(u / 2);\n-    // t negative: u was odd, v may be even (t replaces v)\n-    // t positive: u was even, v is odd (t replaces u)\n+    // B2. Initialize: u and v have been divided by 2^k and at least one is odd.\n+    int t = ((u & 1) == 1) ? u : v;\n+    // t positive: u was odd, v may be even (t replaces u)\n+    // t negative: u was even, v is odd (t replaces v)\n     do {\n-                // B4/B3: cast out twos from t.\n+        // B3.\n         while ((t & 1) == 0) {\n-            // while t is even..\n             // cast out twos\n             t /= 2;\n         }\n-        // B5 [reset max(u,v)]\n         if (t > 0) {\n-            u = -t;\n+            u = t;\n         } else {\n-            v = t;\n+            v = -t;\n         }\n-        // B6/B3. at this point both u and v should be odd.\n-        t = (v - u) / 2;\n-        // |u| larger: t positive (replace u)\n-        // |v| larger: t negative (replace v)\n+        // B4.\n+        t = v - u;\n     } while (t != 0);\n     // gcd is u*2^k\n     return -u * (1 << k);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = Math.abs(p);\n    int v = Math.abs(q);\n    if (u == 0) {\n        return v;\n    } else if (v == 0) {\n        return u;\n    }\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n        // while both u and v are even...\n        u /= 2;\n        v /= 2;\n        // cast out twos.\n        k++;\n    }\n    if (k == 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    while ((u & 1) == 0) {\n        u /= 2;\n        // cast out twos from u.\n    }\n    // B3. Loop and don't check for u==0 or v==0 on odd iterations.\n    do {\n        while ((v & 1) == 0) {\n            v /= 2;\n            // cast out twos from v.\n        }\n        // B5. At this point, both u and v are odd.\n        if (u < v) {\n            final int temp = u;\n            u = v;\n            v = temp;\n        }\n        v = Math.abs(v - u);\n        // Here v >= u.\n    } while (v != 0);\n    // gcd is u*2^k.\n    return u << k;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -1,26 +1,15 @@\n public static int gcd(final int p, final int q) {\n-    int u = p;\n-    int v = q;\n-    if ((u == 0) || (v == 0)) {\n-        return (Math.abs(u) + Math.abs(v));\n+    int u = Math.abs(p);\n+    int v = Math.abs(q);\n+    if (u == 0) {\n+        return v;\n+    } else if (v == 0) {\n+        return u;\n     }\n-    // keep u and v negative, as negative integers range down to\n-    // -2^31, while positive numbers can only be as large as 2^31-1\n-    // (i.e. we can't necessarily negate a negative number without\n-    // overflow)\n-        if (u > 0) {\n-        u = -u;\n-    }\n-    // make u negative\n-    if (v > 0) {\n-        v = -v;\n-    }\n-    // make v negative\n     // B1. [Find power of 2]\n     int k = 0;\n     while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n-        // while u and v are\n-        // both even...\n+        // while both u and v are even...\n         u /= 2;\n         v /= 2;\n         // cast out twos.\n@@ -31,27 +20,25 @@\n     }\n     // B2. Initialize: u and v have been divided by 2^k and at least\n     // one is odd.\n-    int t = ((u & 1) == 1) ? v : -(u / 2);\n-    // t negative: u was odd, v may be even (t replaces v)\n-    // t positive: u was even, v is odd (t replaces u)\n+    while ((u & 1) == 0) {\n+        u /= 2;\n+        // cast out twos from u.\n+    }\n+    // B3. Loop and don't check for u==0 or v==0 on odd iterations.\n     do {\n-                // B4/B3: cast out twos from t.\n-        while ((t & 1) == 0) {\n-            // while t is even..\n-            // cast out twos\n-            t /= 2;\n+        while ((v & 1) == 0) {\n+            v /= 2;\n+            // cast out twos from v.\n         }\n-        // B5 [reset max(u,v)]\n-        if (t > 0) {\n-            u = -t;\n-        } else {\n-            v = t;\n+        // B5. At this point, both u and v are odd.\n+        if (u < v) {\n+            final int temp = u;\n+            u = v;\n+            v = temp;\n         }\n-        // B6/B3. at this point both u and v should be odd.\n-        t = (v - u) / 2;\n-        // |u| larger: t positive (replace u)\n-        // |v| larger: t negative (replace v)\n-    } while (t != 0);\n-    // gcd is u*2^k\n-    return -u * (1 << k);\n+        v = Math.abs(v - u);\n+        // Here v >= u.\n+    } while (v != 0);\n+    // gcd is u*2^k.\n+    return u << k;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = Math.abs(p);\n    int v = Math.abs(q);\n    if ((u == 0) || (v == 0)) {\n        return (u + v);\n    }\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n        u /= 2;\n        v /= 2;\n        k++;\n    }\n    if (k == 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n    while (u != 0 && v != 0) {\n        if ((v & 1) == 1) {\n            int t = u;\n            u = v;\n            v = t % v;\n        } else {\n            v /= 2;\n        }\n    }\n    return u == 0 ? v * (1 << k) : u;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -1,57 +1,26 @@\n public static int gcd(final int p, final int q) {\n-    int u = p;\n-    int v = q;\n+    int u = Math.abs(p);\n+    int v = Math.abs(q);\n     if ((u == 0) || (v == 0)) {\n-        return (Math.abs(u) + Math.abs(v));\n+        return (u + v);\n     }\n-    // keep u and v negative, as negative integers range down to\n-    // -2^31, while positive numbers can only be as large as 2^31-1\n-    // (i.e. we can't necessarily negate a negative number without\n-    // overflow)\n-        if (u > 0) {\n-        u = -u;\n-    }\n-    // make u negative\n-    if (v > 0) {\n-        v = -v;\n-    }\n-    // make v negative\n-    // B1. [Find power of 2]\n     int k = 0;\n     while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n-        // while u and v are\n-        // both even...\n         u /= 2;\n         v /= 2;\n-        // cast out twos.\n         k++;\n     }\n     if (k == 31) {\n         throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n     }\n-    // B2. Initialize: u and v have been divided by 2^k and at least\n-    // one is odd.\n-    int t = ((u & 1) == 1) ? v : -(u / 2);\n-    // t negative: u was odd, v may be even (t replaces v)\n-    // t positive: u was even, v is odd (t replaces u)\n-    do {\n-                // B4/B3: cast out twos from t.\n-        while ((t & 1) == 0) {\n-            // while t is even..\n-            // cast out twos\n-            t /= 2;\n+    while (u != 0 && v != 0) {\n+        if ((v & 1) == 1) {\n+            int t = u;\n+            u = v;\n+            v = t % v;\n+        } else {\n+            v /= 2;\n         }\n-        // B5 [reset max(u,v)]\n-        if (t > 0) {\n-            u = -t;\n-        } else {\n-            v = t;\n-        }\n-        // B6/B3. at this point both u and v should be odd.\n-        t = (v - u) / 2;\n-        // |u| larger: t positive (replace u)\n-        // |v| larger: t negative (replace v)\n-    } while (t != 0);\n-    // gcd is u*2^k\n-    return -u * (1 << k);\n+    }\n+    return u == 0 ? v * (1 << k) : u;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = p;\n    int v = q;\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    if (u > 0) {\n        u = -u;\n    }\n    // make u negative\n    if (v > 0) {\n        v = -v;\n    }\n    // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while (u != 0 && v != 0 && k < 31) {\n        // while u and v are\n        // both non-zero...\n        if ((u & 1) == 0 && (v & 1) == 0) {\n            // if u and v are both even...\n            u /= 2;\n            v /= 2;\n            // cast out twos.\n            k++;\n        } else if ((u & 1) == 0 && (v & 1) == 1) {\n            // if u is even and v is odd\n            u /= 2;\n        } else if ((u & 1) == 1 && (v & 1) == 0) {\n            // if u is odd and v is even\n            v /= 2;\n        } else {\n            // if both u and v are odd\n            if (u >= v) {\n                u = (u - v) / 2;\n            } else {\n                int tmp = u;\n                u = (v - u) / 2;\n                v = tmp;\n            }\n        }\n    }\n    if (k == 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n    // gcd is u*2^k\n    return -u * (1 << k);\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -8,7 +8,7 @@\n     // -2^31, while positive numbers can only be as large as 2^31-1\n     // (i.e. we can't necessarily negate a negative number without\n     // overflow)\n-        if (u > 0) {\n+    if (u > 0) {\n         u = -u;\n     }\n     // make u negative\n@@ -18,40 +18,35 @@\n     // make v negative\n     // B1. [Find power of 2]\n     int k = 0;\n-    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n+    while (u != 0 && v != 0 && k < 31) {\n         // while u and v are\n-        // both even...\n-        u /= 2;\n-        v /= 2;\n-        // cast out twos.\n-        k++;\n+        // both non-zero...\n+        if ((u & 1) == 0 && (v & 1) == 0) {\n+            // if u and v are both even...\n+            u /= 2;\n+            v /= 2;\n+            // cast out twos.\n+            k++;\n+        } else if ((u & 1) == 0 && (v & 1) == 1) {\n+            // if u is even and v is odd\n+            u /= 2;\n+        } else if ((u & 1) == 1 && (v & 1) == 0) {\n+            // if u is odd and v is even\n+            v /= 2;\n+        } else {\n+            // if both u and v are odd\n+            if (u >= v) {\n+                u = (u - v) / 2;\n+            } else {\n+                int tmp = u;\n+                u = (v - u) / 2;\n+                v = tmp;\n+            }\n+        }\n     }\n     if (k == 31) {\n         throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n     }\n-    // B2. Initialize: u and v have been divided by 2^k and at least\n-    // one is odd.\n-    int t = ((u & 1) == 1) ? v : -(u / 2);\n-    // t negative: u was odd, v may be even (t replaces v)\n-    // t positive: u was even, v is odd (t replaces u)\n-    do {\n-                // B4/B3: cast out twos from t.\n-        while ((t & 1) == 0) {\n-            // while t is even..\n-            // cast out twos\n-            t /= 2;\n-        }\n-        // B5 [reset max(u,v)]\n-        if (t > 0) {\n-            u = -t;\n-        } else {\n-            v = t;\n-        }\n-        // B6/B3. at this point both u and v should be odd.\n-        t = (v - u) / 2;\n-        // |u| larger: t positive (replace u)\n-        // |v| larger: t negative (replace v)\n-    } while (t != 0);\n     // gcd is u*2^k\n     return -u * (1 << k);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = Math.abs(p);\n    int v = Math.abs(q);\n    if ((u == 0) || (v == 0)) {\n        return (u + v);\n    }\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n        u >>= 1;\n        v >>= 1;\n        k++;\n    }\n    if (k == 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n    while (u > 0) {\n        if ((u & 1) == 1) {\n            if (v > u) {\n                int t = u;\n                u = v;\n                v = t;\n            }\n            v -= u;\n        } else {\n            if ((v & 1) == 1) {\n                v -= u;\n            }\n            u >>= 1;\n            v >>= 1;\n        }\n    }\n    return (v << k);\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -1,57 +1,33 @@\n public static int gcd(final int p, final int q) {\n-    int u = p;\n-    int v = q;\n+    int u = Math.abs(p);\n+    int v = Math.abs(q);\n     if ((u == 0) || (v == 0)) {\n-        return (Math.abs(u) + Math.abs(v));\n+        return (u + v);\n     }\n-    // keep u and v negative, as negative integers range down to\n-    // -2^31, while positive numbers can only be as large as 2^31-1\n-    // (i.e. we can't necessarily negate a negative number without\n-    // overflow)\n-        if (u > 0) {\n-        u = -u;\n-    }\n-    // make u negative\n-    if (v > 0) {\n-        v = -v;\n-    }\n-    // make v negative\n-    // B1. [Find power of 2]\n     int k = 0;\n     while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n-        // while u and v are\n-        // both even...\n-        u /= 2;\n-        v /= 2;\n-        // cast out twos.\n+        u >>= 1;\n+        v >>= 1;\n         k++;\n     }\n     if (k == 31) {\n         throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n     }\n-    // B2. Initialize: u and v have been divided by 2^k and at least\n-    // one is odd.\n-    int t = ((u & 1) == 1) ? v : -(u / 2);\n-    // t negative: u was odd, v may be even (t replaces v)\n-    // t positive: u was even, v is odd (t replaces u)\n-    do {\n-                // B4/B3: cast out twos from t.\n-        while ((t & 1) == 0) {\n-            // while t is even..\n-            // cast out twos\n-            t /= 2;\n+    while (u > 0) {\n+        if ((u & 1) == 1) {\n+            if (v > u) {\n+                int t = u;\n+                u = v;\n+                v = t;\n+            }\n+            v -= u;\n+        } else {\n+            if ((v & 1) == 1) {\n+                v -= u;\n+            }\n+            u >>= 1;\n+            v >>= 1;\n         }\n-        // B5 [reset max(u,v)]\n-        if (t > 0) {\n-            u = -t;\n-        } else {\n-            v = t;\n-        }\n-        // B6/B3. at this point both u and v should be odd.\n-        t = (v - u) / 2;\n-        // |u| larger: t positive (replace u)\n-        // |v| larger: t negative (replace v)\n-    } while (t != 0);\n-    // gcd is u*2^k\n-    return -u * (1 << k);\n+    }\n+    return (v << k);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = Math.abs(p); // use absolute values instead of negative values\n    int v = Math.abs(q);\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n        // while u and v are\n        // both even...\n        u /= 2;\n        v /= 2;\n        // cast out twos.\n        k++;\n    }\n    if (k == 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    int t = ((u & 1) == 1) ? v : -u;\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0) {\n            // while t is even..\n            // cast out twos\n            t /= 2;\n        }\n        if (t > 0) {\n            u = t; // update u instead of negating it\n        }\n        else {\n            v = -t; // update v instead of negating it\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = u - v;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t != 0);\n    // gcd is u*2^k\n    return u << k;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -1,21 +1,9 @@\n public static int gcd(final int p, final int q) {\n-    int u = p;\n-    int v = q;\n+    int u = Math.abs(p); // use absolute values instead of negative values\n+    int v = Math.abs(q);\n     if ((u == 0) || (v == 0)) {\n         return (Math.abs(u) + Math.abs(v));\n     }\n-    // keep u and v negative, as negative integers range down to\n-    // -2^31, while positive numbers can only be as large as 2^31-1\n-    // (i.e. we can't necessarily negate a negative number without\n-    // overflow)\n-        if (u > 0) {\n-        u = -u;\n-    }\n-    // make u negative\n-    if (v > 0) {\n-        v = -v;\n-    }\n-    // make v negative\n     // B1. [Find power of 2]\n     int k = 0;\n     while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n@@ -31,27 +19,27 @@\n     }\n     // B2. Initialize: u and v have been divided by 2^k and at least\n     // one is odd.\n-    int t = ((u & 1) == 1) ? v : -(u / 2);\n+    int t = ((u & 1) == 1) ? v : -u;\n     // t negative: u was odd, v may be even (t replaces v)\n     // t positive: u was even, v is odd (t replaces u)\n     do {\n-                // B4/B3: cast out twos from t.\n+        // B4/B3: cast out twos from t.\n         while ((t & 1) == 0) {\n             // while t is even..\n             // cast out twos\n             t /= 2;\n         }\n-        // B5 [reset max(u,v)]\n         if (t > 0) {\n-            u = -t;\n-        } else {\n-            v = t;\n+            u = t; // update u instead of negating it\n+        }\n+        else {\n+            v = -t; // update v instead of negating it\n         }\n         // B6/B3. at this point both u and v should be odd.\n-        t = (v - u) / 2;\n+        t = u - v;\n         // |u| larger: t positive (replace u)\n         // |v| larger: t negative (replace v)\n     } while (t != 0);\n     // gcd is u*2^k\n-    return -u * (1 << k);\n+    return u << k;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = p;\n    int v = q;\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    if (u > 0) {\n        u = -u;\n    }\n    // make u negative\n    if (v > 0) {\n        v = -v;\n    }\n    // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while (((u & 1) == 0 || (v & 1) == 0) && k < 31) {\n        // while u and v are\n        // both even...\n        u /= 2;\n        v /= 2;\n        // cast out twos.\n        k++;\n    }\n    if (k == 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    int t = ((u & 1) == 1) ? v : -(u / 2);\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0) {\n            // while t is even..\n            // cast out twos\n            t /= 2;\n        }\n        // B5 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u) / 2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t != 0);\n    // gcd is u*2^k\n    return -u * (1 << k);\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -8,7 +8,7 @@\n     // -2^31, while positive numbers can only be as large as 2^31-1\n     // (i.e. we can't necessarily negate a negative number without\n     // overflow)\n-        if (u > 0) {\n+    if (u > 0) {\n         u = -u;\n     }\n     // make u negative\n@@ -18,7 +18,7 @@\n     // make v negative\n     // B1. [Find power of 2]\n     int k = 0;\n-    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n+    while (((u & 1) == 0 || (v & 1) == 0) && k < 31) {\n         // while u and v are\n         // both even...\n         u /= 2;\n@@ -35,7 +35,7 @@\n     // t negative: u was odd, v may be even (t replaces v)\n     // t positive: u was even, v is odd (t replaces u)\n     do {\n-                // B4/B3: cast out twos from t.\n+        // B4/B3: cast out twos from t.\n         while ((t & 1) == 0) {\n             // while t is even..\n             // cast out twos\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = p;\n    int v = q;\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    if (u > 0) {\n        u = -u;\n    }\n    // make u negative\n    if (v > 0) {\n        v = -v;\n    }\n    // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n        // while u and v are\n        // both even...\n        u /= 2;\n        v /= 2;\n        // cast out twos.\n        k++;\n    }\n    if (k == 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    int t = ((u & 1) == 1) ? u : v;\n    // t negative: u was odd, v may be even (t replaces u)\n    // t positive: u was even, v is odd (t replaces v)\n    do {\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0 && t != 0) {\n            // while t is even..\n            // cast out twos\n            t /= 2;\n        }\n        if (t == 0) {\n            break;\n        }\n        // B5 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = ((v - u) > 0) ? (v - u) : -(v - u);\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (true);\n    // gcd is u*2^k\n    return -u * (1 << k);\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -8,7 +8,7 @@\n     // -2^31, while positive numbers can only be as large as 2^31-1\n     // (i.e. we can't necessarily negate a negative number without\n     // overflow)\n-        if (u > 0) {\n+    if (u > 0) {\n         u = -u;\n     }\n     // make u negative\n@@ -31,15 +31,18 @@\n     }\n     // B2. Initialize: u and v have been divided by 2^k and at least\n     // one is odd.\n-    int t = ((u & 1) == 1) ? v : -(u / 2);\n-    // t negative: u was odd, v may be even (t replaces v)\n-    // t positive: u was even, v is odd (t replaces u)\n+    int t = ((u & 1) == 1) ? u : v;\n+    // t negative: u was odd, v may be even (t replaces u)\n+    // t positive: u was even, v is odd (t replaces v)\n     do {\n-                // B4/B3: cast out twos from t.\n-        while ((t & 1) == 0) {\n+        // B4/B3: cast out twos from t.\n+        while ((t & 1) == 0 && t != 0) {\n             // while t is even..\n             // cast out twos\n             t /= 2;\n+        }\n+        if (t == 0) {\n+            break;\n         }\n         // B5 [reset max(u,v)]\n         if (t > 0) {\n@@ -48,10 +51,10 @@\n             v = t;\n         }\n         // B6/B3. at this point both u and v should be odd.\n-        t = (v - u) / 2;\n+        t = ((v - u) > 0) ? (v - u) : -(v - u);\n         // |u| larger: t positive (replace u)\n         // |v| larger: t negative (replace v)\n-    } while (t != 0);\n+    } while (true);\n     // gcd is u*2^k\n     return -u * (1 << k);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = Math.abs(p);\n    int v = Math.abs(q);\n    if (u == 0 || v == 0) {\n        return (u + v);\n    }\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n        // while u and v are\n        // both even...\n        u /= 2;\n        v /= 2;\n        // cast out twos.\n        k++;\n    }\n    if (k == 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    int t = ((u & 1) == 1) ? v : -(u / 2);\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        // B3: cast out twos from t.\n        while ((t & 1) == 0) {\n            // while t is even..\n            // cast out twos\n            t /= 2;\n        }\n        // B4 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B5/B6. at this point both u and v should be odd.\n        t = (v - u) / 2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t != 0);\n    // gcd is u*2^k\n    return u * (1 << k);\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -1,21 +1,9 @@\n public static int gcd(final int p, final int q) {\n-    int u = p;\n-    int v = q;\n-    if ((u == 0) || (v == 0)) {\n-        return (Math.abs(u) + Math.abs(v));\n+    int u = Math.abs(p);\n+    int v = Math.abs(q);\n+    if (u == 0 || v == 0) {\n+        return (u + v);\n     }\n-    // keep u and v negative, as negative integers range down to\n-    // -2^31, while positive numbers can only be as large as 2^31-1\n-    // (i.e. we can't necessarily negate a negative number without\n-    // overflow)\n-        if (u > 0) {\n-        u = -u;\n-    }\n-    // make u negative\n-    if (v > 0) {\n-        v = -v;\n-    }\n-    // make v negative\n     // B1. [Find power of 2]\n     int k = 0;\n     while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n@@ -35,23 +23,23 @@\n     // t negative: u was odd, v may be even (t replaces v)\n     // t positive: u was even, v is odd (t replaces u)\n     do {\n-                // B4/B3: cast out twos from t.\n+        // B3: cast out twos from t.\n         while ((t & 1) == 0) {\n             // while t is even..\n             // cast out twos\n             t /= 2;\n         }\n-        // B5 [reset max(u,v)]\n+        // B4 [reset max(u,v)]\n         if (t > 0) {\n             u = -t;\n         } else {\n             v = t;\n         }\n-        // B6/B3. at this point both u and v should be odd.\n+        // B5/B6. at this point both u and v should be odd.\n         t = (v - u) / 2;\n         // |u| larger: t positive (replace u)\n         // |v| larger: t negative (replace v)\n     } while (t != 0);\n     // gcd is u*2^k\n-    return -u * (1 << k);\n+    return u * (1 << k);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = p;\n    int v = q;\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    if (u > 0) {\n        u = -u;\n    }\n    // make u negative\n    if (v > 0) {\n        v = -v;\n    }\n    // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n        // while u and v are\n        // both even...\n        u /= 2;\n        v /= 2;\n        // cast out twos.\n        k++;\n    }\n    if (k == 31) {\n        throw new ArithmeticException(\"overflow: gcd(\" + p + \", \" + q + \") is 2^31\");\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    int t = ((u & 1) == 1) ? v : -(u / 2);\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0 && t != 0) {\n            // while t is even..\n            // cast out twos\n            t /= 2;\n        }\n        // B5 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else if (t < 0) {\n            v = -t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u) / 2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t != 0);\n    // gcd is u*2^k\n    return -u * (1 << k);\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -8,7 +8,7 @@\n     // -2^31, while positive numbers can only be as large as 2^31-1\n     // (i.e. we can't necessarily negate a negative number without\n     // overflow)\n-        if (u > 0) {\n+    if (u > 0) {\n         u = -u;\n     }\n     // make u negative\n@@ -27,7 +27,7 @@\n         k++;\n     }\n     if (k == 31) {\n-        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n+        throw new ArithmeticException(\"overflow: gcd(\" + p + \", \" + q + \") is 2^31\");\n     }\n     // B2. Initialize: u and v have been divided by 2^k and at least\n     // one is odd.\n@@ -35,8 +35,8 @@\n     // t negative: u was odd, v may be even (t replaces v)\n     // t positive: u was even, v is odd (t replaces u)\n     do {\n-                // B4/B3: cast out twos from t.\n-        while ((t & 1) == 0) {\n+        // B4/B3: cast out twos from t.\n+        while ((t & 1) == 0 && t != 0) {\n             // while t is even..\n             // cast out twos\n             t /= 2;\n@@ -44,8 +44,8 @@\n         // B5 [reset max(u,v)]\n         if (t > 0) {\n             u = -t;\n-        } else {\n-            v = t;\n+        } else if (t < 0) {\n+            v = -t;\n         }\n         // B6/B3. at this point both u and v should be odd.\n         t = (v - u) / 2;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = Math.abs(p);\n    int v = Math.abs(q);\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    int shift = 0;\n    while (((u & 1) == 0) && ((v & 1) == 0)) {\n        u >>= 1;\n        v >>= 1;\n        shift++;\n    }\n    while ((u & 1) == 0) {\n        u >>= 1;\n    }\n    do {\n        while ((v & 1) == 0) {\n            v >>= 1;\n        }\n        if (u > v) {\n            int t = v;\n            v = u;\n            u = t;\n        }\n        v = v - u;\n    } while (v != 0);\n    return u << shift;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -1,57 +1,28 @@\n public static int gcd(final int p, final int q) {\n-    int u = p;\n-    int v = q;\n+    int u = Math.abs(p);\n+    int v = Math.abs(q);\n     if ((u == 0) || (v == 0)) {\n         return (Math.abs(u) + Math.abs(v));\n     }\n-    // keep u and v negative, as negative integers range down to\n-    // -2^31, while positive numbers can only be as large as 2^31-1\n-    // (i.e. we can't necessarily negate a negative number without\n-    // overflow)\n-        if (u > 0) {\n-        u = -u;\n+    int shift = 0;\n+    while (((u & 1) == 0) && ((v & 1) == 0)) {\n+        u >>= 1;\n+        v >>= 1;\n+        shift++;\n     }\n-    // make u negative\n-    if (v > 0) {\n-        v = -v;\n+    while ((u & 1) == 0) {\n+        u >>= 1;\n     }\n-    // make v negative\n-    // B1. [Find power of 2]\n-    int k = 0;\n-    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n-        // while u and v are\n-        // both even...\n-        u /= 2;\n-        v /= 2;\n-        // cast out twos.\n-        k++;\n-    }\n-    if (k == 31) {\n-        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n-    }\n-    // B2. Initialize: u and v have been divided by 2^k and at least\n-    // one is odd.\n-    int t = ((u & 1) == 1) ? v : -(u / 2);\n-    // t negative: u was odd, v may be even (t replaces v)\n-    // t positive: u was even, v is odd (t replaces u)\n     do {\n-                // B4/B3: cast out twos from t.\n-        while ((t & 1) == 0) {\n-            // while t is even..\n-            // cast out twos\n-            t /= 2;\n+        while ((v & 1) == 0) {\n+            v >>= 1;\n         }\n-        // B5 [reset max(u,v)]\n-        if (t > 0) {\n-            u = -t;\n-        } else {\n-            v = t;\n+        if (u > v) {\n+            int t = v;\n+            v = u;\n+            u = t;\n         }\n-        // B6/B3. at this point both u and v should be odd.\n-        t = (v - u) / 2;\n-        // |u| larger: t positive (replace u)\n-        // |v| larger: t negative (replace v)\n-    } while (t != 0);\n-    // gcd is u*2^k\n-    return -u * (1 << k);\n+        v = v - u;\n+    } while (v != 0);\n+    return u << shift;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = p;\n    int v = q;\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    if (u > 0) {\n        u = -u;\n    }\n    // make u negative\n    if (v > 0) {\n        v = -v;\n    }\n    // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n        // while u and v are\n        // both even...\n        u /= 2;\n        v /= 2;\n        // cast out twos.\n        k++;\n    }\n    if (k == 31) {\n        throw new IllegalArgumentException(\"overflow: gcd(\" + p + \", \" + q + \") is 2^31\");\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    int t = ((u & 1) != 0) ? u : (u / 2);\n    // t negative: u was odd, v may be even (t replaces u)\n    // t positive: u was even, v is odd (t replaces v)\n    do {\n        // B3: cast out twos from t.\n        while ((t & 1) == 0) {\n            // while t is even..\n            // cast out twos\n            t /= 2;\n        }\n        // B4 [reset u or v]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = -t;\n        }\n        // B5. at this point u or v should be 0.\n        t = v + u;\n        // u or v becomes t.\n    } while (t != 0);\n    // gcd is -u*2^k\n    return -u * (1 << k);\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -8,7 +8,7 @@\n     // -2^31, while positive numbers can only be as large as 2^31-1\n     // (i.e. we can't necessarily negate a negative number without\n     // overflow)\n-        if (u > 0) {\n+    if (u > 0) {\n         u = -u;\n     }\n     // make u negative\n@@ -27,31 +27,30 @@\n         k++;\n     }\n     if (k == 31) {\n-        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n+        throw new IllegalArgumentException(\"overflow: gcd(\" + p + \", \" + q + \") is 2^31\");\n     }\n     // B2. Initialize: u and v have been divided by 2^k and at least\n     // one is odd.\n-    int t = ((u & 1) == 1) ? v : -(u / 2);\n-    // t negative: u was odd, v may be even (t replaces v)\n-    // t positive: u was even, v is odd (t replaces u)\n+    int t = ((u & 1) != 0) ? u : (u / 2);\n+    // t negative: u was odd, v may be even (t replaces u)\n+    // t positive: u was even, v is odd (t replaces v)\n     do {\n-                // B4/B3: cast out twos from t.\n+        // B3: cast out twos from t.\n         while ((t & 1) == 0) {\n             // while t is even..\n             // cast out twos\n             t /= 2;\n         }\n-        // B5 [reset max(u,v)]\n+        // B4 [reset u or v]\n         if (t > 0) {\n             u = -t;\n         } else {\n-            v = t;\n+            v = -t;\n         }\n-        // B6/B3. at this point both u and v should be odd.\n-        t = (v - u) / 2;\n-        // |u| larger: t positive (replace u)\n-        // |v| larger: t negative (replace v)\n+        // B5. at this point u or v should be 0.\n+        t = v + u;\n+        // u or v becomes t.\n     } while (t != 0);\n-    // gcd is u*2^k\n+    // gcd is -u*2^k\n     return -u * (1 << k);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = p;\n    int v = q;\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    if (u > 0) {\n        u = -u;\n    }\n    // make u negative\n    if (v > 0) {\n        v = -v;\n    }\n    // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n        // while u and v are both even...\n        u /= 2;\n        v /= 2;\n        // cast out twos\n        k++;\n    }\n    if (k == 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least one is odd.\n    int t = ((u & 1) == 1) ? u : -v;\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0 && t != 0) {\n            // while t is even..\n            // cast out twos\n            t /= 2;\n        }\n        if (t == 0) {\n            break;\n        }\n        // B5 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u) / 2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t != 0);\n    // gcd is u*2^k\n    return -u * (1 << k);\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -8,7 +8,7 @@\n     // -2^31, while positive numbers can only be as large as 2^31-1\n     // (i.e. we can't necessarily negate a negative number without\n     // overflow)\n-        if (u > 0) {\n+    if (u > 0) {\n         u = -u;\n     }\n     // make u negative\n@@ -19,27 +19,28 @@\n     // B1. [Find power of 2]\n     int k = 0;\n     while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n-        // while u and v are\n-        // both even...\n+        // while u and v are both even...\n         u /= 2;\n         v /= 2;\n-        // cast out twos.\n+        // cast out twos\n         k++;\n     }\n     if (k == 31) {\n         throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n     }\n-    // B2. Initialize: u and v have been divided by 2^k and at least\n-    // one is odd.\n-    int t = ((u & 1) == 1) ? v : -(u / 2);\n+    // B2. Initialize: u and v have been divided by 2^k and at least one is odd.\n+    int t = ((u & 1) == 1) ? u : -v;\n     // t negative: u was odd, v may be even (t replaces v)\n     // t positive: u was even, v is odd (t replaces u)\n     do {\n-                // B4/B3: cast out twos from t.\n-        while ((t & 1) == 0) {\n+        // B4/B3: cast out twos from t.\n+        while ((t & 1) == 0 && t != 0) {\n             // while t is even..\n             // cast out twos\n             t /= 2;\n+        }\n+        if (t == 0) {\n+            break;\n         }\n         // B5 [reset max(u,v)]\n         if (t > 0) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = p;\n    int v = q;\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    if (u > 0) {\n        u = -u;\n    }\n    // make u negative\n    if (v > 0) {\n        v = -v;\n    }\n    // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n        // while u and v are\n        // both even...\n        u /= 2;\n        v /= 2;\n        // cast out twos.\n        k++;\n    }\n    if (k == 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    int t;\n    while (v != 0) {\n        t = u;\n        u = v;\n        v = t % v;\n    }\n    // gcd is u*2^k\n    return -u * (1 << k);\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -8,7 +8,7 @@\n     // -2^31, while positive numbers can only be as large as 2^31-1\n     // (i.e. we can't necessarily negate a negative number without\n     // overflow)\n-        if (u > 0) {\n+    if (u > 0) {\n         u = -u;\n     }\n     // make u negative\n@@ -31,27 +31,12 @@\n     }\n     // B2. Initialize: u and v have been divided by 2^k and at least\n     // one is odd.\n-    int t = ((u & 1) == 1) ? v : -(u / 2);\n-    // t negative: u was odd, v may be even (t replaces v)\n-    // t positive: u was even, v is odd (t replaces u)\n-    do {\n-                // B4/B3: cast out twos from t.\n-        while ((t & 1) == 0) {\n-            // while t is even..\n-            // cast out twos\n-            t /= 2;\n-        }\n-        // B5 [reset max(u,v)]\n-        if (t > 0) {\n-            u = -t;\n-        } else {\n-            v = t;\n-        }\n-        // B6/B3. at this point both u and v should be odd.\n-        t = (v - u) / 2;\n-        // |u| larger: t positive (replace u)\n-        // |v| larger: t negative (replace v)\n-    } while (t != 0);\n+    int t;\n+    while (v != 0) {\n+        t = u;\n+        u = v;\n+        v = t % v;\n+    }\n     // gcd is u*2^k\n     return -u * (1 << k);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = Math.abs(p);\n    int v = Math.abs(q);\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n        u /= 2;\n        v /= 2;\n        k++;\n    }\n    int t = (u & 1) == 1 ? v : -(u / 2);\n    while (t != 0) {\n        while ((t & 1) == 0) {\n            t /= 2;\n        }\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        t = (v - u) / 2;\n    }\n    return u < 0 ? -u * (1 << k) : u * (1 << k);\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -1,57 +1,26 @@\n public static int gcd(final int p, final int q) {\n-    int u = p;\n-    int v = q;\n+    int u = Math.abs(p);\n+    int v = Math.abs(q);\n     if ((u == 0) || (v == 0)) {\n         return (Math.abs(u) + Math.abs(v));\n     }\n-    // keep u and v negative, as negative integers range down to\n-    // -2^31, while positive numbers can only be as large as 2^31-1\n-    // (i.e. we can't necessarily negate a negative number without\n-    // overflow)\n-        if (u > 0) {\n-        u = -u;\n-    }\n-    // make u negative\n-    if (v > 0) {\n-        v = -v;\n-    }\n-    // make v negative\n-    // B1. [Find power of 2]\n     int k = 0;\n     while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n-        // while u and v are\n-        // both even...\n         u /= 2;\n         v /= 2;\n-        // cast out twos.\n         k++;\n     }\n-    if (k == 31) {\n-        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n-    }\n-    // B2. Initialize: u and v have been divided by 2^k and at least\n-    // one is odd.\n-    int t = ((u & 1) == 1) ? v : -(u / 2);\n-    // t negative: u was odd, v may be even (t replaces v)\n-    // t positive: u was even, v is odd (t replaces u)\n-    do {\n-                // B4/B3: cast out twos from t.\n+    int t = (u & 1) == 1 ? v : -(u / 2);\n+    while (t != 0) {\n         while ((t & 1) == 0) {\n-            // while t is even..\n-            // cast out twos\n             t /= 2;\n         }\n-        // B5 [reset max(u,v)]\n         if (t > 0) {\n             u = -t;\n         } else {\n             v = t;\n         }\n-        // B6/B3. at this point both u and v should be odd.\n         t = (v - u) / 2;\n-        // |u| larger: t positive (replace u)\n-        // |v| larger: t negative (replace v)\n-    } while (t != 0);\n-    // gcd is u*2^k\n-    return -u * (1 << k);\n+    }\n+    return u < 0 ? -u * (1 << k) : u * (1 << k);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = Math.abs(p);\n    int v = Math.abs(q);\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n        // while u and v are both even...\n        u /= 2;\n        v /= 2;\n        k++;\n    }\n    if (k == 31) {\n        //throwing exception if gcd is too large\n        throw new ArithmeticException(\"overflow: gcd(\" + p + \", \" + q + \") is 2^31\");\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least one is odd.\n    while (u != 0 && v != 0) {\n        int t = v;\n        v = u % v;\n        u = t;\n    }\n    // gcd is u*2^k\n    return u << k;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -1,57 +1,27 @@\n public static int gcd(final int p, final int q) {\n-    int u = p;\n-    int v = q;\n+    int u = Math.abs(p);\n+    int v = Math.abs(q);\n     if ((u == 0) || (v == 0)) {\n         return (Math.abs(u) + Math.abs(v));\n     }\n-    // keep u and v negative, as negative integers range down to\n-    // -2^31, while positive numbers can only be as large as 2^31-1\n-    // (i.e. we can't necessarily negate a negative number without\n-    // overflow)\n-        if (u > 0) {\n-        u = -u;\n-    }\n-    // make u negative\n-    if (v > 0) {\n-        v = -v;\n-    }\n-    // make v negative\n     // B1. [Find power of 2]\n     int k = 0;\n     while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n-        // while u and v are\n-        // both even...\n+        // while u and v are both even...\n         u /= 2;\n         v /= 2;\n-        // cast out twos.\n         k++;\n     }\n     if (k == 31) {\n-        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n+        //throwing exception if gcd is too large\n+        throw new ArithmeticException(\"overflow: gcd(\" + p + \", \" + q + \") is 2^31\");\n     }\n-    // B2. Initialize: u and v have been divided by 2^k and at least\n-    // one is odd.\n-    int t = ((u & 1) == 1) ? v : -(u / 2);\n-    // t negative: u was odd, v may be even (t replaces v)\n-    // t positive: u was even, v is odd (t replaces u)\n-    do {\n-                // B4/B3: cast out twos from t.\n-        while ((t & 1) == 0) {\n-            // while t is even..\n-            // cast out twos\n-            t /= 2;\n-        }\n-        // B5 [reset max(u,v)]\n-        if (t > 0) {\n-            u = -t;\n-        } else {\n-            v = t;\n-        }\n-        // B6/B3. at this point both u and v should be odd.\n-        t = (v - u) / 2;\n-        // |u| larger: t positive (replace u)\n-        // |v| larger: t negative (replace v)\n-    } while (t != 0);\n+    // B2. Initialize: u and v have been divided by 2^k and at least one is odd.\n+    while (u != 0 && v != 0) {\n+        int t = v;\n+        v = u % v;\n+        u = t;\n+    }\n     // gcd is u*2^k\n-    return -u * (1 << k);\n+    return u << k;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = p;\n    int v = q;\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    if (u > 0) {\n        u = -u;\n    }\n    // make u negative\n    if (v > 0) {\n        v = -v;\n    }\n    // make v negative\n    \n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n        // while u and v are\n        // both even...\n        u /= 2;\n        v /= 2;\n        // cast out twos.\n        k++;\n    }\n    if (k == 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    // one is odd.\n    int t = ((u & 1) == 1) ? v : -(u / 2);\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0 && t != 0) {\n            // while t is even..\n            // cast out twos\n            t /= 2;\n        }\n        if (t == 0) break;\n        // B5 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u) / 2;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t != 0);\n    // gcd is u*2^k\n    return -u * (1 << k);\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -8,7 +8,7 @@\n     // -2^31, while positive numbers can only be as large as 2^31-1\n     // (i.e. we can't necessarily negate a negative number without\n     // overflow)\n-        if (u > 0) {\n+    if (u > 0) {\n         u = -u;\n     }\n     // make u negative\n@@ -16,6 +16,7 @@\n         v = -v;\n     }\n     // make v negative\n+    \n     // B1. [Find power of 2]\n     int k = 0;\n     while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n@@ -35,12 +36,13 @@\n     // t negative: u was odd, v may be even (t replaces v)\n     // t positive: u was even, v is odd (t replaces u)\n     do {\n-                // B4/B3: cast out twos from t.\n-        while ((t & 1) == 0) {\n+        // B4/B3: cast out twos from t.\n+        while ((t & 1) == 0 && t != 0) {\n             // while t is even..\n             // cast out twos\n             t /= 2;\n         }\n+        if (t == 0) break;\n         // B5 [reset max(u,v)]\n         if (t > 0) {\n             u = -t;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = Math.abs(p);\n    int v = Math.abs(q);\n    if ((u == 0) || (v == 0)) {\n        return u + v;\n    }\n    int shift = Integer.numberOfTrailingZeros(u | v);\n    u >>= shift;\n    v >>= shift;\n    while ((u != 0) && (v != 0)) {\n        if ((u & 1) == 0) {\n            u >>= 1;\n        } else if ((v & 1) == 0) {\n            v >>= 1;\n        } else if (u >= v) {\n            u = (u - v) >> 1;\n        } else {\n            v = (v - u) >> 1;\n        }\n    }\n    return (u | v) << shift;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -1,57 +1,22 @@\n public static int gcd(final int p, final int q) {\n-    int u = p;\n-    int v = q;\n+    int u = Math.abs(p);\n+    int v = Math.abs(q);\n     if ((u == 0) || (v == 0)) {\n-        return (Math.abs(u) + Math.abs(v));\n+        return u + v;\n     }\n-    // keep u and v negative, as negative integers range down to\n-    // -2^31, while positive numbers can only be as large as 2^31-1\n-    // (i.e. we can't necessarily negate a negative number without\n-    // overflow)\n-        if (u > 0) {\n-        u = -u;\n+    int shift = Integer.numberOfTrailingZeros(u | v);\n+    u >>= shift;\n+    v >>= shift;\n+    while ((u != 0) && (v != 0)) {\n+        if ((u & 1) == 0) {\n+            u >>= 1;\n+        } else if ((v & 1) == 0) {\n+            v >>= 1;\n+        } else if (u >= v) {\n+            u = (u - v) >> 1;\n+        } else {\n+            v = (v - u) >> 1;\n+        }\n     }\n-    // make u negative\n-    if (v > 0) {\n-        v = -v;\n-    }\n-    // make v negative\n-    // B1. [Find power of 2]\n-    int k = 0;\n-    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n-        // while u and v are\n-        // both even...\n-        u /= 2;\n-        v /= 2;\n-        // cast out twos.\n-        k++;\n-    }\n-    if (k == 31) {\n-        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n-    }\n-    // B2. Initialize: u and v have been divided by 2^k and at least\n-    // one is odd.\n-    int t = ((u & 1) == 1) ? v : -(u / 2);\n-    // t negative: u was odd, v may be even (t replaces v)\n-    // t positive: u was even, v is odd (t replaces u)\n-    do {\n-                // B4/B3: cast out twos from t.\n-        while ((t & 1) == 0) {\n-            // while t is even..\n-            // cast out twos\n-            t /= 2;\n-        }\n-        // B5 [reset max(u,v)]\n-        if (t > 0) {\n-            u = -t;\n-        } else {\n-            v = t;\n-        }\n-        // B6/B3. at this point both u and v should be odd.\n-        t = (v - u) / 2;\n-        // |u| larger: t positive (replace u)\n-        // |v| larger: t negative (replace v)\n-    } while (t != 0);\n-    // gcd is u*2^k\n-    return -u * (1 << k);\n+    return (u | v) << shift;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = Math.abs(p);\n    int v = Math.abs(q);\n    if ((u == 0) || (v == 0)) {\n        return (Math.abs(u) + Math.abs(v));\n    }\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n        // while u and v are\n        // both even...\n        u /= 2;\n        v /= 2;\n        // cast out twos.\n        k++;\n    }\n    if (k == 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least one is odd.\n    while (u != 0) {\n        if ((u & 1) == 1) {\n            if (v > u) {\n                int t = u;\n                u = v;\n                v = t;\n            }\n            v -= u;\n        } else {\n            if ((v & 1) == 1) {\n                v = -v;\n            }\n            u /= 2;\n            v /= 2;\n        }\n    }\n    // gcd is v*2^k\n    return v * (1 << k);\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -1,21 +1,9 @@\n public static int gcd(final int p, final int q) {\n-    int u = p;\n-    int v = q;\n+    int u = Math.abs(p);\n+    int v = Math.abs(q);\n     if ((u == 0) || (v == 0)) {\n         return (Math.abs(u) + Math.abs(v));\n     }\n-    // keep u and v negative, as negative integers range down to\n-    // -2^31, while positive numbers can only be as large as 2^31-1\n-    // (i.e. we can't necessarily negate a negative number without\n-    // overflow)\n-        if (u > 0) {\n-        u = -u;\n-    }\n-    // make u negative\n-    if (v > 0) {\n-        v = -v;\n-    }\n-    // make v negative\n     // B1. [Find power of 2]\n     int k = 0;\n     while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n@@ -29,29 +17,23 @@\n     if (k == 31) {\n         throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n     }\n-    // B2. Initialize: u and v have been divided by 2^k and at least\n-    // one is odd.\n-    int t = ((u & 1) == 1) ? v : -(u / 2);\n-    // t negative: u was odd, v may be even (t replaces v)\n-    // t positive: u was even, v is odd (t replaces u)\n-    do {\n-                // B4/B3: cast out twos from t.\n-        while ((t & 1) == 0) {\n-            // while t is even..\n-            // cast out twos\n-            t /= 2;\n+    // B2. Initialize: u and v have been divided by 2^k and at least one is odd.\n+    while (u != 0) {\n+        if ((u & 1) == 1) {\n+            if (v > u) {\n+                int t = u;\n+                u = v;\n+                v = t;\n+            }\n+            v -= u;\n+        } else {\n+            if ((v & 1) == 1) {\n+                v = -v;\n+            }\n+            u /= 2;\n+            v /= 2;\n         }\n-        // B5 [reset max(u,v)]\n-        if (t > 0) {\n-            u = -t;\n-        } else {\n-            v = t;\n-        }\n-        // B6/B3. at this point both u and v should be odd.\n-        t = (v - u) / 2;\n-        // |u| larger: t positive (replace u)\n-        // |v| larger: t negative (replace v)\n-    } while (t != 0);\n-    // gcd is u*2^k\n-    return -u * (1 << k);\n+    }\n+    // gcd is v*2^k\n+    return v * (1 << k);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static int gcd(final int p, final int q) {\n    int u = Math.abs(p);\n    int v = Math.abs(q);\n    if (u == 0 || v == 0) {\n        return u + v;\n    }\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n        u /= 2;\n        v /= 2;\n        k++;\n    }\n    if (k == 31) {\n        throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n    }\n    while (u != 0 && v != 0) {\n        while ((u & 1) == 0) {\n            u /= 2;\n        }\n        while ((v & 1) == 0) {\n            v /= 2;\n        }\n        if (u >= v) {\n            u -= v;\n        } else {\n            v -= u;\n        }\n    }\n    return (u == 0) ? v * (1 << k) : u * (1 << k);\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@gcd\n+++ org/apache/commons/math/util/MathUtils.java@gcd\n@@ -1,57 +1,30 @@\n public static int gcd(final int p, final int q) {\n-    int u = p;\n-    int v = q;\n-    if ((u == 0) || (v == 0)) {\n-        return (Math.abs(u) + Math.abs(v));\n+    int u = Math.abs(p);\n+    int v = Math.abs(q);\n+    if (u == 0 || v == 0) {\n+        return u + v;\n     }\n-    // keep u and v negative, as negative integers range down to\n-    // -2^31, while positive numbers can only be as large as 2^31-1\n-    // (i.e. we can't necessarily negate a negative number without\n-    // overflow)\n-        if (u > 0) {\n-        u = -u;\n-    }\n-    // make u negative\n-    if (v > 0) {\n-        v = -v;\n-    }\n-    // make v negative\n-    // B1. [Find power of 2]\n     int k = 0;\n     while ((u & 1) == 0 && (v & 1) == 0 && k < 31) {\n-        // while u and v are\n-        // both even...\n         u /= 2;\n         v /= 2;\n-        // cast out twos.\n         k++;\n     }\n     if (k == 31) {\n         throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\", new Object[] { p, q });\n     }\n-    // B2. Initialize: u and v have been divided by 2^k and at least\n-    // one is odd.\n-    int t = ((u & 1) == 1) ? v : -(u / 2);\n-    // t negative: u was odd, v may be even (t replaces v)\n-    // t positive: u was even, v is odd (t replaces u)\n-    do {\n-                // B4/B3: cast out twos from t.\n-        while ((t & 1) == 0) {\n-            // while t is even..\n-            // cast out twos\n-            t /= 2;\n+    while (u != 0 && v != 0) {\n+        while ((u & 1) == 0) {\n+            u /= 2;\n         }\n-        // B5 [reset max(u,v)]\n-        if (t > 0) {\n-            u = -t;\n+        while ((v & 1) == 0) {\n+            v /= 2;\n+        }\n+        if (u >= v) {\n+            u -= v;\n         } else {\n-            v = t;\n+            v -= u;\n         }\n-        // B6/B3. at this point both u and v should be odd.\n-        t = (v - u) / 2;\n-        // |u| larger: t positive (replace u)\n-        // |v| larger: t negative (replace v)\n-    } while (t != 0);\n-    // gcd is u*2^k\n-    return -u * (1 << k);\n+    }\n+    return (u == 0) ? v * (1 << k) : u * (1 << k);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]