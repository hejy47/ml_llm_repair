[{"output": "void read(Tokeniser t, CharacterReader r) {\n    // previous TagOpen state did NOT consume, will have a letter char in current\n    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n    char c = r.consume();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        // intended fall through to next >\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case Tokeniser.replacementChar:\n            t.tagPending.appendTagName(Tokeniser.replacementStr);\n            break;\n        case CharacterReader.EOF:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            // buffer underrun\n            t.tagPending.appendTagName(c);\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -20,12 +20,10 @@\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case // replacement\n-        nullChar:\n-            t.tagPending.appendTagName(replacementStr);\n+        case Tokeniser.replacementChar:\n+            t.tagPending.appendTagName(Tokeniser.replacementStr);\n             break;\n-        case // should emit pending tag?\n-        eof:\n+        case CharacterReader.EOF:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,4 +1,8 @@\n void read(Tokeniser t, CharacterReader r) {\n+    // previous TagOpen state did NOT consume, will have a letter char in current\n+    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n+    String tagName = r.consumeTagName();\n+    t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -6,39 +10,25 @@\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n+        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+        case Tokeniser.replacementChar:\n+            t.tagPending.appendTagName(Tokeniser.replacementStr);\n             break;\n-        case eof:\n+        case CharacterReader.EOF:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n-            break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            // buffer underrun\n+            t.tagPending.appendTagName(c);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void read(Tokeniser t, CharacterReader r) {\n    // previous TagOpen state did NOT consume, will have a letter char in current\n    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n    char c = r.consume();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        // intended fall through to next >\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case 0: // replaced missing case with ASCII code for null\n            t.tagPending.appendTagName(replacementStr);\n            break;\n        case CharacterReader.EOF: // replaced missing case with CharacterReader.EOF\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            // buffer underrun\n            t.tagPending.appendTagName(c);\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -20,12 +20,10 @@\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case // replacement\n-        nullChar:\n+        case 0: // replaced missing case with ASCII code for null\n             t.tagPending.appendTagName(replacementStr);\n             break;\n-        case // should emit pending tag?\n-        eof:\n+        case CharacterReader.EOF: // replaced missing case with CharacterReader.EOF\n             t.eofError(this);\n             t.transition(Data);\n             break;\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,4 +1,8 @@\n void read(Tokeniser t, CharacterReader r) {\n+    // previous TagOpen state did NOT consume, will have a letter char in current\n+    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n+    String tagName = r.consumeTagName();\n+    t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -6,39 +10,25 @@\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n+        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+        case 0: // replaced missing case with ASCII code for null\n+            t.tagPending.appendTagName(replacementStr);\n             break;\n-        case eof:\n+        case CharacterReader.EOF: // replaced missing case with CharacterReader.EOF\n             t.eofError(this);\n             t.transition(Data);\n             break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n-            break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            // buffer underrun\n+            t.tagPending.appendTagName(c);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void read(Tokeniser t, CharacterReader r) {\n    // previous TagOpen state did NOT consume, will have a letter char in current\n    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n    char c = r.consume();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        // intended fall through to next >\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case CharacterReader.NULL:\n            t.tagPending.appendTagName(replacementStr);\n            break;\n        case CharacterReader.EOF:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            // buffer underrun\n            t.tagPending.appendTagName(c);\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -20,12 +20,10 @@\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case // replacement\n-        nullChar:\n+        case CharacterReader.NULL:\n             t.tagPending.appendTagName(replacementStr);\n             break;\n-        case // should emit pending tag?\n-        eof:\n+        case CharacterReader.EOF:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,4 +1,8 @@\n void read(Tokeniser t, CharacterReader r) {\n+    // previous TagOpen state did NOT consume, will have a letter char in current\n+    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n+    String tagName = r.consumeTagName();\n+    t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -6,39 +10,25 @@\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n+        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+        case CharacterReader.NULL:\n+            t.tagPending.appendTagName(replacementStr);\n             break;\n-        case eof:\n+        case CharacterReader.EOF:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n-            break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            // buffer underrun\n+            t.tagPending.appendTagName(c);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void read(Tokeniser t, CharacterReader r) {\n    // previous TagOpen state did NOT consume, will have a letter char in current\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n    char c = r.consume();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        // intended fall through to next >\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case '\\u0000':\n            t.error(this);\n            t.tagPending.appendTagName('\\uFFFD');\n            break;\n        case Tokeniser.EOF:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            // buffer underrun\n            t.tagPending.appendTagName(c);\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -1,6 +1,5 @@\n void read(Tokeniser t, CharacterReader r) {\n     // previous TagOpen state did NOT consume, will have a letter char in current\n-    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n     String tagName = r.consumeTagName();\n     t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n@@ -20,12 +19,11 @@\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case // replacement\n-        nullChar:\n-            t.tagPending.appendTagName(replacementStr);\n+        case '\\u0000':\n+            t.error(this);\n+            t.tagPending.appendTagName('\\uFFFD');\n             break;\n-        case // should emit pending tag?\n-        eof:\n+        case Tokeniser.EOF:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,4 +1,7 @@\n void read(Tokeniser t, CharacterReader r) {\n+    // previous TagOpen state did NOT consume, will have a letter char in current\n+    String tagName = r.consumeTagName();\n+    t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -6,39 +9,26 @@\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n+        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n+        case '\\u0000':\n             t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            t.tagPending.appendTagName('\\uFFFD');\n             break;\n-        case eof:\n+        case Tokeniser.EOF:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n-            break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            // buffer underrun\n+            t.tagPending.appendTagName(c);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void read(Tokeniser t, CharacterReader r) {\n    // previous TagOpen state did NOT consume, will have a letter char in current\n    String tagName = r.consumeTagName().toLowerCase(); // consumeTagName() method already returns lowercased string\n    t.tagPending.appendTagName(tagName);\n    char c = r.consume();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case CharacterReader.nullChar: // fixed null char syntax\n            t.tagPending.appendTagName(ReplacementChar); // fixed replacement character syntax\n            break;\n        case CharacterReader.EOF: // fixed EOF syntax\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            t.tagPending.appendTagName(c);\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -1,7 +1,6 @@\n void read(Tokeniser t, CharacterReader r) {\n     // previous TagOpen state did NOT consume, will have a letter char in current\n-    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n-    String tagName = r.consumeTagName();\n+    String tagName = r.consumeTagName().toLowerCase(); // consumeTagName() method already returns lowercased string\n     t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n     switch(c) {\n@@ -15,22 +14,18 @@\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case // replacement\n-        nullChar:\n-            t.tagPending.appendTagName(replacementStr);\n+        case CharacterReader.nullChar: // fixed null char syntax\n+            t.tagPending.appendTagName(ReplacementChar); // fixed replacement character syntax\n             break;\n-        case // should emit pending tag?\n-        eof:\n+        case CharacterReader.EOF: // fixed EOF syntax\n             t.eofError(this);\n             t.transition(Data);\n             break;\n         default:\n-            // buffer underrun\n             t.tagPending.appendTagName(c);\n     }\n }\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,4 +1,7 @@\n void read(Tokeniser t, CharacterReader r) {\n+    // previous TagOpen state did NOT consume, will have a letter char in current\n+    String tagName = r.consumeTagName().toLowerCase(); // consumeTagName() method already returns lowercased string\n+    t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -6,39 +9,23 @@\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+        case CharacterReader.nullChar: // fixed null char syntax\n+            t.tagPending.appendTagName(ReplacementChar); // fixed replacement character syntax\n             break;\n-        case eof:\n+        case CharacterReader.EOF: // fixed EOF syntax\n             t.eofError(this);\n             t.transition(Data);\n             break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n-            break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            t.tagPending.appendTagName(c);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void read(Tokeniser t, CharacterReader r) {\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n    char c = r.consume();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case Tokeniser.nullChar:\n            t.error(this);\n            t.tagPending.appendTagName(Tokeniser.replacementStr);\n            break;\n        case Tokeniser.eof:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            t.tagPending.appendTagName(c);\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -1,6 +1,4 @@\n void read(Tokeniser t, CharacterReader r) {\n-    // previous TagOpen state did NOT consume, will have a letter char in current\n-    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n     String tagName = r.consumeTagName();\n     t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n@@ -15,22 +13,19 @@\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case // replacement\n-        nullChar:\n-            t.tagPending.appendTagName(replacementStr);\n+        case Tokeniser.nullChar:\n+            t.error(this);\n+            t.tagPending.appendTagName(Tokeniser.replacementStr);\n             break;\n-        case // should emit pending tag?\n-        eof:\n+        case Tokeniser.eof:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n         default:\n-            // buffer underrun\n             t.tagPending.appendTagName(c);\n     }\n }\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,4 +1,6 @@\n void read(Tokeniser t, CharacterReader r) {\n+    String tagName = r.consumeTagName();\n+    t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -6,39 +8,24 @@\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n+        case Tokeniser.nullChar:\n             t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            t.tagPending.appendTagName(Tokeniser.replacementStr);\n             break;\n-        case eof:\n+        case Tokeniser.eof:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n-            break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            t.tagPending.appendTagName(c);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void read(Tokeniser t, CharacterReader r) {\n    // previous TagOpen state did NOT consume, will have a letter char in current\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n    if (r.isEmpty()) {\n        t.eofError(this);\n        t.transition(Data);\n        return;\n    }\n    char c = r.consume();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        // intended fall through to next >\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case '\\u0000':\n            t.tagPending.appendTagName('\\uFFFD');\n            break;\n        default:\n            // buffer underrun\n            t.tagPending.appendTagName(c);\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -1,8 +1,12 @@\n void read(Tokeniser t, CharacterReader r) {\n     // previous TagOpen state did NOT consume, will have a letter char in current\n-    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n     String tagName = r.consumeTagName();\n     t.tagPending.appendTagName(tagName);\n+    if (r.isEmpty()) {\n+        t.eofError(this);\n+        t.transition(Data);\n+        return;\n+    }\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -20,14 +24,8 @@\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case // replacement\n-        nullChar:\n-            t.tagPending.appendTagName(replacementStr);\n-            break;\n-        case // should emit pending tag?\n-        eof:\n-            t.eofError(this);\n-            t.transition(Data);\n+        case '\\u0000':\n+            t.tagPending.appendTagName('\\uFFFD');\n             break;\n         default:\n             // buffer underrun\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,4 +1,12 @@\n void read(Tokeniser t, CharacterReader r) {\n+    // previous TagOpen state did NOT consume, will have a letter char in current\n+    String tagName = r.consumeTagName();\n+    t.tagPending.appendTagName(tagName);\n+    if (r.isEmpty()) {\n+        t.eofError(this);\n+        t.transition(Data);\n+        return;\n+    }\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -6,39 +14,21 @@\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n+        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n-            break;\n-        case eof:\n-            t.eofError(this);\n-            t.transition(Data);\n-            break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n+        case '\\u0000':\n+            t.tagPending.appendTagName('\\uFFFD');\n             break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            // buffer underrun\n+            t.tagPending.appendTagName(c);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void read(Tokeniser t, CharacterReader r) {\n    // previous TagOpen state did NOT consume, will have a letter char in current\n    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n    char c = r.consume();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        // intended fall through to next >\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case '\\u0000': // replace with unicode escape\n            t.tagPending.appendTagName(\"\\uFFFD\"); // use replacement unicode character\n            break;\n        case // should emit pending tag?\n        eof:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            // buffer underrun\n            t.tagPending.appendTagName(c);\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -20,9 +20,8 @@\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case // replacement\n-        nullChar:\n-            t.tagPending.appendTagName(replacementStr);\n+        case '\\u0000': // replace with unicode escape\n+            t.tagPending.appendTagName(\"\\uFFFD\"); // use replacement unicode character\n             break;\n         case // should emit pending tag?\n         eof:\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,4 +1,8 @@\n void read(Tokeniser t, CharacterReader r) {\n+    // previous TagOpen state did NOT consume, will have a letter char in current\n+    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n+    String tagName = r.consumeTagName();\n+    t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -6,39 +10,26 @@\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n+        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+        case '\\u0000': // replace with unicode escape\n+            t.tagPending.appendTagName(\"\\uFFFD\"); // use replacement unicode character\n             break;\n-        case eof:\n+        case // should emit pending tag?\n+        eof:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n-            break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            // buffer underrun\n+            t.tagPending.appendTagName(c);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void read(Tokeniser t, CharacterReader r) {\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n    char c = r.consume();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        // intended fall through to next >\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case CharacterReader.NULL:\n            t.tagPending.appendTagName(replacementStr);\n            break;\n        case CharacterReader.EOF:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            // buffer underrun\n            t.tagPending.appendTagName(c);\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -1,6 +1,4 @@\n void read(Tokeniser t, CharacterReader r) {\n-    // previous TagOpen state did NOT consume, will have a letter char in current\n-    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n     String tagName = r.consumeTagName();\n     t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n@@ -20,12 +18,10 @@\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case // replacement\n-        nullChar:\n+        case CharacterReader.NULL:\n             t.tagPending.appendTagName(replacementStr);\n             break;\n-        case // should emit pending tag?\n-        eof:\n+        case CharacterReader.EOF:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,4 +1,6 @@\n void read(Tokeniser t, CharacterReader r) {\n+    String tagName = r.consumeTagName();\n+    t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -6,39 +8,25 @@\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n+        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+        case CharacterReader.NULL:\n+            t.tagPending.appendTagName(replacementStr);\n             break;\n-        case eof:\n+        case CharacterReader.EOF:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n-            break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            // buffer underrun\n+            t.tagPending.appendTagName(c);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void read(Tokeniser t, CharacterReader r) {\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n    char c = r.consume();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case 0:\n            t.tagPending.appendTagName(replacementStr);\n            break;\n        case CharacterReader.EOF:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            t.tagPending.appendTagName(c);\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -1,6 +1,4 @@\n void read(Tokeniser t, CharacterReader r) {\n-    // previous TagOpen state did NOT consume, will have a letter char in current\n-    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n     String tagName = r.consumeTagName();\n     t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n@@ -15,22 +13,18 @@\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case // replacement\n-        nullChar:\n+        case 0:\n             t.tagPending.appendTagName(replacementStr);\n             break;\n-        case // should emit pending tag?\n-        eof:\n+        case CharacterReader.EOF:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n         default:\n-            // buffer underrun\n             t.tagPending.appendTagName(c);\n     }\n }\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,4 +1,6 @@\n void read(Tokeniser t, CharacterReader r) {\n+    String tagName = r.consumeTagName();\n+    t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -6,39 +8,23 @@\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+        case 0:\n+            t.tagPending.appendTagName(replacementStr);\n             break;\n-        case eof:\n+        case CharacterReader.EOF:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n-            break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            t.tagPending.appendTagName(c);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void read(Tokeniser t, CharacterReader r) {\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n    char c = r.consume();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case CharacterReader.NULL:\n            t.tagPending.appendTagName(replacementStr);\n            break;\n        case CharacterReader.EOF:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            t.tagPending.appendTagName(c);\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -1,6 +1,4 @@\n void read(Tokeniser t, CharacterReader r) {\n-    // previous TagOpen state did NOT consume, will have a letter char in current\n-    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n     String tagName = r.consumeTagName();\n     t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n@@ -15,22 +13,18 @@\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case // replacement\n-        nullChar:\n+        case CharacterReader.NULL:\n             t.tagPending.appendTagName(replacementStr);\n             break;\n-        case // should emit pending tag?\n-        eof:\n+        case CharacterReader.EOF:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n         default:\n-            // buffer underrun\n             t.tagPending.appendTagName(c);\n     }\n }\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,4 +1,6 @@\n void read(Tokeniser t, CharacterReader r) {\n+    String tagName = r.consumeTagName();\n+    t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -6,39 +8,23 @@\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+        case CharacterReader.NULL:\n+            t.tagPending.appendTagName(replacementStr);\n             break;\n-        case eof:\n+        case CharacterReader.EOF:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n-            break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            t.tagPending.appendTagName(c);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "void read(Tokeniser t, CharacterReader r) {\n    // previous TagOpen state did NOT consume, will have a letter char in current\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n    if (r.isEmpty()) {\n        t.eofError(this);\n        t.transition(Data);\n        return;\n    }\n    char c = r.consume();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        // intended fall through to next >\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case 0:\n            t.tagPending.appendTagName(replacementStr);\n            break;\n        default:\n            // buffer underrun\n            t.tagPending.appendTagName(c);\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -1,8 +1,12 @@\n void read(Tokeniser t, CharacterReader r) {\n     // previous TagOpen state did NOT consume, will have a letter char in current\n-    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n     String tagName = r.consumeTagName();\n     t.tagPending.appendTagName(tagName);\n+    if (r.isEmpty()) {\n+        t.eofError(this);\n+        t.transition(Data);\n+        return;\n+    }\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -20,14 +24,8 @@\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case // replacement\n-        nullChar:\n+        case 0:\n             t.tagPending.appendTagName(replacementStr);\n-            break;\n-        case // should emit pending tag?\n-        eof:\n-            t.eofError(this);\n-            t.transition(Data);\n             break;\n         default:\n             // buffer underrun\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,4 +1,12 @@\n void read(Tokeniser t, CharacterReader r) {\n+    // previous TagOpen state did NOT consume, will have a letter char in current\n+    String tagName = r.consumeTagName();\n+    t.tagPending.appendTagName(tagName);\n+    if (r.isEmpty()) {\n+        t.eofError(this);\n+        t.transition(Data);\n+        return;\n+    }\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -6,39 +14,21 @@\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n+        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n-            break;\n-        case eof:\n-            t.eofError(this);\n-            t.transition(Data);\n-            break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n+        case 0:\n+            t.tagPending.appendTagName(replacementStr);\n             break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            // buffer underrun\n+            t.tagPending.appendTagName(c);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void read(Tokeniser t, CharacterReader r) {\n    // previous TagOpen state did NOT consume, will have a letter char in current\n    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n    char c = r.consume();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        // intended fall through to next >\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case '\\u0000': // replaced nullChar with correct escape sequence\n            t.tagPending.appendTagName(replacementStr);\n            break;\n        case CharacterReader.EOF: // replaced eof with correct escape sequence\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            // buffer underrun\n            t.tagPending.appendTagName(c);\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -20,12 +20,10 @@\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case // replacement\n-        nullChar:\n+        case '\\u0000': // replaced nullChar with correct escape sequence\n             t.tagPending.appendTagName(replacementStr);\n             break;\n-        case // should emit pending tag?\n-        eof:\n+        case CharacterReader.EOF: // replaced eof with correct escape sequence\n             t.eofError(this);\n             t.transition(Data);\n             break;\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,4 +1,8 @@\n void read(Tokeniser t, CharacterReader r) {\n+    // previous TagOpen state did NOT consume, will have a letter char in current\n+    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n+    String tagName = r.consumeTagName();\n+    t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -6,39 +10,25 @@\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n+        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+        case '\\u0000': // replaced nullChar with correct escape sequence\n+            t.tagPending.appendTagName(replacementStr);\n             break;\n-        case eof:\n+        case CharacterReader.EOF: // replaced eof with correct escape sequence\n             t.eofError(this);\n             t.transition(Data);\n             break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n-            break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            // buffer underrun\n+            t.tagPending.appendTagName(c);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void read(Tokeniser t, CharacterReader r) {\n    // previous TagOpen state did NOT consume, will have a letter char in current\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n    char c = r.consume();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case CharacterReader.EOF:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            if (c == CharacterReader.NULL) {\n                t.tagPending.appendTagName(replacementStr);\n            } else {\n                t.tagPending.appendTagName(c);\n            }\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -1,6 +1,5 @@\n void read(Tokeniser t, CharacterReader r) {\n     // previous TagOpen state did NOT consume, will have a letter char in current\n-    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n     String tagName = r.consumeTagName();\n     t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n@@ -15,22 +14,19 @@\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case // replacement\n-        nullChar:\n-            t.tagPending.appendTagName(replacementStr);\n-            break;\n-        case // should emit pending tag?\n-        eof:\n+        case CharacterReader.EOF:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n         default:\n-            // buffer underrun\n-            t.tagPending.appendTagName(c);\n+            if (c == CharacterReader.NULL) {\n+                t.tagPending.appendTagName(replacementStr);\n+            } else {\n+                t.tagPending.appendTagName(c);\n+            }\n     }\n }\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,4 +1,7 @@\n void read(Tokeniser t, CharacterReader r) {\n+    // previous TagOpen state did NOT consume, will have a letter char in current\n+    String tagName = r.consumeTagName();\n+    t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -6,39 +9,24 @@\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n-            break;\n-        case eof:\n+        case CharacterReader.EOF:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n-            break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            if (c == CharacterReader.NULL) {\n+                t.tagPending.appendTagName(replacementStr);\n+            } else {\n+                t.tagPending.appendTagName(c);\n+            }\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void read(Tokeniser t, CharacterReader r) {\n    // previous TagOpen state did NOT consume, will have a letter char in current\n    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n    char c = r.consume();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        // intended fall through to next >\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case Tokeniser.nullChar:\n            t.tagPending.appendTagName(\"\\uFFFD\");\n            break;\n        case Tokeniser.eof:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            // buffer underrun\n            t.tagPending.appendTagName(c);\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -20,12 +20,10 @@\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case // replacement\n-        nullChar:\n-            t.tagPending.appendTagName(replacementStr);\n+        case Tokeniser.nullChar:\n+            t.tagPending.appendTagName(\"\\uFFFD\");\n             break;\n-        case // should emit pending tag?\n-        eof:\n+        case Tokeniser.eof:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,4 +1,8 @@\n void read(Tokeniser t, CharacterReader r) {\n+    // previous TagOpen state did NOT consume, will have a letter char in current\n+    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n+    String tagName = r.consumeTagName();\n+    t.tagPending.appendTagName(tagName);\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -6,39 +10,25 @@\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n+        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+        case Tokeniser.nullChar:\n+            t.tagPending.appendTagName(\"\\uFFFD\");\n             break;\n-        case eof:\n+        case Tokeniser.eof:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n-            break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            // buffer underrun\n+            t.tagPending.appendTagName(c);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void read(Tokeniser t, CharacterReader r) {\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName.toLowerCase());\n    char c = r.consume();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        // intended fall through to next >\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case 0xFFFD:\n            t.tagPending.appendTagName(\"\\uFFFD\");\n            break;\n        case CharacterReader.EOF:\n            t.eofError(this);\n            t.transition(Data);\n            break;\n        default:\n            // buffer underrun\n            t.tagPending.appendTagName(c);\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -1,8 +1,6 @@\n void read(Tokeniser t, CharacterReader r) {\n-    // previous TagOpen state did NOT consume, will have a letter char in current\n-    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n     String tagName = r.consumeTagName();\n-    t.tagPending.appendTagName(tagName);\n+    t.tagPending.appendTagName(tagName.toLowerCase());\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -20,12 +18,10 @@\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case // replacement\n-        nullChar:\n-            t.tagPending.appendTagName(replacementStr);\n+        case 0xFFFD:\n+            t.tagPending.appendTagName(\"\\uFFFD\");\n             break;\n-        case // should emit pending tag?\n-        eof:\n+        case CharacterReader.EOF:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,4 +1,6 @@\n void read(Tokeniser t, CharacterReader r) {\n+    String tagName = r.consumeTagName();\n+    t.tagPending.appendTagName(tagName.toLowerCase());\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -6,39 +8,25 @@\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n+        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+        case 0xFFFD:\n+            t.tagPending.appendTagName(\"\\uFFFD\");\n             break;\n-        case eof:\n+        case CharacterReader.EOF:\n             t.eofError(this);\n             t.transition(Data);\n             break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n-            break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            // buffer underrun\n+            t.tagPending.appendTagName(c);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void read(Tokeniser t, CharacterReader r) {\n    // previous TagOpen state did NOT consume, will have a letter char in current\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n    if(r.isEmpty()) {\n        t.eofError(this);\n        t.transition(Data);\n        return;\n    }\n    char c = r.current();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        // intended fall through to next >\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case '\\u0000':\n            t.tagPending.appendTagName('\\uFFFD');\n            r.advance();\n            break;\n        default:\n            // buffer underrun\n            t.tagPending.appendTagName(c);\n            r.advance();\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -1,9 +1,13 @@\n void read(Tokeniser t, CharacterReader r) {\n     // previous TagOpen state did NOT consume, will have a letter char in current\n-    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n     String tagName = r.consumeTagName();\n     t.tagPending.appendTagName(tagName);\n-    char c = r.consume();\n+    if(r.isEmpty()) {\n+        t.eofError(this);\n+        t.transition(Data);\n+        return;\n+    }\n+    char c = r.current();\n     switch(c) {\n         case '\\t':\n         case '\\n':\n@@ -20,17 +24,13 @@\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case // replacement\n-        nullChar:\n-            t.tagPending.appendTagName(replacementStr);\n-            break;\n-        case // should emit pending tag?\n-        eof:\n-            t.eofError(this);\n-            t.transition(Data);\n+        case '\\u0000':\n+            t.tagPending.appendTagName('\\uFFFD');\n+            r.advance();\n             break;\n         default:\n             // buffer underrun\n             t.tagPending.appendTagName(c);\n+            r.advance();\n     }\n }\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,44 +1,36 @@\n void read(Tokeniser t, CharacterReader r) {\n-    char c = r.consume();\n+    // previous TagOpen state did NOT consume, will have a letter char in current\n+    String tagName = r.consumeTagName();\n+    t.tagPending.appendTagName(tagName);\n+    if(r.isEmpty()) {\n+        t.eofError(this);\n+        t.transition(Data);\n+        return;\n+    }\n+    char c = r.current();\n     switch(c) {\n         case '\\t':\n         case '\\n':\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n+        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n-            break;\n-        case eof:\n-            t.eofError(this);\n-            t.transition(Data);\n-            break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n+        case '\\u0000':\n+            t.tagPending.appendTagName('\\uFFFD');\n+            r.advance();\n             break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            // buffer underrun\n+            t.tagPending.appendTagName(c);\n+            r.advance();\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void read(Tokeniser t, CharacterReader r) {\n    // previous TagOpen state did NOT consume, will have a letter char in current\n    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n    if (r.isEmpty()) {\n        t.eofError(this);\n        t.transition(Data);\n        return;\n    }\n    char c = r.current();\n    r.advance();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        // intended fall through to next >\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case // replacement\n        nullChar:\n            t.tagPending.appendTagName(replacementStr);\n            break;\n        default:\n            // buffer underrun\n            t.tagPending.appendTagName(c);\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -3,7 +3,13 @@\n     //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n     String tagName = r.consumeTagName();\n     t.tagPending.appendTagName(tagName);\n-    char c = r.consume();\n+    if (r.isEmpty()) {\n+        t.eofError(this);\n+        t.transition(Data);\n+        return;\n+    }\n+    char c = r.current();\n+    r.advance();\n     switch(c) {\n         case '\\t':\n         case '\\n':\n@@ -24,11 +30,6 @@\n         nullChar:\n             t.tagPending.appendTagName(replacementStr);\n             break;\n-        case // should emit pending tag?\n-        eof:\n-            t.eofError(this);\n-            t.transition(Data);\n-            break;\n         default:\n             // buffer underrun\n             t.tagPending.appendTagName(c);\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,44 +1,37 @@\n void read(Tokeniser t, CharacterReader r) {\n-    char c = r.consume();\n+    // previous TagOpen state did NOT consume, will have a letter char in current\n+    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n+    String tagName = r.consumeTagName();\n+    t.tagPending.appendTagName(tagName);\n+    if (r.isEmpty()) {\n+        t.eofError(this);\n+        t.transition(Data);\n+        return;\n+    }\n+    char c = r.current();\n+    r.advance();\n     switch(c) {\n         case '\\t':\n         case '\\n':\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n+        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n-            break;\n-        case eof:\n-            t.eofError(this);\n-            t.transition(Data);\n-            break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n+        case // replacement\n+        nullChar:\n+            t.tagPending.appendTagName(replacementStr);\n             break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            // buffer underrun\n+            t.tagPending.appendTagName(c);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "void read(Tokeniser t, CharacterReader r) {\n    String tagName = r.consumeTagName();\n    t.tagPending.appendTagName(tagName);\n    if (r.isEmpty()) {\n        t.eofError(this);\n        t.transition(Data);\n        return;\n    }\n    char c = r.consume();\n    switch(c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case ' ':\n            t.transition(BeforeAttributeName);\n            break;\n        case '/':\n            t.transition(SelfClosingStartTag);\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case '\\u0000':\n            t.tagPending.appendTagName(replacementStr);\n            break;\n        default:\n            t.tagPending.appendTagName(c);\n    }\n}", "diff": "--- org/jsoup/parser/TokeniserState.java@read\n+++ org/jsoup/parser/TokeniserState.java@read\n@@ -1,8 +1,11 @@\n void read(Tokeniser t, CharacterReader r) {\n-    // previous TagOpen state did NOT consume, will have a letter char in current\n-    //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n     String tagName = r.consumeTagName();\n     t.tagPending.appendTagName(tagName);\n+    if (r.isEmpty()) {\n+        t.eofError(this);\n+        t.transition(Data);\n+        return;\n+    }\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -15,22 +18,14 @@\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through to next >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case // replacement\n-        nullChar:\n+        case '\\u0000':\n             t.tagPending.appendTagName(replacementStr);\n             break;\n-        case // should emit pending tag?\n-        eof:\n-            t.eofError(this);\n-            t.transition(Data);\n-            break;\n         default:\n-            // buffer underrun\n             t.tagPending.appendTagName(c);\n     }\n }\n--- org/jsoup/parser/TokeniserState.java@read1\n+++ org/jsoup/parser/TokeniserState.java@read1\n@@ -1,4 +1,11 @@\n void read(Tokeniser t, CharacterReader r) {\n+    String tagName = r.consumeTagName();\n+    t.tagPending.appendTagName(tagName);\n+    if (r.isEmpty()) {\n+        t.eofError(this);\n+        t.transition(Data);\n+        return;\n+    }\n     char c = r.consume();\n     switch(c) {\n         case '\\t':\n@@ -6,39 +13,19 @@\n         case '\\r':\n         case '\\f':\n         case ' ':\n-            // ignore whitespace\n+            t.transition(BeforeAttributeName);\n             break;\n         case '/':\n             t.transition(SelfClosingStartTag);\n             break;\n-        // intended fall through as if >\n         case '>':\n             t.emitTagPending();\n             t.transition(Data);\n             break;\n-        case nullChar:\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n-            break;\n-        case eof:\n-            t.eofError(this);\n-            t.transition(Data);\n-            break;\n-        case '\"':\n-        case '\\'':\n-        case '<':\n-        case '=':\n-            t.error(this);\n-            t.tagPending.newAttribute();\n-            t.tagPending.appendAttributeName(c);\n-            t.transition(AttributeName);\n+        case '\\u0000':\n+            t.tagPending.appendTagName(replacementStr);\n             break;\n         default:\n-            // A-Z, anything else\n-            t.tagPending.newAttribute();\n-            r.unconsume();\n-            t.transition(AttributeName);\n+            t.tagPending.appendTagName(c);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]