[{"output": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    long result = Math.round(binomialCoefficientDouble(n, k));\n    if (result == Long.MAX_VALUE) {\n        throw new ArithmeticException(\"result too large to represent in a long integer\");\n    }\n    // Use symmetry for large k\n    // We use the formula\n    // (n choose k) = n! / (n-k)! / k!\n    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n    // which could be written\n    // (n choose k) == (n-1 choose k-1) * n / k\n    // For n <= 61, the naive implementation cannot overflow.\n    // For n > 61 but n <= 66, the result cannot overflow,\n    // but we must take care not to overflow intermediate values.\n    // We know that (result * i) is divisible by j,\n    // but (result * i) may overflow, so we split j:\n    // Filter out the gcd, d, so j/d and i/d are integer.\n    // result is divisible by (j/d) because (j/d)\n    // is relative prime to (i/d) and is a divisor of\n    // result * (i/d).\n    // For n > 66, a result overflow might occur, so we check\n    // the multiplication, taking care to not overflow\n    // unnecessary.\n    if (n > 66) {\n        throw new IllegalArgumentException(\"this function doesn't support n greater than 66\");\n    }\n    return result;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -33,5 +33,8 @@\n     // For n > 66, a result overflow might occur, so we check\n     // the multiplication, taking care to not overflow\n     // unnecessary.\n+    if (n > 66) {\n+        throw new IllegalArgumentException(\"this function doesn't support n greater than 66\");\n+    }\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    long result = binomialCoefficientDouble(n, k);\n    if (result < Long.MAX_VALUE) {\n        result = Math.round(result);\n    } else {\n        // Use symmetry for large k\n        // We use the formula\n        // (n choose k) = n! / (n-k)! / k!\n        // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n        // which could be written\n        // (n choose k) == (n-1 choose k-1) * n / k\n        // For n <= 61, the naive implementation cannot overflow.\n        // For n > 61 but n <= 66, the result cannot overflow,\n        // but we must take care not to overflow intermediate values.\n        // We know that (result * i) is divisible by j,\n        // but (result * i) may overflow, so we split j:\n        // Filter out the gcd, d, so j/d and i/d are integer.\n        // result is divisible by (j/d) because (j/d)\n        // is relative prime to (i/d) and is a divisor of\n        // result * (i/d).\n        // For n > 66, a result overflow might occur, so we check\n        // the multiplication, taking care to not overflow\n        // unnecessary.\n        if (k > n / 2) {\n            return binomialCoefficient(n, n - k);\n        }\n        result = 1;\n        for (int i = 1; i <= k; i++) {\n            result *= n - k + i;\n            result /= i;\n        }\n    }\n    if (result == Long.MAX_VALUE) {\n        throw new ArithmeticException(\"result too large to represent in a long integer\");\n    }\n    return result;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -11,27 +11,39 @@\n     if ((k == 1) || (k == n - 1)) {\n         return n;\n     }\n-    long result = Math.round(binomialCoefficientDouble(n, k));\n+    long result = binomialCoefficientDouble(n, k);\n+    if (result < Long.MAX_VALUE) {\n+        result = Math.round(result);\n+    } else {\n+        // Use symmetry for large k\n+        // We use the formula\n+        // (n choose k) = n! / (n-k)! / k!\n+        // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n+        // which could be written\n+        // (n choose k) == (n-1 choose k-1) * n / k\n+        // For n <= 61, the naive implementation cannot overflow.\n+        // For n > 61 but n <= 66, the result cannot overflow,\n+        // but we must take care not to overflow intermediate values.\n+        // We know that (result * i) is divisible by j,\n+        // but (result * i) may overflow, so we split j:\n+        // Filter out the gcd, d, so j/d and i/d are integer.\n+        // result is divisible by (j/d) because (j/d)\n+        // is relative prime to (i/d) and is a divisor of\n+        // result * (i/d).\n+        // For n > 66, a result overflow might occur, so we check\n+        // the multiplication, taking care to not overflow\n+        // unnecessary.\n+        if (k > n / 2) {\n+            return binomialCoefficient(n, n - k);\n+        }\n+        result = 1;\n+        for (int i = 1; i <= k; i++) {\n+            result *= n - k + i;\n+            result /= i;\n+        }\n+    }\n     if (result == Long.MAX_VALUE) {\n         throw new ArithmeticException(\"result too large to represent in a long integer\");\n     }\n-    // Use symmetry for large k\n-    // We use the formula\n-    // (n choose k) = n! / (n-k)! / k!\n-    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n-    // which could be written\n-    // (n choose k) == (n-1 choose k-1) * n / k\n-    // For n <= 61, the naive implementation cannot overflow.\n-    // For n > 61 but n <= 66, the result cannot overflow,\n-    // but we must take care not to overflow intermediate values.\n-    // We know that (result * i) is divisible by j,\n-    // but (result * i) may overflow, so we split j:\n-    // Filter out the gcd, d, so j/d and i/d are integer.\n-    // result is divisible by (j/d) because (j/d)\n-    // is relative prime to (i/d) and is a divisor of\n-    // result * (i/d).\n-    // For n > 66, a result overflow might occur, so we check\n-    // the multiplication, taking care to not overflow\n-    // unnecessary.\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    long result = Math.round(binomialCoefficientDouble(n, k));\n    if (result == Long.MAX_VALUE) {\n        throw new ArithmeticException(\"result too large to represent in a long integer\");\n    }\n    // Use symmetry for large k\n    // We use the formula\n    // (n choose k) = n! / (n-k)! / k!\n    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n    // which could be written\n    // (n choose k) == (n-1 choose k-1) * n / k\n    // For n <= 61, the naive implementation cannot overflow.\n    // For n > 61 but n <= 66, the result cannot overflow,\n    // but we must take care not to overflow intermediate values.\n    // We know that (result * i) is divisible by j,\n    // but (result * i) may overflow, so we split j:\n    // Filter out the gcd, d, so j/d and i/d are integer.\n    // result is divisible by (j/d) because (j/d)\n    // is relative prime to (i/d) and is a divisor of\n    // result * (i/d).\n    // For n > 66, a result overflow might occur, so we check\n    // the multiplication, taking care to not overflow\n    // unnecessary.\n    if (n > 66) {\n        int maxK = n - k > k ? n - k : k;\n        int minK = n - k > k ? k : n - k;\n        long numerator = 1;\n        long denominator = 1;\n        for (int i = 1; i <= minK; i++) {\n            numerator *= (n - maxK + i);\n            denominator *= i;\n            if ((numerator % denominator) == 0) {\n                numerator /= denominator;\n                denominator = 1;\n            }\n        }\n        result = numerator / denominator;\n    }\n    return result;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -33,5 +33,20 @@\n     // For n > 66, a result overflow might occur, so we check\n     // the multiplication, taking care to not overflow\n     // unnecessary.\n+    if (n > 66) {\n+        int maxK = n - k > k ? n - k : k;\n+        int minK = n - k > k ? k : n - k;\n+        long numerator = 1;\n+        long denominator = 1;\n+        for (int i = 1; i <= minK; i++) {\n+            numerator *= (n - maxK + i);\n+            denominator *= i;\n+            if ((numerator % denominator) == 0) {\n+                numerator /= denominator;\n+                denominator = 1;\n+            }\n+        }\n+        result = numerator / denominator;\n+    }\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    long result = Math.round(binomialCoefficientDouble(n, k));\n    if (result == Long.MAX_VALUE) {\n        throw new ArithmeticException(\"result too large to represent in a long integer\");\n    }\n    // Use symmetry for large k\n    // We use the formula\n    // (n choose k) = n! / (n-k)! / k!\n    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n    // which could be written\n    // (n choose k) == (n-1 choose k-1) * n / k\n    // For n <= 61, the naive implementation cannot overflow.\n    // For n > 61 but n <= 66, the result cannot overflow,\n    // but we must take care not to overflow intermediate values.\n    // We know that (result * i) is divisible by j,\n    // but (result * i) may overflow, so we split j:\n    // Filter out the gcd, d, so j/d and i/d are integer.\n    // result is divisible by (j/d) because (j/d)\n    // is relative prime to (i/d) and is a divisor of\n    // result * (i/d).\n    // For n > 66, a result overflow might occur, so we check\n    // the multiplication, taking care to not overflow\n    // unnecessary.\n    if (n > 66) {\n        int d = gcd(k, n - k);\n        long r = 1;\n        for (int i = 1; i <= k / d; i++) {\n            int ni = n - k + i;\n            int di = i;\n            if (ni % d == 0) {\n                ni /= d;\n                di /= d;\n            }\n            r = r * ni / di;\n        }\n        result = r;\n    }\n    return result;\n}\n\n// Helper method for finding the gcd of two numbers\nprivate static int gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -33,5 +33,19 @@\n     // For n > 66, a result overflow might occur, so we check\n     // the multiplication, taking care to not overflow\n     // unnecessary.\n+    if (n > 66) {\n+        int d = gcd(k, n - k);\n+        long r = 1;\n+        for (int i = 1; i <= k / d; i++) {\n+            int ni = n - k + i;\n+            int di = i;\n+            if (ni % d == 0) {\n+                ni /= d;\n+                di /= d;\n+            }\n+            r = r * ni / di;\n+        }\n+        result = r;\n+    }\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    long result = Math.round(binomialCoefficientDouble(n, k));\n    if (result == Long.MAX_VALUE) {\n        throw new ArithmeticException(\"result too large to represent in a long integer\");\n    }\n    // Use symmetry for large k\n    // We use the formula\n    // (n choose k) = n! / (n-k)! / k!\n    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n    // which could be written\n    // (n choose k) == (n-1 choose k-1) * n / k\n    // For n <= 61, the naive implementation cannot overflow.\n    // For n > 61 but n <= 66, the result cannot overflow,\n    // but we must take care not to overflow intermediate values.\n    // We know that (result * (n - i + 1)) is divisible by i,\n    // but (result * (n - i + 1)) may overflow, so we split i:\n    for (int i = 1; i <= k; i++) {\n        long gcd = gcd(i, n - k + i);\n        result = (result / (n - k + i) * (n - i + 1) / (i / gcd));\n    }\n    // For n > 66, a result overflow might occur, so we check\n    // the multiplication, taking care to not overflow\n    // unnecessary.\n    if (result > Long.MAX_VALUE / (n + 1) * k / (n - k + 1)) {\n        throw new ArithmeticException(\"result too large to represent in a long integer\");\n    }\n    return result;\n}\n\n// utility function to calculate gcd\nprivate static long gcd(long a, long b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -24,14 +24,17 @@\n     // For n <= 61, the naive implementation cannot overflow.\n     // For n > 61 but n <= 66, the result cannot overflow,\n     // but we must take care not to overflow intermediate values.\n-    // We know that (result * i) is divisible by j,\n-    // but (result * i) may overflow, so we split j:\n-    // Filter out the gcd, d, so j/d and i/d are integer.\n-    // result is divisible by (j/d) because (j/d)\n-    // is relative prime to (i/d) and is a divisor of\n-    // result * (i/d).\n+    // We know that (result * (n - i + 1)) is divisible by i,\n+    // but (result * (n - i + 1)) may overflow, so we split i:\n+    for (int i = 1; i <= k; i++) {\n+        long gcd = gcd(i, n - k + i);\n+        result = (result / (n - k + i) * (n - i + 1) / (i / gcd));\n+    }\n     // For n > 66, a result overflow might occur, so we check\n     // the multiplication, taking care to not overflow\n     // unnecessary.\n+    if (result > Long.MAX_VALUE / (n + 1) * k / (n - k + 1)) {\n+        throw new ArithmeticException(\"result too large to represent in a long integer\");\n+    }\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private static final int MAX_SAFELY_MULTIPLIED = Long.MAX_VALUE / 31;\n\npublic static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    if (k > n / 2) {\n        return binomialCoefficient(n, n - k);\n    }\n\n    long result = 1;\n    for (int i = 1; i <= k; i++) {\n        if (result > MAX_SAFELY_MULTIPLIED) {\n            // Take care to not overflow.\n            // We know that (result * i / j) is an integer,\n            // so we put j in numerator to avoid division.\n            int d = Integer.parseInt(GreatestCommonDivisor.gcd(i, n - k + i).toString());\n            result = result / d * (n - k + i) / (i / d);\n        } else {\n            result *= n - k + i;\n            result /= i;\n        }\n    }\n    return result;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -11,27 +11,22 @@\n     if ((k == 1) || (k == n - 1)) {\n         return n;\n     }\n-    long result = Math.round(binomialCoefficientDouble(n, k));\n-    if (result == Long.MAX_VALUE) {\n-        throw new ArithmeticException(\"result too large to represent in a long integer\");\n+    if (k > n / 2) {\n+        return binomialCoefficient(n, n - k);\n     }\n-    // Use symmetry for large k\n-    // We use the formula\n-    // (n choose k) = n! / (n-k)! / k!\n-    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n-    // which could be written\n-    // (n choose k) == (n-1 choose k-1) * n / k\n-    // For n <= 61, the naive implementation cannot overflow.\n-    // For n > 61 but n <= 66, the result cannot overflow,\n-    // but we must take care not to overflow intermediate values.\n-    // We know that (result * i) is divisible by j,\n-    // but (result * i) may overflow, so we split j:\n-    // Filter out the gcd, d, so j/d and i/d are integer.\n-    // result is divisible by (j/d) because (j/d)\n-    // is relative prime to (i/d) and is a divisor of\n-    // result * (i/d).\n-    // For n > 66, a result overflow might occur, so we check\n-    // the multiplication, taking care to not overflow\n-    // unnecessary.\n+\n+    long result = 1;\n+    for (int i = 1; i <= k; i++) {\n+        if (result > MAX_SAFELY_MULTIPLIED) {\n+            // Take care to not overflow.\n+            // We know that (result * i / j) is an integer,\n+            // so we put j in numerator to avoid division.\n+            int d = Integer.parseInt(GreatestCommonDivisor.gcd(i, n - k + i).toString());\n+            result = result / d * (n - k + i) / (i / d);\n+        } else {\n+            result *= n - k + i;\n+            result /= i;\n+        }\n+    }\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    if (k > n - k) { // Use symmetry for large k\n        return binomialCoefficient(n, n - k);\n    }\n    // Calculate binomial coefficient using iterative formula to avoid overflow\n    long result = 1;\n    for (int i = 0; i < k; i++) {\n        result *= n - i;\n        result /= i + 1;\n    }\n    return result;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -11,27 +11,14 @@\n     if ((k == 1) || (k == n - 1)) {\n         return n;\n     }\n-    long result = Math.round(binomialCoefficientDouble(n, k));\n-    if (result == Long.MAX_VALUE) {\n-        throw new ArithmeticException(\"result too large to represent in a long integer\");\n+    if (k > n - k) { // Use symmetry for large k\n+        return binomialCoefficient(n, n - k);\n     }\n-    // Use symmetry for large k\n-    // We use the formula\n-    // (n choose k) = n! / (n-k)! / k!\n-    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n-    // which could be written\n-    // (n choose k) == (n-1 choose k-1) * n / k\n-    // For n <= 61, the naive implementation cannot overflow.\n-    // For n > 61 but n <= 66, the result cannot overflow,\n-    // but we must take care not to overflow intermediate values.\n-    // We know that (result * i) is divisible by j,\n-    // but (result * i) may overflow, so we split j:\n-    // Filter out the gcd, d, so j/d and i/d are integer.\n-    // result is divisible by (j/d) because (j/d)\n-    // is relative prime to (i/d) and is a divisor of\n-    // result * (i/d).\n-    // For n > 66, a result overflow might occur, so we check\n-    // the multiplication, taking care to not overflow\n-    // unnecessary.\n+    // Calculate binomial coefficient using iterative formula to avoid overflow\n+    long result = 1;\n+    for (int i = 0; i < k; i++) {\n+        result *= n - i;\n+        result /= i + 1;\n+    }\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    long result = Math.round(binomialCoefficientDouble(n, k));\n    if (result == Long.MAX_VALUE) {\n        throw new ArithmeticException(\"result too large to represent in a long integer\");\n    }\n    // Use symmetry for large k\n    // We use the formula\n    // (n choose k) = n! / (n-k)! / k!\n    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n    // which could be written\n    // (n choose k) == (n-1 choose k-1) * n / k\n    // For n <= 61, the naive implementation cannot overflow.\n    // For n > 61 but n <= 66, the result cannot overflow,\n    // but we must take care not to overflow intermediate values.\n    // We know that (result * i) is divisible by j,\n    // but (result * i) may overflow, so we split j:\n    // Filter out the gcd, d, so j/d and i/d are integer.\n    // result is divisible by (j/d) because (j/d)\n    // is relatively prime to (i/d) and is a divisor of\n    // result * (i/d).\n    // For n > 66, a result overflow might occur, so we check\n    // the multiplication, taking care to not overflow\n    // unnecessary.\n    if (n > 66 && k > 30) {\n        long denominator = 1;\n        long numerator = 1;\n        int j = 1;\n        for (int i = n - k + 1; i <= n; i++) {\n            numerator *= i;\n            while (j <= k && numerator % j == 0) {\n                numerator /= j;\n                denominator *= j;\n                j++;\n            }\n        }\n        result = numerator / denominator;\n    }\n    return result;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -28,10 +28,24 @@\n     // but (result * i) may overflow, so we split j:\n     // Filter out the gcd, d, so j/d and i/d are integer.\n     // result is divisible by (j/d) because (j/d)\n-    // is relative prime to (i/d) and is a divisor of\n+    // is relatively prime to (i/d) and is a divisor of\n     // result * (i/d).\n     // For n > 66, a result overflow might occur, so we check\n     // the multiplication, taking care to not overflow\n     // unnecessary.\n+    if (n > 66 && k > 30) {\n+        long denominator = 1;\n+        long numerator = 1;\n+        int j = 1;\n+        for (int i = n - k + 1; i <= n; i++) {\n+            numerator *= i;\n+            while (j <= k && numerator % j == 0) {\n+                numerator /= j;\n+                denominator *= j;\n+                j++;\n+            }\n+        }\n+        result = numerator / denominator;\n+    }\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    long result = Math.round(binomialCoefficientDouble(n, k));\n    if (result == Long.MAX_VALUE) {\n        throw new ArithmeticException(\"result too large to represent in a long integer\");\n    }\n    // Use symmetry for large k\n    // We use the formula\n    // (n choose k) = n! / (n-k)! / k!\n    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n    // which could be written\n    // (n choose k) == (n-1 choose k-1) * n / k\n    // For n <= 61, the naive implementation cannot overflow.\n    // For n > 61 but n <= 66, the result cannot overflow,\n    // but we must take care not to overflow intermediate values.\n    // We know that (result * i) is divisible by j,\n    // but (result * i) may overflow, so we split j:\n    // Filter out the gcd, d, so j/d and i/d are integer.\n    // result is divisible by (j/d) because (j/d)\n    // is relative prime to (i/d) and is a divisor of\n    // result * (i/d).\n    // For n > 66, a result overflow might occur, so we check\n    // the multiplication, taking care to not overflow\n    // unnecessary.\n\n    // Fixed code begins here\n    if (k > n / 2) {\n        return binomialCoefficient(n, n - k);\n    }\n    // Fixed code ends here\n\n    long res = 1;\n    for (int i = 0; i < k; ++i) {\n        res *= n - i;\n        res /= i + 1;\n    }\n    return res;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -33,5 +33,17 @@\n     // For n > 66, a result overflow might occur, so we check\n     // the multiplication, taking care to not overflow\n     // unnecessary.\n-    return result;\n+\n+    // Fixed code begins here\n+    if (k > n / 2) {\n+        return binomialCoefficient(n, n - k);\n+    }\n+    // Fixed code ends here\n+\n+    long res = 1;\n+    for (int i = 0; i < k; ++i) {\n+        res *= n - i;\n+        res /= i + 1;\n+    }\n+    return res;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    long result = Math.round(binomialCoefficientDouble(n, k));\n    if (result == Long.MAX_VALUE) {\n        throw new ArithmeticException(\"result too large to represent in a long integer\");\n    }\n    // Use symmetry for large k\n    // We use the formula\n    // (n choose k) = n! / (n-k)! / k!\n    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n    // which could be written\n    // (n choose k) == (n-1 choose k-1) * n / k\n    // For n <= 61, the naive implementation cannot overflow.\n    // For n > 61 but n <= 66, the result cannot overflow,\n    // but we must take care not to overflow intermediate values.\n    // We know that (result * i) is divisible by j,\n    // but (result * i) may overflow, so we split j:\n    // Filter out the gcd, d, so j/d and i/d are integer.\n    // result is divisible by (j/d) because (j/d)\n    // is relative prime to (i/d) and is a divisor of\n    // result * (i/d).\n    // For n > 66, a result overflow might occur, so we check\n    // the multiplication, taking care to not overflow\n    // unnecessary.\n    if(n <= 66) {\n        for(int i=1; i<k; i++) {\n            result = result * (n-i) / i;\n        }\n    } else {\n        for(int i=1; i<k; i++) {\n            long gcd = gcd(n-i+1, i);\n            result = (result / (i/gcd)) * ((n-i+1)/gcd);\n        }\n    }\n    return result;\n}\n\nprivate static long gcd(long a, long b) {\n    if(b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -33,5 +33,15 @@\n     // For n > 66, a result overflow might occur, so we check\n     // the multiplication, taking care to not overflow\n     // unnecessary.\n+    if(n <= 66) {\n+        for(int i=1; i<k; i++) {\n+            result = result * (n-i) / i;\n+        }\n+    } else {\n+        for(int i=1; i<k; i++) {\n+            long gcd = gcd(n-i+1, i);\n+            result = (result / (i/gcd)) * ((n-i+1)/gcd);\n+        }\n+    }\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    long result = Math.round(binomialCoefficientDouble(n, k));\n    if (result == Long.MAX_VALUE) {\n        throw new ArithmeticException(\"result too large to represent in a long integer\");\n    }\n    // Use symmetry for large k\n    // We use the formula\n    // (n choose k) = n! / (n-k)! / k!\n    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n    // which could be written\n    // (n choose k) == (n-1 choose k-1) * n / k\n    // For n <= 61, the naive implementation cannot overflow.\n    // For n > 61 but n <= 66, the result cannot overflow,\n    // but we must take care not to overflow intermediate values.\n    // We know that (result * i) is divisible by j,\n    // but (result * i) may overflow, so we split j:\n    // Filter out the gcd, d, so j/d and i/d are integer.\n    // result is divisible by (j/d) because (j/d)\n    // is relative prime to (i/d) and is a divisor of\n    // result * (i/d).\n    // For n > 66, a result overflow might occur, so we check\n    // the multiplication, taking care to not overflow\n    // unnecessary.\n\n    // check for large n, k values where result might overflow\n    if (n > 66 && k > n / 2) {\n        return binomialCoefficient(n, n - k);\n    }\n\n    // apply symmetry for large k values\n    if (k > n / 2) {\n        return binomialCoefficient(n, n - k);\n    }\n\n    return result;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -33,5 +33,16 @@\n     // For n > 66, a result overflow might occur, so we check\n     // the multiplication, taking care to not overflow\n     // unnecessary.\n+\n+    // check for large n, k values where result might overflow\n+    if (n > 66 && k > n / 2) {\n+        return binomialCoefficient(n, n - k);\n+    }\n+\n+    // apply symmetry for large k values\n+    if (k > n / 2) {\n+        return binomialCoefficient(n, n - k);\n+    }\n+\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    if (n > 66) {\n        // check for overflow when multiplying binomial coefficients\n        double result = binomialCoefficientDouble(n, k);\n        if (result > Long.MAX_VALUE) {\n            throw new ArithmeticException(\"result too large to represent in a long integer\");\n        }\n        long floorResult = (long) result;\n        if (floorResult != result) {\n            // if exact value is not representable as long, round to nearest even long\n            return Math.round(result);\n        }\n        return floorResult;\n    }\n    long result = 1;\n    for (int i = 0; i < k; i++) {\n        result *= (n - i);\n        result /= (i + 1);\n    }\n    return result;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -11,27 +11,23 @@\n     if ((k == 1) || (k == n - 1)) {\n         return n;\n     }\n-    long result = Math.round(binomialCoefficientDouble(n, k));\n-    if (result == Long.MAX_VALUE) {\n-        throw new ArithmeticException(\"result too large to represent in a long integer\");\n+    if (n > 66) {\n+        // check for overflow when multiplying binomial coefficients\n+        double result = binomialCoefficientDouble(n, k);\n+        if (result > Long.MAX_VALUE) {\n+            throw new ArithmeticException(\"result too large to represent in a long integer\");\n+        }\n+        long floorResult = (long) result;\n+        if (floorResult != result) {\n+            // if exact value is not representable as long, round to nearest even long\n+            return Math.round(result);\n+        }\n+        return floorResult;\n     }\n-    // Use symmetry for large k\n-    // We use the formula\n-    // (n choose k) = n! / (n-k)! / k!\n-    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n-    // which could be written\n-    // (n choose k) == (n-1 choose k-1) * n / k\n-    // For n <= 61, the naive implementation cannot overflow.\n-    // For n > 61 but n <= 66, the result cannot overflow,\n-    // but we must take care not to overflow intermediate values.\n-    // We know that (result * i) is divisible by j,\n-    // but (result * i) may overflow, so we split j:\n-    // Filter out the gcd, d, so j/d and i/d are integer.\n-    // result is divisible by (j/d) because (j/d)\n-    // is relative prime to (i/d) and is a divisor of\n-    // result * (i/d).\n-    // For n > 66, a result overflow might occur, so we check\n-    // the multiplication, taking care to not overflow\n-    // unnecessary.\n+    long result = 1;\n+    for (int i = 0; i < k; i++) {\n+        result *= (n - i);\n+        result /= (i + 1);\n+    }\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    long result = Math.round(binomialCoefficientDouble(n, k));\n    if (result == Long.MAX_VALUE) {\n        throw new ArithmeticException(\"result too large to represent in a long integer\");\n    }\n    // Use symmetry for large k\n    // We use the formula\n    // (n choose k) = n! / (n-k)! / k!\n    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n    // which could be written\n    // (n choose k) == (n-1 choose k-1) * n / k\n    // For n <= 61, the naive implementation cannot overflow.\n    // For n > 61 but n <= 66, the result cannot overflow,\n    // but we must take care not to overflow intermediate values.\n    // We know that (result * i) is divisible by j,\n    // but (result * i) may overflow, so we split j:\n    // Filter out the gcd, d, so j/d and i/d are integer.\n    // result is divisible by (j/d) because (j/d)\n    // is relative prime to (i/d) and is a divisor of\n    // result * (i/d).\n    if(n <= 66) {\n        long ans = 1;\n        for(int i=n-k+1; i<=n; i++) {\n            ans *= i;\n            ans /= (i-n+k);\n        }\n        return ans;\n    }\n    // For n > 66, a result overflow might occur, so we check\n    // the multiplication, taking care to not overflow\n    // unnecessary.\n    long ans1 = 1;\n    for(int i=n-k+1, j=1; j<=k; i++,j++) {\n        long d = gcd(ans1, j);\n        ans1 /= d;\n        long t = i / (j / d);\n        if(ans1 > Long.MAX_VALUE / t) {\n            throw new ArithmeticException(\"result too large to represent in a long integer\");\n        }\n        ans1 *= t;\n    }\n    return ans1;\n}\n\nprivate static long gcd(long a, long b) {\n    while(b > 0) {\n        long c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -30,8 +30,26 @@\n     // result is divisible by (j/d) because (j/d)\n     // is relative prime to (i/d) and is a divisor of\n     // result * (i/d).\n+    if(n <= 66) {\n+        long ans = 1;\n+        for(int i=n-k+1; i<=n; i++) {\n+            ans *= i;\n+            ans /= (i-n+k);\n+        }\n+        return ans;\n+    }\n     // For n > 66, a result overflow might occur, so we check\n     // the multiplication, taking care to not overflow\n     // unnecessary.\n-    return result;\n+    long ans1 = 1;\n+    for(int i=n-k+1, j=1; j<=k; i++,j++) {\n+        long d = gcd(ans1, j);\n+        ans1 /= d;\n+        long t = i / (j / d);\n+        if(ans1 > Long.MAX_VALUE / t) {\n+            throw new ArithmeticException(\"result too large to represent in a long integer\");\n+        }\n+        ans1 *= t;\n+    }\n+    return ans1;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    if (k > n / 2) {\n        return binomialCoefficient(n, n - k);\n    }\n    long result = 1;\n    for (int i = 1; i <= k; i++) {\n        result *= n - k + i;\n        result /= i;\n    }\n    return result;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -11,27 +11,13 @@\n     if ((k == 1) || (k == n - 1)) {\n         return n;\n     }\n-    long result = Math.round(binomialCoefficientDouble(n, k));\n-    if (result == Long.MAX_VALUE) {\n-        throw new ArithmeticException(\"result too large to represent in a long integer\");\n+    if (k > n / 2) {\n+        return binomialCoefficient(n, n - k);\n     }\n-    // Use symmetry for large k\n-    // We use the formula\n-    // (n choose k) = n! / (n-k)! / k!\n-    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n-    // which could be written\n-    // (n choose k) == (n-1 choose k-1) * n / k\n-    // For n <= 61, the naive implementation cannot overflow.\n-    // For n > 61 but n <= 66, the result cannot overflow,\n-    // but we must take care not to overflow intermediate values.\n-    // We know that (result * i) is divisible by j,\n-    // but (result * i) may overflow, so we split j:\n-    // Filter out the gcd, d, so j/d and i/d are integer.\n-    // result is divisible by (j/d) because (j/d)\n-    // is relative prime to (i/d) and is a divisor of\n-    // result * (i/d).\n-    // For n > 66, a result overflow might occur, so we check\n-    // the multiplication, taking care to not overflow\n-    // unnecessary.\n+    long result = 1;\n+    for (int i = 1; i <= k; i++) {\n+        result *= n - k + i;\n+        result /= i;\n+    }\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n\n    // Use symmetry for large k\n    if (k > n / 2) {\n        return binomialCoefficient(n, n - k);\n    }\n    long result = 1;\n    for (int i = 0; i < k; i++) {\n        result *= (n - i);\n        result /= (i + 1);\n    }\n    return result;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -11,27 +11,15 @@\n     if ((k == 1) || (k == n - 1)) {\n         return n;\n     }\n-    long result = Math.round(binomialCoefficientDouble(n, k));\n-    if (result == Long.MAX_VALUE) {\n-        throw new ArithmeticException(\"result too large to represent in a long integer\");\n+\n+    // Use symmetry for large k\n+    if (k > n / 2) {\n+        return binomialCoefficient(n, n - k);\n     }\n-    // Use symmetry for large k\n-    // We use the formula\n-    // (n choose k) = n! / (n-k)! / k!\n-    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n-    // which could be written\n-    // (n choose k) == (n-1 choose k-1) * n / k\n-    // For n <= 61, the naive implementation cannot overflow.\n-    // For n > 61 but n <= 66, the result cannot overflow,\n-    // but we must take care not to overflow intermediate values.\n-    // We know that (result * i) is divisible by j,\n-    // but (result * i) may overflow, so we split j:\n-    // Filter out the gcd, d, so j/d and i/d are integer.\n-    // result is divisible by (j/d) because (j/d)\n-    // is relative prime to (i/d) and is a divisor of\n-    // result * (i/d).\n-    // For n > 66, a result overflow might occur, so we check\n-    // the multiplication, taking care to not overflow\n-    // unnecessary.\n+    long result = 1;\n+    for (int i = 0; i < k; i++) {\n+        result *= (n - i);\n+        result /= (i + 1);\n+    }\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    long result;\n    if (k > n - k) {\n        // Use symmetry for large k\n        result = binomialCoefficient(n, n - k);\n    } else {\n        result = 1;\n        for (int i = 1; i <= k; i++) {\n            result *= n - k + i;\n            result /= i;\n        }\n    }\n    if (result == Long.MAX_VALUE) {\n        throw new ArithmeticException(\"result too large to represent in a long integer\");\n    }\n    return result;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -11,27 +11,19 @@\n     if ((k == 1) || (k == n - 1)) {\n         return n;\n     }\n-    long result = Math.round(binomialCoefficientDouble(n, k));\n+    long result;\n+    if (k > n - k) {\n+        // Use symmetry for large k\n+        result = binomialCoefficient(n, n - k);\n+    } else {\n+        result = 1;\n+        for (int i = 1; i <= k; i++) {\n+            result *= n - k + i;\n+            result /= i;\n+        }\n+    }\n     if (result == Long.MAX_VALUE) {\n         throw new ArithmeticException(\"result too large to represent in a long integer\");\n     }\n-    // Use symmetry for large k\n-    // We use the formula\n-    // (n choose k) = n! / (n-k)! / k!\n-    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n-    // which could be written\n-    // (n choose k) == (n-1 choose k-1) * n / k\n-    // For n <= 61, the naive implementation cannot overflow.\n-    // For n > 61 but n <= 66, the result cannot overflow,\n-    // but we must take care not to overflow intermediate values.\n-    // We know that (result * i) is divisible by j,\n-    // but (result * i) may overflow, so we split j:\n-    // Filter out the gcd, d, so j/d and i/d are integer.\n-    // result is divisible by (j/d) because (j/d)\n-    // is relative prime to (i/d) and is a divisor of\n-    // result * (i/d).\n-    // For n > 66, a result overflow might occur, so we check\n-    // the multiplication, taking care to not overflow\n-    // unnecessary.\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    if (k > n - k) {\n        return binomialCoefficient(n, n - k);\n    }\n    long result = 1;\n    for (int i = 1; i <= k; ++i) {\n        result *= (n - k + i);\n        result /= i;\n    }\n    return result;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -11,27 +11,13 @@\n     if ((k == 1) || (k == n - 1)) {\n         return n;\n     }\n-    long result = Math.round(binomialCoefficientDouble(n, k));\n-    if (result == Long.MAX_VALUE) {\n-        throw new ArithmeticException(\"result too large to represent in a long integer\");\n+    if (k > n - k) {\n+        return binomialCoefficient(n, n - k);\n     }\n-    // Use symmetry for large k\n-    // We use the formula\n-    // (n choose k) = n! / (n-k)! / k!\n-    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n-    // which could be written\n-    // (n choose k) == (n-1 choose k-1) * n / k\n-    // For n <= 61, the naive implementation cannot overflow.\n-    // For n > 61 but n <= 66, the result cannot overflow,\n-    // but we must take care not to overflow intermediate values.\n-    // We know that (result * i) is divisible by j,\n-    // but (result * i) may overflow, so we split j:\n-    // Filter out the gcd, d, so j/d and i/d are integer.\n-    // result is divisible by (j/d) because (j/d)\n-    // is relative prime to (i/d) and is a divisor of\n-    // result * (i/d).\n-    // For n > 66, a result overflow might occur, so we check\n-    // the multiplication, taking care to not overflow\n-    // unnecessary.\n+    long result = 1;\n+    for (int i = 1; i <= k; ++i) {\n+        result *= (n - k + i);\n+        result /= i;\n+    }\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    long result = Math.round(binomialCoefficientDouble(n, k));\n    if (result == Long.MAX_VALUE) {\n        throw new ArithmeticException(\"result too large to represent in a long integer\");\n    }\n    // Use symmetry for large k\n    // We use the formula\n    // (n choose k) = n! / (n-k)! / k!\n    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n    // which could be written\n    // (n choose k) == (n-1 choose k-1) * n / k\n    // For n <= 61, the naive implementation cannot overflow.\n    // For n > 61 but n <= 66, the result cannot overflow,\n    // but we must take care not to overflow intermediate values.\n    // We know that (result * i) is divisible by j,\n    // but (result * i) may overflow, so we split j:\n    // Filter out the gcd, d, so j/d and i/d are integer.\n    // result is divisible by (j/d) because (j/d)\n    // is relative prime to (i/d) and is a divisor of\n    // result * (i/d).\n    // For n > 66, a result overflow might occur, so we check\n    // the multiplication, taking care to not overflow\n    // unnecessary.\n    if (n <= 66) {\n        for (int i = n - k + 1, j = 1; j <= k; i++, j++) {\n            result *= i;\n            result /= j;\n        }\n    } else {\n        for (int i = n - k + 1, j = 1; j <= k; i++, j++) {\n            long d = gcd(i, j);\n            result = result / (j / d);\n            result = result * (i / d);\n        }\n    }\n    return result;\n}\n\n// Helper function for calculating gcd\nprivate static long gcd(long a, long b) {\n    if (b == 0) {\n        return a;\n    }\n    return gcd(b, a % b);\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -33,5 +33,17 @@\n     // For n > 66, a result overflow might occur, so we check\n     // the multiplication, taking care to not overflow\n     // unnecessary.\n+    if (n <= 66) {\n+        for (int i = n - k + 1, j = 1; j <= k; i++, j++) {\n+            result *= i;\n+            result /= j;\n+        }\n+    } else {\n+        for (int i = n - k + 1, j = 1; j <= k; i++, j++) {\n+            long d = gcd(i, j);\n+            result = result / (j / d);\n+            result = result * (i / d);\n+        }\n+    }\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static long binomialCoefficient(final int n, final int k) {\n    if (n < k) {\n        throw new IllegalArgumentException(\"must have n >= k for binomial coefficient (n,k)\");\n    }\n    if (n < 0) {\n        throw new IllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k)\");\n    }\n    if ((n == k) || (k == 0)) {\n        return 1;\n    }\n    if ((k == 1) || (k == n - 1)) {\n        return n;\n    }\n    long result = Math.round(binomialCoefficientDouble(n, k));\n    if (result == Long.MAX_VALUE) {\n        throw new ArithmeticException(\"result too large to represent in a long integer\");\n    }\n    // Use symmetry for large k\n    // We use the formula\n    // (n choose k) = n! / (n-k)! / k!\n    // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n    // which could be written\n    // (n choose k) == (n-1 choose k-1) * n / k\n    // For n <= 61, the naive implementation cannot overflow.\n    // For n > 61 but n <= 66, the result cannot overflow,\n    // but we must take care not to overflow intermediate values.\n    // We know that (result * i) is divisible by j,\n    // but (result * i) may overflow, so we split j:\n    // Filter out the gcd, d, so j/d and i/d are integer.\n    // result is divisible by (j/d) because (j/d)\n    // is relative prime to (i/d) and is a divisor of\n    // result * (i/d).\n    // For n > 66, a result overflow might occur, so we check\n    // the multiplication, taking care to not overflow\n    // unnecessary.\n    if (n > 66) {\n        int d = 2;\n        int i = n - k + 1;\n        long x = 1;\n        while (i <= n) {\n            // Do division before multiplication to avoid overflow\n            // x = x * i / d;\n            // or, equivalently\n            // x = (x / d) * i;\n            long r = x % d;\n            x /= d;\n            x *= i;\n            // Reduce (i/d) and d\n            if (r == 0) {\n                d++;\n            }\n            i++;\n        }\n        result = x;\n    }\n    return result;\n}", "diff": "--- org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n+++ org/apache/commons/math/util/MathUtils.java@binomialCoefficient\n@@ -33,5 +33,25 @@\n     // For n > 66, a result overflow might occur, so we check\n     // the multiplication, taking care to not overflow\n     // unnecessary.\n+    if (n > 66) {\n+        int d = 2;\n+        int i = n - k + 1;\n+        long x = 1;\n+        while (i <= n) {\n+            // Do division before multiplication to avoid overflow\n+            // x = x * i / d;\n+            // or, equivalently\n+            // x = (x / d) * i;\n+            long r = x % d;\n+            x /= d;\n+            x *= i;\n+            // Reduce (i/d) and d\n+            if (r == 0) {\n+                d++;\n+            }\n+            i++;\n+        }\n+        result = x;\n+    }\n     return result;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]