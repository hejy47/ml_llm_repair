[{"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        int daysInStartMonth = start.getActualMaximum(Calendar.DAY_OF_MONTH);\n        days += daysInStartMonth;\n        months -= 1;\n        start.add(Calendar.MONTH, 1);\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,13 +36,10 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        int daysInStartMonth = start.getActualMaximum(Calendar.DAY_OF_MONTH);\n+        days += daysInStartMonth;\n         months -= 1;\n+        start.add(Calendar.MONTH, 1);\n     }\n     while (months < 0) {\n         months += 12;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,12 +36,7 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n         months -= 1;\n     }\n     while (months < 0) {\n@@ -64,7 +59,7 @@\n             years = 0;\n         } else {\n             // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             years = 0;\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTimeInMillis(startMillis); // Changed to setTimeInMillis\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTimeInMillis(endMillis); // Changed to setTimeInMillis\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        int maxDaysInMonth = end.getActualMaximum(Calendar.DAY_OF_MONTH); // Added\n        days += maxDaysInMonth - start.get(Calendar.DAY_OF_MONTH) + 1; // Fixed calculation\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -7,9 +7,9 @@\n     // timezones get funky around 0, so normalizing everything to GMT\n     // stops the hours being off\n     Calendar start = Calendar.getInstance(timezone);\n-    start.setTime(new Date(startMillis));\n+    start.setTimeInMillis(startMillis); // Changed to setTimeInMillis\n     Calendar end = Calendar.getInstance(timezone);\n-    end.setTime(new Date(endMillis));\n+    end.setTimeInMillis(endMillis); // Changed to setTimeInMillis\n     // initial estimates\n     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n@@ -36,12 +36,8 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        int maxDaysInMonth = end.getActualMaximum(Calendar.DAY_OF_MONTH); // Added\n+        days += maxDaysInMonth - start.get(Calendar.DAY_OF_MONTH) + 1; // Fixed calculation\n         months -= 1;\n     }\n     while (months < 0) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTimeInMillis(startMillis);\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTimeInMillis(endMillis);\n    int endYear = end.get(Calendar.YEAR);\n    int endMonth = end.get(Calendar.MONTH) + 1;\n    int endDay = end.get(Calendar.DAY_OF_MONTH);\n    int endHour = end.get(Calendar.HOUR_OF_DAY);\n    int endMinute = end.get(Calendar.MINUTE);\n    int endSecond = end.get(Calendar.SECOND);\n    int endMillisecond = end.get(Calendar.MILLISECOND);\n    int startYear = start.get(Calendar.YEAR);\n    int startMonth = start.get(Calendar.MONTH) + 1;\n    int startDay = start.get(Calendar.DAY_OF_MONTH);\n    int startHour = start.get(Calendar.HOUR_OF_DAY);\n    int startMinute = start.get(Calendar.MINUTE);\n    int startSecond = start.get(Calendar.SECOND);\n    int startMillisecond = start.get(Calendar.MILLISECOND);\n    int carry = 0;\n    int millisDiff = endMillisecond - startMillisecond;\n    if (millisDiff < 0) {\n        carry = 1;\n        millisDiff += 1000;\n    }\n    int secondsDiff = endSecond - startSecond - carry;\n    carry = 0;\n    if (secondsDiff < 0) {\n        carry = 1;\n        secondsDiff += 60;\n    }\n    int minutesDiff = endMinute - startMinute - carry;\n    carry = 0;\n    if (minutesDiff < 0) {\n        carry = 1;\n        minutesDiff += 60;\n    }\n    int hoursDiff = endHour - startHour - carry;\n    carry = 0;\n    if (hoursDiff < 0) {\n        carry = 1;\n        hoursDiff += 24;\n    }\n    int daysInEndMonth = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n    int daysDiff = endDay - startDay - carry;\n    carry = 0;\n    if (daysDiff < 0) {\n        carry = daysInEndMonth;\n        daysDiff += daysInEndMonth;\n    }\n    int monthsDiff = endMonth - startMonth - carry;\n    carry = 0;\n    if (monthsDiff < 0) {\n        carry = 12;\n        monthsDiff += 12;\n    }\n    int yearsDiff = endYear - startYear - carry;\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            monthsDiff += yearsDiff * 12;\n            yearsDiff = 0;\n        } else {\n            int daysInEndYear = end.getActualMaximum(Calendar.DAY_OF_YEAR);\n            int startDayOfYear = start.get(Calendar.DAY_OF_YEAR);\n            int endDayOfYear = end.get(Calendar.DAY_OF_YEAR);\n            daysDiff += daysInEndYear * (yearsDiff - 1) + (daysInEndYear - startDayOfYear + endDayOfYear);\n            yearsDiff = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        monthsDiff += yearsDiff * 12;\n        yearsDiff = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        int hoursInEndDay = end.getActualMaximum(Calendar.HOUR_OF_DAY);\n        int hoursDiffInDays = hoursInEndDay - startHour + endHour;\n        daysDiff += hoursDiffInDays / 24;\n        hoursDiff = hoursDiffInDays % 24;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutesDiff += hoursDiff * 60;\n        hoursDiff = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        secondsDiff += minutesDiff * 60;\n        minutesDiff = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        millisDiff += secondsDiff * 1000;\n        secondsDiff = 0;\n    }\n    return format(tokens, yearsDiff, monthsDiff, daysDiff, hoursDiff, minutesDiff, secondsDiff, millisDiff, padWithZeros);\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -4,89 +4,95 @@\n         return formatDuration(millis, format, padWithZeros);\n     }\n     Token[] tokens = lexx(format);\n-    // timezones get funky around 0, so normalizing everything to GMT\n-    // stops the hours being off\n     Calendar start = Calendar.getInstance(timezone);\n-    start.setTime(new Date(startMillis));\n+    start.setTimeInMillis(startMillis);\n     Calendar end = Calendar.getInstance(timezone);\n-    end.setTime(new Date(endMillis));\n-    // initial estimates\n-    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n-    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n-    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n-    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n-    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n-    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n-    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n-    // each initial estimate is adjusted in case it is under 0\n-    while (milliseconds < 0) {\n-        milliseconds += 1000;\n-        seconds -= 1;\n+    end.setTimeInMillis(endMillis);\n+    int endYear = end.get(Calendar.YEAR);\n+    int endMonth = end.get(Calendar.MONTH) + 1;\n+    int endDay = end.get(Calendar.DAY_OF_MONTH);\n+    int endHour = end.get(Calendar.HOUR_OF_DAY);\n+    int endMinute = end.get(Calendar.MINUTE);\n+    int endSecond = end.get(Calendar.SECOND);\n+    int endMillisecond = end.get(Calendar.MILLISECOND);\n+    int startYear = start.get(Calendar.YEAR);\n+    int startMonth = start.get(Calendar.MONTH) + 1;\n+    int startDay = start.get(Calendar.DAY_OF_MONTH);\n+    int startHour = start.get(Calendar.HOUR_OF_DAY);\n+    int startMinute = start.get(Calendar.MINUTE);\n+    int startSecond = start.get(Calendar.SECOND);\n+    int startMillisecond = start.get(Calendar.MILLISECOND);\n+    int carry = 0;\n+    int millisDiff = endMillisecond - startMillisecond;\n+    if (millisDiff < 0) {\n+        carry = 1;\n+        millisDiff += 1000;\n     }\n-    while (seconds < 0) {\n-        seconds += 60;\n-        minutes -= 1;\n+    int secondsDiff = endSecond - startSecond - carry;\n+    carry = 0;\n+    if (secondsDiff < 0) {\n+        carry = 1;\n+        secondsDiff += 60;\n     }\n-    while (minutes < 0) {\n-        minutes += 60;\n-        hours -= 1;\n+    int minutesDiff = endMinute - startMinute - carry;\n+    carry = 0;\n+    if (minutesDiff < 0) {\n+        carry = 1;\n+        minutesDiff += 60;\n     }\n-    while (hours < 0) {\n-        hours += 24;\n-        days -= 1;\n+    int hoursDiff = endHour - startHour - carry;\n+    carry = 0;\n+    if (hoursDiff < 0) {\n+        carry = 1;\n+        hoursDiff += 24;\n     }\n-    while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n-        months -= 1;\n+    int daysInEndMonth = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+    int daysDiff = endDay - startDay - carry;\n+    carry = 0;\n+    if (daysDiff < 0) {\n+        carry = daysInEndMonth;\n+        daysDiff += daysInEndMonth;\n     }\n-    while (months < 0) {\n-        months += 12;\n-        years -= 1;\n+    int monthsDiff = endMonth - startMonth - carry;\n+    carry = 0;\n+    if (monthsDiff < 0) {\n+        carry = 12;\n+        monthsDiff += 12;\n     }\n-    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n-    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n-    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n-    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n-    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n-    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n-    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n-    // This next block of code adds in values that\n-    // aren't requested. This allows the user to ask for the\n-    // number of months and get the real count and not just 0->11.\n+    int yearsDiff = endYear - startYear - carry;\n     if (!Token.containsTokenWithValue(tokens, y)) {\n         if (Token.containsTokenWithValue(tokens, M)) {\n-            months += 12 * years;\n-            years = 0;\n+            monthsDiff += yearsDiff * 12;\n+            yearsDiff = 0;\n         } else {\n-            // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n-            years = 0;\n+            int daysInEndYear = end.getActualMaximum(Calendar.DAY_OF_YEAR);\n+            int startDayOfYear = start.get(Calendar.DAY_OF_YEAR);\n+            int endDayOfYear = end.get(Calendar.DAY_OF_YEAR);\n+            daysDiff += daysInEndYear * (yearsDiff - 1) + (daysInEndYear - startDayOfYear + endDayOfYear);\n+            yearsDiff = 0;\n         }\n     }\n     if (!Token.containsTokenWithValue(tokens, M)) {\n-        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n-        months = 0;\n+        monthsDiff += yearsDiff * 12;\n+        yearsDiff = 0;\n     }\n     if (!Token.containsTokenWithValue(tokens, d)) {\n-        hours += 24 * days;\n-        days = 0;\n+        int hoursInEndDay = end.getActualMaximum(Calendar.HOUR_OF_DAY);\n+        int hoursDiffInDays = hoursInEndDay - startHour + endHour;\n+        daysDiff += hoursDiffInDays / 24;\n+        hoursDiff = hoursDiffInDays % 24;\n     }\n     if (!Token.containsTokenWithValue(tokens, H)) {\n-        minutes += 60 * hours;\n-        hours = 0;\n+        minutesDiff += hoursDiff * 60;\n+        hoursDiff = 0;\n     }\n     if (!Token.containsTokenWithValue(tokens, m)) {\n-        seconds += 60 * minutes;\n-        minutes = 0;\n+        secondsDiff += minutesDiff * 60;\n+        minutesDiff = 0;\n     }\n     if (!Token.containsTokenWithValue(tokens, s)) {\n-        milliseconds += 1000 * seconds;\n-        seconds = 0;\n+        millisDiff += secondsDiff * 1000;\n+        secondsDiff = 0;\n     }\n-    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n+    return format(tokens, yearsDiff, monthsDiff, daysDiff, hoursDiff, minutesDiff, secondsDiff, millisDiff, padWithZeros);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        Calendar temp = Calendar.getInstance();\n        temp.setTime(end.getTime());\n        temp.add(Calendar.MONTH, -1);\n        // new way of computing the number of days between two dates\n        days += temp.getActualMaximum(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH) + end.get(Calendar.DAY_OF_MONTH);\n        // Same as before\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,12 +36,12 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        Calendar temp = Calendar.getInstance();\n+        temp.setTime(end.getTime());\n+        temp.add(Calendar.MONTH, -1);\n+        // new way of computing the number of days between two dates\n+        days += temp.getActualMaximum(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH) + end.get(Calendar.DAY_OF_MONTH);\n+        // Same as before\n         months -= 1;\n     }\n     while (months < 0) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,12 +36,7 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n         months -= 1;\n     }\n     while (months < 0) {\n@@ -63,8 +58,7 @@\n             months += 12 * years;\n             years = 0;\n         } else {\n-            // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             years = 0;\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        int maxDayOfMonth = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        if (start.get(Calendar.MONTH) == end.get(Calendar.MONTH) && start.get(Calendar.YEAR) == end.get(Calendar.YEAR)) {\n            // If both dates are in the same month for the same year, then we can calculate\n            // the difference without needing to worry about leap years or variable month lengths.\n            days += end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        } else {\n            // Otherwise, find the max day of the month and add that to the start date. Then\n            // add the number of days remaining from the end date (since it's still within the same month).\n            days += (maxDayOfMonth - start.get(Calendar.DAY_OF_MONTH)) + end.get(Calendar.DAY_OF_MONTH);\n        }\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else if (!Token.containsTokenWithValue(tokens, d)) {\n            // If the format doesn't ask for years, months, or days, then convert to hours.\n            hours += (years * 365 * 24) + (months * maxDayOfMonth * 24) + (days * 24);\n            years = 0;\n            months = 0;\n            days = 0;\n        } else {\n            // Otherwise, convert to days.\n            days += (years * 365) + (months * maxDayOfMonth);\n            years = 0;\n            months = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,12 +36,16 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        int maxDayOfMonth = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+        if (start.get(Calendar.MONTH) == end.get(Calendar.MONTH) && start.get(Calendar.YEAR) == end.get(Calendar.YEAR)) {\n+            // If both dates are in the same month for the same year, then we can calculate\n+            // the difference without needing to worry about leap years or variable month lengths.\n+            days += end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n+        } else {\n+            // Otherwise, find the max day of the month and add that to the start date. Then\n+            // add the number of days remaining from the end date (since it's still within the same month).\n+            days += (maxDayOfMonth - start.get(Calendar.DAY_OF_MONTH)) + end.get(Calendar.DAY_OF_MONTH);\n+        }\n         months -= 1;\n     }\n     while (months < 0) {\n@@ -62,10 +66,17 @@\n         if (Token.containsTokenWithValue(tokens, M)) {\n             months += 12 * years;\n             years = 0;\n+        } else if (!Token.containsTokenWithValue(tokens, d)) {\n+            // If the format doesn't ask for years, months, or days, then convert to hours.\n+            hours += (years * 365 * 24) + (months * maxDayOfMonth * 24) + (days * 24);\n+            years = 0;\n+            months = 0;\n+            days = 0;\n         } else {\n-            // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            // Otherwise, convert to days.\n+            days += (years * 365) + (months * maxDayOfMonth);\n             years = 0;\n+            months = 0;\n         }\n     }\n     if (!Token.containsTokenWithValue(tokens, M)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTimeInMillis(startMillis);\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTimeInMillis(endMillis);\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        int daysInStartMonth = start.getActualMaximum(Calendar.DAY_OF_MONTH);\n        days += daysInStartMonth;\n        months -= 1;\n        start.add(Calendar.MONTH, 1);\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -7,9 +7,9 @@\n     // timezones get funky around 0, so normalizing everything to GMT\n     // stops the hours being off\n     Calendar start = Calendar.getInstance(timezone);\n-    start.setTime(new Date(startMillis));\n+    start.setTimeInMillis(startMillis);\n     Calendar end = Calendar.getInstance(timezone);\n-    end.setTime(new Date(endMillis));\n+    end.setTimeInMillis(endMillis);\n     // initial estimates\n     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n@@ -36,13 +36,10 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        int daysInStartMonth = start.getActualMaximum(Calendar.DAY_OF_MONTH);\n+        days += daysInStartMonth;\n         months -= 1;\n+        start.add(Calendar.MONTH, 1);\n     }\n     while (months < 0) {\n         months += 12;\n@@ -64,7 +61,7 @@\n             years = 0;\n         } else {\n             // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             years = 0;\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        end.add(Calendar.MONTH, -1);\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,12 +36,8 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        end.add(Calendar.MONTH, -1);\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n         months -= 1;\n     }\n     while (months < 0) {\n@@ -64,7 +60,7 @@\n             years = 0;\n         } else {\n             // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             years = 0;\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        //days += 31;\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        months -= 1;\n        start.add(Calendar.MONTH, 1);\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,13 +36,10 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        //days += 31;\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n         months -= 1;\n+        start.add(Calendar.MONTH, 1);\n     }\n     while (months < 0) {\n         months += 12;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n        long millis = endMillis - startMillis;\n        if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n            return formatDuration(millis, format, padWithZeros);\n        }\n        Token[] tokens = lexx(format);\n        // timezones get funky around 0, so normalizing everything to GMT\n        // stops the hours being off\n        Calendar start = Calendar.getInstance(timezone);\n        start.setTimeInMillis(startMillis);\n        Calendar end = Calendar.getInstance(timezone);\n        end.setTimeInMillis(endMillis);\n        // initial estimates\n        int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n        int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n        int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n        int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n        int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n        int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n        int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n        // each initial estimate is adjusted in case it is under 0\n        while (milliseconds < 0) {\n            milliseconds += 1000;\n            seconds -= 1;\n        }\n        while (seconds < 0) {\n            seconds += 60;\n            minutes -= 1;\n        }\n        while (minutes < 0) {\n            minutes += 60;\n            hours -= 1;\n        }\n        while (hours < 0) {\n            hours += 24;\n            days -= 1;\n        }\n        while (days < 0) {\n            if (months == 0) {\n                // If there are no months, we can just add days to the duration\n                years -= 1;\n                months = 11;\n                days += getLastDayOfMonth(start);\n            } else {\n                // Otherwise, we need to calculate the last day of the previous month\n                months -= 1;\n                days += getLastDayOfMonth(start.get(Calendar.YEAR), start.get(Calendar.MONTH));\n            }\n        }\n        while (months < 0) {\n            months += 12;\n            years -= 1;\n        }\n        milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n        seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n        minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n        hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n        days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n        months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n        years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n        // This next block of code adds in values that\n        // aren't requested. This allows the user to ask for the\n        // number of months and get the real count and not just 0->11.\n        if (!Token.containsTokenWithValue(tokens, y)) {\n            if (Token.containsTokenWithValue(tokens, M)) {\n                months += 12 * years;\n                years = 0;\n            } else {\n                // TODO: this is a bit weak, needs work to know about leap years\n                days += 365 * years;\n                years = 0;\n            }\n        }\n        if (!Token.containsTokenWithValue(tokens, M)) {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, H)) {\n            minutes += 60 * hours;\n            hours = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, m)) {\n            seconds += 60 * minutes;\n            minutes = 0;\n        }\n        if (!Token.containsTokenWithValue(tokens, s)) {\n            milliseconds += 1000 * seconds;\n            seconds = 0;\n        }\n        return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n    }\n\n    private static int getLastDayOfMonth(int year, int month) {\n        Calendar calendar = Calendar.getInstance();\n        calendar.clear();\n        calendar.set(Calendar.YEAR, year);\n        calendar.set(Calendar.MONTH, month);\n        return calendar.getActualMaximum(Calendar.DAY_OF_MONTH);\n    }\n\n    private static int getLastDayOfMonth(Calendar calendar) {\n        return calendar.getActualMaximum(Calendar.DAY_OF_MONTH);\n    }", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        //days += 31;\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n        // Also it's contextual - if asked for no M in the format then I should probably\n        // be doing no calculating here.\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,7 +36,8 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n+        //days += 31;\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n         //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n         // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n         // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n@@ -64,7 +65,7 @@\n             years = 0;\n         } else {\n             // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             years = 0;\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        int maxDay = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        days += maxDay - start.get(Calendar.DAY_OF_MONTH) + 1;\n        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n        // Also it's contextual - if asked for no M in the format then I should probably\n        // be doing no calculating here.\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, Token.y)) {\n        if (Token.containsTokenWithValue(tokens, Token.M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,7 +36,8 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n+        int maxDay = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+        days += maxDay - start.get(Calendar.DAY_OF_MONTH) + 1;\n         //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n         // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n         // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n@@ -58,33 +59,33 @@\n     // This next block of code adds in values that\n     // aren't requested. This allows the user to ask for the\n     // number of months and get the real count and not just 0->11.\n-    if (!Token.containsTokenWithValue(tokens, y)) {\n-        if (Token.containsTokenWithValue(tokens, M)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.y)) {\n+        if (Token.containsTokenWithValue(tokens, Token.M)) {\n             months += 12 * years;\n             years = 0;\n         } else {\n             // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             years = 0;\n         }\n     }\n-    if (!Token.containsTokenWithValue(tokens, M)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.M)) {\n         days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n         months = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, d)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.d)) {\n         hours += 24 * days;\n         days = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, H)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.H)) {\n         minutes += 60 * hours;\n         hours = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, m)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.m)) {\n         seconds += 60 * minutes;\n         minutes = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, s)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.s)) {\n         milliseconds += 1000 * seconds;\n         seconds = 0;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTimeInMillis(startMillis);\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTimeInMillis(endMillis);\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, Token.y)) {\n        if (Token.containsTokenWithValue(tokens, Token.M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -7,9 +7,9 @@\n     // timezones get funky around 0, so normalizing everything to GMT\n     // stops the hours being off\n     Calendar start = Calendar.getInstance(timezone);\n-    start.setTime(new Date(startMillis));\n+    start.setTimeInMillis(startMillis);\n     Calendar end = Calendar.getInstance(timezone);\n-    end.setTime(new Date(endMillis));\n+    end.setTimeInMillis(endMillis);\n     // initial estimates\n     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n@@ -36,12 +36,7 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n         months -= 1;\n     }\n     while (months < 0) {\n@@ -58,33 +53,32 @@\n     // This next block of code adds in values that\n     // aren't requested. This allows the user to ask for the\n     // number of months and get the real count and not just 0->11.\n-    if (!Token.containsTokenWithValue(tokens, y)) {\n-        if (Token.containsTokenWithValue(tokens, M)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.y)) {\n+        if (Token.containsTokenWithValue(tokens, Token.M)) {\n             months += 12 * years;\n             years = 0;\n         } else {\n-            // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n             years = 0;\n         }\n     }\n-    if (!Token.containsTokenWithValue(tokens, M)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.M)) {\n         days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n         months = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, d)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.d)) {\n         hours += 24 * days;\n         days = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, H)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.H)) {\n         minutes += 60 * hours;\n         hours = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, m)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.m)) {\n         seconds += 60 * minutes;\n         minutes = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, s)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.s)) {\n         milliseconds += 1000 * seconds;\n         seconds = 0;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        // days += 31;\n        int maxDay = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        int startDay = start.get(Calendar.DAY_OF_MONTH);\n        days += (maxDay - startDay + 1);\n        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n        // Also it's contextual - if asked for no M in the format then I should probably\n        // be doing no calculating here.\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n            months = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,7 +36,10 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n+        // days += 31;\n+        int maxDay = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+        int startDay = start.get(Calendar.DAY_OF_MONTH);\n+        days += (maxDay - startDay + 1);\n         //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n         // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n         // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n@@ -64,8 +67,8 @@\n             years = 0;\n         } else {\n             // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n-            years = 0;\n+            days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n+            months = 0;\n         }\n     }\n     if (!Token.containsTokenWithValue(tokens, M)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTimeInMillis(startMillis);\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTimeInMillis(endMillis);\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, Token.y)) {\n        if (Token.containsTokenWithValue(tokens, Token.M)) {\n            // using 2000 so we don't count leap years\n            int midYear = end.get(Calendar.YEAR) - 2000 + (end.get(Calendar.MONTH) - start.get(Calendar.MONTH))/12;\n            months += 12 * midYear;\n            years = 0;\n        } else {\n            int midYear = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n            if (months < 0) {\n                midYear -= 1;\n            }\n            days += DateUtils.getDaysPerYear(start.get(Calendar.YEAR)) * midYear;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        if (!Token.containsTokenWithValue(tokens, Token.d)) {\n            hours += 24 * days;\n            days = 0;\n        }\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, Token.s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -7,9 +7,9 @@\n     // timezones get funky around 0, so normalizing everything to GMT\n     // stops the hours being off\n     Calendar start = Calendar.getInstance(timezone);\n-    start.setTime(new Date(startMillis));\n+    start.setTimeInMillis(startMillis);\n     Calendar end = Calendar.getInstance(timezone);\n-    end.setTime(new Date(endMillis));\n+    end.setTimeInMillis(endMillis);\n     // initial estimates\n     int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n     int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n@@ -36,12 +36,7 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        days += end.getActualMaximum(Calendar.DAY_OF_MONTH);\n         months -= 1;\n     }\n     while (months < 0) {\n@@ -58,33 +53,42 @@\n     // This next block of code adds in values that\n     // aren't requested. This allows the user to ask for the\n     // number of months and get the real count and not just 0->11.\n-    if (!Token.containsTokenWithValue(tokens, y)) {\n-        if (Token.containsTokenWithValue(tokens, M)) {\n-            months += 12 * years;\n+    if (!Token.containsTokenWithValue(tokens, Token.y)) {\n+        if (Token.containsTokenWithValue(tokens, Token.M)) {\n+            // using 2000 so we don't count leap years\n+            int midYear = end.get(Calendar.YEAR) - 2000 + (end.get(Calendar.MONTH) - start.get(Calendar.MONTH))/12;\n+            months += 12 * midYear;\n             years = 0;\n         } else {\n-            // TODO: this is a bit weak, needs work to know about leap years\n-            days += 365 * years;\n+            int midYear = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n+            if (months < 0) {\n+                midYear -= 1;\n+            }\n+            days += DateUtils.getDaysPerYear(start.get(Calendar.YEAR)) * midYear;\n             years = 0;\n         }\n     }\n-    if (!Token.containsTokenWithValue(tokens, M)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.M)) {\n         days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n+        if (!Token.containsTokenWithValue(tokens, Token.d)) {\n+            hours += 24 * days;\n+            days = 0;\n+        }\n         months = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, d)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.d)) {\n         hours += 24 * days;\n         days = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, H)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.H)) {\n         minutes += 60 * hours;\n         hours = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, m)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.m)) {\n         seconds += 60 * minutes;\n         minutes = 0;\n     }\n-    if (!Token.containsTokenWithValue(tokens, s)) {\n+    if (!Token.containsTokenWithValue(tokens, Token.s)) {\n         milliseconds += 1000 * seconds;\n         seconds = 0;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        // Fixed code starts here\n        Calendar temp = Calendar.getInstance(timezone);\n        temp.setTime(new Date(endMillis));\n        temp.add(Calendar.MONTH, -1);\n        days += temp.getActualMaximum(Calendar.DAY_OF_MONTH);\n        // Fixed code ends here\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,12 +36,12 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        // Fixed code starts here\n+        Calendar temp = Calendar.getInstance(timezone);\n+        temp.setTime(new Date(endMillis));\n+        temp.add(Calendar.MONTH, -1);\n+        days += temp.getActualMaximum(Calendar.DAY_OF_MONTH);\n+        // Fixed code ends here\n         months -= 1;\n     }\n     while (months < 0) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        if (months == 1) {\n            days += isLeapYear(end.get(Calendar.YEAR)) ? 29 : 28;\n        } else {\n            days += getDaysInMonth(start);\n            months -= 1;\n        }\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}\n\nprivate static boolean isLeapYear(int year) {\n    return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);\n}\n\nprivate static int getDaysInMonth(Calendar cal) {\n    switch(cal.get(Calendar.MONTH)) {\n        case 0:\n        case 2:\n        case 4:\n        case 6:\n        case 7:\n        case 9:\n        case 11:\n            return 31;\n        case 3:\n        case 5:\n        case 8:\n        case 10:\n            return 30;\n        case 1:\n            return isLeapYear(cal.get(Calendar.YEAR)) ? 29 : 28;\n        default:\n            throw new IllegalArgumentException(\"Invalid month supplied to getDaysInMonth: \" + cal.get(Calendar.MONTH));\n    }\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,13 +36,12 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n-        months -= 1;\n+        if (months == 1) {\n+            days += isLeapYear(end.get(Calendar.YEAR)) ? 29 : 28;\n+        } else {\n+            days += getDaysInMonth(start);\n+            months -= 1;\n+        }\n     }\n     while (months < 0) {\n         months += 12;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public static String formatPeriod(long startMillis, long endMillis, String format, boolean padWithZeros, TimeZone timezone) {\n    long millis = endMillis - startMillis;\n    if (millis < 28 * DateUtils.MILLIS_PER_DAY) {\n        return formatDuration(millis, format, padWithZeros);\n    }\n    Token[] tokens = lexx(format);\n    // timezones get funky around 0, so normalizing everything to GMT\n    // stops the hours being off\n    Calendar start = Calendar.getInstance(timezone);\n    start.setTime(new Date(startMillis));\n    Calendar end = Calendar.getInstance(timezone);\n    end.setTime(new Date(endMillis));\n    // initial estimates\n    int milliseconds = end.get(Calendar.MILLISECOND) - start.get(Calendar.MILLISECOND);\n    int seconds = end.get(Calendar.SECOND) - start.get(Calendar.SECOND);\n    int minutes = end.get(Calendar.MINUTE) - start.get(Calendar.MINUTE);\n    int hours = end.get(Calendar.HOUR_OF_DAY) - start.get(Calendar.HOUR_OF_DAY);\n    int days = end.get(Calendar.DAY_OF_MONTH) - start.get(Calendar.DAY_OF_MONTH);\n    int months = end.get(Calendar.MONTH) - start.get(Calendar.MONTH);\n    int years = end.get(Calendar.YEAR) - start.get(Calendar.YEAR);\n    // each initial estimate is adjusted in case it is under 0\n    while (milliseconds < 0) {\n        milliseconds += 1000;\n        seconds -= 1;\n    }\n    while (seconds < 0) {\n        seconds += 60;\n        minutes -= 1;\n    }\n    while (minutes < 0) {\n        minutes += 60;\n        hours -= 1;\n    }\n    while (hours < 0) {\n        hours += 24;\n        days -= 1;\n    }\n    while (days < 0) {\n        // Check the actual month of the end date since different months have different number of days\n        int daysInMonth = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n        days += daysInMonth;\n        months -= 1;\n    }\n    while (months < 0) {\n        months += 12;\n        years -= 1;\n    }\n    milliseconds -= reduceAndCorrect(start, end, Calendar.MILLISECOND, milliseconds);\n    seconds -= reduceAndCorrect(start, end, Calendar.SECOND, seconds);\n    minutes -= reduceAndCorrect(start, end, Calendar.MINUTE, minutes);\n    hours -= reduceAndCorrect(start, end, Calendar.HOUR_OF_DAY, hours);\n    days -= reduceAndCorrect(start, end, Calendar.DAY_OF_MONTH, days);\n    months -= reduceAndCorrect(start, end, Calendar.MONTH, months);\n    years -= reduceAndCorrect(start, end, Calendar.YEAR, years);\n    // This next block of code adds in values that\n    // aren't requested. This allows the user to ask for the\n    // number of months and get the real count and not just 0->11.\n    if (!Token.containsTokenWithValue(tokens, y)) {\n        if (Token.containsTokenWithValue(tokens, M)) {\n            months += 12 * years;\n            years = 0;\n        } else {\n            // TODO: this is a bit weak, needs work to know about leap years\n            days += 365 * years;\n            years = 0;\n        }\n    }\n    if (!Token.containsTokenWithValue(tokens, M)) {\n        days += end.get(Calendar.DAY_OF_YEAR) - start.get(Calendar.DAY_OF_YEAR);\n        months = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, d)) {\n        hours += 24 * days;\n        days = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, H)) {\n        minutes += 60 * hours;\n        hours = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, m)) {\n        seconds += 60 * minutes;\n        minutes = 0;\n    }\n    if (!Token.containsTokenWithValue(tokens, s)) {\n        milliseconds += 1000 * seconds;\n        seconds = 0;\n    }\n    return format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);\n}", "diff": "--- org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n+++ org/apache/commons/lang/time/DurationFormatUtils.java@formatPeriod\n@@ -36,12 +36,9 @@\n         days -= 1;\n     }\n     while (days < 0) {\n-        days += 31;\n-        //days += 31; // TODO: Need tests to show this is bad and the new code is good.\n-        // HEN: It's a tricky subject. Jan 15th to March 10th. If I count days-first it is\n-        // 1 month and 26 days, but if I count month-first then it is 1 month and 23 days.\n-        // Also it's contextual - if asked for no M in the format then I should probably\n-        // be doing no calculating here.\n+        // Check the actual month of the end date since different months have different number of days\n+        int daysInMonth = end.getActualMaximum(Calendar.DAY_OF_MONTH);\n+        days += daysInMonth;\n         months -= 1;\n     }\n     while (months < 0) {\n", "finish_reason": "stop", "valid": false, "num": 1}]