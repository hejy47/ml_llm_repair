[{"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node n = t.getCurrentNode().getParent();\n    if (n != null && isCallToScopeMethod(n)) {\n        if(n.getSourceFileName() != null && getSourceRegion(n) != null) {\n            transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@enterScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@enterScope\n@@ -2,6 +2,8 @@\n public void enterScope(NodeTraversal t) {\n     Node n = t.getCurrentNode().getParent();\n     if (n != null && isCallToScopeMethod(n)) {\n-        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n+        if(n.getSourceFileName() != null && getSourceRegion(n) != null) {\n+            transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n+        }\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,9 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    // Validate the top level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        int type = n.getType();\n-        if (type == Token.NAME && parent.getType() == Token.VAR) {\n-            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-                String name = n.getString();\n-                Var aliasVar = t.getScope().getVar(name);\n-                aliases.put(name, aliasVar);\n-                aliasDefinitionsInOrder.add(n);\n-                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n-                transformation.addAlias(name, qualifiedName);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-            }\n-        }\n-        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n-            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n+public void enterScope(NodeTraversal t) {\n+    Node n = t.getCurrentNode().getParent();\n+    if (n != null && isCallToScopeMethod(n)) {\n+        if(n.getSourceFileName() != null && getSourceRegion(n) != null) {\n+            transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n         }\n     }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (n.getType() == Token.NAME) {\n-            String name = n.getString();\n-            Var aliasVar = aliases.get(name);\n-            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n-                // Note, to support the transitive case, it's important we don't\n-                // clone aliasedNode here.  For example,\n-                // var g = goog; var d = g.dom; d.createElement('DIV');\n-                // The node in aliasedNode (which is \"g\") will be replaced in the\n-                // changes pass above with \"goog\".  If we cloned here, we'd end up\n-                // with <code>g.dom.createElement('DIV')</code>.\n-                Node aliasedNode = aliasVar.getInitialValue();\n-                aliasUsages.add(new AliasedNode(n, aliasedNode));\n-            }\n-        }\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n-    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node n = t.getScopeRoot();\n    if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@enterScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@enterScope\n@@ -1,6 +1,6 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    Node n = t.getCurrentNode().getParent();\n+    Node n = t.getScopeRoot();\n     if (n != null && isCallToScopeMethod(n)) {\n         transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n     }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,7 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    // Validate the top level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        int type = n.getType();\n-        if (type == Token.NAME && parent.getType() == Token.VAR) {\n-            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-                String name = n.getString();\n-                Var aliasVar = t.getScope().getVar(name);\n-                aliases.put(name, aliasVar);\n-                aliasDefinitionsInOrder.add(n);\n-                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n-                transformation.addAlias(name, qualifiedName);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-            }\n-        }\n-        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n-            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (n.getType() == Token.NAME) {\n-            String name = n.getString();\n-            Var aliasVar = aliases.get(name);\n-            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n-                // Note, to support the transitive case, it's important we don't\n-                // clone aliasedNode here.  For example,\n-                // var g = goog; var d = g.dom; d.createElement('DIV');\n-                // The node in aliasedNode (which is \"g\") will be replaced in the\n-                // changes pass above with \"goog\".  If we cloned here, we'd end up\n-                // with <code>g.dom.createElement('DIV')</code>.\n-                Node aliasedNode = aliasVar.getInitialValue();\n-                aliasUsages.add(new AliasedNode(n, aliasedNode));\n-            }\n-        }\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+public void enterScope(NodeTraversal t) {\n+    Node n = t.getScopeRoot();\n+    if (n != null && isCallToScopeMethod(n)) {\n+        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node n = t.getCurrentNode().getParent();\n    if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), n.getLineno(), getSourceRegion(n));\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@enterScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@enterScope\n@@ -2,6 +2,6 @@\n public void enterScope(NodeTraversal t) {\n     Node n = t.getCurrentNode().getParent();\n     if (n != null && isCallToScopeMethod(n)) {\n-        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n+        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), n.getLineno(), getSourceRegion(n));\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,7 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    // Validate the top level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        int type = n.getType();\n-        if (type == Token.NAME && parent.getType() == Token.VAR) {\n-            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-                String name = n.getString();\n-                Var aliasVar = t.getScope().getVar(name);\n-                aliases.put(name, aliasVar);\n-                aliasDefinitionsInOrder.add(n);\n-                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n-                transformation.addAlias(name, qualifiedName);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-            }\n-        }\n-        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n-            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (n.getType() == Token.NAME) {\n-            String name = n.getString();\n-            Var aliasVar = aliases.get(name);\n-            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n-                // Note, to support the transitive case, it's important we don't\n-                // clone aliasedNode here.  For example,\n-                // var g = goog; var d = g.dom; d.createElement('DIV');\n-                // The node in aliasedNode (which is \"g\") will be replaced in the\n-                // changes pass above with \"goog\".  If we cloned here, we'd end up\n-                // with <code>g.dom.createElement('DIV')</code>.\n-                Node aliasedNode = aliasVar.getInitialValue();\n-                aliasUsages.add(new AliasedNode(n, aliasedNode));\n-            }\n-        }\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+public void enterScope(NodeTraversal t) {\n+    Node n = t.getCurrentNode().getParent();\n+    if (n != null && isCallToScopeMethod(n)) {\n+        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), n.getLineno(), getSourceRegion(n));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node n = t.getCurrentNode().getParent();\n    if (n != null && isCallToScopeMethod(n)) {\n        SourcePosition startPosition = t.getSourcePosition();\n        SourcePosition endPosition = t.getEndSourcePosition();\n        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), new SourceRegion(startPosition, endPosition));\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@enterScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@enterScope\n@@ -2,6 +2,8 @@\n public void enterScope(NodeTraversal t) {\n     Node n = t.getCurrentNode().getParent();\n     if (n != null && isCallToScopeMethod(n)) {\n-        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n+        SourcePosition startPosition = t.getSourcePosition();\n+        SourcePosition endPosition = t.getEndSourcePosition();\n+        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), new SourceRegion(startPosition, endPosition));\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,9 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    // Validate the top level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        int type = n.getType();\n-        if (type == Token.NAME && parent.getType() == Token.VAR) {\n-            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-                String name = n.getString();\n-                Var aliasVar = t.getScope().getVar(name);\n-                aliases.put(name, aliasVar);\n-                aliasDefinitionsInOrder.add(n);\n-                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n-                transformation.addAlias(name, qualifiedName);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-            }\n-        }\n-        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n-            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (n.getType() == Token.NAME) {\n-            String name = n.getString();\n-            Var aliasVar = aliases.get(name);\n-            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n-                // Note, to support the transitive case, it's important we don't\n-                // clone aliasedNode here.  For example,\n-                // var g = goog; var d = g.dom; d.createElement('DIV');\n-                // The node in aliasedNode (which is \"g\") will be replaced in the\n-                // changes pass above with \"goog\".  If we cloned here, we'd end up\n-                // with <code>g.dom.createElement('DIV')</code>.\n-                Node aliasedNode = aliasVar.getInitialValue();\n-                aliasUsages.add(new AliasedNode(n, aliasedNode));\n-            }\n-        }\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+public void enterScope(NodeTraversal t) {\n+    Node n = t.getCurrentNode().getParent();\n+    if (n != null && isCallToScopeMethod(n)) {\n+        SourcePosition startPosition = t.getSourcePosition();\n+        SourcePosition endPosition = t.getEndSourcePosition();\n+        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), new SourceRegion(startPosition, endPosition));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node n = t.getClosestHoistScope().getParent(); // Using getClosestHoistScope() to get the parent node of the enclosing scope\n    if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@enterScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@enterScope\n@@ -1,6 +1,6 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    Node n = t.getCurrentNode().getParent();\n+    Node n = t.getClosestHoistScope().getParent(); // Using getClosestHoistScope() to get the parent node of the enclosing scope\n     if (n != null && isCallToScopeMethod(n)) {\n         transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n     }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,7 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    // Validate the top level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        int type = n.getType();\n-        if (type == Token.NAME && parent.getType() == Token.VAR) {\n-            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-                String name = n.getString();\n-                Var aliasVar = t.getScope().getVar(name);\n-                aliases.put(name, aliasVar);\n-                aliasDefinitionsInOrder.add(n);\n-                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n-                transformation.addAlias(name, qualifiedName);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-            }\n-        }\n-        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n-            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (n.getType() == Token.NAME) {\n-            String name = n.getString();\n-            Var aliasVar = aliases.get(name);\n-            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n-                // Note, to support the transitive case, it's important we don't\n-                // clone aliasedNode here.  For example,\n-                // var g = goog; var d = g.dom; d.createElement('DIV');\n-                // The node in aliasedNode (which is \"g\") will be replaced in the\n-                // changes pass above with \"goog\".  If we cloned here, we'd end up\n-                // with <code>g.dom.createElement('DIV')</code>.\n-                Node aliasedNode = aliasVar.getInitialValue();\n-                aliasUsages.add(new AliasedNode(n, aliasedNode));\n-            }\n-        }\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+public void enterScope(NodeTraversal t) {\n+    Node n = t.getClosestHoistScope().getParent(); // Using getClosestHoistScope() to get the parent node of the enclosing scope\n+    if (n != null && isCallToScopeMethod(n)) {\n+        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node n = t.getClosestHoistScope().getRootNode();\n    if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@enterScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@enterScope\n@@ -1,6 +1,6 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    Node n = t.getCurrentNode().getParent();\n+    Node n = t.getClosestHoistScope().getRootNode();\n     if (n != null && isCallToScopeMethod(n)) {\n         transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n     }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,7 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    // Validate the top level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        int type = n.getType();\n-        if (type == Token.NAME && parent.getType() == Token.VAR) {\n-            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-                String name = n.getString();\n-                Var aliasVar = t.getScope().getVar(name);\n-                aliases.put(name, aliasVar);\n-                aliasDefinitionsInOrder.add(n);\n-                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n-                transformation.addAlias(name, qualifiedName);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-            }\n-        }\n-        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n-            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (n.getType() == Token.NAME) {\n-            String name = n.getString();\n-            Var aliasVar = aliases.get(name);\n-            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n-                // Note, to support the transitive case, it's important we don't\n-                // clone aliasedNode here.  For example,\n-                // var g = goog; var d = g.dom; d.createElement('DIV');\n-                // The node in aliasedNode (which is \"g\") will be replaced in the\n-                // changes pass above with \"goog\".  If we cloned here, we'd end up\n-                // with <code>g.dom.createElement('DIV')</code>.\n-                Node aliasedNode = aliasVar.getInitialValue();\n-                aliasUsages.add(new AliasedNode(n, aliasedNode));\n-            }\n-        }\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+public void enterScope(NodeTraversal t) {\n+    Node n = t.getClosestHoistScope().getRootNode();\n+    if (n != null && isCallToScopeMethod(n)) {\n+        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node n = t.getCurrentNode().getParent();\n    if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), n.getLineno(), n.getCharno());\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@enterScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@enterScope\n@@ -2,6 +2,6 @@\n public void enterScope(NodeTraversal t) {\n     Node n = t.getCurrentNode().getParent();\n     if (n != null && isCallToScopeMethod(n)) {\n-        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n+        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), n.getLineno(), n.getCharno());\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,7 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    // Validate the top level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        int type = n.getType();\n-        if (type == Token.NAME && parent.getType() == Token.VAR) {\n-            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-                String name = n.getString();\n-                Var aliasVar = t.getScope().getVar(name);\n-                aliases.put(name, aliasVar);\n-                aliasDefinitionsInOrder.add(n);\n-                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n-                transformation.addAlias(name, qualifiedName);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-            }\n-        }\n-        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n-            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (n.getType() == Token.NAME) {\n-            String name = n.getString();\n-            Var aliasVar = aliases.get(name);\n-            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n-                // Note, to support the transitive case, it's important we don't\n-                // clone aliasedNode here.  For example,\n-                // var g = goog; var d = g.dom; d.createElement('DIV');\n-                // The node in aliasedNode (which is \"g\") will be replaced in the\n-                // changes pass above with \"goog\".  If we cloned here, we'd end up\n-                // with <code>g.dom.createElement('DIV')</code>.\n-                Node aliasedNode = aliasVar.getInitialValue();\n-                aliasUsages.add(new AliasedNode(n, aliasedNode));\n-            }\n-        }\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+public void enterScope(NodeTraversal t) {\n+    Node n = t.getCurrentNode().getParent();\n+    if (n != null && isCallToScopeMethod(n)) {\n+        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), n.getLineno(), n.getCharno());\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node n = t.getClosestHoistScope();\n    if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@enterScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@enterScope\n@@ -1,6 +1,6 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    Node n = t.getCurrentNode().getParent();\n+    Node n = t.getClosestHoistScope();\n     if (n != null && isCallToScopeMethod(n)) {\n         transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n     }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,7 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    // Validate the top level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        int type = n.getType();\n-        if (type == Token.NAME && parent.getType() == Token.VAR) {\n-            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-                String name = n.getString();\n-                Var aliasVar = t.getScope().getVar(name);\n-                aliases.put(name, aliasVar);\n-                aliasDefinitionsInOrder.add(n);\n-                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n-                transformation.addAlias(name, qualifiedName);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-            }\n-        }\n-        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n-            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (n.getType() == Token.NAME) {\n-            String name = n.getString();\n-            Var aliasVar = aliases.get(name);\n-            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n-                // Note, to support the transitive case, it's important we don't\n-                // clone aliasedNode here.  For example,\n-                // var g = goog; var d = g.dom; d.createElement('DIV');\n-                // The node in aliasedNode (which is \"g\") will be replaced in the\n-                // changes pass above with \"goog\".  If we cloned here, we'd end up\n-                // with <code>g.dom.createElement('DIV')</code>.\n-                Node aliasedNode = aliasVar.getInitialValue();\n-                aliasUsages.add(new AliasedNode(n, aliasedNode));\n-            }\n-        }\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+public void enterScope(NodeTraversal t) {\n+    Node n = t.getClosestHoistScope();\n+    if (n != null && isCallToScopeMethod(n)) {\n+        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node n = t.getClosestHoistScope().getParent();\n    if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@enterScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@enterScope\n@@ -1,6 +1,6 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    Node n = t.getCurrentNode().getParent();\n+    Node n = t.getClosestHoistScope().getParent();\n     if (n != null && isCallToScopeMethod(n)) {\n         transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n     }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,7 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    // Validate the top level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        int type = n.getType();\n-        if (type == Token.NAME && parent.getType() == Token.VAR) {\n-            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-                String name = n.getString();\n-                Var aliasVar = t.getScope().getVar(name);\n-                aliases.put(name, aliasVar);\n-                aliasDefinitionsInOrder.add(n);\n-                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n-                transformation.addAlias(name, qualifiedName);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-            }\n-        }\n-        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n-            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (n.getType() == Token.NAME) {\n-            String name = n.getString();\n-            Var aliasVar = aliases.get(name);\n-            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n-                // Note, to support the transitive case, it's important we don't\n-                // clone aliasedNode here.  For example,\n-                // var g = goog; var d = g.dom; d.createElement('DIV');\n-                // The node in aliasedNode (which is \"g\") will be replaced in the\n-                // changes pass above with \"goog\".  If we cloned here, we'd end up\n-                // with <code>g.dom.createElement('DIV')</code>.\n-                Node aliasedNode = aliasVar.getInitialValue();\n-                aliasUsages.add(new AliasedNode(n, aliasedNode));\n-            }\n-        }\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+public void enterScope(NodeTraversal t) {\n+    Node n = t.getClosestHoistScope().getParent();\n+    if (n != null && isCallToScopeMethod(n)) {\n+        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node n = t.getCurrentNode().getParent();\n    if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), n.getLineno());\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@enterScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@enterScope\n@@ -2,6 +2,6 @@\n public void enterScope(NodeTraversal t) {\n     Node n = t.getCurrentNode().getParent();\n     if (n != null && isCallToScopeMethod(n)) {\n-        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n+        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), n.getLineno());\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,7 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    // Validate the top level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        int type = n.getType();\n-        if (type == Token.NAME && parent.getType() == Token.VAR) {\n-            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-                String name = n.getString();\n-                Var aliasVar = t.getScope().getVar(name);\n-                aliases.put(name, aliasVar);\n-                aliasDefinitionsInOrder.add(n);\n-                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n-                transformation.addAlias(name, qualifiedName);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-            }\n-        }\n-        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n-            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (n.getType() == Token.NAME) {\n-            String name = n.getString();\n-            Var aliasVar = aliases.get(name);\n-            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n-                // Note, to support the transitive case, it's important we don't\n-                // clone aliasedNode here.  For example,\n-                // var g = goog; var d = g.dom; d.createElement('DIV');\n-                // The node in aliasedNode (which is \"g\") will be replaced in the\n-                // changes pass above with \"goog\".  If we cloned here, we'd end up\n-                // with <code>g.dom.createElement('DIV')</code>.\n-                Node aliasedNode = aliasVar.getInitialValue();\n-                aliasUsages.add(new AliasedNode(n, aliasedNode));\n-            }\n-        }\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+public void enterScope(NodeTraversal t) {\n+    Node n = t.getCurrentNode().getParent();\n+    if (n != null && isCallToScopeMethod(n)) {\n+        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), n.getLineno());\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node n = t.getCurrentNode();\n    // check if the current node is a function node\n    if (n.isFunction()) {\n        // check if the function is a call to a scope method\n        Node parent = n.getParent();\n        if (parent != null && isCallToScopeMethod(parent)) {\n            transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@enterScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@enterScope\n@@ -1,7 +1,12 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    Node n = t.getCurrentNode().getParent();\n-    if (n != null && isCallToScopeMethod(n)) {\n-        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n+    Node n = t.getCurrentNode();\n+    // check if the current node is a function node\n+    if (n.isFunction()) {\n+        // check if the function is a call to a scope method\n+        Node parent = n.getParent();\n+        if (parent != null && isCallToScopeMethod(parent)) {\n+            transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n+        }\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,12 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    // Validate the top level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        int type = n.getType();\n-        if (type == Token.NAME && parent.getType() == Token.VAR) {\n-            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-                String name = n.getString();\n-                Var aliasVar = t.getScope().getVar(name);\n-                aliases.put(name, aliasVar);\n-                aliasDefinitionsInOrder.add(n);\n-                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n-                transformation.addAlias(name, qualifiedName);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-            }\n-        }\n-        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n-            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n+public void enterScope(NodeTraversal t) {\n+    Node n = t.getCurrentNode();\n+    // check if the current node is a function node\n+    if (n.isFunction()) {\n+        // check if the function is a call to a scope method\n+        Node parent = n.getParent();\n+        if (parent != null && isCallToScopeMethod(parent)) {\n+            transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n         }\n     }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (n.getType() == Token.NAME) {\n-            String name = n.getString();\n-            Var aliasVar = aliases.get(name);\n-            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n-                // Note, to support the transitive case, it's important we don't\n-                // clone aliasedNode here.  For example,\n-                // var g = goog; var d = g.dom; d.createElement('DIV');\n-                // The node in aliasedNode (which is \"g\") will be replaced in the\n-                // changes pass above with \"goog\".  If we cloned here, we'd end up\n-                // with <code>g.dom.createElement('DIV')</code>.\n-                Node aliasedNode = aliasVar.getInitialValue();\n-                aliasUsages.add(new AliasedNode(n, aliasedNode));\n-            }\n-        }\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n-    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node n = t.getCurrentNode().getParent();\n    if (n != null && isCallToScopeMethod(n)) {\n        SourcePosition sourcePosition = t.getSourcePosition();\n        if (sourcePosition != null) {\n            transformation = transformationHandler.logAliasTransformation(sourcePosition.getSourceFile().getName(), sourcePosition.getStartLine(), sourcePosition.getStartCharacter(), sourcePosition.getEndLine(), sourcePosition.getEndCharacter());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@enterScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@enterScope\n@@ -2,6 +2,9 @@\n public void enterScope(NodeTraversal t) {\n     Node n = t.getCurrentNode().getParent();\n     if (n != null && isCallToScopeMethod(n)) {\n-        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n+        SourcePosition sourcePosition = t.getSourcePosition();\n+        if (sourcePosition != null) {\n+            transformation = transformationHandler.logAliasTransformation(sourcePosition.getSourceFile().getName(), sourcePosition.getStartLine(), sourcePosition.getStartCharacter(), sourcePosition.getEndLine(), sourcePosition.getEndCharacter());\n+        }\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,10 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    // Validate the top level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        int type = n.getType();\n-        if (type == Token.NAME && parent.getType() == Token.VAR) {\n-            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-                String name = n.getString();\n-                Var aliasVar = t.getScope().getVar(name);\n-                aliases.put(name, aliasVar);\n-                aliasDefinitionsInOrder.add(n);\n-                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n-                transformation.addAlias(name, qualifiedName);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-            }\n-        }\n-        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n-            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n+public void enterScope(NodeTraversal t) {\n+    Node n = t.getCurrentNode().getParent();\n+    if (n != null && isCallToScopeMethod(n)) {\n+        SourcePosition sourcePosition = t.getSourcePosition();\n+        if (sourcePosition != null) {\n+            transformation = transformationHandler.logAliasTransformation(sourcePosition.getSourceFile().getName(), sourcePosition.getStartLine(), sourcePosition.getStartCharacter(), sourcePosition.getEndLine(), sourcePosition.getEndCharacter());\n         }\n     }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (n.getType() == Token.NAME) {\n-            String name = n.getString();\n-            Var aliasVar = aliases.get(name);\n-            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n-                // Note, to support the transitive case, it's important we don't\n-                // clone aliasedNode here.  For example,\n-                // var g = goog; var d = g.dom; d.createElement('DIV');\n-                // The node in aliasedNode (which is \"g\") will be replaced in the\n-                // changes pass above with \"goog\".  If we cloned here, we'd end up\n-                // with <code>g.dom.createElement('DIV')</code>.\n-                Node aliasedNode = aliasVar.getInitialValue();\n-                aliasUsages.add(new AliasedNode(n, aliasedNode));\n-            }\n-        }\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n-    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node n = t.getCurrentNode().getParent();\n    if (n != null && NodeUtil.isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), NodeUtil.getSourceRegion(n));\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@enterScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@enterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     Node n = t.getCurrentNode().getParent();\n-    if (n != null && isCallToScopeMethod(n)) {\n-        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n+    if (n != null && NodeUtil.isCallToScopeMethod(n)) {\n+        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), NodeUtil.getSourceRegion(n));\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,7 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    // Validate the top level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        int type = n.getType();\n-        if (type == Token.NAME && parent.getType() == Token.VAR) {\n-            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-                String name = n.getString();\n-                Var aliasVar = t.getScope().getVar(name);\n-                aliases.put(name, aliasVar);\n-                aliasDefinitionsInOrder.add(n);\n-                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n-                transformation.addAlias(name, qualifiedName);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-            }\n-        }\n-        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n-            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (n.getType() == Token.NAME) {\n-            String name = n.getString();\n-            Var aliasVar = aliases.get(name);\n-            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n-                // Note, to support the transitive case, it's important we don't\n-                // clone aliasedNode here.  For example,\n-                // var g = goog; var d = g.dom; d.createElement('DIV');\n-                // The node in aliasedNode (which is \"g\") will be replaced in the\n-                // changes pass above with \"goog\".  If we cloned here, we'd end up\n-                // with <code>g.dom.createElement('DIV')</code>.\n-                Node aliasedNode = aliasVar.getInitialValue();\n-                aliasUsages.add(new AliasedNode(n, aliasedNode));\n-            }\n-        }\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+public void enterScope(NodeTraversal t) {\n+    Node n = t.getCurrentNode().getParent();\n+    if (n != null && NodeUtil.isCallToScopeMethod(n)) {\n+        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), NodeUtil.getSourceRegion(n));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node n = t.getCurrentNode().getParent();\n    if (n != null && n.isCall() && isCallToScopeMethod(n.getFirstChild())) {\n        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@enterScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@enterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     Node n = t.getCurrentNode().getParent();\n-    if (n != null && isCallToScopeMethod(n)) {\n+    if (n != null && n.isCall() && isCallToScopeMethod(n.getFirstChild())) {\n         transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,7 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    // Validate the top level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        int type = n.getType();\n-        if (type == Token.NAME && parent.getType() == Token.VAR) {\n-            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-                String name = n.getString();\n-                Var aliasVar = t.getScope().getVar(name);\n-                aliases.put(name, aliasVar);\n-                aliasDefinitionsInOrder.add(n);\n-                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n-                transformation.addAlias(name, qualifiedName);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-            }\n-        }\n-        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n-            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (n.getType() == Token.NAME) {\n-            String name = n.getString();\n-            Var aliasVar = aliases.get(name);\n-            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n-                // Note, to support the transitive case, it's important we don't\n-                // clone aliasedNode here.  For example,\n-                // var g = goog; var d = g.dom; d.createElement('DIV');\n-                // The node in aliasedNode (which is \"g\") will be replaced in the\n-                // changes pass above with \"goog\".  If we cloned here, we'd end up\n-                // with <code>g.dom.createElement('DIV')</code>.\n-                Node aliasedNode = aliasVar.getInitialValue();\n-                aliasUsages.add(new AliasedNode(n, aliasedNode));\n-            }\n-        }\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+public void enterScope(NodeTraversal t) {\n+    Node n = t.getCurrentNode().getParent();\n+    if (n != null && n.isCall() && isCallToScopeMethod(n.getFirstChild())) {\n+        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node n = t.getEnclosingScope().getRootNode().getParent();\n    if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@enterScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@enterScope\n@@ -1,6 +1,6 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    Node n = t.getCurrentNode().getParent();\n+    Node n = t.getEnclosingScope().getRootNode().getParent();\n     if (n != null && isCallToScopeMethod(n)) {\n         transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n     }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,7 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    // Validate the top level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        int type = n.getType();\n-        if (type == Token.NAME && parent.getType() == Token.VAR) {\n-            if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-                String name = n.getString();\n-                Var aliasVar = t.getScope().getVar(name);\n-                aliases.put(name, aliasVar);\n-                aliasDefinitionsInOrder.add(n);\n-                String qualifiedName = aliasVar.getInitialValue().getQualifiedName();\n-                transformation.addAlias(name, qualifiedName);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-            }\n-        }\n-        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) && n == parent.getFirstChild()) {\n-            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (n.getType() == Token.NAME) {\n-            String name = n.getString();\n-            Var aliasVar = aliases.get(name);\n-            if (aliasVar != null && t.getScope().getVar(name) == aliasVar) {\n-                // Note, to support the transitive case, it's important we don't\n-                // clone aliasedNode here.  For example,\n-                // var g = goog; var d = g.dom; d.createElement('DIV');\n-                // The node in aliasedNode (which is \"g\") will be replaced in the\n-                // changes pass above with \"goog\".  If we cloned here, we'd end up\n-                // with <code>g.dom.createElement('DIV')</code>.\n-                Node aliasedNode = aliasVar.getInitialValue();\n-                aliasUsages.add(new AliasedNode(n, aliasedNode));\n-            }\n-        }\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+public void enterScope(NodeTraversal t) {\n+    Node n = t.getEnclosingScope().getRootNode().getParent();\n+    if (n != null && isCallToScopeMethod(n)) {\n+        transformation = transformationHandler.logAliasTransformation(n.getSourceFileName(), getSourceRegion(n));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]