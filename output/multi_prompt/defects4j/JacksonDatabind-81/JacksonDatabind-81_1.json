[{"output": "@Override\npublic JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n    // Ok: start by refining the main type itself; common to all types\n    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n        try {\n            type = tf.constructSpecializedType(baseType, valueClass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n        }\n    }\n    // Then further processing for container types\n    // First, key type (for Maps, Map-like types):\n    if (type.isMapLikeType()) {\n        JavaType keyType = type.getKeyType();\n        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n        if (keyClass != null) {\n            try {\n                keyType = tf.constructSpecializedType(keyType, keyClass);\n                type = ((MapLikeType) type).withKeyType(keyType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    JavaType contentType = type.getContentType();\n    if (contentType != null) {\n        // collection[like], map[like], array, reference\n        // And then value types for all containers:\n        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n        if (contentClass != null) {\n            try {\n                contentType = tf.constructSpecializedType(contentType, contentClass);\n                type = type.withContentType(contentType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n@@ -1,96 +1,43 @@\n @Override\n-public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n+public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n     JavaType type = baseType;\n     final TypeFactory tf = config.getTypeFactory();\n-    final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n+    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n     // Ok: start by refining the main type itself; common to all types\n-    final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n-    if (serClass != null) {\n-        if (type.hasRawClass(serClass)) {\n-            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n-            //    static typing this way\n-            type = type.withStaticTyping();\n-        } else {\n-            Class<?> currRaw = type.getRawClass();\n-            try {\n-                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n-                //   may be needed here too in future?\n-                if (serClass.isAssignableFrom(currRaw)) {\n-                    // common case\n-                    type = tf.constructGeneralizedType(type, serClass);\n-                } else if (currRaw.isAssignableFrom(serClass)) {\n-                    // specialization, ok as well\n-                    type = tf.constructSpecializedType(type, serClass);\n-                    // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                } else {\n-                    throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName()));\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae);\n-            }\n+    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n+    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n+        try {\n+            type = tf.constructSpecializedType(baseType, valueClass);\n+        } catch (IllegalArgumentException iae) {\n+            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n         }\n     }\n     // Then further processing for container types\n     // First, key type (for Maps, Map-like types):\n     if (type.isMapLikeType()) {\n         JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n+        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n         if (keyClass != null) {\n-            if (keyType.hasRawClass(keyClass)) {\n-                keyType = keyType.withStaticTyping();\n-            } else {\n-                Class<?> currRaw = keyType.getRawClass();\n-                try {\n-                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n-                    //   specialize (narrow) type sometimes, even if more commonly opposite\n-                    //   is needed.\n-                    if (keyClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n-                    } else if (currRaw.isAssignableFrom(keyClass)) {\n-                        // specialization, ok as well\n-                        keyType = tf.constructSpecializedType(keyType, keyClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                keyType = tf.constructSpecializedType(keyType, keyClass);\n+                type = ((MapLikeType) type).withKeyType(keyType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = ((MapLikeType) type).withKeyType(keyType);\n         }\n     }\n     JavaType contentType = type.getContentType();\n     if (contentType != null) {\n         // collection[like], map[like], array, reference\n         // And then value types for all containers:\n-        final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n+        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n         if (contentClass != null) {\n-            if (contentType.hasRawClass(contentClass)) {\n-                contentType = contentType.withStaticTyping();\n-            } else {\n-                // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n-                //   specialize (narrow) type sometimes, even if more commonly opposite\n-                //   is needed.\n-                Class<?> currRaw = contentType.getRawClass();\n-                try {\n-                    if (contentClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        contentType = tf.constructGeneralizedType(contentType, contentClass);\n-                    } else if (currRaw.isAssignableFrom(contentClass)) {\n-                        // specialization, ok as well\n-                        contentType = tf.constructSpecializedType(contentType, contentClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    // shouldn't really happen\n-                    throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                contentType = tf.constructSpecializedType(contentType, contentClass);\n+                type = type.withContentType(contentType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = type.withContentType(contentType);\n         }\n     }\n     return type;\n--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n@@ -7,7 +7,7 @@\n     final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n     if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n         try {\n-            type = tf.constructSpecializedType(type, valueClass);\n+            type = tf.constructSpecializedType(baseType, valueClass);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n    // Ok: start by refining the main type itself; common to all types\n    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n        try {\n            type = tf.constructSpecializedType(type, valueClass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n        }\n    }\n    // Then further processing for container types\n    // Fix: Add null check for jsonDeser before processing container types\n    if(jsonDeser != null){\n        // First, key type (for Maps, Map-like types):\n        if (type.isMapLikeType()) {\n            JavaType keyType = type.getKeyType();\n            final Class<?> keyClass = _classIfExplicit(jsonDeser.keyAs());\n            if (keyClass != null) {\n                try {\n                    keyType = tf.constructSpecializedType(keyType, keyClass);\n                    type = ((MapLikeType) type).withKeyType(keyType);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n                }\n            }\n        }\n        JavaType contentType = type.getContentType();\n        if (contentType != null) {\n            // collection[like], map[like], array, reference\n            // And then value types for all containers:\n            final Class<?> contentClass = _classIfExplicit(jsonDeser.contentAs());\n            if (contentClass != null) {\n                try {\n                    contentType = tf.constructSpecializedType(contentType, contentClass);\n                    type = type.withContentType(contentType);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n                }\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n@@ -1,96 +1,46 @@\n @Override\n-public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n+public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n     JavaType type = baseType;\n     final TypeFactory tf = config.getTypeFactory();\n-    final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n+    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n     // Ok: start by refining the main type itself; common to all types\n-    final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n-    if (serClass != null) {\n-        if (type.hasRawClass(serClass)) {\n-            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n-            //    static typing this way\n-            type = type.withStaticTyping();\n-        } else {\n-            Class<?> currRaw = type.getRawClass();\n-            try {\n-                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n-                //   may be needed here too in future?\n-                if (serClass.isAssignableFrom(currRaw)) {\n-                    // common case\n-                    type = tf.constructGeneralizedType(type, serClass);\n-                } else if (currRaw.isAssignableFrom(serClass)) {\n-                    // specialization, ok as well\n-                    type = tf.constructSpecializedType(type, serClass);\n-                    // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                } else {\n-                    throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName()));\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae);\n-            }\n+    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n+    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n+        try {\n+            type = tf.constructSpecializedType(type, valueClass);\n+        } catch (IllegalArgumentException iae) {\n+            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n         }\n     }\n     // Then further processing for container types\n-    // First, key type (for Maps, Map-like types):\n-    if (type.isMapLikeType()) {\n-        JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n-        if (keyClass != null) {\n-            if (keyType.hasRawClass(keyClass)) {\n-                keyType = keyType.withStaticTyping();\n-            } else {\n-                Class<?> currRaw = keyType.getRawClass();\n+    // Fix: Add null check for jsonDeser before processing container types\n+    if(jsonDeser != null){\n+        // First, key type (for Maps, Map-like types):\n+        if (type.isMapLikeType()) {\n+            JavaType keyType = type.getKeyType();\n+            final Class<?> keyClass = _classIfExplicit(jsonDeser.keyAs());\n+            if (keyClass != null) {\n                 try {\n-                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n-                    //   specialize (narrow) type sometimes, even if more commonly opposite\n-                    //   is needed.\n-                    if (keyClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n-                    } else if (currRaw.isAssignableFrom(keyClass)) {\n-                        // specialization, ok as well\n-                        keyType = tf.constructSpecializedType(keyType, keyClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName()));\n-                    }\n+                    keyType = tf.constructSpecializedType(keyType, keyClass);\n+                    type = ((MapLikeType) type).withKeyType(keyType);\n                 } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n+                    throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n                 }\n             }\n-            type = ((MapLikeType) type).withKeyType(keyType);\n         }\n-    }\n-    JavaType contentType = type.getContentType();\n-    if (contentType != null) {\n-        // collection[like], map[like], array, reference\n-        // And then value types for all containers:\n-        final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n-        if (contentClass != null) {\n-            if (contentType.hasRawClass(contentClass)) {\n-                contentType = contentType.withStaticTyping();\n-            } else {\n-                // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n-                //   specialize (narrow) type sometimes, even if more commonly opposite\n-                //   is needed.\n-                Class<?> currRaw = contentType.getRawClass();\n+        JavaType contentType = type.getContentType();\n+        if (contentType != null) {\n+            // collection[like], map[like], array, reference\n+            // And then value types for all containers:\n+            final Class<?> contentClass = _classIfExplicit(jsonDeser.contentAs());\n+            if (contentClass != null) {\n                 try {\n-                    if (contentClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        contentType = tf.constructGeneralizedType(contentType, contentClass);\n-                    } else if (currRaw.isAssignableFrom(contentClass)) {\n-                        // specialization, ok as well\n-                        contentType = tf.constructSpecializedType(contentType, contentClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName()));\n-                    }\n+                    contentType = tf.constructSpecializedType(contentType, contentClass);\n+                    type = type.withContentType(contentType);\n                 } catch (IllegalArgumentException iae) {\n-                    // shouldn't really happen\n-                    throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n+                    throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n                 }\n             }\n-            type = type.withContentType(contentType);\n         }\n     }\n     return type;\n--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n@@ -13,30 +13,33 @@\n         }\n     }\n     // Then further processing for container types\n-    // First, key type (for Maps, Map-like types):\n-    if (type.isMapLikeType()) {\n-        JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n-        if (keyClass != null) {\n-            try {\n-                keyType = tf.constructSpecializedType(keyType, keyClass);\n-                type = ((MapLikeType) type).withKeyType(keyType);\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n+    // Fix: Add null check for jsonDeser before processing container types\n+    if(jsonDeser != null){\n+        // First, key type (for Maps, Map-like types):\n+        if (type.isMapLikeType()) {\n+            JavaType keyType = type.getKeyType();\n+            final Class<?> keyClass = _classIfExplicit(jsonDeser.keyAs());\n+            if (keyClass != null) {\n+                try {\n+                    keyType = tf.constructSpecializedType(keyType, keyClass);\n+                    type = ((MapLikeType) type).withKeyType(keyType);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n+                }\n             }\n         }\n-    }\n-    JavaType contentType = type.getContentType();\n-    if (contentType != null) {\n-        // collection[like], map[like], array, reference\n-        // And then value types for all containers:\n-        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n-        if (contentClass != null) {\n-            try {\n-                contentType = tf.constructSpecializedType(contentType, contentClass);\n-                type = type.withContentType(contentType);\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n+        JavaType contentType = type.getContentType();\n+        if (contentType != null) {\n+            // collection[like], map[like], array, reference\n+            // And then value types for all containers:\n+            final Class<?> contentClass = _classIfExplicit(jsonDeser.contentAs());\n+            if (contentClass != null) {\n+                try {\n+                    contentType = tf.constructSpecializedType(contentType, contentClass);\n+                    type = type.withContentType(contentType);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n+                }\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n    // Ok: start by refining the main type itself; common to all types\n    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n        try {\n            type = tf.constructSpecializedType(type, valueClass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), null, iae);\n        }\n    }\n    // Then further processing for container types\n    // First, key type (for Maps, Map-like types):\n    if (type.isMapLikeType()) {\n        JavaType keyType = type.getKeyType();\n        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n        if (keyClass != null) {\n            try {\n                keyType = tf.constructSpecializedType(keyType, keyClass);\n                type = ((MapLikeType) type).withKeyType(keyType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), null, iae);\n            }\n        }\n    }\n    JavaType contentType = type.getContentType();\n    if (contentType != null) {\n        // collection[like], map[like], array, reference\n        // And then value types for all containers:\n        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n        if (contentClass != null) {\n            try {\n                contentType = tf.constructSpecializedType(contentType, contentClass);\n                type = type.withContentType(contentType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), null, iae);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n@@ -1,96 +1,43 @@\n @Override\n-public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n+public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n     JavaType type = baseType;\n     final TypeFactory tf = config.getTypeFactory();\n-    final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n+    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n     // Ok: start by refining the main type itself; common to all types\n-    final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n-    if (serClass != null) {\n-        if (type.hasRawClass(serClass)) {\n-            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n-            //    static typing this way\n-            type = type.withStaticTyping();\n-        } else {\n-            Class<?> currRaw = type.getRawClass();\n-            try {\n-                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n-                //   may be needed here too in future?\n-                if (serClass.isAssignableFrom(currRaw)) {\n-                    // common case\n-                    type = tf.constructGeneralizedType(type, serClass);\n-                } else if (currRaw.isAssignableFrom(serClass)) {\n-                    // specialization, ok as well\n-                    type = tf.constructSpecializedType(type, serClass);\n-                    // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                } else {\n-                    throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName()));\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae);\n-            }\n+    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n+    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n+        try {\n+            type = tf.constructSpecializedType(type, valueClass);\n+        } catch (IllegalArgumentException iae) {\n+            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), null, iae);\n         }\n     }\n     // Then further processing for container types\n     // First, key type (for Maps, Map-like types):\n     if (type.isMapLikeType()) {\n         JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n+        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n         if (keyClass != null) {\n-            if (keyType.hasRawClass(keyClass)) {\n-                keyType = keyType.withStaticTyping();\n-            } else {\n-                Class<?> currRaw = keyType.getRawClass();\n-                try {\n-                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n-                    //   specialize (narrow) type sometimes, even if more commonly opposite\n-                    //   is needed.\n-                    if (keyClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n-                    } else if (currRaw.isAssignableFrom(keyClass)) {\n-                        // specialization, ok as well\n-                        keyType = tf.constructSpecializedType(keyType, keyClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                keyType = tf.constructSpecializedType(keyType, keyClass);\n+                type = ((MapLikeType) type).withKeyType(keyType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), null, iae);\n             }\n-            type = ((MapLikeType) type).withKeyType(keyType);\n         }\n     }\n     JavaType contentType = type.getContentType();\n     if (contentType != null) {\n         // collection[like], map[like], array, reference\n         // And then value types for all containers:\n-        final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n+        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n         if (contentClass != null) {\n-            if (contentType.hasRawClass(contentClass)) {\n-                contentType = contentType.withStaticTyping();\n-            } else {\n-                // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n-                //   specialize (narrow) type sometimes, even if more commonly opposite\n-                //   is needed.\n-                Class<?> currRaw = contentType.getRawClass();\n-                try {\n-                    if (contentClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        contentType = tf.constructGeneralizedType(contentType, contentClass);\n-                    } else if (currRaw.isAssignableFrom(contentClass)) {\n-                        // specialization, ok as well\n-                        contentType = tf.constructSpecializedType(contentType, contentClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    // shouldn't really happen\n-                    throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                contentType = tf.constructSpecializedType(contentType, contentClass);\n+                type = type.withContentType(contentType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), null, iae);\n             }\n-            type = type.withContentType(contentType);\n         }\n     }\n     return type;\n--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n@@ -9,7 +9,7 @@\n         try {\n             type = tf.constructSpecializedType(type, valueClass);\n         } catch (IllegalArgumentException iae) {\n-            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n+            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), null, iae);\n         }\n     }\n     // Then further processing for container types\n@@ -22,7 +22,7 @@\n                 keyType = tf.constructSpecializedType(keyType, keyClass);\n                 type = ((MapLikeType) type).withKeyType(keyType);\n             } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), null, iae);\n             }\n         }\n     }\n@@ -36,7 +36,7 @@\n                 contentType = tf.constructSpecializedType(contentType, contentClass);\n                 type = type.withContentType(contentType);\n             } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), null, iae);\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n    // Ok: start by refining the main type itself; common to all types\n    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n        try {\n            type = tf.constructSpecializedType(type, valueClass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n        }\n    }\n    // Then further processing for container types\n    // First, key type (for Maps, Map-like types):\n    if (type.isMapLikeType()) {\n        JavaType keyType = type.getKeyType();\n        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n        if (keyClass != null) {\n            try {\n                keyType = tf.constructSpecializedType(keyType, keyClass);\n                type = type.withKeyType(keyType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    if (type.isContainerType()) {\n        JavaType contentType = type.getContentType();\n        if (contentType != null) {\n            // collection[like], map[like], array, reference\n            // And then value types for all containers:\n            final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n            if (contentClass != null) {\n                try {\n                    contentType = tf.constructSpecializedType(contentType, contentClass);\n                    type = type.withContentType(contentType);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n                }\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n@@ -1,96 +1,45 @@\n @Override\n-public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n+public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n     JavaType type = baseType;\n     final TypeFactory tf = config.getTypeFactory();\n-    final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n+    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n     // Ok: start by refining the main type itself; common to all types\n-    final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n-    if (serClass != null) {\n-        if (type.hasRawClass(serClass)) {\n-            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n-            //    static typing this way\n-            type = type.withStaticTyping();\n-        } else {\n-            Class<?> currRaw = type.getRawClass();\n-            try {\n-                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n-                //   may be needed here too in future?\n-                if (serClass.isAssignableFrom(currRaw)) {\n-                    // common case\n-                    type = tf.constructGeneralizedType(type, serClass);\n-                } else if (currRaw.isAssignableFrom(serClass)) {\n-                    // specialization, ok as well\n-                    type = tf.constructSpecializedType(type, serClass);\n-                    // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                } else {\n-                    throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName()));\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae);\n-            }\n+    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n+    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n+        try {\n+            type = tf.constructSpecializedType(type, valueClass);\n+        } catch (IllegalArgumentException iae) {\n+            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n         }\n     }\n     // Then further processing for container types\n     // First, key type (for Maps, Map-like types):\n     if (type.isMapLikeType()) {\n         JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n+        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n         if (keyClass != null) {\n-            if (keyType.hasRawClass(keyClass)) {\n-                keyType = keyType.withStaticTyping();\n-            } else {\n-                Class<?> currRaw = keyType.getRawClass();\n+            try {\n+                keyType = tf.constructSpecializedType(keyType, keyClass);\n+                type = type.withKeyType(keyType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n+            }\n+        }\n+    }\n+    if (type.isContainerType()) {\n+        JavaType contentType = type.getContentType();\n+        if (contentType != null) {\n+            // collection[like], map[like], array, reference\n+            // And then value types for all containers:\n+            final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n+            if (contentClass != null) {\n                 try {\n-                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n-                    //   specialize (narrow) type sometimes, even if more commonly opposite\n-                    //   is needed.\n-                    if (keyClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n-                    } else if (currRaw.isAssignableFrom(keyClass)) {\n-                        // specialization, ok as well\n-                        keyType = tf.constructSpecializedType(keyType, keyClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName()));\n-                    }\n+                    contentType = tf.constructSpecializedType(contentType, contentClass);\n+                    type = type.withContentType(contentType);\n                 } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n+                    throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n                 }\n             }\n-            type = ((MapLikeType) type).withKeyType(keyType);\n-        }\n-    }\n-    JavaType contentType = type.getContentType();\n-    if (contentType != null) {\n-        // collection[like], map[like], array, reference\n-        // And then value types for all containers:\n-        final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n-        if (contentClass != null) {\n-            if (contentType.hasRawClass(contentClass)) {\n-                contentType = contentType.withStaticTyping();\n-            } else {\n-                // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n-                //   specialize (narrow) type sometimes, even if more commonly opposite\n-                //   is needed.\n-                Class<?> currRaw = contentType.getRawClass();\n-                try {\n-                    if (contentClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        contentType = tf.constructGeneralizedType(contentType, contentClass);\n-                    } else if (currRaw.isAssignableFrom(contentClass)) {\n-                        // specialization, ok as well\n-                        contentType = tf.constructSpecializedType(contentType, contentClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    // shouldn't really happen\n-                    throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n-            }\n-            type = type.withContentType(contentType);\n         }\n     }\n     return type;\n--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n@@ -20,23 +20,25 @@\n         if (keyClass != null) {\n             try {\n                 keyType = tf.constructSpecializedType(keyType, keyClass);\n-                type = ((MapLikeType) type).withKeyType(keyType);\n+                type = type.withKeyType(keyType);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n         }\n     }\n-    JavaType contentType = type.getContentType();\n-    if (contentType != null) {\n-        // collection[like], map[like], array, reference\n-        // And then value types for all containers:\n-        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n-        if (contentClass != null) {\n-            try {\n-                contentType = tf.constructSpecializedType(contentType, contentClass);\n-                type = type.withContentType(contentType);\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n+    if (type.isContainerType()) {\n+        JavaType contentType = type.getContentType();\n+        if (contentType != null) {\n+            // collection[like], map[like], array, reference\n+            // And then value types for all containers:\n+            final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n+            if (contentClass != null) {\n+                try {\n+                    contentType = tf.constructSpecializedType(contentType, contentClass);\n+                    type = type.withContentType(contentType);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n+                }\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n    // Ok: start by refining the main type itself; common to all types\n    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n        try {\n            type = tf.constructSpecializedType(type, valueClass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n        }\n    }\n    // Then further processing for container types\n    // First, key type (for Maps, Map-like types):\n    if (type.isMapLikeType()) {\n        JavaType keyType = type.getKeyType();\n        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n        if (keyClass != null) {\n            try {\n                keyType = tf.constructSpecializedType(keyType, keyClass);\n                type = ((MapLikeType) type).withKeyType(keyType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    JavaType contentType = type.getContentType();\n    if (contentType != null && type.isContainerType()) { // fix here to check if type is a container type\n        // collection[like], map[like], array, reference\n        // And then value types for all containers:\n        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n        if (contentClass != null) {\n            try {\n                contentType = tf.constructSpecializedType(contentType, contentClass);\n                type = type.withContentType(contentType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n@@ -1,96 +1,43 @@\n @Override\n-public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n+public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n     JavaType type = baseType;\n     final TypeFactory tf = config.getTypeFactory();\n-    final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n+    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n     // Ok: start by refining the main type itself; common to all types\n-    final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n-    if (serClass != null) {\n-        if (type.hasRawClass(serClass)) {\n-            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n-            //    static typing this way\n-            type = type.withStaticTyping();\n-        } else {\n-            Class<?> currRaw = type.getRawClass();\n-            try {\n-                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n-                //   may be needed here too in future?\n-                if (serClass.isAssignableFrom(currRaw)) {\n-                    // common case\n-                    type = tf.constructGeneralizedType(type, serClass);\n-                } else if (currRaw.isAssignableFrom(serClass)) {\n-                    // specialization, ok as well\n-                    type = tf.constructSpecializedType(type, serClass);\n-                    // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                } else {\n-                    throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName()));\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae);\n-            }\n+    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n+    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n+        try {\n+            type = tf.constructSpecializedType(type, valueClass);\n+        } catch (IllegalArgumentException iae) {\n+            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n         }\n     }\n     // Then further processing for container types\n     // First, key type (for Maps, Map-like types):\n     if (type.isMapLikeType()) {\n         JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n+        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n         if (keyClass != null) {\n-            if (keyType.hasRawClass(keyClass)) {\n-                keyType = keyType.withStaticTyping();\n-            } else {\n-                Class<?> currRaw = keyType.getRawClass();\n-                try {\n-                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n-                    //   specialize (narrow) type sometimes, even if more commonly opposite\n-                    //   is needed.\n-                    if (keyClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n-                    } else if (currRaw.isAssignableFrom(keyClass)) {\n-                        // specialization, ok as well\n-                        keyType = tf.constructSpecializedType(keyType, keyClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                keyType = tf.constructSpecializedType(keyType, keyClass);\n+                type = ((MapLikeType) type).withKeyType(keyType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = ((MapLikeType) type).withKeyType(keyType);\n         }\n     }\n     JavaType contentType = type.getContentType();\n-    if (contentType != null) {\n+    if (contentType != null && type.isContainerType()) { // fix here to check if type is a container type\n         // collection[like], map[like], array, reference\n         // And then value types for all containers:\n-        final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n+        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n         if (contentClass != null) {\n-            if (contentType.hasRawClass(contentClass)) {\n-                contentType = contentType.withStaticTyping();\n-            } else {\n-                // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n-                //   specialize (narrow) type sometimes, even if more commonly opposite\n-                //   is needed.\n-                Class<?> currRaw = contentType.getRawClass();\n-                try {\n-                    if (contentClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        contentType = tf.constructGeneralizedType(contentType, contentClass);\n-                    } else if (currRaw.isAssignableFrom(contentClass)) {\n-                        // specialization, ok as well\n-                        contentType = tf.constructSpecializedType(contentType, contentClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    // shouldn't really happen\n-                    throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                contentType = tf.constructSpecializedType(contentType, contentClass);\n+                type = type.withContentType(contentType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = type.withContentType(contentType);\n         }\n     }\n     return type;\n--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n@@ -27,7 +27,7 @@\n         }\n     }\n     JavaType contentType = type.getContentType();\n-    if (contentType != null) {\n+    if (contentType != null && type.isContainerType()) { // fix here to check if type is a container type\n         // collection[like], map[like], array, reference\n         // And then value types for all containers:\n         final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n    // Ok: start by refining the main type itself; common to all types\n    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n        try {\n            type = tf.constructSpecializedType(type, valueClass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n        }\n    }\n    // Then further processing for container types\n    // First, key type (for Maps, Map-like types):\n    if (type.isMapLikeType()) {\n        JavaType keyType = type.getKeyType();\n        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n        if (keyClass != null) {\n            try {\n                keyType = tf.constructSpecializedType(keyType, keyClass);\n                type = ((MapLikeType) type).withKeyType(keyType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    if (type.getContentType() != null) {\n        JavaType contentType = type.getContentType();\n        // Then, value type for arrays...\n        if (type.isArrayType()) {\n            final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n            if (contentClass != null) {\n                try {\n                    contentType = tf.constructSpecializedType(contentType, contentClass);\n                    type = type.withContentType(contentType);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null, String.format(\"Failed to narrow content type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n                }\n            }\n        }\n        // ... collection or Map, or reference:\n        else if (type.isReferenceType()) {\n            if (type instanceof com.fasterxml.jackson.databind.type.ResolvedRecursiveType) {\n                return type;\n            }\n            // 06-Oct-2016, tatu: TypeFactory should cache RecursiceType instances: if not, it could\n            //    infinitely loop on some cases. Hence construction of types should be through TypeFactory\n            final JavaType referredType = tf.constructType(type.getReferencedType());\n            final JavaType[] params = tf.findTypeParameters(referredType, com.fasterxml.jackson.databind.type.ReferenceType.class);\n            if ((params != null) && (params.length == 1)) {\n                try {\n                    contentType = tf.constructSpecializedType(contentType, params[0].getRawClass());\n                    type = type.withContentType(contentType);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null, String.format(\"Failed to narrow content type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n                }\n            }\n        }\n        // ... and for containers:\n        else {\n            final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n            if (contentClass != null) {\n                try {\n                    contentType = tf.constructSpecializedType(contentType, contentClass);\n                    type = type.withContentType(contentType);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n                }\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n@@ -1,96 +1,74 @@\n @Override\n-public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n+public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n     JavaType type = baseType;\n     final TypeFactory tf = config.getTypeFactory();\n-    final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n+    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n     // Ok: start by refining the main type itself; common to all types\n-    final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n-    if (serClass != null) {\n-        if (type.hasRawClass(serClass)) {\n-            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n-            //    static typing this way\n-            type = type.withStaticTyping();\n-        } else {\n-            Class<?> currRaw = type.getRawClass();\n-            try {\n-                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n-                //   may be needed here too in future?\n-                if (serClass.isAssignableFrom(currRaw)) {\n-                    // common case\n-                    type = tf.constructGeneralizedType(type, serClass);\n-                } else if (currRaw.isAssignableFrom(serClass)) {\n-                    // specialization, ok as well\n-                    type = tf.constructSpecializedType(type, serClass);\n-                    // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                } else {\n-                    throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName()));\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae);\n-            }\n+    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n+    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n+        try {\n+            type = tf.constructSpecializedType(type, valueClass);\n+        } catch (IllegalArgumentException iae) {\n+            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n         }\n     }\n     // Then further processing for container types\n     // First, key type (for Maps, Map-like types):\n     if (type.isMapLikeType()) {\n         JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n+        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n         if (keyClass != null) {\n-            if (keyType.hasRawClass(keyClass)) {\n-                keyType = keyType.withStaticTyping();\n-            } else {\n-                Class<?> currRaw = keyType.getRawClass();\n+            try {\n+                keyType = tf.constructSpecializedType(keyType, keyClass);\n+                type = ((MapLikeType) type).withKeyType(keyType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n+            }\n+        }\n+    }\n+    if (type.getContentType() != null) {\n+        JavaType contentType = type.getContentType();\n+        // Then, value type for arrays...\n+        if (type.isArrayType()) {\n+            final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n+            if (contentClass != null) {\n                 try {\n-                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n-                    //   specialize (narrow) type sometimes, even if more commonly opposite\n-                    //   is needed.\n-                    if (keyClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n-                    } else if (currRaw.isAssignableFrom(keyClass)) {\n-                        // specialization, ok as well\n-                        keyType = tf.constructSpecializedType(keyType, keyClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName()));\n-                    }\n+                    contentType = tf.constructSpecializedType(contentType, contentClass);\n+                    type = type.withContentType(contentType);\n                 } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n+                    throw new JsonMappingException(null, String.format(\"Failed to narrow content type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n                 }\n             }\n-            type = ((MapLikeType) type).withKeyType(keyType);\n         }\n-    }\n-    JavaType contentType = type.getContentType();\n-    if (contentType != null) {\n-        // collection[like], map[like], array, reference\n-        // And then value types for all containers:\n-        final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n-        if (contentClass != null) {\n-            if (contentType.hasRawClass(contentClass)) {\n-                contentType = contentType.withStaticTyping();\n-            } else {\n-                // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n-                //   specialize (narrow) type sometimes, even if more commonly opposite\n-                //   is needed.\n-                Class<?> currRaw = contentType.getRawClass();\n+        // ... collection or Map, or reference:\n+        else if (type.isReferenceType()) {\n+            if (type instanceof com.fasterxml.jackson.databind.type.ResolvedRecursiveType) {\n+                return type;\n+            }\n+            // 06-Oct-2016, tatu: TypeFactory should cache RecursiceType instances: if not, it could\n+            //    infinitely loop on some cases. Hence construction of types should be through TypeFactory\n+            final JavaType referredType = tf.constructType(type.getReferencedType());\n+            final JavaType[] params = tf.findTypeParameters(referredType, com.fasterxml.jackson.databind.type.ReferenceType.class);\n+            if ((params != null) && (params.length == 1)) {\n                 try {\n-                    if (contentClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        contentType = tf.constructGeneralizedType(contentType, contentClass);\n-                    } else if (currRaw.isAssignableFrom(contentClass)) {\n-                        // specialization, ok as well\n-                        contentType = tf.constructSpecializedType(contentType, contentClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName()));\n-                    }\n+                    contentType = tf.constructSpecializedType(contentType, params[0].getRawClass());\n+                    type = type.withContentType(contentType);\n                 } catch (IllegalArgumentException iae) {\n-                    // shouldn't really happen\n-                    throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n+                    throw new JsonMappingException(null, String.format(\"Failed to narrow content type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n                 }\n             }\n-            type = type.withContentType(contentType);\n+        }\n+        // ... and for containers:\n+        else {\n+            final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n+            if (contentClass != null) {\n+                try {\n+                    contentType = tf.constructSpecializedType(contentType, contentClass);\n+                    type = type.withContentType(contentType);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n+                }\n+            }\n         }\n     }\n     return type;\n--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n@@ -26,17 +26,48 @@\n             }\n         }\n     }\n-    JavaType contentType = type.getContentType();\n-    if (contentType != null) {\n-        // collection[like], map[like], array, reference\n-        // And then value types for all containers:\n-        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n-        if (contentClass != null) {\n-            try {\n-                contentType = tf.constructSpecializedType(contentType, contentClass);\n-                type = type.withContentType(contentType);\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n+    if (type.getContentType() != null) {\n+        JavaType contentType = type.getContentType();\n+        // Then, value type for arrays...\n+        if (type.isArrayType()) {\n+            final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n+            if (contentClass != null) {\n+                try {\n+                    contentType = tf.constructSpecializedType(contentType, contentClass);\n+                    type = type.withContentType(contentType);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(null, String.format(\"Failed to narrow content type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n+                }\n+            }\n+        }\n+        // ... collection or Map, or reference:\n+        else if (type.isReferenceType()) {\n+            if (type instanceof com.fasterxml.jackson.databind.type.ResolvedRecursiveType) {\n+                return type;\n+            }\n+            // 06-Oct-2016, tatu: TypeFactory should cache RecursiceType instances: if not, it could\n+            //    infinitely loop on some cases. Hence construction of types should be through TypeFactory\n+            final JavaType referredType = tf.constructType(type.getReferencedType());\n+            final JavaType[] params = tf.findTypeParameters(referredType, com.fasterxml.jackson.databind.type.ReferenceType.class);\n+            if ((params != null) && (params.length == 1)) {\n+                try {\n+                    contentType = tf.constructSpecializedType(contentType, params[0].getRawClass());\n+                    type = type.withContentType(contentType);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(null, String.format(\"Failed to narrow content type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n+                }\n+            }\n+        }\n+        // ... and for containers:\n+        else {\n+            final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n+            if (contentClass != null) {\n+                try {\n+                    contentType = tf.constructSpecializedType(contentType, contentClass);\n+                    type = type.withContentType(contentType);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n+                }\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n    // Ok: start by refining the main type itself; common to all types\n    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n        try {\n            type = tf.constructSpecializedType(type, valueClass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n        }\n    }\n    // Then further processing for container types\n    // First, key type (for Maps, Map-like types):\n    if (type.isMapLikeType()) {\n        JavaType keyType = type.getKeyType();\n        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n        if (keyClass != null) {\n            try {\n                keyType = tf.constructSpecializedType(keyType, keyClass);\n                type = ((MapLikeType) type).withKeyType(keyType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    JavaType contentType = type.getContentType();\n    if (contentType != null) {\n        // collection[like], map[like], array, reference\n        // And then value types for all containers:\n        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n        if (contentClass != null) {\n            try {\n                contentType = tf.constructSpecializedType(contentType, contentClass);\n                type = type.withContentType(contentType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n@@ -1,96 +1,43 @@\n @Override\n-public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n+public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n     JavaType type = baseType;\n     final TypeFactory tf = config.getTypeFactory();\n-    final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n+    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n     // Ok: start by refining the main type itself; common to all types\n-    final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n-    if (serClass != null) {\n-        if (type.hasRawClass(serClass)) {\n-            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n-            //    static typing this way\n-            type = type.withStaticTyping();\n-        } else {\n-            Class<?> currRaw = type.getRawClass();\n-            try {\n-                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n-                //   may be needed here too in future?\n-                if (serClass.isAssignableFrom(currRaw)) {\n-                    // common case\n-                    type = tf.constructGeneralizedType(type, serClass);\n-                } else if (currRaw.isAssignableFrom(serClass)) {\n-                    // specialization, ok as well\n-                    type = tf.constructSpecializedType(type, serClass);\n-                    // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                } else {\n-                    throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName()));\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae);\n-            }\n+    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n+    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n+        try {\n+            type = tf.constructSpecializedType(type, valueClass);\n+        } catch (IllegalArgumentException iae) {\n+            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n         }\n     }\n     // Then further processing for container types\n     // First, key type (for Maps, Map-like types):\n     if (type.isMapLikeType()) {\n         JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n+        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n         if (keyClass != null) {\n-            if (keyType.hasRawClass(keyClass)) {\n-                keyType = keyType.withStaticTyping();\n-            } else {\n-                Class<?> currRaw = keyType.getRawClass();\n-                try {\n-                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n-                    //   specialize (narrow) type sometimes, even if more commonly opposite\n-                    //   is needed.\n-                    if (keyClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n-                    } else if (currRaw.isAssignableFrom(keyClass)) {\n-                        // specialization, ok as well\n-                        keyType = tf.constructSpecializedType(keyType, keyClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                keyType = tf.constructSpecializedType(keyType, keyClass);\n+                type = ((MapLikeType) type).withKeyType(keyType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = ((MapLikeType) type).withKeyType(keyType);\n         }\n     }\n     JavaType contentType = type.getContentType();\n     if (contentType != null) {\n         // collection[like], map[like], array, reference\n         // And then value types for all containers:\n-        final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n+        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n         if (contentClass != null) {\n-            if (contentType.hasRawClass(contentClass)) {\n-                contentType = contentType.withStaticTyping();\n-            } else {\n-                // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n-                //   specialize (narrow) type sometimes, even if more commonly opposite\n-                //   is needed.\n-                Class<?> currRaw = contentType.getRawClass();\n-                try {\n-                    if (contentClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        contentType = tf.constructGeneralizedType(contentType, contentClass);\n-                    } else if (currRaw.isAssignableFrom(contentClass)) {\n-                        // specialization, ok as well\n-                        contentType = tf.constructSpecializedType(contentType, contentClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    // shouldn't really happen\n-                    throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                contentType = tf.constructSpecializedType(contentType, contentClass);\n+                type = type.withContentType(contentType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = type.withContentType(contentType);\n         }\n     }\n     return type;\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "@Override\npublic JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n    // Ok: start by refining the main type itself; common to all types\n    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n        try {\n            type = tf.constructSpecializedType(type, valueClass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n        }\n    }\n    // Then further processing for container types\n    // First, key type (for Maps, Map-like types):\n    if (type.isMapLikeType()) {\n        JavaType keyType = type.getKeyType();\n        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n        if (keyClass != null) {\n            try {\n                keyType = tf.constructSpecializedType(keyType, keyClass);\n                type = ((MapLikeType) type).withKeyType(keyType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    if (type.isContainerType()) {\n        JavaType contentType = type.getContentType();\n        if (contentType != null) {\n            // collection[like], map[like], array, reference\n            // And then value types for all containers:\n            final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n            if (contentClass != null) {\n                try {\n                    contentType = tf.constructSpecializedType(contentType, contentClass);\n                    type = type.withContentType(contentType);\n                } catch (IllegalArgumentException iae) {\n                    throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n                }\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n@@ -1,96 +1,45 @@\n @Override\n-public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n+public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n     JavaType type = baseType;\n     final TypeFactory tf = config.getTypeFactory();\n-    final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n+    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n     // Ok: start by refining the main type itself; common to all types\n-    final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n-    if (serClass != null) {\n-        if (type.hasRawClass(serClass)) {\n-            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n-            //    static typing this way\n-            type = type.withStaticTyping();\n-        } else {\n-            Class<?> currRaw = type.getRawClass();\n-            try {\n-                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n-                //   may be needed here too in future?\n-                if (serClass.isAssignableFrom(currRaw)) {\n-                    // common case\n-                    type = tf.constructGeneralizedType(type, serClass);\n-                } else if (currRaw.isAssignableFrom(serClass)) {\n-                    // specialization, ok as well\n-                    type = tf.constructSpecializedType(type, serClass);\n-                    // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                } else {\n-                    throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName()));\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae);\n-            }\n+    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n+    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n+        try {\n+            type = tf.constructSpecializedType(type, valueClass);\n+        } catch (IllegalArgumentException iae) {\n+            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n         }\n     }\n     // Then further processing for container types\n     // First, key type (for Maps, Map-like types):\n     if (type.isMapLikeType()) {\n         JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n+        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n         if (keyClass != null) {\n-            if (keyType.hasRawClass(keyClass)) {\n-                keyType = keyType.withStaticTyping();\n-            } else {\n-                Class<?> currRaw = keyType.getRawClass();\n+            try {\n+                keyType = tf.constructSpecializedType(keyType, keyClass);\n+                type = ((MapLikeType) type).withKeyType(keyType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n+            }\n+        }\n+    }\n+    if (type.isContainerType()) {\n+        JavaType contentType = type.getContentType();\n+        if (contentType != null) {\n+            // collection[like], map[like], array, reference\n+            // And then value types for all containers:\n+            final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n+            if (contentClass != null) {\n                 try {\n-                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n-                    //   specialize (narrow) type sometimes, even if more commonly opposite\n-                    //   is needed.\n-                    if (keyClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n-                    } else if (currRaw.isAssignableFrom(keyClass)) {\n-                        // specialization, ok as well\n-                        keyType = tf.constructSpecializedType(keyType, keyClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName()));\n-                    }\n+                    contentType = tf.constructSpecializedType(contentType, contentClass);\n+                    type = type.withContentType(contentType);\n                 } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n+                    throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n                 }\n             }\n-            type = ((MapLikeType) type).withKeyType(keyType);\n-        }\n-    }\n-    JavaType contentType = type.getContentType();\n-    if (contentType != null) {\n-        // collection[like], map[like], array, reference\n-        // And then value types for all containers:\n-        final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n-        if (contentClass != null) {\n-            if (contentType.hasRawClass(contentClass)) {\n-                contentType = contentType.withStaticTyping();\n-            } else {\n-                // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n-                //   specialize (narrow) type sometimes, even if more commonly opposite\n-                //   is needed.\n-                Class<?> currRaw = contentType.getRawClass();\n-                try {\n-                    if (contentClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        contentType = tf.constructGeneralizedType(contentType, contentClass);\n-                    } else if (currRaw.isAssignableFrom(contentClass)) {\n-                        // specialization, ok as well\n-                        contentType = tf.constructSpecializedType(contentType, contentClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    // shouldn't really happen\n-                    throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n-            }\n-            type = type.withContentType(contentType);\n         }\n     }\n     return type;\n--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n@@ -26,17 +26,19 @@\n             }\n         }\n     }\n-    JavaType contentType = type.getContentType();\n-    if (contentType != null) {\n-        // collection[like], map[like], array, reference\n-        // And then value types for all containers:\n-        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n-        if (contentClass != null) {\n-            try {\n-                contentType = tf.constructSpecializedType(contentType, contentClass);\n-                type = type.withContentType(contentType);\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n+    if (type.isContainerType()) {\n+        JavaType contentType = type.getContentType();\n+        if (contentType != null) {\n+            // collection[like], map[like], array, reference\n+            // And then value types for all containers:\n+            final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n+            if (contentClass != null) {\n+                try {\n+                    contentType = tf.constructSpecializedType(contentType, contentClass);\n+                    type = type.withContentType(contentType);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n+                }\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n    // Ok: start by refining the main type itself; common to all types\n    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n        try {\n            type = tf.constructSpecializedType(type, valueClass);\n        } catch (IllegalArgumentException iae) {\n            throw JsonMappingException.from(a, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n        }\n    }\n    // Then further processing for container types\n    // First, key type (for Maps, Map-like types):\n    if (type.isMapLikeType()) {\n        JavaType keyType = type.getKeyType();\n        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n        if (keyClass != null) {\n            try {\n                keyType = tf.constructSpecializedType(keyType, keyClass);\n                type = ((MapLikeType) type).withKeyType(keyType);\n            } catch (IllegalArgumentException iae) {\n                throw JsonMappingException.from(a, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    JavaType contentType = type.getContentType();\n    if (contentType != null) {\n        // collection[like], map[like], array, reference\n        // And then value types for all containers:\n        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n        if (contentClass != null) {\n            try {\n                contentType = tf.constructSpecializedType(contentType, contentClass);\n                type = type.withContentType(contentType);\n            } catch (IllegalArgumentException iae) {\n                throw JsonMappingException.from(a, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n@@ -1,96 +1,43 @@\n @Override\n-public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n+public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n     JavaType type = baseType;\n     final TypeFactory tf = config.getTypeFactory();\n-    final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n+    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n     // Ok: start by refining the main type itself; common to all types\n-    final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n-    if (serClass != null) {\n-        if (type.hasRawClass(serClass)) {\n-            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n-            //    static typing this way\n-            type = type.withStaticTyping();\n-        } else {\n-            Class<?> currRaw = type.getRawClass();\n-            try {\n-                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n-                //   may be needed here too in future?\n-                if (serClass.isAssignableFrom(currRaw)) {\n-                    // common case\n-                    type = tf.constructGeneralizedType(type, serClass);\n-                } else if (currRaw.isAssignableFrom(serClass)) {\n-                    // specialization, ok as well\n-                    type = tf.constructSpecializedType(type, serClass);\n-                    // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                } else {\n-                    throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName()));\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae);\n-            }\n+    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n+    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n+        try {\n+            type = tf.constructSpecializedType(type, valueClass);\n+        } catch (IllegalArgumentException iae) {\n+            throw JsonMappingException.from(a, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n         }\n     }\n     // Then further processing for container types\n     // First, key type (for Maps, Map-like types):\n     if (type.isMapLikeType()) {\n         JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n+        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n         if (keyClass != null) {\n-            if (keyType.hasRawClass(keyClass)) {\n-                keyType = keyType.withStaticTyping();\n-            } else {\n-                Class<?> currRaw = keyType.getRawClass();\n-                try {\n-                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n-                    //   specialize (narrow) type sometimes, even if more commonly opposite\n-                    //   is needed.\n-                    if (keyClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n-                    } else if (currRaw.isAssignableFrom(keyClass)) {\n-                        // specialization, ok as well\n-                        keyType = tf.constructSpecializedType(keyType, keyClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                keyType = tf.constructSpecializedType(keyType, keyClass);\n+                type = ((MapLikeType) type).withKeyType(keyType);\n+            } catch (IllegalArgumentException iae) {\n+                throw JsonMappingException.from(a, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = ((MapLikeType) type).withKeyType(keyType);\n         }\n     }\n     JavaType contentType = type.getContentType();\n     if (contentType != null) {\n         // collection[like], map[like], array, reference\n         // And then value types for all containers:\n-        final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n+        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n         if (contentClass != null) {\n-            if (contentType.hasRawClass(contentClass)) {\n-                contentType = contentType.withStaticTyping();\n-            } else {\n-                // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n-                //   specialize (narrow) type sometimes, even if more commonly opposite\n-                //   is needed.\n-                Class<?> currRaw = contentType.getRawClass();\n-                try {\n-                    if (contentClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        contentType = tf.constructGeneralizedType(contentType, contentClass);\n-                    } else if (currRaw.isAssignableFrom(contentClass)) {\n-                        // specialization, ok as well\n-                        contentType = tf.constructSpecializedType(contentType, contentClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    // shouldn't really happen\n-                    throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                contentType = tf.constructSpecializedType(contentType, contentClass);\n+                type = type.withContentType(contentType);\n+            } catch (IllegalArgumentException iae) {\n+                throw JsonMappingException.from(a, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = type.withContentType(contentType);\n         }\n     }\n     return type;\n--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n@@ -9,7 +9,7 @@\n         try {\n             type = tf.constructSpecializedType(type, valueClass);\n         } catch (IllegalArgumentException iae) {\n-            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n+            throw JsonMappingException.from(a, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n         }\n     }\n     // Then further processing for container types\n@@ -22,7 +22,7 @@\n                 keyType = tf.constructSpecializedType(keyType, keyClass);\n                 type = ((MapLikeType) type).withKeyType(keyType);\n             } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n+                throw JsonMappingException.from(a, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n         }\n     }\n@@ -36,7 +36,7 @@\n                 contentType = tf.constructSpecializedType(contentType, contentClass);\n                 type = type.withContentType(contentType);\n             } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n+                throw JsonMappingException.from(a, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n    // Ok: start by refining the main type itself; common to all types\n    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n        try {\n            TypeBindings bindings = type.getBindings();\n            if (bindings == null) {\n                bindings = new TypeBindings(tf, type.getRawClass());\n            }\n            type = tf.constructSpecializedType(type, valueClass).withBindings(bindings);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n        }\n    }\n    // Then further processing for container types\n    // First, key type (for Maps, Map-like types):\n    if (type.isMapLikeType()) {\n        JavaType keyType = type.getKeyType();\n        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n        if (keyClass != null) {\n            try {\n                keyType = tf.constructSpecializedType(keyType, keyClass);\n                type = ((MapLikeType) type).withKeyType(keyType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    JavaType contentType = type.getContentType();\n    if (contentType != null) {\n        // collection[like], map[like], array, reference\n        // And then value types for all containers:\n        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n        if (contentClass != null) {\n            try {\n                TypeBindings bindings = contentType.getBindings();\n                if (bindings == null) {\n                    bindings = new TypeBindings(tf, contentType.getRawClass());\n                }\n                contentType = tf.constructSpecializedType(contentType, contentClass).withBindings(bindings);\n                type = type.withContentType(contentType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n@@ -1,96 +1,51 @@\n @Override\n-public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n+public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n     JavaType type = baseType;\n     final TypeFactory tf = config.getTypeFactory();\n-    final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n+    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n     // Ok: start by refining the main type itself; common to all types\n-    final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n-    if (serClass != null) {\n-        if (type.hasRawClass(serClass)) {\n-            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n-            //    static typing this way\n-            type = type.withStaticTyping();\n-        } else {\n-            Class<?> currRaw = type.getRawClass();\n-            try {\n-                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n-                //   may be needed here too in future?\n-                if (serClass.isAssignableFrom(currRaw)) {\n-                    // common case\n-                    type = tf.constructGeneralizedType(type, serClass);\n-                } else if (currRaw.isAssignableFrom(serClass)) {\n-                    // specialization, ok as well\n-                    type = tf.constructSpecializedType(type, serClass);\n-                    // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                } else {\n-                    throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName()));\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae);\n+    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n+    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n+        try {\n+            TypeBindings bindings = type.getBindings();\n+            if (bindings == null) {\n+                bindings = new TypeBindings(tf, type.getRawClass());\n             }\n+            type = tf.constructSpecializedType(type, valueClass).withBindings(bindings);\n+        } catch (IllegalArgumentException iae) {\n+            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n         }\n     }\n     // Then further processing for container types\n     // First, key type (for Maps, Map-like types):\n     if (type.isMapLikeType()) {\n         JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n+        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n         if (keyClass != null) {\n-            if (keyType.hasRawClass(keyClass)) {\n-                keyType = keyType.withStaticTyping();\n-            } else {\n-                Class<?> currRaw = keyType.getRawClass();\n-                try {\n-                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n-                    //   specialize (narrow) type sometimes, even if more commonly opposite\n-                    //   is needed.\n-                    if (keyClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n-                    } else if (currRaw.isAssignableFrom(keyClass)) {\n-                        // specialization, ok as well\n-                        keyType = tf.constructSpecializedType(keyType, keyClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                keyType = tf.constructSpecializedType(keyType, keyClass);\n+                type = ((MapLikeType) type).withKeyType(keyType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = ((MapLikeType) type).withKeyType(keyType);\n         }\n     }\n     JavaType contentType = type.getContentType();\n     if (contentType != null) {\n         // collection[like], map[like], array, reference\n         // And then value types for all containers:\n-        final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n+        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n         if (contentClass != null) {\n-            if (contentType.hasRawClass(contentClass)) {\n-                contentType = contentType.withStaticTyping();\n-            } else {\n-                // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n-                //   specialize (narrow) type sometimes, even if more commonly opposite\n-                //   is needed.\n-                Class<?> currRaw = contentType.getRawClass();\n-                try {\n-                    if (contentClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        contentType = tf.constructGeneralizedType(contentType, contentClass);\n-                    } else if (currRaw.isAssignableFrom(contentClass)) {\n-                        // specialization, ok as well\n-                        contentType = tf.constructSpecializedType(contentType, contentClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    // shouldn't really happen\n-                    throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n+            try {\n+                TypeBindings bindings = contentType.getBindings();\n+                if (bindings == null) {\n+                    bindings = new TypeBindings(tf, contentType.getRawClass());\n                 }\n+                contentType = tf.constructSpecializedType(contentType, contentClass).withBindings(bindings);\n+                type = type.withContentType(contentType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = type.withContentType(contentType);\n         }\n     }\n     return type;\n--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n@@ -7,7 +7,11 @@\n     final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n     if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n         try {\n-            type = tf.constructSpecializedType(type, valueClass);\n+            TypeBindings bindings = type.getBindings();\n+            if (bindings == null) {\n+                bindings = new TypeBindings(tf, type.getRawClass());\n+            }\n+            type = tf.constructSpecializedType(type, valueClass).withBindings(bindings);\n         } catch (IllegalArgumentException iae) {\n             throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n         }\n@@ -33,7 +37,11 @@\n         final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n         if (contentClass != null) {\n             try {\n-                contentType = tf.constructSpecializedType(contentType, contentClass);\n+                TypeBindings bindings = contentType.getBindings();\n+                if (bindings == null) {\n+                    bindings = new TypeBindings(tf, contentType.getRawClass());\n+                }\n+                contentType = tf.constructSpecializedType(contentType, contentClass).withBindings(bindings);\n                 type = type.withContentType(contentType);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "There is not enough information provided to determine the fix for the given function in the JacksonDatabind project. Please provide more context and details about the specific issue or error message encountered.", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n    // Ok: start by refining the main type itself; common to all types\n    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n        try {\n            type = tf.constructSpecializedType(type, valueClass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n        }\n    }\n    // Then further processing for container types\n    // First, key type (for Maps, Map-like types):\n    if (type.isMapLikeType()) {\n        JavaType keyType = type.getKeyType();\n        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n        if (keyClass != null) {\n            try {\n                keyType = tf.constructSpecializedType(keyType, keyClass);\n                type = ((MapLikeType) type).withKeyType(keyType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    JavaType contentType = type.getContentType();\n    if (contentType != null) {\n        // collection[like], map[like], array, reference\n        // And then value types for all containers:\n        final Class<?> contentClass = (jsonDeser == null) ? null : jsonDeser.contentAs();\n        if (contentClass != null) {\n            try {\n                contentType = tf.constructSpecializedType(contentType, contentClass);\n                type = type.withContentType(contentType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n@@ -1,96 +1,43 @@\n @Override\n-public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n+public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n     JavaType type = baseType;\n     final TypeFactory tf = config.getTypeFactory();\n-    final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n+    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n     // Ok: start by refining the main type itself; common to all types\n-    final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n-    if (serClass != null) {\n-        if (type.hasRawClass(serClass)) {\n-            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n-            //    static typing this way\n-            type = type.withStaticTyping();\n-        } else {\n-            Class<?> currRaw = type.getRawClass();\n-            try {\n-                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n-                //   may be needed here too in future?\n-                if (serClass.isAssignableFrom(currRaw)) {\n-                    // common case\n-                    type = tf.constructGeneralizedType(type, serClass);\n-                } else if (currRaw.isAssignableFrom(serClass)) {\n-                    // specialization, ok as well\n-                    type = tf.constructSpecializedType(type, serClass);\n-                    // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                } else {\n-                    throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName()));\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae);\n-            }\n+    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n+    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n+        try {\n+            type = tf.constructSpecializedType(type, valueClass);\n+        } catch (IllegalArgumentException iae) {\n+            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n         }\n     }\n     // Then further processing for container types\n     // First, key type (for Maps, Map-like types):\n     if (type.isMapLikeType()) {\n         JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n+        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n         if (keyClass != null) {\n-            if (keyType.hasRawClass(keyClass)) {\n-                keyType = keyType.withStaticTyping();\n-            } else {\n-                Class<?> currRaw = keyType.getRawClass();\n-                try {\n-                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n-                    //   specialize (narrow) type sometimes, even if more commonly opposite\n-                    //   is needed.\n-                    if (keyClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n-                    } else if (currRaw.isAssignableFrom(keyClass)) {\n-                        // specialization, ok as well\n-                        keyType = tf.constructSpecializedType(keyType, keyClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                keyType = tf.constructSpecializedType(keyType, keyClass);\n+                type = ((MapLikeType) type).withKeyType(keyType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = ((MapLikeType) type).withKeyType(keyType);\n         }\n     }\n     JavaType contentType = type.getContentType();\n     if (contentType != null) {\n         // collection[like], map[like], array, reference\n         // And then value types for all containers:\n-        final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n+        final Class<?> contentClass = (jsonDeser == null) ? null : jsonDeser.contentAs();\n         if (contentClass != null) {\n-            if (contentType.hasRawClass(contentClass)) {\n-                contentType = contentType.withStaticTyping();\n-            } else {\n-                // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n-                //   specialize (narrow) type sometimes, even if more commonly opposite\n-                //   is needed.\n-                Class<?> currRaw = contentType.getRawClass();\n-                try {\n-                    if (contentClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        contentType = tf.constructGeneralizedType(contentType, contentClass);\n-                    } else if (currRaw.isAssignableFrom(contentClass)) {\n-                        // specialization, ok as well\n-                        contentType = tf.constructSpecializedType(contentType, contentClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    // shouldn't really happen\n-                    throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                contentType = tf.constructSpecializedType(contentType, contentClass);\n+                type = type.withContentType(contentType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = type.withContentType(contentType);\n         }\n     }\n     return type;\n--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n@@ -30,7 +30,7 @@\n     if (contentType != null) {\n         // collection[like], map[like], array, reference\n         // And then value types for all containers:\n-        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n+        final Class<?> contentClass = (jsonDeser == null) ? null : jsonDeser.contentAs();\n         if (contentClass != null) {\n             try {\n                 contentType = tf.constructSpecializedType(contentType, contentClass);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n    // Ok: start by refining the main type itself; common to all types\n    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n        try {\n            type = tf.constructSpecializedType(type, valueClass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n        }\n    }\n    // Then further processing for container types\n    // First, key type (for Maps, Map-like types):\n    if (type.isMapLikeType()) {\n        JavaType keyType = type.getKeyType();\n        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n        if (keyClass != null) {\n            try {\n                keyType = tf.constructSpecializedType(keyType, keyClass);\n                type = ((MapLikeType) type).withKeyType(keyType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    JavaType contentType = type.getContentType();\n    if (contentType != null) {\n        // collection[like], map[like], array, reference\n        // And then value types for all containers:\n        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n        if (contentClass != null) {\n            try {\n                contentType = tf.constructSpecializedType(contentType, contentClass);\n                type = type.withContentType(contentType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    if (jsonDeser != null && jsonDeser.builder() != NoClass.class) {\n        type = type.withStaticTyping();\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n@@ -1,97 +1,47 @@\n @Override\n-public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n+public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n     JavaType type = baseType;\n     final TypeFactory tf = config.getTypeFactory();\n-    final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n+    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n     // Ok: start by refining the main type itself; common to all types\n-    final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n-    if (serClass != null) {\n-        if (type.hasRawClass(serClass)) {\n-            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n-            //    static typing this way\n-            type = type.withStaticTyping();\n-        } else {\n-            Class<?> currRaw = type.getRawClass();\n-            try {\n-                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n-                //   may be needed here too in future?\n-                if (serClass.isAssignableFrom(currRaw)) {\n-                    // common case\n-                    type = tf.constructGeneralizedType(type, serClass);\n-                } else if (currRaw.isAssignableFrom(serClass)) {\n-                    // specialization, ok as well\n-                    type = tf.constructSpecializedType(type, serClass);\n-                    // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                } else {\n-                    throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName()));\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae);\n-            }\n+    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n+    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n+        try {\n+            type = tf.constructSpecializedType(type, valueClass);\n+        } catch (IllegalArgumentException iae) {\n+            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n         }\n     }\n     // Then further processing for container types\n     // First, key type (for Maps, Map-like types):\n     if (type.isMapLikeType()) {\n         JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n+        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n         if (keyClass != null) {\n-            if (keyType.hasRawClass(keyClass)) {\n-                keyType = keyType.withStaticTyping();\n-            } else {\n-                Class<?> currRaw = keyType.getRawClass();\n-                try {\n-                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n-                    //   specialize (narrow) type sometimes, even if more commonly opposite\n-                    //   is needed.\n-                    if (keyClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n-                    } else if (currRaw.isAssignableFrom(keyClass)) {\n-                        // specialization, ok as well\n-                        keyType = tf.constructSpecializedType(keyType, keyClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                keyType = tf.constructSpecializedType(keyType, keyClass);\n+                type = ((MapLikeType) type).withKeyType(keyType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = ((MapLikeType) type).withKeyType(keyType);\n         }\n     }\n     JavaType contentType = type.getContentType();\n     if (contentType != null) {\n         // collection[like], map[like], array, reference\n         // And then value types for all containers:\n-        final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n+        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n         if (contentClass != null) {\n-            if (contentType.hasRawClass(contentClass)) {\n-                contentType = contentType.withStaticTyping();\n-            } else {\n-                // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n-                //   specialize (narrow) type sometimes, even if more commonly opposite\n-                //   is needed.\n-                Class<?> currRaw = contentType.getRawClass();\n-                try {\n-                    if (contentClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        contentType = tf.constructGeneralizedType(contentType, contentClass);\n-                    } else if (currRaw.isAssignableFrom(contentClass)) {\n-                        // specialization, ok as well\n-                        contentType = tf.constructSpecializedType(contentType, contentClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    // shouldn't really happen\n-                    throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                contentType = tf.constructSpecializedType(contentType, contentClass);\n+                type = type.withContentType(contentType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = type.withContentType(contentType);\n         }\n+    }\n+    if (jsonDeser != null && jsonDeser.builder() != NoClass.class) {\n+        type = type.withStaticTyping();\n     }\n     return type;\n }\n--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n@@ -40,5 +40,8 @@\n             }\n         }\n     }\n+    if (jsonDeser != null && jsonDeser.builder() != NoClass.class) {\n+        type = type.withStaticTyping();\n+    }\n     return type;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// Adding null checks for jsonDeser to prevent NullPointerException in later checks\n@Override\npublic JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n    // Ok: start by refining the main type itself; common to all types\n    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n        try {\n            type = tf.constructSpecializedType(type, valueClass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n        }\n    }\n    // Then further processing for container types\n    // First, key type (for Maps, Map-like types):\n    if (type.isMapLikeType() && jsonDeser != null) {\n        JavaType keyType = type.getKeyType();\n        final Class<?> keyClass = _classIfExplicit(jsonDeser.keyAs());\n        if (keyClass != null) {\n            try {\n                keyType = tf.constructSpecializedType(keyType, keyClass);\n                type = ((MapLikeType) type).withKeyType(keyType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    JavaType contentType = type.getContentType();\n    if (contentType != null && jsonDeser != null) {\n        // collection[like], map[like], array, reference\n        // And then value types for all containers:\n        final Class<?> contentClass = _classIfExplicit(jsonDeser.contentAs());\n        if (contentClass != null) {\n            try {\n                contentType = tf.constructSpecializedType(contentType, contentClass);\n                type = type.withContentType(contentType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n@@ -1,96 +1,43 @@\n @Override\n-public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n+public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n     JavaType type = baseType;\n     final TypeFactory tf = config.getTypeFactory();\n-    final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n+    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n     // Ok: start by refining the main type itself; common to all types\n-    final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n-    if (serClass != null) {\n-        if (type.hasRawClass(serClass)) {\n-            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n-            //    static typing this way\n-            type = type.withStaticTyping();\n-        } else {\n-            Class<?> currRaw = type.getRawClass();\n-            try {\n-                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n-                //   may be needed here too in future?\n-                if (serClass.isAssignableFrom(currRaw)) {\n-                    // common case\n-                    type = tf.constructGeneralizedType(type, serClass);\n-                } else if (currRaw.isAssignableFrom(serClass)) {\n-                    // specialization, ok as well\n-                    type = tf.constructSpecializedType(type, serClass);\n-                    // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                } else {\n-                    throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName()));\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae);\n-            }\n+    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n+    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n+        try {\n+            type = tf.constructSpecializedType(type, valueClass);\n+        } catch (IllegalArgumentException iae) {\n+            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n         }\n     }\n     // Then further processing for container types\n     // First, key type (for Maps, Map-like types):\n-    if (type.isMapLikeType()) {\n+    if (type.isMapLikeType() && jsonDeser != null) {\n         JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n+        final Class<?> keyClass = _classIfExplicit(jsonDeser.keyAs());\n         if (keyClass != null) {\n-            if (keyType.hasRawClass(keyClass)) {\n-                keyType = keyType.withStaticTyping();\n-            } else {\n-                Class<?> currRaw = keyType.getRawClass();\n-                try {\n-                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n-                    //   specialize (narrow) type sometimes, even if more commonly opposite\n-                    //   is needed.\n-                    if (keyClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n-                    } else if (currRaw.isAssignableFrom(keyClass)) {\n-                        // specialization, ok as well\n-                        keyType = tf.constructSpecializedType(keyType, keyClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                keyType = tf.constructSpecializedType(keyType, keyClass);\n+                type = ((MapLikeType) type).withKeyType(keyType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = ((MapLikeType) type).withKeyType(keyType);\n         }\n     }\n     JavaType contentType = type.getContentType();\n-    if (contentType != null) {\n+    if (contentType != null && jsonDeser != null) {\n         // collection[like], map[like], array, reference\n         // And then value types for all containers:\n-        final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n+        final Class<?> contentClass = _classIfExplicit(jsonDeser.contentAs());\n         if (contentClass != null) {\n-            if (contentType.hasRawClass(contentClass)) {\n-                contentType = contentType.withStaticTyping();\n-            } else {\n-                // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n-                //   specialize (narrow) type sometimes, even if more commonly opposite\n-                //   is needed.\n-                Class<?> currRaw = contentType.getRawClass();\n-                try {\n-                    if (contentClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        contentType = tf.constructGeneralizedType(contentType, contentClass);\n-                    } else if (currRaw.isAssignableFrom(contentClass)) {\n-                        // specialization, ok as well\n-                        contentType = tf.constructSpecializedType(contentType, contentClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    // shouldn't really happen\n-                    throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                contentType = tf.constructSpecializedType(contentType, contentClass);\n+                type = type.withContentType(contentType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = type.withContentType(contentType);\n         }\n     }\n     return type;\n--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n@@ -14,9 +14,9 @@\n     }\n     // Then further processing for container types\n     // First, key type (for Maps, Map-like types):\n-    if (type.isMapLikeType()) {\n+    if (type.isMapLikeType() && jsonDeser != null) {\n         JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n+        final Class<?> keyClass = _classIfExplicit(jsonDeser.keyAs());\n         if (keyClass != null) {\n             try {\n                 keyType = tf.constructSpecializedType(keyType, keyClass);\n@@ -27,10 +27,10 @@\n         }\n     }\n     JavaType contentType = type.getContentType();\n-    if (contentType != null) {\n+    if (contentType != null && jsonDeser != null) {\n         // collection[like], map[like], array, reference\n         // And then value types for all containers:\n-        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n+        final Class<?> contentClass = _classIfExplicit(jsonDeser.contentAs());\n         if (contentClass != null) {\n             try {\n                 contentType = tf.constructSpecializedType(contentType, contentClass);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n    // Ok: start by refining the main type itself; common to all types\n    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n        try {\n            type = tf.constructSpecializedType(type, valueClass);\n        } catch (IllegalArgumentException iae) {\n            throw JsonMappingException.from(a, String.format(\"Failed to narrow type %s with annotation (value %s)\", type, valueClass.getName()), iae);\n        }\n    }\n    // Then further processing for container types\n    // First, key type (for Maps, Map-like types):\n    if (type.isMapLikeType()) {\n        JavaType keyType = type.getKeyType();\n        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n        if (keyClass != null) {\n            try {\n                keyType = tf.constructSpecializedType(keyType, keyClass);\n                type = ((MapLikeType) type).withKeyType(keyType);\n            } catch (IllegalArgumentException iae) {\n                throw JsonMappingException.from(a, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s)\", type, keyClass.getName()), iae);\n            }\n        }\n    }\n    JavaType contentType = type.getContentType();\n    if (contentType != null) {\n        // collection[like], map[like], array, reference\n        // And then value types for all containers:\n        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n        if (contentClass != null) {\n            try {\n                contentType = tf.constructSpecializedType(contentType, contentClass);\n                type = type.withContentType(contentType);\n            } catch (IllegalArgumentException iae) {\n                throw JsonMappingException.from(a, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s)\", type, contentClass.getName()), iae);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n@@ -1,96 +1,43 @@\n @Override\n-public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n+public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n     JavaType type = baseType;\n     final TypeFactory tf = config.getTypeFactory();\n-    final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n+    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n     // Ok: start by refining the main type itself; common to all types\n-    final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n-    if (serClass != null) {\n-        if (type.hasRawClass(serClass)) {\n-            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n-            //    static typing this way\n-            type = type.withStaticTyping();\n-        } else {\n-            Class<?> currRaw = type.getRawClass();\n-            try {\n-                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n-                //   may be needed here too in future?\n-                if (serClass.isAssignableFrom(currRaw)) {\n-                    // common case\n-                    type = tf.constructGeneralizedType(type, serClass);\n-                } else if (currRaw.isAssignableFrom(serClass)) {\n-                    // specialization, ok as well\n-                    type = tf.constructSpecializedType(type, serClass);\n-                    // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                } else {\n-                    throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName()));\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae);\n-            }\n+    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n+    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n+        try {\n+            type = tf.constructSpecializedType(type, valueClass);\n+        } catch (IllegalArgumentException iae) {\n+            throw JsonMappingException.from(a, String.format(\"Failed to narrow type %s with annotation (value %s)\", type, valueClass.getName()), iae);\n         }\n     }\n     // Then further processing for container types\n     // First, key type (for Maps, Map-like types):\n     if (type.isMapLikeType()) {\n         JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n+        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n         if (keyClass != null) {\n-            if (keyType.hasRawClass(keyClass)) {\n-                keyType = keyType.withStaticTyping();\n-            } else {\n-                Class<?> currRaw = keyType.getRawClass();\n-                try {\n-                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n-                    //   specialize (narrow) type sometimes, even if more commonly opposite\n-                    //   is needed.\n-                    if (keyClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n-                    } else if (currRaw.isAssignableFrom(keyClass)) {\n-                        // specialization, ok as well\n-                        keyType = tf.constructSpecializedType(keyType, keyClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                keyType = tf.constructSpecializedType(keyType, keyClass);\n+                type = ((MapLikeType) type).withKeyType(keyType);\n+            } catch (IllegalArgumentException iae) {\n+                throw JsonMappingException.from(a, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s)\", type, keyClass.getName()), iae);\n             }\n-            type = ((MapLikeType) type).withKeyType(keyType);\n         }\n     }\n     JavaType contentType = type.getContentType();\n     if (contentType != null) {\n         // collection[like], map[like], array, reference\n         // And then value types for all containers:\n-        final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n+        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n         if (contentClass != null) {\n-            if (contentType.hasRawClass(contentClass)) {\n-                contentType = contentType.withStaticTyping();\n-            } else {\n-                // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n-                //   specialize (narrow) type sometimes, even if more commonly opposite\n-                //   is needed.\n-                Class<?> currRaw = contentType.getRawClass();\n-                try {\n-                    if (contentClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        contentType = tf.constructGeneralizedType(contentType, contentClass);\n-                    } else if (currRaw.isAssignableFrom(contentClass)) {\n-                        // specialization, ok as well\n-                        contentType = tf.constructSpecializedType(contentType, contentClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    // shouldn't really happen\n-                    throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                contentType = tf.constructSpecializedType(contentType, contentClass);\n+                type = type.withContentType(contentType);\n+            } catch (IllegalArgumentException iae) {\n+                throw JsonMappingException.from(a, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s)\", type, contentClass.getName()), iae);\n             }\n-            type = type.withContentType(contentType);\n         }\n     }\n     return type;\n--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n@@ -9,7 +9,7 @@\n         try {\n             type = tf.constructSpecializedType(type, valueClass);\n         } catch (IllegalArgumentException iae) {\n-            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n+            throw JsonMappingException.from(a, String.format(\"Failed to narrow type %s with annotation (value %s)\", type, valueClass.getName()), iae);\n         }\n     }\n     // Then further processing for container types\n@@ -22,7 +22,7 @@\n                 keyType = tf.constructSpecializedType(keyType, keyClass);\n                 type = ((MapLikeType) type).withKeyType(keyType);\n             } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n+                throw JsonMappingException.from(a, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s)\", type, keyClass.getName()), iae);\n             }\n         }\n     }\n@@ -36,7 +36,7 @@\n                 contentType = tf.constructSpecializedType(contentType, contentClass);\n                 type = type.withContentType(contentType);\n             } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n+                throw JsonMappingException.from(a, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s)\", type, contentClass.getName()), iae);\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n    // Ok: start by refining the main type itself; common to all types\n    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n        try {\n            type = tf.constructSpecializedType(type, valueClass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n        }\n    }\n    // Then further processing for container types\n    // First, key type (for Maps, Map-like types):\n    if (type.isMapLikeType()) {\n        // Check if keyAs is specified in annotation\n        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n        if (keyClass != null) {\n            try {\n                final JavaType originalKeyType = type.getKeyType();\n                JavaType newKeyType = tf.constructSpecializedType(originalKeyType, keyClass);\n                type = ((MapLikeType) type).withKeyType(newKeyType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    JavaType contentType = type.getContentType();\n    if (contentType != null) {\n        // collection[like], map[like], array, reference\n        // And then value types for all containers:\n        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n        if (contentClass != null) {\n            try {\n                contentType = tf.constructSpecializedType(contentType, contentClass);\n                type = type.withContentType(contentType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n@@ -1,96 +1,44 @@\n @Override\n-public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n+public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n     JavaType type = baseType;\n     final TypeFactory tf = config.getTypeFactory();\n-    final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n+    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n     // Ok: start by refining the main type itself; common to all types\n-    final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n-    if (serClass != null) {\n-        if (type.hasRawClass(serClass)) {\n-            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n-            //    static typing this way\n-            type = type.withStaticTyping();\n-        } else {\n-            Class<?> currRaw = type.getRawClass();\n-            try {\n-                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n-                //   may be needed here too in future?\n-                if (serClass.isAssignableFrom(currRaw)) {\n-                    // common case\n-                    type = tf.constructGeneralizedType(type, serClass);\n-                } else if (currRaw.isAssignableFrom(serClass)) {\n-                    // specialization, ok as well\n-                    type = tf.constructSpecializedType(type, serClass);\n-                    // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                } else {\n-                    throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName()));\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae);\n-            }\n+    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n+    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n+        try {\n+            type = tf.constructSpecializedType(type, valueClass);\n+        } catch (IllegalArgumentException iae) {\n+            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n         }\n     }\n     // Then further processing for container types\n     // First, key type (for Maps, Map-like types):\n     if (type.isMapLikeType()) {\n-        JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n+        // Check if keyAs is specified in annotation\n+        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n         if (keyClass != null) {\n-            if (keyType.hasRawClass(keyClass)) {\n-                keyType = keyType.withStaticTyping();\n-            } else {\n-                Class<?> currRaw = keyType.getRawClass();\n-                try {\n-                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n-                    //   specialize (narrow) type sometimes, even if more commonly opposite\n-                    //   is needed.\n-                    if (keyClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n-                    } else if (currRaw.isAssignableFrom(keyClass)) {\n-                        // specialization, ok as well\n-                        keyType = tf.constructSpecializedType(keyType, keyClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                final JavaType originalKeyType = type.getKeyType();\n+                JavaType newKeyType = tf.constructSpecializedType(originalKeyType, keyClass);\n+                type = ((MapLikeType) type).withKeyType(newKeyType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = ((MapLikeType) type).withKeyType(keyType);\n         }\n     }\n     JavaType contentType = type.getContentType();\n     if (contentType != null) {\n         // collection[like], map[like], array, reference\n         // And then value types for all containers:\n-        final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n+        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n         if (contentClass != null) {\n-            if (contentType.hasRawClass(contentClass)) {\n-                contentType = contentType.withStaticTyping();\n-            } else {\n-                // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n-                //   specialize (narrow) type sometimes, even if more commonly opposite\n-                //   is needed.\n-                Class<?> currRaw = contentType.getRawClass();\n-                try {\n-                    if (contentClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        contentType = tf.constructGeneralizedType(contentType, contentClass);\n-                    } else if (currRaw.isAssignableFrom(contentClass)) {\n-                        // specialization, ok as well\n-                        contentType = tf.constructSpecializedType(contentType, contentClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    // shouldn't really happen\n-                    throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                contentType = tf.constructSpecializedType(contentType, contentClass);\n+                type = type.withContentType(contentType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = type.withContentType(contentType);\n         }\n     }\n     return type;\n--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n@@ -15,12 +15,13 @@\n     // Then further processing for container types\n     // First, key type (for Maps, Map-like types):\n     if (type.isMapLikeType()) {\n-        JavaType keyType = type.getKeyType();\n+        // Check if keyAs is specified in annotation\n         final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n         if (keyClass != null) {\n             try {\n-                keyType = tf.constructSpecializedType(keyType, keyClass);\n-                type = ((MapLikeType) type).withKeyType(keyType);\n+                final JavaType originalKeyType = type.getKeyType();\n+                JavaType newKeyType = tf.constructSpecializedType(originalKeyType, keyClass);\n+                type = ((MapLikeType) type).withKeyType(newKeyType);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n    // Ok: start by refining the main type itself; common to all types\n    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n        try {\n            type = tf.constructSpecializedType(type, valueClass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n        }\n    }\n    // Then further processing for container types\n    // First, key type (for Maps, Map-like types):\n    if (type.isMapLikeType()) {\n        JavaType keyType = type.getKeyType();\n        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n        if (keyClass != null) {\n            try {\n                keyType = tf.constructSpecializedType(keyType, keyClass);\n                type = ((MapLikeType) type).withKeyType(keyType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    if (type.getContentType() != null) {\n        // collection[like], map[like], array, reference\n        // And then value types for all containers:\n        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n        if (contentClass != null) {\n            try {\n                type = type.withContentType(tf.constructSpecializedType(type.getContentType(), contentClass));\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n@@ -1,96 +1,41 @@\n @Override\n-public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n+public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n     JavaType type = baseType;\n     final TypeFactory tf = config.getTypeFactory();\n-    final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n+    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n     // Ok: start by refining the main type itself; common to all types\n-    final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n-    if (serClass != null) {\n-        if (type.hasRawClass(serClass)) {\n-            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n-            //    static typing this way\n-            type = type.withStaticTyping();\n-        } else {\n-            Class<?> currRaw = type.getRawClass();\n-            try {\n-                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n-                //   may be needed here too in future?\n-                if (serClass.isAssignableFrom(currRaw)) {\n-                    // common case\n-                    type = tf.constructGeneralizedType(type, serClass);\n-                } else if (currRaw.isAssignableFrom(serClass)) {\n-                    // specialization, ok as well\n-                    type = tf.constructSpecializedType(type, serClass);\n-                    // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                } else {\n-                    throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName()));\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae);\n-            }\n+    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n+    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n+        try {\n+            type = tf.constructSpecializedType(type, valueClass);\n+        } catch (IllegalArgumentException iae) {\n+            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n         }\n     }\n     // Then further processing for container types\n     // First, key type (for Maps, Map-like types):\n     if (type.isMapLikeType()) {\n         JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n+        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n         if (keyClass != null) {\n-            if (keyType.hasRawClass(keyClass)) {\n-                keyType = keyType.withStaticTyping();\n-            } else {\n-                Class<?> currRaw = keyType.getRawClass();\n-                try {\n-                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n-                    //   specialize (narrow) type sometimes, even if more commonly opposite\n-                    //   is needed.\n-                    if (keyClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n-                    } else if (currRaw.isAssignableFrom(keyClass)) {\n-                        // specialization, ok as well\n-                        keyType = tf.constructSpecializedType(keyType, keyClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                keyType = tf.constructSpecializedType(keyType, keyClass);\n+                type = ((MapLikeType) type).withKeyType(keyType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = ((MapLikeType) type).withKeyType(keyType);\n         }\n     }\n-    JavaType contentType = type.getContentType();\n-    if (contentType != null) {\n+    if (type.getContentType() != null) {\n         // collection[like], map[like], array, reference\n         // And then value types for all containers:\n-        final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n+        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n         if (contentClass != null) {\n-            if (contentType.hasRawClass(contentClass)) {\n-                contentType = contentType.withStaticTyping();\n-            } else {\n-                // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n-                //   specialize (narrow) type sometimes, even if more commonly opposite\n-                //   is needed.\n-                Class<?> currRaw = contentType.getRawClass();\n-                try {\n-                    if (contentClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        contentType = tf.constructGeneralizedType(contentType, contentClass);\n-                    } else if (currRaw.isAssignableFrom(contentClass)) {\n-                        // specialization, ok as well\n-                        contentType = tf.constructSpecializedType(contentType, contentClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    // shouldn't really happen\n-                    throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                type = type.withContentType(tf.constructSpecializedType(type.getContentType(), contentClass));\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = type.withContentType(contentType);\n         }\n     }\n     return type;\n--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n@@ -26,15 +26,13 @@\n             }\n         }\n     }\n-    JavaType contentType = type.getContentType();\n-    if (contentType != null) {\n+    if (type.getContentType() != null) {\n         // collection[like], map[like], array, reference\n         // And then value types for all containers:\n         final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n         if (contentClass != null) {\n             try {\n-                contentType = tf.constructSpecializedType(contentType, contentClass);\n-                type = type.withContentType(contentType);\n+                type = type.withContentType(tf.constructSpecializedType(type.getContentType(), contentClass));\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n    JavaType type = baseType;\n    final TypeFactory tf = config.getTypeFactory();\n    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n    // Ok: start by refining the main type itself; common to all types\n    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n        try {\n            type = tf.constructSpecializedType(type, valueClass);\n        } catch (IllegalArgumentException iae) {\n            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n        }\n    }\n    // Then further processing for container types\n    // First, key type (for Maps, Map-like types):\n    if (type.isMapLikeType()) {\n        JavaType keyType = type.getKeyType();\n        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n        if (keyClass != null) {\n            try {\n                keyType = tf.constructSpecializedType(keyType, keyClass);\n                type = type.withKeyType(keyType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    JavaType contentType = type.getContentType();\n    if (contentType != null) {\n        // collection[like], map[like], array, reference\n        // And then value types for all containers:\n        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n        if (contentClass != null) {\n            try {\n                contentType = tf.constructSpecializedType(contentType, contentClass);\n                type = type.withContentType(contentType);\n            } catch (IllegalArgumentException iae) {\n                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n            }\n        }\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineSerializationType\n@@ -1,96 +1,43 @@\n @Override\n-public JavaType refineSerializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n+public JavaType refineDeserializationType(final MapperConfig<?> config, final Annotated a, final JavaType baseType) throws JsonMappingException {\n     JavaType type = baseType;\n     final TypeFactory tf = config.getTypeFactory();\n-    final JsonSerialize jsonSer = _findAnnotation(a, JsonSerialize.class);\n+    final JsonDeserialize jsonDeser = _findAnnotation(a, JsonDeserialize.class);\n     // Ok: start by refining the main type itself; common to all types\n-    final Class<?> serClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.as());\n-    if (serClass != null) {\n-        if (type.hasRawClass(serClass)) {\n-            // 30-Nov-2015, tatu: As per [databind#1023], need to allow forcing of\n-            //    static typing this way\n-            type = type.withStaticTyping();\n-        } else {\n-            Class<?> currRaw = type.getRawClass();\n-            try {\n-                // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`,\n-                //   may be needed here too in future?\n-                if (serClass.isAssignableFrom(currRaw)) {\n-                    // common case\n-                    type = tf.constructGeneralizedType(type, serClass);\n-                } else if (currRaw.isAssignableFrom(serClass)) {\n-                    // specialization, ok as well\n-                    type = tf.constructSpecializedType(type, serClass);\n-                    // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                } else {\n-                    throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName()));\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(null, String.format(\"Failed to widen type %s with annotation (value %s), from '%s': %s\", type, serClass.getName(), a.getName(), iae.getMessage()), iae);\n-            }\n+    final Class<?> valueClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.as());\n+    if ((valueClass != null) && !type.hasRawClass(valueClass)) {\n+        try {\n+            type = tf.constructSpecializedType(type, valueClass);\n+        } catch (IllegalArgumentException iae) {\n+            throw new JsonMappingException(null, String.format(\"Failed to narrow type %s with annotation (value %s), from '%s': %s\", type, valueClass.getName(), a.getName(), iae.getMessage()), iae);\n         }\n     }\n     // Then further processing for container types\n     // First, key type (for Maps, Map-like types):\n     if (type.isMapLikeType()) {\n         JavaType keyType = type.getKeyType();\n-        final Class<?> keyClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.keyAs());\n+        final Class<?> keyClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.keyAs());\n         if (keyClass != null) {\n-            if (keyType.hasRawClass(keyClass)) {\n-                keyType = keyType.withStaticTyping();\n-            } else {\n-                Class<?> currRaw = keyType.getRawClass();\n-                try {\n-                    // 19-May-2016, tatu: As per [databind#1231], [databind#1178] may need to actually\n-                    //   specialize (narrow) type sometimes, even if more commonly opposite\n-                    //   is needed.\n-                    if (keyClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        keyType = tf.constructGeneralizedType(keyType, keyClass);\n-                    } else if (currRaw.isAssignableFrom(keyClass)) {\n-                        // specialization, ok as well\n-                        keyType = tf.constructSpecializedType(keyType, keyClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization key type %s into %s; types not related\", keyType, keyClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(null, String.format(\"Failed to widen key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                keyType = tf.constructSpecializedType(keyType, keyClass);\n+                type = type.withKeyType(keyType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = ((MapLikeType) type).withKeyType(keyType);\n         }\n     }\n     JavaType contentType = type.getContentType();\n     if (contentType != null) {\n         // collection[like], map[like], array, reference\n         // And then value types for all containers:\n-        final Class<?> contentClass = (jsonSer == null) ? null : _classIfExplicit(jsonSer.contentAs());\n+        final Class<?> contentClass = (jsonDeser == null) ? null : _classIfExplicit(jsonDeser.contentAs());\n         if (contentClass != null) {\n-            if (contentType.hasRawClass(contentClass)) {\n-                contentType = contentType.withStaticTyping();\n-            } else {\n-                // 03-Apr-2016, tatu: As per [databind#1178], may need to actually\n-                //   specialize (narrow) type sometimes, even if more commonly opposite\n-                //   is needed.\n-                Class<?> currRaw = contentType.getRawClass();\n-                try {\n-                    if (contentClass.isAssignableFrom(currRaw)) {\n-                        // common case\n-                        contentType = tf.constructGeneralizedType(contentType, contentClass);\n-                    } else if (currRaw.isAssignableFrom(contentClass)) {\n-                        // specialization, ok as well\n-                        contentType = tf.constructSpecializedType(contentType, contentClass);\n-                        // 27-Apr-2017, tatu: [databind#1592] ignore primitive<->wrapper refinements\n-                    } else {\n-                        throw new JsonMappingException(null, String.format(\"Can not refine serialization content type %s into %s; types not related\", contentType, contentClass.getName()));\n-                    }\n-                } catch (IllegalArgumentException iae) {\n-                    // shouldn't really happen\n-                    throw new JsonMappingException(null, String.format(\"Internal error: failed to refine value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n-                }\n+            try {\n+                contentType = tf.constructSpecializedType(contentType, contentClass);\n+                type = type.withContentType(contentType);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(null, String.format(\"Failed to narrow value type of %s with concrete-type annotation (value %s), from '%s': %s\", type, contentClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n-            type = type.withContentType(contentType);\n         }\n     }\n     return type;\n--- com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n+++ com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java@refineDeserializationType\n@@ -20,7 +20,7 @@\n         if (keyClass != null) {\n             try {\n                 keyType = tf.constructSpecializedType(keyType, keyClass);\n-                type = ((MapLikeType) type).withKeyType(keyType);\n+                type = type.withKeyType(keyType);\n             } catch (IllegalArgumentException iae) {\n                 throw new JsonMappingException(null, String.format(\"Failed to narrow key type of %s with concrete-type annotation (value %s), from '%s': %s\", type, keyClass.getName(), a.getName(), iae.getMessage()), iae);\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}]