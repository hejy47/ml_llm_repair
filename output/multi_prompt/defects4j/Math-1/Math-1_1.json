[{"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n            // in maxDenominator mode, if the last fraction was very close to the actual value\n            // q2 may overflow in the next iteration; in this case return the last one.\n            if (q1 < maxDenominator) {\n                this.numerator = (int) p1;\n                this.denominator = (int) q1;\n            } else {\n                this.numerator = (int) p0;\n                this.denominator = (int) q0;\n            }\n            return;\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -28,7 +28,14 @@\n         if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n             // in maxDenominator mode, if the last fraction was very close to the actual value\n             // q2 may overflow in the next iteration; in this case return the last one.\n-            throw new FractionConversionException(value, p2, q2);\n+            if (q1 < maxDenominator) {\n+                this.numerator = (int) p1;\n+                this.denominator = (int) q1;\n+            } else {\n+                this.numerator = (int) p0;\n+                this.denominator = (int) q0;\n+            }\n+            return;\n         }\n         double convergent = (double) p2 / (double) q2;\n         if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n@@ -42,9 +49,6 @@\n             stop = true;\n         }\n     } while (!stop);\n-    if (n >= maxIterations) {\n-        throw new FractionConversionException(value, maxIterations);\n-    }\n     if (q2 < maxDenominator) {\n         this.numerator = (int) p2;\n         this.denominator = (int) q2;\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Long.MAX_VALUE; // changed from Integer.MAX_VALUE to Long.MAX_VALUE for correct overflow checking\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n            // in maxDenominator mode, if the last fraction was very close to the actual value\n            // q2 may overflow in the next iteration; in this case return the last one.\n            throw new FractionConversionException(value, p1, q1); // changed to use p1 and q1 instead of p2 and q2\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -1,5 +1,5 @@\n private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n-    long overflow = Integer.MAX_VALUE;\n+    long overflow = Long.MAX_VALUE; // changed from Integer.MAX_VALUE to Long.MAX_VALUE for correct overflow checking\n     double r0 = value;\n     long a0 = (long) FastMath.floor(r0);\n     if (FastMath.abs(a0) > overflow) {\n@@ -28,7 +28,7 @@\n         if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n             // in maxDenominator mode, if the last fraction was very close to the actual value\n             // q2 may overflow in the next iteration; in this case return the last one.\n-            throw new FractionConversionException(value, p2, q2);\n+            throw new FractionConversionException(value, p1, q1); // changed to use p1 and q1 instead of p2 and q2\n         }\n         double convergent = (double) p2 / (double) q2;\n         if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n            // in maxDenominator mode, if the last fraction was very close to the actual value\n            // q2 may overflow in the next iteration; in this case return the last one.\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 <= maxDenominator) {  // fixed condition q2 <= maxDenominator\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 <= maxDenominator) {  // fixed condition q2 <= maxDenominator\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -31,7 +31,7 @@\n             throw new FractionConversionException(value, p2, q2);\n         }\n         double convergent = (double) p2 / (double) q2;\n-        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n+        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 <= maxDenominator) {  // fixed condition q2 <= maxDenominator\n             p0 = p1;\n             p1 = p2;\n             q0 = q1;\n@@ -45,7 +45,7 @@\n     if (n >= maxIterations) {\n         throw new FractionConversionException(value, maxIterations);\n     }\n-    if (q2 < maxDenominator) {\n+    if (q2 <= maxDenominator) {  // fixed condition q2 <= maxDenominator\n         this.numerator = (int) p2;\n         this.denominator = (int) q2;\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n            // in maxDenominator mode, if the last fraction was very close to the actual value\n            // q2 may overflow in the next iteration; in this case return the last one.\n            if (q1 <= maxDenominator) {\n                this.numerator = (int) p1;\n                this.denominator = (int) q1;\n                return;\n            } else {\n                throw new FractionConversionException(value, p1, q1);\n            }\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q1 <= maxDenominator) {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    } else {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -28,7 +28,13 @@\n         if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n             // in maxDenominator mode, if the last fraction was very close to the actual value\n             // q2 may overflow in the next iteration; in this case return the last one.\n-            throw new FractionConversionException(value, p2, q2);\n+            if (q1 <= maxDenominator) {\n+                this.numerator = (int) p1;\n+                this.denominator = (int) q1;\n+                return;\n+            } else {\n+                throw new FractionConversionException(value, p1, q1);\n+            }\n         }\n         double convergent = (double) p2 / (double) q2;\n         if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n@@ -45,11 +51,11 @@\n     if (n >= maxIterations) {\n         throw new FractionConversionException(value, maxIterations);\n     }\n-    if (q2 < maxDenominator) {\n+    if (q1 <= maxDenominator) {\n+        this.numerator = (int) p1;\n+        this.denominator = (int) q1;\n+    } else {\n         this.numerator = (int) p2;\n         this.denominator = (int) q2;\n-    } else {\n-        this.numerator = (int) p1;\n-        this.denominator = (int) q1;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = a1 * p1 + p0;\n        q2 = a1 * q1 + q0;\n        if (Math.abs(p2) > overflow || Math.abs(q2) > overflow) {\n            // in maxDenominator mode, if the last fraction was very close to the actual value\n            // q2 may overflow in the next iteration; in this case return the last one.\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && Math.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -23,15 +23,15 @@\n         ++n;\n         double r1 = 1.0 / (r0 - a0);\n         long a1 = (long) FastMath.floor(r1);\n-        p2 = (a1 * p1) + p0;\n-        q2 = (a1 * q1) + q0;\n-        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n+        p2 = a1 * p1 + p0;\n+        q2 = a1 * q1 + q0;\n+        if (Math.abs(p2) > overflow || Math.abs(q2) > overflow) {\n             // in maxDenominator mode, if the last fraction was very close to the actual value\n             // q2 may overflow in the next iteration; in this case return the last one.\n             throw new FractionConversionException(value, p2, q2);\n         }\n         double convergent = (double) p2 / (double) q2;\n-        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n+        if (n < maxIterations && Math.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n             p0 = p1;\n             p1 = p2;\n             q0 = q1;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if (FastMath.abs(q2) > overflow || p2 > maxDenominator * q2) {\n            // If numerator is too big, the fraction may exceed the maxDenominator.\n            if (q1 >= maxDenominator) {\n                throw new FractionConversionException(value, p1, q1);\n            } else {\n                p2 = p1;\n                q2 = q1;\n                stop = true;\n            }\n        } else if (q2 < maxDenominator) { // No overflow, so it's safe to use these values.\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else { // precisely maxDenominator\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    this.numerator = (int) p2;\n    this.denominator = (int) q2;\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -25,31 +25,29 @@\n         long a1 = (long) FastMath.floor(r1);\n         p2 = (a1 * p1) + p0;\n         q2 = (a1 * q1) + q0;\n-        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n-            // in maxDenominator mode, if the last fraction was very close to the actual value\n-            // q2 may overflow in the next iteration; in this case return the last one.\n-            throw new FractionConversionException(value, p2, q2);\n-        }\n-        double convergent = (double) p2 / (double) q2;\n-        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n+        if (FastMath.abs(q2) > overflow || p2 > maxDenominator * q2) {\n+            // If numerator is too big, the fraction may exceed the maxDenominator.\n+            if (q1 >= maxDenominator) {\n+                throw new FractionConversionException(value, p1, q1);\n+            } else {\n+                p2 = p1;\n+                q2 = q1;\n+                stop = true;\n+            }\n+        } else if (q2 < maxDenominator) { // No overflow, so it's safe to use these values.\n             p0 = p1;\n             p1 = p2;\n             q0 = q1;\n             q1 = q2;\n             a0 = a1;\n             r0 = r1;\n-        } else {\n+        } else { // precisely maxDenominator\n             stop = true;\n         }\n     } while (!stop);\n     if (n >= maxIterations) {\n         throw new FractionConversionException(value, maxIterations);\n     }\n-    if (q2 < maxDenominator) {\n-        this.numerator = (int) p2;\n-        this.denominator = (int) q2;\n-    } else {\n-        this.numerator = (int) p1;\n-        this.denominator = (int) q1;\n-    }\n+    this.numerator = (int) p2;\n+    this.denominator = (int) q2;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n            // in maxDenominator mode, if the last fraction was very close to the actual value\n            // q2 may overflow in the next iteration; in this case return the last one.\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 <= maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q1 <= maxDenominator) {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    } else {\n        this.numerator = (int) p0;\n        this.denominator = (int) q0;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -31,7 +31,7 @@\n             throw new FractionConversionException(value, p2, q2);\n         }\n         double convergent = (double) p2 / (double) q2;\n-        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n+        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 <= maxDenominator) {\n             p0 = p1;\n             p1 = p2;\n             q0 = q1;\n@@ -45,11 +45,11 @@\n     if (n >= maxIterations) {\n         throw new FractionConversionException(value, maxIterations);\n     }\n-    if (q2 < maxDenominator) {\n-        this.numerator = (int) p2;\n-        this.denominator = (int) q2;\n-    } else {\n+    if (q1 <= maxDenominator) {\n         this.numerator = (int) p1;\n         this.denominator = (int) q1;\n+    } else {\n+        this.numerator = (int) p0;\n+        this.denominator = (int) q0;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n            // in maxDenominator mode, if the last fraction was very close to the actual value\n            // q2 may overflow in the next iteration; in this case return the last one.\n            if (q1 <= maxDenominator) { // Only throw exception if q1 is larger than maxDenominator\n                throw new FractionConversionException(value, p1, q1);\n            }\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n            return;\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -28,7 +28,12 @@\n         if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n             // in maxDenominator mode, if the last fraction was very close to the actual value\n             // q2 may overflow in the next iteration; in this case return the last one.\n-            throw new FractionConversionException(value, p2, q2);\n+            if (q1 <= maxDenominator) { // Only throw exception if q1 is larger than maxDenominator\n+                throw new FractionConversionException(value, p1, q1);\n+            }\n+            this.numerator = (int) p1;\n+            this.denominator = (int) q1;\n+            return;\n         }\n         double convergent = (double) p2 / (double) q2;\n         if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n@@ -42,9 +47,6 @@\n             stop = true;\n         }\n     } while (!stop);\n-    if (n >= maxIterations) {\n-        throw new FractionConversionException(value, maxIterations);\n-    }\n     if (q2 < maxDenominator) {\n         this.numerator = (int) p2;\n         this.denominator = (int) q2;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = a1 * p1 + p0;\n        q2 = a1 * q1 + q0;\n        if ((p2 > overflow) || (q2 > overflow)) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -23,11 +23,9 @@\n         ++n;\n         double r1 = 1.0 / (r0 - a0);\n         long a1 = (long) FastMath.floor(r1);\n-        p2 = (a1 * p1) + p0;\n-        q2 = (a1 * q1) + q0;\n-        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n-            // in maxDenominator mode, if the last fraction was very close to the actual value\n-            // q2 may overflow in the next iteration; in this case return the last one.\n+        p2 = a1 * p1 + p0;\n+        q2 = a1 * q1 + q0;\n+        if ((p2 > overflow) || (q2 > overflow)) {\n             throw new FractionConversionException(value, p2, q2);\n         }\n         double convergent = (double) p2 / (double) q2;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n            if (maxDenominator == Integer.MAX_VALUE) {\n                throw new FractionConversionException(value, p2, q2);\n            }\n            // in maxDenominator mode, never throw an exception - return the last value.\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n            return;\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    this.numerator = (int) p1;\n    this.denominator = (int) q1;\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -26,9 +26,13 @@\n         p2 = (a1 * p1) + p0;\n         q2 = (a1 * q1) + q0;\n         if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n-            // in maxDenominator mode, if the last fraction was very close to the actual value\n-            // q2 may overflow in the next iteration; in this case return the last one.\n-            throw new FractionConversionException(value, p2, q2);\n+            if (maxDenominator == Integer.MAX_VALUE) {\n+                throw new FractionConversionException(value, p2, q2);\n+            }\n+            // in maxDenominator mode, never throw an exception - return the last value.\n+            this.numerator = (int) p1;\n+            this.denominator = (int) q1;\n+            return;\n         }\n         double convergent = (double) p2 / (double) q2;\n         if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n@@ -42,14 +46,6 @@\n             stop = true;\n         }\n     } while (!stop);\n-    if (n >= maxIterations) {\n-        throw new FractionConversionException(value, maxIterations);\n-    }\n-    if (q2 < maxDenominator) {\n-        this.numerator = (int) p2;\n-        this.denominator = (int) q2;\n-    } else {\n-        this.numerator = (int) p1;\n-        this.denominator = (int) q1;\n-    }\n+    this.numerator = (int) p1;\n+    this.denominator = (int) q1;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n            // in maxDenominator mode, if the last fraction was very close to the actual value\n            // q2 may overflow in the next iteration; in this case return the last one.\n            if (q1 < maxDenominator) {\n                this.numerator = (int) p1;\n                this.denominator = (int) q1;\n                return;\n            } else {\n                throw new FractionConversionException(value, p1, q1);\n            }\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q1 < maxDenominator) {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    } else {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -28,7 +28,13 @@\n         if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n             // in maxDenominator mode, if the last fraction was very close to the actual value\n             // q2 may overflow in the next iteration; in this case return the last one.\n-            throw new FractionConversionException(value, p2, q2);\n+            if (q1 < maxDenominator) {\n+                this.numerator = (int) p1;\n+                this.denominator = (int) q1;\n+                return;\n+            } else {\n+                throw new FractionConversionException(value, p1, q1);\n+            }\n         }\n         double convergent = (double) p2 / (double) q2;\n         if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n@@ -45,11 +51,11 @@\n     if (n >= maxIterations) {\n         throw new FractionConversionException(value, maxIterations);\n     }\n-    if (q2 < maxDenominator) {\n+    if (q1 < maxDenominator) {\n+        this.numerator = (int) p1;\n+        this.denominator = (int) q1;\n+    } else {\n         this.numerator = (int) p2;\n         this.denominator = (int) q2;\n-    } else {\n-        this.numerator = (int) p1;\n-        this.denominator = (int) q1;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n            // in maxDenominator mode, if the last fraction was very close to the actual value\n            // q2 may overflow in the next iteration; in this case return the last one.\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 <= maxDenominator) { //Fixed the maxDenominator condition\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 <= maxDenominator) { //Fixed the maxDenominator condition\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -31,7 +31,7 @@\n             throw new FractionConversionException(value, p2, q2);\n         }\n         double convergent = (double) p2 / (double) q2;\n-        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n+        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 <= maxDenominator) { //Fixed the maxDenominator condition\n             p0 = p1;\n             p1 = p2;\n             q0 = q1;\n@@ -45,7 +45,7 @@\n     if (n >= maxIterations) {\n         throw new FractionConversionException(value, maxIterations);\n     }\n-    if (q2 < maxDenominator) {\n+    if (q2 <= maxDenominator) { //Fixed the maxDenominator condition\n         this.numerator = (int) p2;\n         this.denominator = (int) q2;\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n\n        // Fixed: Check for q2 == 0\n        if (q2 == 0) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        \n        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n            // in maxDenominator mode, if the last fraction was very close to the actual value\n            // q2 may overflow in the next iteration; in this case return the last one.\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -25,6 +25,12 @@\n         long a1 = (long) FastMath.floor(r1);\n         p2 = (a1 * p1) + p0;\n         q2 = (a1 * q1) + q0;\n+\n+        // Fixed: Check for q2 == 0\n+        if (q2 == 0) {\n+            throw new FractionConversionException(value, p2, q2);\n+        }\n+        \n         if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n             // in maxDenominator mode, if the last fraction was very close to the actual value\n             // q2 may overflow in the next iteration; in this case return the last one.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    double overflow = Long.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -1,11 +1,10 @@\n private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n-    long overflow = Integer.MAX_VALUE;\n+    double overflow = Long.MAX_VALUE;\n     double r0 = value;\n     long a0 = (long) FastMath.floor(r0);\n     if (FastMath.abs(a0) > overflow) {\n         throw new FractionConversionException(value, a0, 1l);\n     }\n-    // check for (almost) integer arguments, which should not go to iterations.\n     if (FastMath.abs(a0 - value) < epsilon) {\n         this.numerator = (int) a0;\n         this.denominator = 1;\n@@ -26,8 +25,6 @@\n         p2 = (a1 * p1) + p0;\n         q2 = (a1 * q1) + q0;\n         if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n-            // in maxDenominator mode, if the last fraction was very close to the actual value\n-            // q2 may overflow in the next iteration; in this case return the last one.\n             throw new FractionConversionException(value, p2, q2);\n         }\n         double convergent = (double) p2 / (double) q2;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n            // in maxDenominator mode, if the last fraction was very close to the actual value\n            // q2 may overflow in the next iteration; in this case return the last one.\n            if(q1 <= maxDenominator){\n                this.numerator = (int) p1;\n                this.denominator = (int) q1;\n                return;\n            }\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -28,6 +28,11 @@\n         if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n             // in maxDenominator mode, if the last fraction was very close to the actual value\n             // q2 may overflow in the next iteration; in this case return the last one.\n+            if(q1 <= maxDenominator){\n+                this.numerator = (int) p1;\n+                this.denominator = (int) q1;\n+                return;\n+            }\n             throw new FractionConversionException(value, p2, q2);\n         }\n         double convergent = (double) p2 / (double) q2;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1 + epsilon);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n            // in maxDenominator mode, if the last fraction was very close to the actual value\n            // q2 may overflow in the next iteration; in this case return the last one.\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -22,7 +22,7 @@\n     do {\n         ++n;\n         double r1 = 1.0 / (r0 - a0);\n-        long a1 = (long) FastMath.floor(r1);\n+        long a1 = (long) FastMath.floor(r1 + epsilon);\n         p2 = (a1 * p1) + p0;\n         q2 = (a1 * q1) + q0;\n         if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((q2 == 0) || (FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n            // in maxDenominator mode, if the last fraction was very close to the actual value\n            // q2 may overflow in the next iteration; in this case return the last one.\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop && q2 != 0);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -25,7 +25,7 @@\n         long a1 = (long) FastMath.floor(r1);\n         p2 = (a1 * p1) + p0;\n         q2 = (a1 * q1) + q0;\n-        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n+        if ((q2 == 0) || (FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n             // in maxDenominator mode, if the last fraction was very close to the actual value\n             // q2 may overflow in the next iteration; in this case return the last one.\n             throw new FractionConversionException(value, p2, q2);\n@@ -41,7 +41,7 @@\n         } else {\n             stop = true;\n         }\n-    } while (!stop);\n+    } while (!stop && q2 != 0);\n     if (n >= maxIterations) {\n         throw new FractionConversionException(value, maxIterations);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = (a1 * p1) + p0;\n        q2 = (a1 * q1) + q0;\n        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n            // in maxDenominator mode, if the last fraction was very close to the actual value\n            // q2 may overflow in the next iteration; in this case return the last one.\n            if(q1 < maxDenominator){\n                this.numerator = (int) p1;\n                this.denominator = (int) q1;\n                return;\n            }\n            else{\n                throw new FractionConversionException(value, p1, q1);\n            }\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    if (n >= maxIterations) {\n        throw new FractionConversionException(value, maxIterations);\n    }\n    if (q2 < maxDenominator) {\n        this.numerator = (int) p2;\n        this.denominator = (int) q2;\n    } else {\n        this.numerator = (int) p1;\n        this.denominator = (int) q1;\n    }\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -28,7 +28,14 @@\n         if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n             // in maxDenominator mode, if the last fraction was very close to the actual value\n             // q2 may overflow in the next iteration; in this case return the last one.\n-            throw new FractionConversionException(value, p2, q2);\n+            if(q1 < maxDenominator){\n+                this.numerator = (int) p1;\n+                this.denominator = (int) q1;\n+                return;\n+            }\n+            else{\n+                throw new FractionConversionException(value, p1, q1);\n+            }\n         }\n         double convergent = (double) p2 / (double) q2;\n         if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private Fraction(double value, double epsilon, int maxDenominator, int maxIterations) throws FractionConversionException {\n    long overflow = Integer.MAX_VALUE;\n    double r0 = value;\n    long a0 = (long) FastMath.floor(r0);\n    if (FastMath.abs(a0) > overflow) {\n        throw new FractionConversionException(value, a0, 1l);\n    }\n    // check for (almost) integer arguments, which should not go to iterations.\n    if (FastMath.abs(a0 - value) < epsilon) {\n        this.numerator = (int) a0;\n        this.denominator = 1;\n        return;\n    }\n    long p0 = 1;\n    long q0 = 0;\n    long p1 = a0;\n    long q1 = 1;\n    long p2 = 0;\n    long q2 = 1;\n    int n = 0;\n    boolean stop = false;\n    do {\n        ++n;\n        double r1 = 1.0 / (r0 - a0);\n        long a1 = (long) FastMath.floor(r1);\n        p2 = a1 * p1 + p0;\n        q2 = a1 * q1 + q0;\n        if (q2 <= 0 || q2 > maxDenominator || p2 <= -overflow || p2 >= overflow) {\n            // in maxDenominator mode, if the last fraction was very close to the actual value\n            // q2 may overflow in the next iteration; in this case return the last one.\n            throw new FractionConversionException(value, p2, q2);\n        }\n        double convergent = (double) p2 / (double) q2;\n        if (n < maxIterations && Math.abs(convergent - value) > epsilon) {\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n            a0 = a1;\n            r0 = r1;\n        } else {\n            stop = true;\n        }\n    } while (!stop);\n    this.numerator = (int) p2;\n    this.denominator = (int) q2;\n}", "diff": "--- org/apache/commons/math3/fraction/Fraction.java@Fraction\n+++ org/apache/commons/math3/fraction/Fraction.java@Fraction\n@@ -23,15 +23,15 @@\n         ++n;\n         double r1 = 1.0 / (r0 - a0);\n         long a1 = (long) FastMath.floor(r1);\n-        p2 = (a1 * p1) + p0;\n-        q2 = (a1 * q1) + q0;\n-        if ((FastMath.abs(p2) > overflow) || (FastMath.abs(q2) > overflow)) {\n+        p2 = a1 * p1 + p0;\n+        q2 = a1 * q1 + q0;\n+        if (q2 <= 0 || q2 > maxDenominator || p2 <= -overflow || p2 >= overflow) {\n             // in maxDenominator mode, if the last fraction was very close to the actual value\n             // q2 may overflow in the next iteration; in this case return the last one.\n             throw new FractionConversionException(value, p2, q2);\n         }\n         double convergent = (double) p2 / (double) q2;\n-        if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n+        if (n < maxIterations && Math.abs(convergent - value) > epsilon) {\n             p0 = p1;\n             p1 = p2;\n             q0 = q1;\n@@ -42,14 +42,6 @@\n             stop = true;\n         }\n     } while (!stop);\n-    if (n >= maxIterations) {\n-        throw new FractionConversionException(value, maxIterations);\n-    }\n-    if (q2 < maxDenominator) {\n-        this.numerator = (int) p2;\n-        this.denominator = (int) q2;\n-    } else {\n-        this.numerator = (int) p1;\n-        this.denominator = (int) q1;\n-    }\n+    this.numerator = (int) p2;\n+    this.denominator = (int) q2;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]