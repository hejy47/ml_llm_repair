[{"output": "// as per [#368]\n// removed when fix [#528]\n//private IllegalArgumentException _noExisting() {\n//    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n//}\n@Override\npublic TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n    if (_idType == JsonTypeInfo.Id.NONE) {\n        return null;\n    }\n    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n    //    regardless of setting\n    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n    JavaType defaultImpl;\n    if (_defaultImpl == null) {\n        defaultImpl = null;\n    } else {\n        // 20-Mar-2016, tatu: It is important to do specialization go through\n        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n        //   call to JavaType was used, but that can not work reliably with 2.7\n        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n        //   if so, need to add explicit checks for marker types. Not ideal, but\n        //   seems like a reasonable compromise.\n        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n        } else {\n            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n            // Fix: Added the following check to prevent InvalidTypeIdException for abstract classes and interfaces\n            if (defaultImpl.getRawClass().isInterface() || Modifier.isAbstract(defaultImpl.getRawClass().getModifiers())) {\n                throw new IllegalStateException(\"Cannot construct standard type serializer for inclusion type: \" + _includeAs + \" and base type: \" + baseType.getRawClass().getName() + \" since the default implementation class: \" + _defaultImpl.getName() + \" is an interface or abstract class\");\n            }\n        }\n    }\n    // First, method for converting type info to type id:\n    switch(_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case PROPERTY:\n        case // as per [#528] same class as PROPERTY\n        EXISTING_PROPERTY:\n            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n    }\n    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n@@ -1,23 +1,43 @@\n @Override\n-public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n+public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n     if (_idType == JsonTypeInfo.Id.NONE) {\n         return null;\n     }\n     // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n     //    regardless of setting\n-    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n+    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n+    JavaType defaultImpl;\n+    if (_defaultImpl == null) {\n+        defaultImpl = null;\n+    } else {\n+        // 20-Mar-2016, tatu: It is important to do specialization go through\n+        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n+        //   call to JavaType was used, but that can not work reliably with 2.7\n+        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n+        //   if so, need to add explicit checks for marker types. Not ideal, but\n+        //   seems like a reasonable compromise.\n+        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n+            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n+        } else {\n+            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n+            // Fix: Added the following check to prevent InvalidTypeIdException for abstract classes and interfaces\n+            if (defaultImpl.getRawClass().isInterface() || Modifier.isAbstract(defaultImpl.getRawClass().getModifiers())) {\n+                throw new IllegalStateException(\"Cannot construct standard type serializer for inclusion type: \" + _includeAs + \" and base type: \" + baseType.getRawClass().getName() + \" since the default implementation class: \" + _defaultImpl.getName() + \" is an interface or abstract class\");\n+            }\n+        }\n+    }\n+    // First, method for converting type info to type id:\n     switch(_includeAs) {\n         case WRAPPER_ARRAY:\n-            return new AsArrayTypeSerializer(idRes, null);\n+            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case PROPERTY:\n-            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n+        case // as per [#528] same class as PROPERTY\n+        EXISTING_PROPERTY:\n+            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n         case WRAPPER_OBJECT:\n-            return new AsWrapperTypeSerializer(idRes, null);\n+            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n-            return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n-        case EXISTING_PROPERTY:\n-            // as per [#528]\n-            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n+            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n     }\n     throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n@@ -25,6 +25,10 @@\n             defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n         } else {\n             defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n+            // Fix: Added the following check to prevent InvalidTypeIdException for abstract classes and interfaces\n+            if (defaultImpl.getRawClass().isInterface() || Modifier.isAbstract(defaultImpl.getRawClass().getModifiers())) {\n+                throw new IllegalStateException(\"Cannot construct standard type serializer for inclusion type: \" + _includeAs + \" and base type: \" + baseType.getRawClass().getName() + \" since the default implementation class: \" + _defaultImpl.getName() + \" is an interface or abstract class\");\n+            }\n         }\n     }\n     // First, method for converting type info to type id:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "The function does not seem to have any obvious bugs.", "diff": "", "finish_reason": "stop", "valid": false, "num": 5}, {"output": "// as per [#368]\n// removed when fix [#528]\n//private IllegalArgumentException _noExisting() {\n//    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n//}\n@Override\npublic TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n    if (_idType == JsonTypeInfo.Id.NONE) {\n        return null;\n    }\n    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n    //    regardless of setting\n    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n    JavaType defaultImpl;\n    if (_defaultImpl == null) {\n        defaultImpl = null;\n    } else {\n        // 20-Mar-2016, tatu: It is important to do specialization go through\n        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n        //   call to JavaType was used, but that can not work reliably with 2.7\n        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n        //   if so, need to add explicit checks for marker types. Not ideal, but\n        //   seems like a reasonable compromise.\n        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n        } else {\n            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n        }\n    }\n    // First, method for converting type info to type id:\n    switch(_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case PROPERTY:\n        case // as per [#528] same class as PROPERTY\n        EXISTING_PROPERTY:\n            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n    }\n    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n@@ -1,23 +1,39 @@\n @Override\n-public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n+public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n     if (_idType == JsonTypeInfo.Id.NONE) {\n         return null;\n     }\n     // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n     //    regardless of setting\n-    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n+    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n+    JavaType defaultImpl;\n+    if (_defaultImpl == null) {\n+        defaultImpl = null;\n+    } else {\n+        // 20-Mar-2016, tatu: It is important to do specialization go through\n+        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n+        //   call to JavaType was used, but that can not work reliably with 2.7\n+        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n+        //   if so, need to add explicit checks for marker types. Not ideal, but\n+        //   seems like a reasonable compromise.\n+        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n+            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n+        } else {\n+            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n+        }\n+    }\n+    // First, method for converting type info to type id:\n     switch(_includeAs) {\n         case WRAPPER_ARRAY:\n-            return new AsArrayTypeSerializer(idRes, null);\n+            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case PROPERTY:\n-            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n+        case // as per [#528] same class as PROPERTY\n+        EXISTING_PROPERTY:\n+            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n         case WRAPPER_OBJECT:\n-            return new AsWrapperTypeSerializer(idRes, null);\n+            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n-            return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n-        case EXISTING_PROPERTY:\n-            // as per [#528]\n-            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n+            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n     }\n     throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n@@ -24,7 +24,7 @@\n         if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n             defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n         } else {\n-            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n+            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n         }\n     }\n     // First, method for converting type info to type id:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// as per [#368]\n// removed when fix [#528]\n//private IllegalArgumentException _noExisting() {\n//    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n//}\n@Override\npublic TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n    if (_idType == JsonTypeInfo.Id.NONE) {\n        return null;\n    }\n    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n    //    regardless of setting\n    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n    JavaType defaultImpl;\n    if (_defaultImpl == null) {\n        defaultImpl = null;\n    } else {\n        // 20-Mar-2016, tatu: It is important to do specialization go through\n        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n        //   call to JavaType was used, but that can not work reliably with 2.7\n        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n        //   if so, need to add explicit checks for marker types. Not ideal, but\n        //   seems like a reasonable compromise.\n        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n        } else if (_defaultImpl.getTypeName().endsWith(\"[]\")) {\n            // prevent UnsupportedOperationException for array types\n            defaultImpl = config.getTypeFactory().constructArrayType(_defaultImpl.getContentType());\n        } else {\n            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n        }\n    }\n    // First, method for converting type info to type id:\n    switch(_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case PROPERTY:\n        case // as per [#528] same class as PROPERTY\n        EXISTING_PROPERTY:\n            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n    }\n    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n@@ -1,23 +1,42 @@\n @Override\n-public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n+public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n     if (_idType == JsonTypeInfo.Id.NONE) {\n         return null;\n     }\n     // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n     //    regardless of setting\n-    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n+    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n+    JavaType defaultImpl;\n+    if (_defaultImpl == null) {\n+        defaultImpl = null;\n+    } else {\n+        // 20-Mar-2016, tatu: It is important to do specialization go through\n+        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n+        //   call to JavaType was used, but that can not work reliably with 2.7\n+        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n+        //   if so, need to add explicit checks for marker types. Not ideal, but\n+        //   seems like a reasonable compromise.\n+        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n+            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n+        } else if (_defaultImpl.getTypeName().endsWith(\"[]\")) {\n+            // prevent UnsupportedOperationException for array types\n+            defaultImpl = config.getTypeFactory().constructArrayType(_defaultImpl.getContentType());\n+        } else {\n+            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n+        }\n+    }\n+    // First, method for converting type info to type id:\n     switch(_includeAs) {\n         case WRAPPER_ARRAY:\n-            return new AsArrayTypeSerializer(idRes, null);\n+            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case PROPERTY:\n-            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n+        case // as per [#528] same class as PROPERTY\n+        EXISTING_PROPERTY:\n+            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n         case WRAPPER_OBJECT:\n-            return new AsWrapperTypeSerializer(idRes, null);\n+            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n-            return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n-        case EXISTING_PROPERTY:\n-            // as per [#528]\n-            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n+            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n     }\n     throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n@@ -23,6 +23,9 @@\n         //   seems like a reasonable compromise.\n         if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n             defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n+        } else if (_defaultImpl.getTypeName().endsWith(\"[]\")) {\n+            // prevent UnsupportedOperationException for array types\n+            defaultImpl = config.getTypeFactory().constructArrayType(_defaultImpl.getContentType());\n         } else {\n             defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// as per [#368]\n// removed when fix [#528]\n//private IllegalArgumentException _noExisting() {\n//    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n//}\n@Override\npublic TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n    if (_idType == JsonTypeInfo.Id.NONE) {\n        return null;\n    }\n    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n    //    regardless of setting\n    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n    JavaType defaultImpl;\n    if (_defaultImpl == null) {\n        defaultImpl = null;\n    } else {\n        // 20-Mar-2016, tatu: It is important to do specialization go through\n        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n        //   call to JavaType was used, but that can not work reliably with 2.7\n        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n        //   if so, need to add explicit checks for marker types. Not ideal, but\n        //   seems like a reasonable compromise.\n        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n        } else {\n            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n        }\n    }\n    // First, method for converting type info to type id:\n    switch(_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case PROPERTY:\n        case // as per [#528] same class as PROPERTY\n        EXISTING_PROPERTY:\n            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        default:\n            throw new IllegalStateException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n@@ -1,23 +1,40 @@\n @Override\n-public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n+public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n     if (_idType == JsonTypeInfo.Id.NONE) {\n         return null;\n     }\n     // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n     //    regardless of setting\n-    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n+    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n+    JavaType defaultImpl;\n+    if (_defaultImpl == null) {\n+        defaultImpl = null;\n+    } else {\n+        // 20-Mar-2016, tatu: It is important to do specialization go through\n+        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n+        //   call to JavaType was used, but that can not work reliably with 2.7\n+        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n+        //   if so, need to add explicit checks for marker types. Not ideal, but\n+        //   seems like a reasonable compromise.\n+        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n+            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n+        } else {\n+            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n+        }\n+    }\n+    // First, method for converting type info to type id:\n     switch(_includeAs) {\n         case WRAPPER_ARRAY:\n-            return new AsArrayTypeSerializer(idRes, null);\n+            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case PROPERTY:\n-            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n+        case // as per [#528] same class as PROPERTY\n+        EXISTING_PROPERTY:\n+            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n         case WRAPPER_OBJECT:\n-            return new AsWrapperTypeSerializer(idRes, null);\n+            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n-            return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n-        case EXISTING_PROPERTY:\n-            // as per [#528]\n-            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n+            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n+        default:\n+            throw new IllegalStateException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n     }\n-    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n@@ -39,6 +39,7 @@\n             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n+        default:\n+            throw new IllegalStateException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n     }\n-    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// as per [#368]\n// removed when fix [#528]\n//private IllegalArgumentException _noExisting() {\n//    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n//}\n@Override\npublic TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n    if (_idType == JsonTypeInfo.Id.NONE) {\n        return null;\n    }\n    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n    //    regardless of setting\n    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n    JavaType defaultImpl;\n    if (_defaultImpl == null) {\n        defaultImpl = null;\n    } else {\n        // 20-Mar-2016, tatu: It is important to do specialization go through\n        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n        //   call to JavaType was used, but that can not work reliably with 2.7\n        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n        //   if so, need to add explicit checks for marker types. Not ideal, but\n        //   seems like a reasonable compromise.\n        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n        } else {\n            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n        }\n    }\n    // First, method for converting type info to type id:\n    switch(_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case PROPERTY:\n        case // as per [#528] same class as PROPERTY\n        EXISTING_PROPERTY:\n            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        default:\n            throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n@@ -1,23 +1,40 @@\n @Override\n-public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n+public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n     if (_idType == JsonTypeInfo.Id.NONE) {\n         return null;\n     }\n     // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n     //    regardless of setting\n-    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n+    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n+    JavaType defaultImpl;\n+    if (_defaultImpl == null) {\n+        defaultImpl = null;\n+    } else {\n+        // 20-Mar-2016, tatu: It is important to do specialization go through\n+        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n+        //   call to JavaType was used, but that can not work reliably with 2.7\n+        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n+        //   if so, need to add explicit checks for marker types. Not ideal, but\n+        //   seems like a reasonable compromise.\n+        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n+            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n+        } else {\n+            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n+        }\n+    }\n+    // First, method for converting type info to type id:\n     switch(_includeAs) {\n         case WRAPPER_ARRAY:\n-            return new AsArrayTypeSerializer(idRes, null);\n+            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case PROPERTY:\n-            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n+        case // as per [#528] same class as PROPERTY\n+        EXISTING_PROPERTY:\n+            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case WRAPPER_OBJECT:\n-            return new AsWrapperTypeSerializer(idRes, null);\n+            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n-            return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n-        case EXISTING_PROPERTY:\n-            // as per [#528]\n-            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n+            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n+        default:\n+            throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n     }\n-    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n@@ -34,11 +34,12 @@\n         case PROPERTY:\n         case // as per [#528] same class as PROPERTY\n         EXISTING_PROPERTY:\n-            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n+            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case WRAPPER_OBJECT:\n             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n+        default:\n+            throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n     }\n-    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// as per [#368]\n// removed when fix [#528]\n//private IllegalArgumentException _noExisting() {\n//    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n//}\n@Override\npublic TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n    if (_idType == JsonTypeInfo.Id.NONE) {\n        return null;\n    }\n    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n    //    regardless of setting\n    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n    JavaType defaultImpl;\n    if (_defaultImpl == null) {\n        defaultImpl = null;\n    } else {\n        // 20-Mar-2016, tatu: It is important to do specialization go through\n        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n        //   call to JavaType was used, but that can not work reliably with 2.7\n        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n        //   if so, need to add explicit checks for marker types. Not ideal, but\n        //   seems like a reasonable compromise.\n        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n        } else {\n            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n        }\n    }\n    // First, method for converting type info to type id:\n    switch(_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case PROPERTY:\n        case // as per [#528] same class as PROPERTY\n        EXISTING_PROPERTY:\n            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _typeIdVisible);\n    }\n    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n@@ -1,23 +1,39 @@\n @Override\n-public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n+public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n     if (_idType == JsonTypeInfo.Id.NONE) {\n         return null;\n     }\n     // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n     //    regardless of setting\n-    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n+    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n+    JavaType defaultImpl;\n+    if (_defaultImpl == null) {\n+        defaultImpl = null;\n+    } else {\n+        // 20-Mar-2016, tatu: It is important to do specialization go through\n+        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n+        //   call to JavaType was used, but that can not work reliably with 2.7\n+        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n+        //   if so, need to add explicit checks for marker types. Not ideal, but\n+        //   seems like a reasonable compromise.\n+        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n+            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n+        } else {\n+            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n+        }\n+    }\n+    // First, method for converting type info to type id:\n     switch(_includeAs) {\n         case WRAPPER_ARRAY:\n-            return new AsArrayTypeSerializer(idRes, null);\n+            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case PROPERTY:\n-            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n+        case // as per [#528] same class as PROPERTY\n+        EXISTING_PROPERTY:\n+            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n         case WRAPPER_OBJECT:\n-            return new AsWrapperTypeSerializer(idRes, null);\n+            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n-            return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n-        case EXISTING_PROPERTY:\n-            // as per [#528]\n-            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n+            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _typeIdVisible);\n     }\n     throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n@@ -38,7 +38,7 @@\n         case WRAPPER_OBJECT:\n             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n-            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n+            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _typeIdVisible);\n     }\n     throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// as per [#368]\n// removed when fix [#528]\n//private IllegalArgumentException _noExisting() {\n//    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n//}\n@Override\npublic TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n    if (_idType == JsonTypeInfo.Id.NONE) {\n        return null;\n    }\n    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n    //    regardless of setting\n    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n    JavaType defaultImpl;\n    if (_defaultImpl == null) {\n        defaultImpl = null;\n    } else {\n        // 20-Mar-2016, tatu: It is important to do specialization go through\n        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n        //   call to JavaType was used, but that can not work reliably with 2.7\n        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n        //   if so, need to add explicit checks for marker types. Not ideal, but\n        //   seems like a reasonable compromise.\n        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n        } else {\n            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n        }\n    }\n    // First, method for converting type info to type id:\n    switch(_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case PROPERTY:\n        case // as per [#528] same class as PROPERTY\n        EXISTING_PROPERTY:\n            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        default:\n            throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n@@ -1,23 +1,40 @@\n @Override\n-public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n+public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n     if (_idType == JsonTypeInfo.Id.NONE) {\n         return null;\n     }\n     // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n     //    regardless of setting\n-    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n+    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n+    JavaType defaultImpl;\n+    if (_defaultImpl == null) {\n+        defaultImpl = null;\n+    } else {\n+        // 20-Mar-2016, tatu: It is important to do specialization go through\n+        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n+        //   call to JavaType was used, but that can not work reliably with 2.7\n+        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n+        //   if so, need to add explicit checks for marker types. Not ideal, but\n+        //   seems like a reasonable compromise.\n+        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n+            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n+        } else {\n+            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n+        }\n+    }\n+    // First, method for converting type info to type id:\n     switch(_includeAs) {\n         case WRAPPER_ARRAY:\n-            return new AsArrayTypeSerializer(idRes, null);\n+            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case PROPERTY:\n-            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n+        case // as per [#528] same class as PROPERTY\n+        EXISTING_PROPERTY:\n+            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n         case WRAPPER_OBJECT:\n-            return new AsWrapperTypeSerializer(idRes, null);\n+            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n-            return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n-        case EXISTING_PROPERTY:\n-            // as per [#528]\n-            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n+            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n+        default:\n+            throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n     }\n-    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n@@ -39,6 +39,7 @@\n             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n+        default:\n+            throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n     }\n-    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "// as per [#368]\n// removed when fix [#528]\n//private IllegalArgumentException _noExisting() {\n//    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n//}\n@Override\npublic TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n    if (_idType == JsonTypeInfo.Id.NONE) {\n        return null;\n    }\n    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n    //    regardless of setting\n    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n    JavaType defaultImpl;\n    if (_defaultImpl == null) {\n        defaultImpl = null;\n    } else {\n        // 20-Mar-2016, tatu: It is important to do specialization go through\n        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n        //   call to JavaType was used, but that can not work reliably with 2.7\n        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n        //   if so, need to add explicit checks for marker types. Not ideal, but\n        //   seems like a reasonable compromise.\n        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n        } else {\n            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n        }\n    }\n    // First, method for converting type info to type id:\n    switch(_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case PROPERTY:\n        case // as per [#528] same class as PROPERTY\n        EXISTING_PROPERTY:\n            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        default: // added default case to prevent IllegalStateException\n            throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n@@ -1,23 +1,40 @@\n @Override\n-public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n+public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n     if (_idType == JsonTypeInfo.Id.NONE) {\n         return null;\n     }\n     // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n     //    regardless of setting\n-    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n+    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n+    JavaType defaultImpl;\n+    if (_defaultImpl == null) {\n+        defaultImpl = null;\n+    } else {\n+        // 20-Mar-2016, tatu: It is important to do specialization go through\n+        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n+        //   call to JavaType was used, but that can not work reliably with 2.7\n+        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n+        //   if so, need to add explicit checks for marker types. Not ideal, but\n+        //   seems like a reasonable compromise.\n+        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n+            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n+        } else {\n+            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n+        }\n+    }\n+    // First, method for converting type info to type id:\n     switch(_includeAs) {\n         case WRAPPER_ARRAY:\n-            return new AsArrayTypeSerializer(idRes, null);\n+            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case PROPERTY:\n-            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n+        case // as per [#528] same class as PROPERTY\n+        EXISTING_PROPERTY:\n+            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n         case WRAPPER_OBJECT:\n-            return new AsWrapperTypeSerializer(idRes, null);\n+            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n-            return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n-        case EXISTING_PROPERTY:\n-            // as per [#528]\n-            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n+            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n+        default: // added default case to prevent IllegalStateException\n+            throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n     }\n-    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n@@ -39,6 +39,7 @@\n             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n+        default: // added default case to prevent IllegalStateException\n+            throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n     }\n-    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// as per [#368]\n// removed when fix [#528]\n//private IllegalArgumentException _noExisting() {\n//    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n//}\n@Override\npublic TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n    if (_idType == null || _idType == JsonTypeInfo.Id.NONE) {\n        return null;\n    }\n    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n    //    regardless of setting\n    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n    JavaType defaultImpl;\n    if (_defaultImpl == null) {\n        defaultImpl = null;\n    } else {\n        // 20-Mar-2016, tatu: It is important to do specialization go through\n        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n        //   call to JavaType was used, but that can not work reliably with 2.7\n        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n        //   if so, need to add explicit checks for marker types. Not ideal, but\n        //   seems like a reasonable compromise.\n        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n        } else {\n            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n        }\n    }\n    // First, method for converting type info to type id:\n    switch(_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case PROPERTY:\n        case EXISTING_PROPERTY: // fixed: included as PROPERTY\n            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n    }\n    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n@@ -1,23 +1,38 @@\n @Override\n-public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n-    if (_idType == JsonTypeInfo.Id.NONE) {\n+public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n+    if (_idType == null || _idType == JsonTypeInfo.Id.NONE) {\n         return null;\n     }\n     // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n     //    regardless of setting\n-    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n+    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n+    JavaType defaultImpl;\n+    if (_defaultImpl == null) {\n+        defaultImpl = null;\n+    } else {\n+        // 20-Mar-2016, tatu: It is important to do specialization go through\n+        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n+        //   call to JavaType was used, but that can not work reliably with 2.7\n+        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n+        //   if so, need to add explicit checks for marker types. Not ideal, but\n+        //   seems like a reasonable compromise.\n+        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n+            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n+        } else {\n+            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n+        }\n+    }\n+    // First, method for converting type info to type id:\n     switch(_includeAs) {\n         case WRAPPER_ARRAY:\n-            return new AsArrayTypeSerializer(idRes, null);\n+            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case PROPERTY:\n-            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n+        case EXISTING_PROPERTY: // fixed: included as PROPERTY\n+            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n         case WRAPPER_OBJECT:\n-            return new AsWrapperTypeSerializer(idRes, null);\n+            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n-            return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n-        case EXISTING_PROPERTY:\n-            // as per [#528]\n-            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n+            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n     }\n     throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n@@ -5,7 +5,7 @@\n //}\n @Override\n public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n-    if (_idType == JsonTypeInfo.Id.NONE) {\n+    if (_idType == null || _idType == JsonTypeInfo.Id.NONE) {\n         return null;\n     }\n     // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n@@ -32,8 +32,7 @@\n         case WRAPPER_ARRAY:\n             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case PROPERTY:\n-        case // as per [#528] same class as PROPERTY\n-        EXISTING_PROPERTY:\n+        case EXISTING_PROPERTY: // fixed: included as PROPERTY\n             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n         case WRAPPER_OBJECT:\n             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// as per [#368]\n// removed when fix [#528]\n//private IllegalArgumentException _noExisting() {\n//    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n//}\n@Override\npublic TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n    if (_idType == JsonTypeInfo.Id.NONE) {\n        return null;\n    }\n    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n    //    regardless of setting\n    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n    JavaType defaultImpl;\n    if (_defaultImpl == null) {\n        defaultImpl = null;\n    } else {\n        // 20-Mar-2016, tatu: It is important to do specialization go through\n        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n        //   call to JavaType was used, but that can not work reliably with 2.7\n        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n        //   if so, need to add explicit checks for marker types. Not ideal, but\n        //   seems like a reasonable compromise.\n        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n        } else {\n            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n        }\n    }\n    // First, method for converting type info to type id:\n    switch(_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case PROPERTY:\n        case // as per [#528] same class as PROPERTY\n        EXISTING_PROPERTY:\n            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n    }\n    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n@@ -1,23 +1,39 @@\n @Override\n-public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n+public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n     if (_idType == JsonTypeInfo.Id.NONE) {\n         return null;\n     }\n     // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n     //    regardless of setting\n-    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n+    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n+    JavaType defaultImpl;\n+    if (_defaultImpl == null) {\n+        defaultImpl = null;\n+    } else {\n+        // 20-Mar-2016, tatu: It is important to do specialization go through\n+        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n+        //   call to JavaType was used, but that can not work reliably with 2.7\n+        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n+        //   if so, need to add explicit checks for marker types. Not ideal, but\n+        //   seems like a reasonable compromise.\n+        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n+            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n+        } else {\n+            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n+        }\n+    }\n+    // First, method for converting type info to type id:\n     switch(_includeAs) {\n         case WRAPPER_ARRAY:\n-            return new AsArrayTypeSerializer(idRes, null);\n+            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case PROPERTY:\n-            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n+        case // as per [#528] same class as PROPERTY\n+        EXISTING_PROPERTY:\n+            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n         case WRAPPER_OBJECT:\n-            return new AsWrapperTypeSerializer(idRes, null);\n+            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n-            return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n-        case EXISTING_PROPERTY:\n-            // as per [#528]\n-            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n+            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n     }\n     throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n@@ -38,7 +38,7 @@\n         case WRAPPER_OBJECT:\n             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n-            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n+            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n     }\n     throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// as per [#368]\n// removed when fix [#528]\n//private IllegalArgumentException _noExisting() {\n//    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n//}\n@Override\npublic TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n    if (_idType == JsonTypeInfo.Id.NONE) {\n        return null;\n    }\n    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n    //    regardless of setting\n    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n    JavaType defaultImpl;\n    if (_defaultImpl == null) {\n        defaultImpl = null;\n    } else {\n        // 20-Mar-2016, tatu: It is important to do specialization go through\n        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n        //   call to JavaType was used, but that can not work reliably with 2.7\n        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n        //   if so, need to add explicit checks for marker types. Not ideal, but\n        //   seems like a reasonable compromise.\n        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n        } else {\n            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n        }\n    }\n    // First, method for converting type info to type id:\n    switch(_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case PROPERTY:\n        case // as per [#528] same class as PROPERTY\n        EXISTING_PROPERTY:\n            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        default: // add a default case to fix the bug\n            throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n@@ -1,23 +1,40 @@\n @Override\n-public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n+public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n     if (_idType == JsonTypeInfo.Id.NONE) {\n         return null;\n     }\n     // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n     //    regardless of setting\n-    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n+    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n+    JavaType defaultImpl;\n+    if (_defaultImpl == null) {\n+        defaultImpl = null;\n+    } else {\n+        // 20-Mar-2016, tatu: It is important to do specialization go through\n+        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n+        //   call to JavaType was used, but that can not work reliably with 2.7\n+        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n+        //   if so, need to add explicit checks for marker types. Not ideal, but\n+        //   seems like a reasonable compromise.\n+        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n+            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n+        } else {\n+            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n+        }\n+    }\n+    // First, method for converting type info to type id:\n     switch(_includeAs) {\n         case WRAPPER_ARRAY:\n-            return new AsArrayTypeSerializer(idRes, null);\n+            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case PROPERTY:\n-            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n+        case // as per [#528] same class as PROPERTY\n+        EXISTING_PROPERTY:\n+            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n         case WRAPPER_OBJECT:\n-            return new AsWrapperTypeSerializer(idRes, null);\n+            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n-            return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n-        case EXISTING_PROPERTY:\n-            // as per [#528]\n-            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n+            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n+        default: // add a default case to fix the bug\n+            throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n     }\n-    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n@@ -39,6 +39,7 @@\n             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n+        default: // add a default case to fix the bug\n+            throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n     }\n-    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// as per [#368]\n// removed when fix [#528]\n//private IllegalArgumentException _noExisting() {\n//    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n//}\n@Override\npublic TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n    if (_idType == JsonTypeInfo.Id.NONE) {\n        return null;\n    }\n    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n    //    regardless of setting\n    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n    JavaType defaultImpl;\n    if (_defaultImpl == null) {\n        defaultImpl = null;\n    } else {\n        // 20-Mar-2016, tatu: It is important to do specialization go through\n        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n        //   call to JavaType was used, but that can not work reliably with 2.7\n        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n        //   if so, need to add explicit checks for marker types. Not ideal, but\n        //   seems like a reasonable compromise.\n        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n        } else {\n            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n        }\n    }\n    // First, method for converting type info to type id:\n    switch(_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case PROPERTY:\n        case // as per [#528] same class as PROPERTY\n        EXISTING_PROPERTY:\n            // Check if the includeAs property is supported\n            if (_includeAs == EXISTING_PROPERTY) {\n                throw new IllegalStateException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n            }\n            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n    }\n    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n@@ -1,23 +1,43 @@\n @Override\n-public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n+public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n     if (_idType == JsonTypeInfo.Id.NONE) {\n         return null;\n     }\n     // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n     //    regardless of setting\n-    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n+    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n+    JavaType defaultImpl;\n+    if (_defaultImpl == null) {\n+        defaultImpl = null;\n+    } else {\n+        // 20-Mar-2016, tatu: It is important to do specialization go through\n+        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n+        //   call to JavaType was used, but that can not work reliably with 2.7\n+        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n+        //   if so, need to add explicit checks for marker types. Not ideal, but\n+        //   seems like a reasonable compromise.\n+        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n+            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n+        } else {\n+            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n+        }\n+    }\n+    // First, method for converting type info to type id:\n     switch(_includeAs) {\n         case WRAPPER_ARRAY:\n-            return new AsArrayTypeSerializer(idRes, null);\n+            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case PROPERTY:\n-            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n+        case // as per [#528] same class as PROPERTY\n+        EXISTING_PROPERTY:\n+            // Check if the includeAs property is supported\n+            if (_includeAs == EXISTING_PROPERTY) {\n+                throw new IllegalStateException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n+            }\n+            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n         case WRAPPER_OBJECT:\n-            return new AsWrapperTypeSerializer(idRes, null);\n+            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n-            return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n-        case EXISTING_PROPERTY:\n-            // as per [#528]\n-            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n+            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n     }\n     throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n@@ -34,6 +34,10 @@\n         case PROPERTY:\n         case // as per [#528] same class as PROPERTY\n         EXISTING_PROPERTY:\n+            // Check if the includeAs property is supported\n+            if (_includeAs == EXISTING_PROPERTY) {\n+                throw new IllegalStateException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n+            }\n             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n         case WRAPPER_OBJECT:\n             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// as per [#368]\n// removed when fix [#528]\n//private IllegalArgumentException _noExisting() {\n//    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n//}\n@Override\npublic TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n    if (_idType == JsonTypeInfo.Id.NONE) {\n        return null;\n    }\n    // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n    //    regardless of setting\n    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n    JavaType defaultImpl;\n    if (_defaultImpl == null) {\n        defaultImpl = null;\n    } else {\n        // 20-Mar-2016, tatu: It is important to do specialization go through\n        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n        //   call to JavaType was used, but that can not work reliably with 2.7\n        //   Fixed in this line to use TypeFactory to resolve type.\n        defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n    }\n    // First, method for converting type info to type id:\n    switch(_includeAs) {\n        case WRAPPER_ARRAY:\n            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case PROPERTY:\n        case // as per [#528] same class as PROPERTY\n        EXISTING_PROPERTY:\n            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n        case WRAPPER_OBJECT:\n            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n        case EXTERNAL_PROPERTY:\n            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n    }\n    throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n}", "diff": "--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeSerializer\n@@ -1,23 +1,33 @@\n @Override\n-public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n+public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) {\n     if (_idType == JsonTypeInfo.Id.NONE) {\n         return null;\n     }\n     // 03-Oct-2016, tatu: As per [databind#1395] better prevent use for primitives,\n     //    regardless of setting\n-    TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n+    TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n+    JavaType defaultImpl;\n+    if (_defaultImpl == null) {\n+        defaultImpl = null;\n+    } else {\n+        // 20-Mar-2016, tatu: It is important to do specialization go through\n+        //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n+        //   call to JavaType was used, but that can not work reliably with 2.7\n+        //   Fixed in this line to use TypeFactory to resolve type.\n+        defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n+    }\n+    // First, method for converting type info to type id:\n     switch(_includeAs) {\n         case WRAPPER_ARRAY:\n-            return new AsArrayTypeSerializer(idRes, null);\n+            return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case PROPERTY:\n-            return new AsPropertyTypeSerializer(idRes, null, _typeProperty);\n+        case // as per [#528] same class as PROPERTY\n+        EXISTING_PROPERTY:\n+            return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl, _includeAs);\n         case WRAPPER_OBJECT:\n-            return new AsWrapperTypeSerializer(idRes, null);\n+            return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n         case EXTERNAL_PROPERTY:\n-            return new AsExternalTypeSerializer(idRes, null, _typeProperty);\n-        case EXISTING_PROPERTY:\n-            // as per [#528]\n-            return new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n+            return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, defaultImpl);\n     }\n     throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \" + _includeAs);\n }\n--- com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n+++ com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java@buildTypeDeserializer\n@@ -18,14 +18,8 @@\n         // 20-Mar-2016, tatu: It is important to do specialization go through\n         //   TypeFactory to ensure proper resolution; with 2.7 and before, direct\n         //   call to JavaType was used, but that can not work reliably with 2.7\n-        // 20-Mar-2016, tatu: Can finally add a check for type compatibility BUT\n-        //   if so, need to add explicit checks for marker types. Not ideal, but\n-        //   seems like a reasonable compromise.\n-        if ((_defaultImpl == Void.class) || (_defaultImpl == NoClass.class)) {\n-            defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n-        } else {\n-            defaultImpl = config.getTypeFactory().constructSpecializedType(baseType, _defaultImpl);\n-        }\n+        //   Fixed in this line to use TypeFactory to resolve type.\n+        defaultImpl = config.getTypeFactory().constructType(_defaultImpl);\n     }\n     // First, method for converting type info to type id:\n     switch(_includeAs) {\n", "finish_reason": "stop", "valid": false, "num": 1}]