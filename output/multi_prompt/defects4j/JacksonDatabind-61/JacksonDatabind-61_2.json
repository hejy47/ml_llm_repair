[{"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n        // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.hasContentType() && !t.isReferenceType()) {\n                t = t.getContentType();\n            }\n            return t.hasContentType() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.hasContentType() && !t.isReferenceType()) {\n                t = t.getContentType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.isJavaLangObject();\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -9,18 +9,18 @@\n         // fall through\n         case OBJECT_AND_NON_CONCRETE:\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n-            while (t.isReferenceType()) {\n-                t = t.getReferencedType();\n+            while (t.hasContentType() && !t.isReferenceType()) {\n+                t = t.getContentType();\n             }\n-            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n+            return t.hasContentType() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n             !TreeNode.class.isAssignableFrom(t.getRawClass()));\n         case NON_FINAL:\n             while (t.isArrayType()) {\n                 t = t.getContentType();\n             }\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n-            while (t.isReferenceType()) {\n-                t = t.getReferencedType();\n+            while (t.hasContentType() && !t.isReferenceType()) {\n+                t = t.getContentType();\n             }\n             // [databind#88] Should not apply to JSON tree models:\n             return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n        // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !JsonNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !JsonNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.isJavaLangObject();\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -13,7 +13,7 @@\n                 t = t.getReferencedType();\n             }\n             return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n-            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n+            !JsonNode.class.isAssignableFrom(t.getRawClass()));\n         case NON_FINAL:\n             while (t.isArrayType()) {\n                 t = t.getContentType();\n@@ -23,7 +23,7 @@\n                 t = t.getReferencedType();\n             }\n             // [databind#88] Should not apply to JSON tree models:\n-            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n+            return !t.isFinal() && !JsonNode.class.isAssignableFrom(t.getRawClass());\n         default:\n             //case JAVA_LANG_OBJECT:\n             return t.isJavaLangObject();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n        // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            return t.getRawClass() == Object.class || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.getRawClass() == Object.class;\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -12,7 +12,7 @@\n             while (t.isReferenceType()) {\n                 t = t.getReferencedType();\n             }\n-            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n+            return t.getRawClass() == Object.class || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n             !TreeNode.class.isAssignableFrom(t.getRawClass()));\n         case NON_FINAL:\n             while (t.isArrayType()) {\n@@ -26,6 +26,6 @@\n             return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n         default:\n             //case JAVA_LANG_OBJECT:\n-            return t.isJavaLangObject();\n+            return t.getRawClass() == Object.class;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.hasContentType() && t.getContentType().isArrayType()) {\n                t = t.getContentType();\n            }\n        // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.hasContentType() && t.getContentType().hasRawClass(ReferenceType.class)) {\n                t = t.getContentType();\n            }\n            return t.hasRawClass(Object.class) || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.hasContentType() && t.getContentType().isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.hasContentType() && t.getContentType().hasRawClass(ReferenceType.class)) {\n                t = t.getContentType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.hasRawClass(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -3,29 +3,29 @@\n     //  primitive types too, regardless\n     switch(_appliesFor) {\n         case NON_CONCRETE_AND_ARRAYS:\n-            while (t.isArrayType()) {\n+            while (t.hasContentType() && t.getContentType().isArrayType()) {\n                 t = t.getContentType();\n             }\n         // fall through\n         case OBJECT_AND_NON_CONCRETE:\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n-            while (t.isReferenceType()) {\n-                t = t.getReferencedType();\n+            while (t.hasContentType() && t.getContentType().hasRawClass(ReferenceType.class)) {\n+                t = t.getContentType();\n             }\n-            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n+            return t.hasRawClass(Object.class) || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n             !TreeNode.class.isAssignableFrom(t.getRawClass()));\n         case NON_FINAL:\n-            while (t.isArrayType()) {\n+            while (t.hasContentType() && t.getContentType().isArrayType()) {\n                 t = t.getContentType();\n             }\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n-            while (t.isReferenceType()) {\n-                t = t.getReferencedType();\n+            while (t.hasContentType() && t.getContentType().hasRawClass(ReferenceType.class)) {\n+                t = t.getContentType();\n             }\n             // [databind#88] Should not apply to JSON tree models:\n             return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n         default:\n             //case JAVA_LANG_OBJECT:\n-            return t.isJavaLangObject();\n+            return t.hasRawClass(Object.class);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    // primitive types too, regardless\n    switch (_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.hasGenericTypes()) {\n              t = t.getContentType();\n            }\n            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n                    !TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.hasGenericTypes()) {\n                t = t.getContentType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.isJavaLangObject();\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -1,26 +1,26 @@\n public boolean useForType(JavaType t) {\n     // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n-    //  primitive types too, regardless\n-    switch(_appliesFor) {\n+    // primitive types too, regardless\n+    switch (_appliesFor) {\n         case NON_CONCRETE_AND_ARRAYS:\n             while (t.isArrayType()) {\n                 t = t.getContentType();\n             }\n-        // fall through\n+            // fall through\n         case OBJECT_AND_NON_CONCRETE:\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n-            while (t.isReferenceType()) {\n-                t = t.getReferencedType();\n+            while (t.hasGenericTypes()) {\n+              t = t.getContentType();\n             }\n             return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n-            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n+                    !TreeNode.class.isAssignableFrom(t.getRawClass()));\n         case NON_FINAL:\n             while (t.isArrayType()) {\n                 t = t.getContentType();\n             }\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n-            while (t.isReferenceType()) {\n-                t = t.getReferencedType();\n+            while (t.hasGenericTypes()) {\n+                t = t.getContentType();\n             }\n             // [databind#88] Should not apply to JSON tree models:\n             return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n        // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t != null && t.isJavaLangObject();\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -26,6 +26,6 @@\n             return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n         default:\n             //case JAVA_LANG_OBJECT:\n-            return t.isJavaLangObject();\n+            return t != null && t.isJavaLangObject();\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.isJavaLangObject();\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -6,7 +6,7 @@\n             while (t.isArrayType()) {\n                 t = t.getContentType();\n             }\n-        // fall through\n+            // fall through\n         case OBJECT_AND_NON_CONCRETE:\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n             while (t.isReferenceType()) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            break; // Added break statement to exit switch after this case is done\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.isJavaLangObject();\n    }\n    // Added return statement to handle cases when _appliesFor is NON_CONCRETE_AND_ARRAYS\n    return !t.isConcrete() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -6,7 +6,7 @@\n             while (t.isArrayType()) {\n                 t = t.getContentType();\n             }\n-        // fall through\n+            break; // Added break statement to exit switch after this case is done\n         case OBJECT_AND_NON_CONCRETE:\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n             while (t.isReferenceType()) {\n@@ -28,4 +28,6 @@\n             //case JAVA_LANG_OBJECT:\n             return t.isJavaLangObject();\n     }\n+    // Added return statement to handle cases when _appliesFor is NON_CONCRETE_AND_ARRAYS\n+    return !t.isConcrete() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n        // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.hasContentType() && t.isReferenceType()) {\n                t = t.getContentType();\n            }\n            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.hasContentType() && t.isReferenceType()) {\n                t = t.getContentType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.isJavaLangObject();\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -9,8 +9,8 @@\n         // fall through\n         case OBJECT_AND_NON_CONCRETE:\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n-            while (t.isReferenceType()) {\n-                t = t.getReferencedType();\n+            while (t.hasContentType() && t.isReferenceType()) {\n+                t = t.getContentType();\n             }\n             return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n             !TreeNode.class.isAssignableFrom(t.getRawClass()));\n@@ -19,8 +19,8 @@\n                 t = t.getContentType();\n             }\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n-            while (t.isReferenceType()) {\n-                t = t.getReferencedType();\n+            while (t.hasContentType() && t.isReferenceType()) {\n+                t = t.getContentType();\n             }\n             // [databind#88] Should not apply to JSON tree models:\n             return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.isJavaLangObject() || (t.isPrimitive() && t.getRawClass().equals(Void.TYPE));\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -6,7 +6,7 @@\n             while (t.isArrayType()) {\n                 t = t.getContentType();\n             }\n-        // fall through\n+            // fall through\n         case OBJECT_AND_NON_CONCRETE:\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n             while (t.isReferenceType()) {\n@@ -26,6 +26,6 @@\n             return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n         default:\n             //case JAVA_LANG_OBJECT:\n-            return t.isJavaLangObject();\n+            return t.isJavaLangObject() || (t.isPrimitive() && t.getRawClass().equals(Void.TYPE));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !JsonNode.class.isAssignableFrom(t.getRawClass())); // Fix: change TreeNode to JsonNode\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !JsonNode.class.isAssignableFrom(t.getRawClass()); // Fix: change TreeNode to JsonNode\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.isJavaLangObject();\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -6,14 +6,14 @@\n             while (t.isArrayType()) {\n                 t = t.getContentType();\n             }\n-        // fall through\n+            // fall through\n         case OBJECT_AND_NON_CONCRETE:\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n             while (t.isReferenceType()) {\n                 t = t.getReferencedType();\n             }\n             return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n-            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n+            !JsonNode.class.isAssignableFrom(t.getRawClass())); // Fix: change TreeNode to JsonNode\n         case NON_FINAL:\n             while (t.isArrayType()) {\n                 t = t.getContentType();\n@@ -23,7 +23,7 @@\n                 t = t.getReferencedType();\n             }\n             // [databind#88] Should not apply to JSON tree models:\n-            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n+            return !t.isFinal() && !JsonNode.class.isAssignableFrom(t.getRawClass()); // Fix: change TreeNode to JsonNode\n         default:\n             //case JAVA_LANG_OBJECT:\n             return t.isJavaLangObject();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n        // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.hasContentType() && t.isReferenceType() && t.isContainerType()) {\n                t = t.getContentType();\n            }\n            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.hasContentType() && t.isReferenceType() && t.isContainerType()) {\n                t = t.getContentType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.isJavaLangObject();\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -9,8 +9,8 @@\n         // fall through\n         case OBJECT_AND_NON_CONCRETE:\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n-            while (t.isReferenceType()) {\n-                t = t.getReferencedType();\n+            while (t.hasContentType() && t.isReferenceType() && t.isContainerType()) {\n+                t = t.getContentType();\n             }\n             return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n             !TreeNode.class.isAssignableFrom(t.getRawClass()));\n@@ -19,8 +19,8 @@\n                 t = t.getContentType();\n             }\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n-            while (t.isReferenceType()) {\n-                t = t.getReferencedType();\n+            while (t.hasContentType() && t.isReferenceType() && t.isContainerType()) {\n+                t = t.getContentType();\n             }\n             // [databind#88] Should not apply to JSON tree models:\n             return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.hasContentType() && t.isContainerType()) {\n                t = t.getContentType();\n            }\n        // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.hasContentType() && t.isReferenceType()) {\n                t = t.getContentType();\n            }\n            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.hasContentType() && t.isContainerType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.hasContentType() && t.isReferenceType()) {\n                t = t.getContentType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.isJavaLangObject();\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -3,24 +3,24 @@\n     //  primitive types too, regardless\n     switch(_appliesFor) {\n         case NON_CONCRETE_AND_ARRAYS:\n-            while (t.isArrayType()) {\n+            while (t.hasContentType() && t.isContainerType()) {\n                 t = t.getContentType();\n             }\n         // fall through\n         case OBJECT_AND_NON_CONCRETE:\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n-            while (t.isReferenceType()) {\n-                t = t.getReferencedType();\n+            while (t.hasContentType() && t.isReferenceType()) {\n+                t = t.getContentType();\n             }\n             return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n             !TreeNode.class.isAssignableFrom(t.getRawClass()));\n         case NON_FINAL:\n-            while (t.isArrayType()) {\n+            while (t.hasContentType() && t.isContainerType()) {\n                 t = t.getContentType();\n             }\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n-            while (t.isReferenceType()) {\n-                t = t.getReferencedType();\n+            while (t.hasContentType() && t.isReferenceType()) {\n+                t = t.getContentType();\n             }\n             // [databind#88] Should not apply to JSON tree models:\n             return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n        // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getContentType();\n            }\n            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.isJavaLangObject() || t.isPrimitive();\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -10,7 +10,7 @@\n         case OBJECT_AND_NON_CONCRETE:\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n             while (t.isReferenceType()) {\n-                t = t.getReferencedType();\n+                t = t.getContentType();\n             }\n             return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n             !TreeNode.class.isAssignableFrom(t.getRawClass()));\n@@ -26,6 +26,6 @@\n             return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n         default:\n             //case JAVA_LANG_OBJECT:\n-            return t.isJavaLangObject();\n+            return t.isJavaLangObject() || t.isPrimitive();\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n        // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            return t.isTypeOrSubTypeOf(Object.class) || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.isTypeOrSubTypeOf(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -12,7 +12,7 @@\n             while (t.isReferenceType()) {\n                 t = t.getReferencedType();\n             }\n-            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n+            return t.isTypeOrSubTypeOf(Object.class) || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n             !TreeNode.class.isAssignableFrom(t.getRawClass()));\n         case NON_FINAL:\n             while (t.isArrayType()) {\n@@ -26,6 +26,6 @@\n             return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n         default:\n             //case JAVA_LANG_OBJECT:\n-            return t.isJavaLangObject();\n+            return t.isTypeOrSubTypeOf(Object.class);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    // primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n        // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !JsonNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.isJavaLangObject();\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -1,6 +1,6 @@\n public boolean useForType(JavaType t) {\n     // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n-    //  primitive types too, regardless\n+    // primitive types too, regardless\n     switch(_appliesFor) {\n         case NON_CONCRETE_AND_ARRAYS:\n             while (t.isArrayType()) {\n@@ -23,7 +23,7 @@\n                 t = t.getReferencedType();\n             }\n             // [databind#88] Should not apply to JSON tree models:\n-            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n+            return !t.isFinal() && !JsonNode.class.isAssignableFrom(t.getRawClass());\n         default:\n             //case JAVA_LANG_OBJECT:\n             return t.isJavaLangObject();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n        // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !JsonNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.isJavaLangObject();\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -23,7 +23,7 @@\n                 t = t.getReferencedType();\n             }\n             // [databind#88] Should not apply to JSON tree models:\n-            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n+            return !t.isFinal() && !JsonNode.class.isAssignableFrom(t.getRawClass());\n         default:\n             //case JAVA_LANG_OBJECT:\n             return t.isJavaLangObject();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n        // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            return t.isJavaLangObject() ||\n                    (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n                    !JsonNode.class.isAssignableFrom(t.getRawClass()));\n\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() &&\n                    !JsonNode.class.isAssignableFrom(t.getRawClass());\n\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.isJavaLangObject();\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -12,8 +12,10 @@\n             while (t.isReferenceType()) {\n                 t = t.getReferencedType();\n             }\n-            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n-            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n+            return t.isJavaLangObject() ||\n+                    (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n+                    !JsonNode.class.isAssignableFrom(t.getRawClass()));\n+\n         case NON_FINAL:\n             while (t.isArrayType()) {\n                 t = t.getContentType();\n@@ -23,7 +25,9 @@\n                 t = t.getReferencedType();\n             }\n             // [databind#88] Should not apply to JSON tree models:\n-            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n+            return !t.isFinal() &&\n+                    !JsonNode.class.isAssignableFrom(t.getRawClass());\n+\n         default:\n             //case JAVA_LANG_OBJECT:\n             return t.isJavaLangObject();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n        // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.hasContentType() && t.contentType().isReferenceType()) {\n                t = t.getContentType();\n            }\n            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.hasContentType() && t.contentType().isReferenceType()) {\n                t = t.getContentType();\n            }\n            // [databind#88] Should not apply to JSON tree models:\n            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.isJavaLangObject();\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -9,8 +9,8 @@\n         // fall through\n         case OBJECT_AND_NON_CONCRETE:\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n-            while (t.isReferenceType()) {\n-                t = t.getReferencedType();\n+            while (t.hasContentType() && t.contentType().isReferenceType()) {\n+                t = t.getContentType();\n             }\n             return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n             !TreeNode.class.isAssignableFrom(t.getRawClass()));\n@@ -19,8 +19,8 @@\n                 t = t.getContentType();\n             }\n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n-            while (t.isReferenceType()) {\n-                t = t.getReferencedType();\n+            while (t.hasContentType() && t.contentType().isReferenceType()) {\n+                t = t.getContentType();\n             }\n             // [databind#88] Should not apply to JSON tree models:\n             return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public boolean useForType(JavaType t) {\n    // 03-Oct-2016, tatu: As per [databind#1395], need to skip\n    //  primitive types too, regardless\n    switch(_appliesFor) {\n        case NON_CONCRETE_AND_ARRAYS:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n        // fall through\n        case OBJECT_AND_NON_CONCRETE:\n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            return t.isJavaLangObject() || (!t.isConcrete() && // [databind#88] Should not apply to JSON tree models:\n            !TreeNode.class.isAssignableFrom(t.getRawClass()));\n        case NON_FINAL:\n            while (t.isArrayType()) {\n                t = t.getContentType();\n            }\n            \n            // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n            while (t.isReferenceType()) {\n                t = t.getReferencedType();\n            }\n            // Here is the fix, add isInterface check to ensure the method\n            // does not fail to use Interfaces.\n            return (!t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass()))\n                    || t.isInterface();\n        default:\n            //case JAVA_LANG_OBJECT:\n            return t.isJavaLangObject();\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n+++ com/fasterxml/jackson/databind/ObjectMapper.java@useForType\n@@ -18,12 +18,15 @@\n             while (t.isArrayType()) {\n                 t = t.getContentType();\n             }\n+            \n             // 19-Apr-2016, tatu: ReferenceType like Optional also requires similar handling:\n             while (t.isReferenceType()) {\n                 t = t.getReferencedType();\n             }\n-            // [databind#88] Should not apply to JSON tree models:\n-            return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass());\n+            // Here is the fix, add isInterface check to ensure the method\n+            // does not fail to use Interfaces.\n+            return (!t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass()))\n+                    || t.isInterface();\n         default:\n             //case JAVA_LANG_OBJECT:\n             return t.isJavaLangObject();\n", "finish_reason": "stop", "valid": false, "num": 1}]