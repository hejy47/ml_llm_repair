[{"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            String name = n.getString();\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(name)\n                    && !name.equals(\"undefined\") && !name.equals(\"NaN\");\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -8,7 +8,9 @@\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n-            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n+            String name = n.getString();\n+            return !NodeUtil.isConstantName(n) && !knownConstants.contains(name)\n+                    && !name.equals(\"undefined\") && !name.equals(\"NaN\");\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n         case Token.GETELEM:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            if (!NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString())) {\n                return true;\n            }\n            break;\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            if (!NodeUtil.isConstantName(n.getFirstChild())) {\n                return true;\n            }\n            break;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -8,11 +8,17 @@\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n-            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n+            if (!NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString())) {\n+                return true;\n+            }\n+            break;\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n         case Token.GETELEM:\n-            return true;\n+            if (!NodeUtil.isConstantName(n.getFirstChild())) {\n+                return true;\n+            }\n+            break;\n     }\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n         if (canBeSideEffected(c, knownConstants)) {\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n            return !NodeUtil.isConstantName(n.getFirstChild()) || canBeSideEffected(n.getFirstChild(), knownConstants);\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -11,6 +11,7 @@\n             return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n+            return !NodeUtil.isConstantName(n.getFirstChild()) || canBeSideEffected(n.getFirstChild(), knownConstants);\n         case Token.GETELEM:\n             return true;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            if (!NodeUtil.isImmutableValue(n.getFirstChild())) {\n                return true;\n            }\n            break;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -3,8 +3,6 @@\n         case Token.CALL:\n         case Token.NEW:\n             // Function calls or constructor can reference changed values.\n-            // TODO(johnlenz): Add some mechanism for determining that functions\n-            // are unaffected by side effects.\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n@@ -12,7 +10,10 @@\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n         case Token.GETELEM:\n-            return true;\n+            if (!NodeUtil.isImmutableValue(n.getFirstChild())) {\n+                return true;\n+            }\n+            break;\n     }\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n         if (canBeSideEffected(c, knownConstants)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            if(!NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString())) {\n                return true;\n            }\n            break;\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            if(canBeSideEffected(n.getFirstChild(), knownConstants)) {\n                return true;\n            }\n            break;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -8,11 +8,17 @@\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n-            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n+            if(!NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString())) {\n+                return true;\n+            }\n+            break;\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n         case Token.GETELEM:\n-            return true;\n+            if(canBeSideEffected(n.getFirstChild(), knownConstants)) {\n+                return true;\n+            }\n+            break;\n     }\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n         if (canBeSideEffected(c, knownConstants)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructors reference changed values through 'this' and parameters.\n            return true;\n        case Token.NAME:\n            // Non-constant NAMEs values may have been changed.\n            return (!NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString())) || n.isVar() || n.isLet() || n.isConst() || n.isClass() || n.isFunction();\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            Node propNode = n.getLastChild();\n            // Non-literal properties can have their values changed.\n            return !(propNode.isString()) || (!knownConstants.contains(propNode.getString()));\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -2,17 +2,17 @@\n     switch(n.getType()) {\n         case Token.CALL:\n         case Token.NEW:\n-            // Function calls or constructor can reference changed values.\n-            // TODO(johnlenz): Add some mechanism for determining that functions\n-            // are unaffected by side effects.\n+            // Function calls or constructors reference changed values through 'this' and parameters.\n             return true;\n         case Token.NAME:\n-            // Non-constant names values may have been changed.\n-            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n+            // Non-constant NAMEs values may have been changed.\n+            return (!NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString())) || n.isVar() || n.isLet() || n.isConst() || n.isClass() || n.isFunction();\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n         case Token.GETELEM:\n-            return true;\n+            Node propNode = n.getLastChild();\n+            // Non-literal properties can have their values changed.\n+            return !(propNode.isString()) || (!knownConstants.contains(propNode.getString()));\n     }\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n         if (canBeSideEffected(c, knownConstants)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            String name = n.getString();\n            if (NodeUtil.isConstantName(n)) {\n                name = name.replaceAll(\"[\\\\[\\\\]]\", \"\");\n            }\n            return !knownConstants.contains(name);\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -8,7 +8,11 @@\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n-            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n+            String name = n.getString();\n+            if (NodeUtil.isConstantName(n)) {\n+                name = name.replaceAll(\"[\\\\[\\\\]]\", \"\");\n+            }\n+            return !knownConstants.contains(name);\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n         case Token.GETELEM:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            // Do not consider variables declared inside loops and if statements\n            if (NodeUtil.isStatementBlockParent(n) || NodeUtil.isLoopStructure(n.getParent())) {\n                return false;\n            }\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -8,6 +8,10 @@\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n+            // Do not consider variables declared inside loops and if statements\n+            if (NodeUtil.isStatementBlockParent(n) || NodeUtil.isLoopStructure(n.getParent())) {\n+                return false;\n+            }\n             return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return canBeSideEffected(n.getFirstChild(), knownConstants); // check for properties on the first argument\n        default:\n            for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n                if (canBeSideEffected(c, knownConstants)) {\n                    return true;\n                }\n            }\n            return false;\n    }\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -12,12 +12,13 @@\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n         case Token.GETELEM:\n-            return true;\n+            return canBeSideEffected(n.getFirstChild(), knownConstants); // check for properties on the first argument\n+        default:\n+            for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+                if (canBeSideEffected(c, knownConstants)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n     }\n-    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-        if (canBeSideEffected(c, knownConstants)) {\n-            return true;\n-        }\n-    }\n-    return false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructors can reference changed values.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            // Only return true if the property access is not on a constant NAME.\n            // This is because properties can also be on objects that may be mutated.\n            return n.getChildCount() > 0 && !NodeUtil.isConstantName(n.getFirstChild());\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -2,9 +2,7 @@\n     switch(n.getType()) {\n         case Token.CALL:\n         case Token.NEW:\n-            // Function calls or constructor can reference changed values.\n-            // TODO(johnlenz): Add some mechanism for determining that functions\n-            // are unaffected by side effects.\n+            // Function calls or constructors can reference changed values.\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n@@ -12,7 +10,9 @@\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n         case Token.GETELEM:\n-            return true;\n+            // Only return true if the property access is not on a constant NAME.\n+            // This is because properties can also be on objects that may be mutated.\n+            return n.getChildCount() > 0 && !NodeUtil.isConstantName(n.getFirstChild());\n     }\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n         if (canBeSideEffected(c, knownConstants)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            if (NodeUtil.isConstantName(n)) {\n                return false;\n            } else {\n                String name = n.getString();\n                if (knownConstants.contains(name)) {\n                    return false;\n                } else {\n                    return true;\n                }\n            }\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return canBeSideEffected(n.getFirstChild(), knownConstants);\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -8,11 +8,20 @@\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n-            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n+            if (NodeUtil.isConstantName(n)) {\n+                return false;\n+            } else {\n+                String name = n.getString();\n+                if (knownConstants.contains(name)) {\n+                    return false;\n+                } else {\n+                    return true;\n+                }\n+            }\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n         case Token.GETELEM:\n-            return true;\n+            return canBeSideEffected(n.getFirstChild(), knownConstants);\n     }\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n         if (canBeSideEffected(c, knownConstants)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            if (!NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString())){\n                return true;\n            } else if (n.getParent() != null && (n.getParent().getType() == Token.GETPROP || n.getParent().getType() == Token.GETELEM)){\n                // Only return true if the constant name is not a part of a property access.\n                return true;\n            }\n            return false;\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -8,7 +8,13 @@\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n-            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n+            if (!NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString())){\n+                return true;\n+            } else if (n.getParent() != null && (n.getParent().getType() == Token.GETPROP || n.getParent().getType() == Token.GETELEM)){\n+                // Only return true if the constant name is not a part of a property access.\n+                return true;\n+            }\n+            return false;\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n         case Token.GETELEM:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n        case Token.FOR:\n        case Token.FOR_IN:\n        case Token.DO:\n        case Token.WHILE:\n            // If loop condition can change, then any node inside the loop may be side-effected.\n            Node condition = n.getFirstChild();\n            if (canBeSideEffected(condition, knownConstants)) {\n                return true;\n            }\n            break;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -13,6 +13,16 @@\n         case Token.GETPROP:\n         case Token.GETELEM:\n             return true;\n+        case Token.FOR:\n+        case Token.FOR_IN:\n+        case Token.DO:\n+        case Token.WHILE:\n+            // If loop condition can change, then any node inside the loop may be side-effected.\n+            Node condition = n.getFirstChild();\n+            if (canBeSideEffected(condition, knownConstants)) {\n+                return true;\n+            }\n+            break;\n     }\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n         if (canBeSideEffected(c, knownConstants)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // Note: in some cases, function calls may not cause side-effects, e.g. if they only return a constant value.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return canBeSideEffected(n.getFirstChild(), knownConstants);\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -3,8 +3,7 @@\n         case Token.CALL:\n         case Token.NEW:\n             // Function calls or constructor can reference changed values.\n-            // TODO(johnlenz): Add some mechanism for determining that functions\n-            // are unaffected by side effects.\n+            // Note: in some cases, function calls may not cause side-effects, e.g. if they only return a constant value.\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n@@ -12,7 +11,7 @@\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n         case Token.GETELEM:\n-            return true;\n+            return canBeSideEffected(n.getFirstChild(), knownConstants);\n     }\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n         if (canBeSideEffected(c, knownConstants)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructors can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return canBeSideEffected(n.getFirstChild(), knownConstants);\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -2,7 +2,7 @@\n     switch(n.getType()) {\n         case Token.CALL:\n         case Token.NEW:\n-            // Function calls or constructor can reference changed values.\n+            // Function calls or constructors can reference changed values.\n             // TODO(johnlenz): Add some mechanism for determining that functions\n             // are unaffected by side effects.\n             return true;\n@@ -12,7 +12,7 @@\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n         case Token.GETELEM:\n-            return true;\n+            return canBeSideEffected(n.getFirstChild(), knownConstants);\n     }\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n         if (canBeSideEffected(c, knownConstants)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        case Token.GETPROP:\n        case Token.GETELEM:\n            // Properties on constant NAMEs can still be side-effected.\n            if (NodeUtil.isGet(n) && NodeUtil.isConstantName(n.getFirstChild())) {\n                return true;\n            }\n            break;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -3,16 +3,17 @@\n         case Token.CALL:\n         case Token.NEW:\n             // Function calls or constructor can reference changed values.\n-            // TODO(johnlenz): Add some mechanism for determining that functions\n-            // are unaffected by side effects.\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n             return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n-        // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n         case Token.GETELEM:\n-            return true;\n+            // Properties on constant NAMEs can still be side-effected.\n+            if (NodeUtil.isGet(n) && NodeUtil.isConstantName(n.getFirstChild())) {\n+                return true;\n+            }\n+            break;\n     }\n     for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n         if (canBeSideEffected(c, knownConstants)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // TODO(johnlenz): Add some mechanism for determining that functions\n            // are unaffected by side effects.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            if(knownConstants != null) {\n                return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n            } else {\n                return !NodeUtil.isConstantName(n);\n            }\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -8,7 +8,11 @@\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n-            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n+            if(knownConstants != null) {\n+                return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n+            } else {\n+                return !NodeUtil.isConstantName(n);\n+            }\n         // Properties on constant NAMEs can still be side-effected.\n         case Token.GETPROP:\n         case Token.GETELEM:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // Check if they are built-in constants.\n            if (NodeUtil.isImmutableValue(n.getFirstChild())) {\n                return false;\n            }\n            // Non built-in constants could be parameterized.\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -3,8 +3,11 @@\n         case Token.CALL:\n         case Token.NEW:\n             // Function calls or constructor can reference changed values.\n-            // TODO(johnlenz): Add some mechanism for determining that functions\n-            // are unaffected by side effects.\n+            // Check if they are built-in constants.\n+            if (NodeUtil.isImmutableValue(n.getFirstChild())) {\n+                return false;\n+            }\n+            // Non built-in constants could be parameterized.\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean canBeSideEffected(Node n, Set<String> knownConstants) {\n    switch(n.getType()) {\n        case Token.CALL:\n        case Token.NEW:\n            // Function calls or constructor can reference changed values.\n            // Check if the function is marked as pure before allowing it\n            Node fnNode = n.getFirstChild();\n            if (fnNode != null && fnNode.isQualifiedName()) {\n                Scope.Var var = NodeUtil.getNearestHoistScopeVar(fnNode);\n                if (var != null) {\n                    JSDocInfo info = var.getJSDocInfo();\n                    if (info != null && info.isNoSideEffects()) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        case Token.NAME:\n            // Non-constant names values may have been changed.\n            return !NodeUtil.isConstantName(n) && !knownConstants.contains(n.getString());\n        // Properties on constant NAMEs can still be side-effected.\n        case Token.GETPROP:\n        case Token.GETELEM:\n            return true;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (canBeSideEffected(c, knownConstants)) {\n            return true;\n        }\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n+++ com/google/javascript/jscomp/NodeUtil.java@canBeSideEffected\n@@ -3,8 +3,17 @@\n         case Token.CALL:\n         case Token.NEW:\n             // Function calls or constructor can reference changed values.\n-            // TODO(johnlenz): Add some mechanism for determining that functions\n-            // are unaffected by side effects.\n+            // Check if the function is marked as pure before allowing it\n+            Node fnNode = n.getFirstChild();\n+            if (fnNode != null && fnNode.isQualifiedName()) {\n+                Scope.Var var = NodeUtil.getNearestHoistScopeVar(fnNode);\n+                if (var != null) {\n+                    JSDocInfo info = var.getJSDocInfo();\n+                    if (info != null && info.isNoSideEffects()) {\n+                        return false;\n+                    }\n+                }\n+            }\n             return true;\n         case Token.NAME:\n             // Non-constant names values may have been changed.\n", "finish_reason": "stop", "valid": false, "num": 1}]