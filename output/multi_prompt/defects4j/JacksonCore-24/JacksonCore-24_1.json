[{"output": "protected void convertNumberToInt() throws IOException {\n    // First, converting from long ought to be easy\n    if ((_numTypesValid & NR_LONG) != 0) {\n        // Let's verify it's lossless conversion by simple roundtrip\n        long longValue = _numberLong;\n        if (longValue > Integer.MAX_VALUE || longValue < Integer.MIN_VALUE) {\n            _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n        }\n        _numberInt = (int) longValue;\n    } else if ((_numTypesValid & NR_BIGINT) != 0) {\n        if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigInt.intValue();\n    } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n        // Need to check boundaries\n        if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n            reportOverflowInt();\n        }\n        _numberInt = (int) _numberDouble;\n    } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n        if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigDecimal.intValue();\n    } else {\n        _throwInternal();\n    }\n    _numTypesValid |= NR_INT;\n}", "diff": "--- com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n+++ com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n@@ -2,11 +2,11 @@\n     // First, converting from long ought to be easy\n     if ((_numTypesValid & NR_LONG) != 0) {\n         // Let's verify it's lossless conversion by simple roundtrip\n-        int result = (int) _numberLong;\n-        if (((long) result) != _numberLong) {\n+        long longValue = _numberLong;\n+        if (longValue > Integer.MAX_VALUE || longValue < Integer.MIN_VALUE) {\n             _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n         }\n-        _numberInt = result;\n+        _numberInt = (int) longValue;\n     } else if ((_numTypesValid & NR_BIGINT) != 0) {\n         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n             reportOverflowInt();\n", "finish_reason": "stop", "valid": false, "num": 5}, {"output": "protected void convertNumberToInt() throws IOException {\n    // First, converting from long ought to be easy\n    if ((_numTypesValid & NR_LONG) != 0) {\n        // Let's verify it's lossless conversion by simple roundtrip\n        long longValue = _numberLong; // assign _numberLong to long variable\n        int result = (int) longValue;\n        if (((long) result) != longValue) {\n            _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n        }\n        _numberInt = result;\n    } else if ((_numTypesValid & NR_BIGINT) != 0) {\n        if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigInt.intValue();\n    } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n        // Need to check boundaries\n        if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n            reportOverflowInt();\n        }\n        _numberInt = (int) _numberDouble;\n    } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n        if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigDecimal.intValue();\n    } else {\n        _throwInternal();\n    }\n    _numTypesValid |= NR_INT;\n}", "diff": "--- com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n+++ com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n@@ -2,8 +2,9 @@\n     // First, converting from long ought to be easy\n     if ((_numTypesValid & NR_LONG) != 0) {\n         // Let's verify it's lossless conversion by simple roundtrip\n-        int result = (int) _numberLong;\n-        if (((long) result) != _numberLong) {\n+        long longValue = _numberLong; // assign _numberLong to long variable\n+        int result = (int) longValue;\n+        if (((long) result) != longValue) {\n             _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n         }\n         _numberInt = result;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void convertNumberToInt() throws IOException {\n    // First, converting from long ought to be easy\n    if ((_numTypesValid & NR_LONG) != 0) {\n        // Let's verify it's lossless conversion by simple roundtrip\n        long val = _numberLong;\n        if (val < Integer.MIN_VALUE || val > Integer.MAX_VALUE) {\n            _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n        }\n        _numberInt = (int) val;\n\n    } else if ((_numTypesValid & NR_BIGINT) != 0) {\n        if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigInt.intValue();\n\n    } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n        // Need to check boundaries\n        double value = _numberDouble;\n        if (value < Integer.MIN_VALUE || value > Integer.MAX_VALUE || Double.isNaN(value) || Double.isInfinite(value)) {\n            reportOverflowInt();\n        }\n        _numberInt = (int) value;\n\n    } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n        if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigDecimal.intValue();\n    } else {\n        _throwInternal();\n    }\n    _numTypesValid |= NR_INT;\n}", "diff": "--- com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n+++ com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n@@ -2,22 +2,26 @@\n     // First, converting from long ought to be easy\n     if ((_numTypesValid & NR_LONG) != 0) {\n         // Let's verify it's lossless conversion by simple roundtrip\n-        int result = (int) _numberLong;\n-        if (((long) result) != _numberLong) {\n+        long val = _numberLong;\n+        if (val < Integer.MIN_VALUE || val > Integer.MAX_VALUE) {\n             _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n         }\n-        _numberInt = result;\n+        _numberInt = (int) val;\n+\n     } else if ((_numTypesValid & NR_BIGINT) != 0) {\n         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n             reportOverflowInt();\n         }\n         _numberInt = _numberBigInt.intValue();\n+\n     } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n         // Need to check boundaries\n-        if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n+        double value = _numberDouble;\n+        if (value < Integer.MIN_VALUE || value > Integer.MAX_VALUE || Double.isNaN(value) || Double.isInfinite(value)) {\n             reportOverflowInt();\n         }\n-        _numberInt = (int) _numberDouble;\n+        _numberInt = (int) value;\n+\n     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n         if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n             reportOverflowInt();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void convertNumberToInt() throws IOException {\n    // First, converting from long ought to be easy\n    if ((_numTypesValid & NR_LONG) != 0) {\n        // Let's verify it's lossless conversion by simple roundtrip\n        long longVal = _numberLong;\n        if (longVal < Integer.MIN_VALUE || longVal > Integer.MAX_VALUE) {\n            _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n        }\n        _numberInt = (int)longVal;\n    } else if ((_numTypesValid & NR_BIGINT) != 0) {\n        if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigInt.intValue();\n    } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n        // Need to check boundaries\n        if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n            reportOverflowInt();\n        }\n        _numberInt = (int) _numberDouble;\n    } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n        if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigDecimal.intValue();\n    } else {\n        _throwInternal();\n    }\n    _numTypesValid |= NR_INT;\n}", "diff": "--- com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n+++ com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n@@ -2,11 +2,11 @@\n     // First, converting from long ought to be easy\n     if ((_numTypesValid & NR_LONG) != 0) {\n         // Let's verify it's lossless conversion by simple roundtrip\n-        int result = (int) _numberLong;\n-        if (((long) result) != _numberLong) {\n+        long longVal = _numberLong;\n+        if (longVal < Integer.MIN_VALUE || longVal > Integer.MAX_VALUE) {\n             _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n         }\n-        _numberInt = result;\n+        _numberInt = (int)longVal;\n     } else if ((_numTypesValid & NR_BIGINT) != 0) {\n         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n             reportOverflowInt();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void convertNumberToInt() throws IOException {\n    // First, converting from long ought to be easy\n    if ((_numTypesValid & NR_LONG) != 0) {\n        // Let's verify it's lossless conversion by simple roundtrip\n        long result = _numberLong;\n        if (result < Integer.MIN_VALUE || result > Integer.MAX_VALUE) {\n            _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n        }\n        _numberInt = (int) result;\n    } else if ((_numTypesValid & NR_BIGINT) != 0) {\n        if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigInt.intValue();\n    } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n        // Need to check boundaries\n        if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n            reportOverflowInt();\n        }\n        _numberInt = (int) _numberDouble;\n    } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n        if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigDecimal.intValue();\n    } else {\n        _throwInternal();\n    }\n    _numTypesValid |= NR_INT;\n}", "diff": "--- com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n+++ com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n@@ -2,11 +2,11 @@\n     // First, converting from long ought to be easy\n     if ((_numTypesValid & NR_LONG) != 0) {\n         // Let's verify it's lossless conversion by simple roundtrip\n-        int result = (int) _numberLong;\n-        if (((long) result) != _numberLong) {\n+        long result = _numberLong;\n+        if (result < Integer.MIN_VALUE || result > Integer.MAX_VALUE) {\n             _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n         }\n-        _numberInt = result;\n+        _numberInt = (int) result;\n     } else if ((_numTypesValid & NR_BIGINT) != 0) {\n         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n             reportOverflowInt();\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "protected void convertNumberToInt() throws IOException {\n    // First, converting from long ought to be easy\n    if ((_numTypesValid & NR_LONG) != 0) {\n        // Let's verify it's lossless conversion by simple roundtrip\n        long val = _numberLong;\n        if (val < Integer.MIN_VALUE || val > Integer.MAX_VALUE) {\n            _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n        }\n        _numberInt = (int) val;\n    } else if ((_numTypesValid & NR_BIGINT) != 0) {\n        if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigInt.intValue();\n    } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n        // Need to check boundaries\n        double value = _numberDouble;\n        if (value < Integer.MIN_VALUE || value > Integer.MAX_VALUE || Double.isNaN(value)) {\n            reportOverflowInt();\n        }\n        _numberInt = (int) value;\n    } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n        if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigDecimal.intValue();\n    } else {\n        _throwInternal();\n    }\n    _numTypesValid |= NR_INT;\n}", "diff": "--- com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n+++ com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n@@ -2,11 +2,11 @@\n     // First, converting from long ought to be easy\n     if ((_numTypesValid & NR_LONG) != 0) {\n         // Let's verify it's lossless conversion by simple roundtrip\n-        int result = (int) _numberLong;\n-        if (((long) result) != _numberLong) {\n+        long val = _numberLong;\n+        if (val < Integer.MIN_VALUE || val > Integer.MAX_VALUE) {\n             _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n         }\n-        _numberInt = result;\n+        _numberInt = (int) val;\n     } else if ((_numTypesValid & NR_BIGINT) != 0) {\n         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n             reportOverflowInt();\n@@ -14,10 +14,11 @@\n         _numberInt = _numberBigInt.intValue();\n     } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n         // Need to check boundaries\n-        if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n+        double value = _numberDouble;\n+        if (value < Integer.MIN_VALUE || value > Integer.MAX_VALUE || Double.isNaN(value)) {\n             reportOverflowInt();\n         }\n-        _numberInt = (int) _numberDouble;\n+        _numberInt = (int) value;\n     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n         if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n             reportOverflowInt();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void convertNumberToInt() throws IOException {\n    // First, converting from long ought to be easy\n    if ((_numTypesValid & NR_LONG) != 0) {\n        // Let's verify it's lossless conversion by simple roundtrip\n        long result = _numberLong;\n        if (result > Integer.MAX_VALUE || result < Integer.MIN_VALUE) {\n            _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n        }\n        _numberInt = (int)result;\n    } else if ((_numTypesValid & NR_BIGINT) != 0) {\n        if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigInt.intValue();\n    } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n        // Need to check boundaries\n        if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n            reportOverflowInt();\n        }\n        _numberInt = (int) _numberDouble;\n    } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n        if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigDecimal.intValue();\n    } else {\n        _throwInternal();\n    }\n    _numTypesValid |= NR_INT;\n}", "diff": "--- com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n+++ com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n@@ -2,11 +2,11 @@\n     // First, converting from long ought to be easy\n     if ((_numTypesValid & NR_LONG) != 0) {\n         // Let's verify it's lossless conversion by simple roundtrip\n-        int result = (int) _numberLong;\n-        if (((long) result) != _numberLong) {\n+        long result = _numberLong;\n+        if (result > Integer.MAX_VALUE || result < Integer.MIN_VALUE) {\n             _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n         }\n-        _numberInt = result;\n+        _numberInt = (int)result;\n     } else if ((_numTypesValid & NR_BIGINT) != 0) {\n         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n             reportOverflowInt();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void convertNumberToInt() throws IOException {\n    // First, converting from long ought to be easy\n    if ((_numTypesValid & NR_LONG) != 0) {\n        // Let's verify it's lossless conversion by simple roundtrip\n        long longResult = _numberLong;\n        if (longResult < Integer.MIN_VALUE || longResult > Integer.MAX_VALUE) {\n            _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n        }\n        _numberInt = (int) longResult;\n    } else if ((_numTypesValid & NR_BIGINT) != 0) {\n        if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigInt.intValue();\n    } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n        // Need to check boundaries\n        if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n            reportOverflowInt();\n        }\n        _numberInt = (int) _numberDouble;\n    } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n        if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigDecimal.intValue();\n    } else {\n        _throwInternal();\n    }\n    _numTypesValid |= NR_INT;\n}", "diff": "--- com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n+++ com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n@@ -2,11 +2,11 @@\n     // First, converting from long ought to be easy\n     if ((_numTypesValid & NR_LONG) != 0) {\n         // Let's verify it's lossless conversion by simple roundtrip\n-        int result = (int) _numberLong;\n-        if (((long) result) != _numberLong) {\n+        long longResult = _numberLong;\n+        if (longResult < Integer.MIN_VALUE || longResult > Integer.MAX_VALUE) {\n             _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n         }\n-        _numberInt = result;\n+        _numberInt = (int) longResult;\n     } else if ((_numTypesValid & NR_BIGINT) != 0) {\n         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n             reportOverflowInt();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void convertNumberToInt() throws IOException {\n    // First, converting from long ought to be easy\n    if ((_numTypesValid & NR_LONG) != 0) {\n        // Let's verify it's lossless conversion by simple roundtrip\n        long l = _numberLong;\n        if ((int) l != l) {\n            _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n        }\n        _numberInt = (int) l;\n    } else if ((_numTypesValid & NR_BIGINT) != 0) {\n        if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigInt.intValue();\n    } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n        // Need to check boundaries\n        double d = _numberDouble;\n        if (d < MIN_INT_D || d > MAX_INT_D) {\n            reportOverflowInt();\n        }\n        _numberInt = (int) d;\n    } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n        if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigDecimal.intValue();\n    } else {\n        _throwInternal();\n    }\n    _numTypesValid |= NR_INT;\n}", "diff": "--- com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n+++ com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n@@ -2,11 +2,11 @@\n     // First, converting from long ought to be easy\n     if ((_numTypesValid & NR_LONG) != 0) {\n         // Let's verify it's lossless conversion by simple roundtrip\n-        int result = (int) _numberLong;\n-        if (((long) result) != _numberLong) {\n+        long l = _numberLong;\n+        if ((int) l != l) {\n             _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n         }\n-        _numberInt = result;\n+        _numberInt = (int) l;\n     } else if ((_numTypesValid & NR_BIGINT) != 0) {\n         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n             reportOverflowInt();\n@@ -14,10 +14,11 @@\n         _numberInt = _numberBigInt.intValue();\n     } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n         // Need to check boundaries\n-        if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n+        double d = _numberDouble;\n+        if (d < MIN_INT_D || d > MAX_INT_D) {\n             reportOverflowInt();\n         }\n-        _numberInt = (int) _numberDouble;\n+        _numberInt = (int) d;\n     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n         if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n             reportOverflowInt();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void convertNumberToInt() throws IOException {\n    // First, converting from long ought to be easy\n    if ((_numTypesValid & NR_LONG) != 0) {\n        // Let's verify it's lossless conversion by simple roundtrip\n        long longValue = _numberLong;\n        if (longValue < Integer.MIN_VALUE || longValue > Integer.MAX_VALUE) {\n            _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n        }\n        _numberInt = (int) longValue;\n    } else if ((_numTypesValid & NR_BIGINT) != 0) {\n        if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigInt.intValue();\n    } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n        // Need to check boundaries\n        if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n            reportOverflowInt();\n        }\n        _numberInt = (int) _numberDouble;\n    } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n        if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigDecimal.intValue();\n    } else {\n        _throwInternal();\n    }\n    _numTypesValid |= NR_INT;\n}", "diff": "--- com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n+++ com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n@@ -2,11 +2,11 @@\n     // First, converting from long ought to be easy\n     if ((_numTypesValid & NR_LONG) != 0) {\n         // Let's verify it's lossless conversion by simple roundtrip\n-        int result = (int) _numberLong;\n-        if (((long) result) != _numberLong) {\n+        long longValue = _numberLong;\n+        if (longValue < Integer.MIN_VALUE || longValue > Integer.MAX_VALUE) {\n             _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n         }\n-        _numberInt = result;\n+        _numberInt = (int) longValue;\n     } else if ((_numTypesValid & NR_BIGINT) != 0) {\n         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n             reportOverflowInt();\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "protected void convertNumberToInt() throws IOException {\n    // First, converting from long ought to be easy\n    if ((_numTypesValid & NR_LONG) != 0) {\n        // Let's verify it's lossless conversion by simple roundtrip\n        long longValue = _numberLong; // Store _numberLong in a long variable\n        int result = (int) longValue;\n        if (((long) result) != longValue) { // Compare with the long variable\n            _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n        }\n        _numberInt = result;\n    } else if ((_numTypesValid & NR_BIGINT) != 0) {\n        if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigInt.intValue();\n    } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n        // Need to check boundaries\n        if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n            reportOverflowInt();\n        }\n        _numberInt = (int) _numberDouble;\n    } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n        if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigDecimal.intValue();\n    } else {\n        _throwInternal();\n    }\n    _numTypesValid |= NR_INT;\n}", "diff": "--- com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n+++ com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n@@ -2,8 +2,9 @@\n     // First, converting from long ought to be easy\n     if ((_numTypesValid & NR_LONG) != 0) {\n         // Let's verify it's lossless conversion by simple roundtrip\n-        int result = (int) _numberLong;\n-        if (((long) result) != _numberLong) {\n+        long longValue = _numberLong; // Store _numberLong in a long variable\n+        int result = (int) longValue;\n+        if (((long) result) != longValue) { // Compare with the long variable\n             _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n         }\n         _numberInt = result;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void convertNumberToInt() throws IOException {\n    // First, converting from long ought to be easy\n    if ((_numTypesValid & NR_LONG) != 0) {\n        // Let's verify it's lossless conversion by simple roundtrip\n        long longVal = _numberLong;\n        if (longVal < Integer.MIN_VALUE || longVal > Integer.MAX_VALUE) {\n            _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n        }\n        _numberInt = (int) longVal;\n    } else if ((_numTypesValid & NR_BIGINT) != 0) {\n        if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigInt.intValue();\n    } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n        // Need to check boundaries\n        if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n            reportOverflowInt();\n        }\n        _numberInt = (int) _numberDouble;\n    } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n        if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigDecimal.intValue();\n    } else {\n        _throwInternal();\n    }\n    _numTypesValid |= NR_INT;\n}", "diff": "--- com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n+++ com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n@@ -2,11 +2,11 @@\n     // First, converting from long ought to be easy\n     if ((_numTypesValid & NR_LONG) != 0) {\n         // Let's verify it's lossless conversion by simple roundtrip\n-        int result = (int) _numberLong;\n-        if (((long) result) != _numberLong) {\n+        long longVal = _numberLong;\n+        if (longVal < Integer.MIN_VALUE || longVal > Integer.MAX_VALUE) {\n             _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n         }\n-        _numberInt = result;\n+        _numberInt = (int) longVal;\n     } else if ((_numTypesValid & NR_BIGINT) != 0) {\n         if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n             reportOverflowInt();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void convertNumberToInt() throws IOException {\n    // First, converting from long ought to be easy\n    if ((_numTypesValid & NR_LONG) != 0) {\n        // Let's verify it's lossless conversion by simple roundtrip\n        long longValue = _numberLong; // Store long value to avoid casting issue\n        int result = (int) longValue;\n        if (((long) result) != longValue) {\n            _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n        }\n        _numberInt = result;\n    } else if ((_numTypesValid & NR_BIGINT) != 0) {\n        if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigInt.intValue();\n    } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n        // Need to check boundaries\n        if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n            reportOverflowInt();\n        }\n        _numberInt = (int) _numberDouble;\n    } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n        if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigDecimal.intValue();\n    } else {\n        _throwInternal();\n    }\n    _numTypesValid |= NR_INT;\n}", "diff": "--- com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n+++ com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n@@ -2,8 +2,9 @@\n     // First, converting from long ought to be easy\n     if ((_numTypesValid & NR_LONG) != 0) {\n         // Let's verify it's lossless conversion by simple roundtrip\n-        int result = (int) _numberLong;\n-        if (((long) result) != _numberLong) {\n+        long longValue = _numberLong; // Store long value to avoid casting issue\n+        int result = (int) longValue;\n+        if (((long) result) != longValue) {\n             _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n         }\n         _numberInt = result;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected void convertNumberToInt() throws IOException {\n    // First, converting from long ought to be easy\n    if ((_numTypesValid & NR_LONG) != 0) {\n        // Let's verify it's lossless conversion by simple roundtrip\n        long longValue = _numberLong;\n        int result = (int) longValue;\n        if (((long) result) != longValue) {\n            _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n        }\n        _numberInt = result;\n    } else if ((_numTypesValid & NR_BIGINT) != 0) {\n        if (BI_MIN_INT.compareTo(_numberBigInt) > 0 || BI_MAX_INT.compareTo(_numberBigInt) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigInt.intValue();\n    } else if ((_numTypesValid & NR_DOUBLE) != 0) {\n        // Need to check boundaries\n        if (_numberDouble < MIN_INT_D || _numberDouble > MAX_INT_D) {\n            reportOverflowInt();\n        }\n        _numberInt = (int) _numberDouble;\n    } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) {\n        if (BD_MIN_INT.compareTo(_numberBigDecimal) > 0 || BD_MAX_INT.compareTo(_numberBigDecimal) < 0) {\n            reportOverflowInt();\n        }\n        _numberInt = _numberBigDecimal.intValue();\n    } else {\n        _throwInternal();\n    }\n    _numTypesValid |= NR_INT;\n}", "diff": "--- com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n+++ com/fasterxml/jackson/core/base/ParserBase.java@convertNumberToInt\n@@ -2,8 +2,9 @@\n     // First, converting from long ought to be easy\n     if ((_numTypesValid & NR_LONG) != 0) {\n         // Let's verify it's lossless conversion by simple roundtrip\n-        int result = (int) _numberLong;\n-        if (((long) result) != _numberLong) {\n+        long longValue = _numberLong;\n+        int result = (int) longValue;\n+        if (((long) result) != longValue) {\n             _reportError(\"Numeric value (\" + getText() + \") out of range of int\");\n         }\n         _numberInt = result;\n", "finish_reason": "stop", "valid": false, "num": 1}]