[{"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                // fix: set the new parameter to optional param if the old parameter is optional\n                if (oldParam.isOptionalArg()) {\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -28,6 +28,10 @@\n                     newParam.setVarArgs(false);\n                     newParam.setOptionalArg(true);\n                 }\n+                // fix: set the new parameter to optional param if the old parameter is optional\n+                if (oldParam.isOptionalArg()) {\n+                    newParam.setOptionalArg(true);\n+                }\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                parametersNode.addChildToBack(newParam);\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            parametersNode.addChildToBack(newParam);\n        }\n        parametersNode.srcrefTree(paramsParent);\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -28,12 +28,18 @@\n                     newParam.setVarArgs(false);\n                     newParam.setOptionalArg(true);\n                 }\n+                parametersNode.addChildToBack(newParam);\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n-        parametersNode = paramBuilder.build();\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            parametersNode.addChildToBack(newParam);\n+        }\n+        parametersNode.srcrefTree(paramsParent);\n     }\n     return this;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                // Adding newParams to builder, if it matches the oldParam\n                if (oldParam.isOptionalArg() && !newParam.isOptionalArg()) {\n                    newParam.setOptionalArg(true);\n                }\n                if (oldParam.isVarArgs() && !newParam.isVarArgs()) {\n                    newParam.setIsVarArgs(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -28,6 +28,13 @@\n                     newParam.setVarArgs(false);\n                     newParam.setOptionalArg(true);\n                 }\n+                // Adding newParams to builder, if it matches the oldParam\n+                if (oldParam.isOptionalArg() && !newParam.isOptionalArg()) {\n+                    newParam.setOptionalArg(true);\n+                }\n+                if (oldParam.isVarArgs() && !newParam.isVarArgs()) {\n+                    newParam.setIsVarArgs(true);\n+                }\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                // Add new param to parameters node if it was not added already\n                if (!parametersNode.hasChild(newParam)) {\n                    parametersNode.addChildToBack(newParam);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n                // Add new param to parameters node if it was not added already\n                if (!parametersNode.hasChild(paramBuilder.build())) {\n                    parametersNode.addChildToBack(paramBuilder.build());\n                }\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n            addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(newParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(newParam));\n            // Add new param to parameters node if it was not added already\n            if (!parametersNode.hasChild(newParam)) {\n                parametersNode.addChildToBack(newParam);\n            }\n        }\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -28,12 +28,29 @@\n                     newParam.setVarArgs(false);\n                     newParam.setOptionalArg(true);\n                 }\n+                // Add new param to parameters node if it was not added already\n+                if (!parametersNode.hasChild(newParam)) {\n+                    parametersNode.addChildToBack(newParam);\n+                }\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+                // Add new param to parameters node if it was not added already\n+                if (!parametersNode.hasChild(paramBuilder.build())) {\n+                    parametersNode.addChildToBack(paramBuilder.build());\n+                }\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n-        parametersNode = paramBuilder.build();\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n+            addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(newParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(newParam));\n+            // Add new param to parameters node if it was not added already\n+            if (!parametersNode.hasChild(newParam)) {\n+                parametersNode.addChildToBack(newParam);\n+            }\n+        }\n     }\n     return this;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && oldParamsListHitOptArgs && newParam.isVarArgs()) {\n                    // If there are more parameters left and we already hit the optional/varargs section of the old function,\n                    // this must be an optional varargs parameter in the new function\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -24,7 +24,9 @@\n                 oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                 // The subclass method might write its var_args as individual\n                 // arguments.\n-                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n+                if (currentParam.getNext() != null && oldParamsListHitOptArgs && newParam.isVarArgs()) {\n+                    // If there are more parameters left and we already hit the optional/varargs section of the old function,\n+                    // this must be an optional varargs parameter in the new function\n                     newParam.setVarArgs(false);\n                     newParam.setOptionalArg(true);\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -33,6 +33,11 @@\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (newParam.isVarArgs() && (currentParam.getNext() != null || oldParam.isVarArgs())) \n                {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -24,7 +24,8 @@\n                 oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                 // The subclass method might write its var_args as individual\n                 // arguments.\n-                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n+                if (newParam.isVarArgs() && (currentParam.getNext() != null || oldParam.isVarArgs())) \n+                {\n                     newParam.setVarArgs(false);\n                     newParam.setOptionalArg(true);\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            // Check to avoid NoSuchElementException if oldParams iterator is shorter than expected.\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            paramBuilder.newParameterFromNode(oldParams.next());\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -18,6 +18,7 @@\n         boolean warnedAboutArgList = false;\n         boolean oldParamsListHitOptArgs = false;\n         for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n+            // Check to avoid NoSuchElementException if oldParams iterator is shorter than expected.\n             if (oldParams.hasNext()) {\n                 Node oldParam = oldParams.next();\n                 Node newParam = paramBuilder.newParameterFromNode(oldParam);\n@@ -33,6 +34,9 @@\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (oldParams.hasNext()) {\n+            paramBuilder.newParameterFromNode(oldParams.next());\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                paramBuilder.add(newParam);\n            } else {\n                Node newParam = paramBuilder.newParameter(typeRegistry.getNativeType(UNKNOWN_TYPE));\n                warnedAboutArgList |= addParameter(newParam, warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            paramBuilder.add(newParam);\n            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -28,11 +28,19 @@\n                     newParam.setVarArgs(false);\n                     newParam.setOptionalArg(true);\n                 }\n+                paramBuilder.add(newParam);\n             } else {\n-                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+                Node newParam = paramBuilder.newParameter(typeRegistry.getNativeType(UNKNOWN_TYPE));\n+                warnedAboutArgList |= addParameter(newParam, warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            paramBuilder.add(newParam);\n+            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (newParam.isVarArgs()) {\n                    // Check if the current parameter is the last parameter in the function signature\n                    boolean isLastParam = currentParam.getNext() == null;\n                    if (!isLastParam || (isLastParam && oldParam.isVarArgs())) {\n                        // If not last parameter, or it is last parameter but the old function signature also has a vararg,\n                        // then set the parameter to be optional instead of varargs.\n                        newParam.setVarArgs(false);\n                        newParam.setOptionalArg(true);\n                    }\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -24,9 +24,15 @@\n                 oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                 // The subclass method might write its var_args as individual\n                 // arguments.\n-                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n-                    newParam.setVarArgs(false);\n-                    newParam.setOptionalArg(true);\n+                if (newParam.isVarArgs()) {\n+                    // Check if the current parameter is the last parameter in the function signature\n+                    boolean isLastParam = currentParam.getNext() == null;\n+                    if (!isLastParam || (isLastParam && oldParam.isVarArgs())) {\n+                        // If not last parameter, or it is last parameter but the old function signature also has a vararg,\n+                        // then set the parameter to be optional instead of varargs.\n+                        newParam.setVarArgs(false);\n+                        newParam.setOptionalArg(true);\n+                    }\n                 }\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                paramBuilder.addParameter(newParam);\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n            paramBuilder.addParameter(newParam);\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -28,11 +28,18 @@\n                     newParam.setVarArgs(false);\n                     newParam.setOptionalArg(true);\n                 }\n+                paramBuilder.addParameter(newParam);\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n+            paramBuilder.addParameter(newParam);\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                // Add new parameter to the parameter builder\n                paramBuilder.addParameter(newParam);\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            paramBuilder.addParameter(newParam);\n            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -28,11 +28,19 @@\n                     newParam.setVarArgs(false);\n                     newParam.setOptionalArg(true);\n                 }\n+                // Add new parameter to the parameter builder\n+                paramBuilder.addParameter(newParam);\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            paramBuilder.addParameter(newParam);\n+            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n                oldParamsListHitOptArgs = false; // reset in case of default args in subclass method\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            // Check for optional and/or var_args in remaining old params\n            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n            // Add a \"fake\" parameter for old params to preserve function arity\n            warnedAboutArgList |= addParameter(paramBuilder, paramBuilder.getDeclaredType(oldParam), warnedAboutArgList, codingConvention.isOptionalParameter(oldParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(oldParam));\n            oldParamsListHitOptArgs = false; // reset in case of default args in subclass method\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -30,9 +30,18 @@\n                 }\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+                oldParamsListHitOptArgs = false; // reset in case of default args in subclass method\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            // Check for optional and/or var_args in remaining old params\n+            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n+            // Add a \"fake\" parameter for old params to preserve function arity\n+            warnedAboutArgList |= addParameter(paramBuilder, paramBuilder.getDeclaredType(oldParam), warnedAboutArgList, codingConvention.isOptionalParameter(oldParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(oldParam));\n+            oldParamsListHitOptArgs = false; // reset in case of default args in subclass method\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                paramBuilder.add(newParam);\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n            if (newParam.isVarArgs()) {\n                newParam.setVarArgs(false);\n                newParam.setOptionalArg(true);\n            }\n            paramBuilder.add(newParam);\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -28,11 +28,22 @@\n                     newParam.setVarArgs(false);\n                     newParam.setOptionalArg(true);\n                 }\n+                paramBuilder.add(newParam);\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n+            if (newParam.isVarArgs()) {\n+                newParam.setVarArgs(false);\n+                newParam.setOptionalArg(true);\n+            }\n+            paramBuilder.add(newParam);\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                // Adding the inferred type of the parameter.\n                JSType type = currentParam.getJSType();\n                if (type != null && !typeRegistry.getNativeType(UNKNOWN_TYPE).equals(type)) {\n                    newParam.setJSType(type);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -28,6 +28,11 @@\n                     newParam.setVarArgs(false);\n                     newParam.setOptionalArg(true);\n                 }\n+                // Adding the inferred type of the parameter.\n+                JSType type = currentParam.getJSType();\n+                if (type != null && !typeRegistry.getNativeType(UNKNOWN_TYPE).equals(type)) {\n+                    newParam.setJSType(type);\n+                }\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                parametersNode.addChildToBack(newParam);\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n                Node newParam = paramBuilder.build();\n                parametersNode.addChildToBack(newParam);\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            parametersNode.addChildToBack(newParam);\n        }\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -28,12 +28,19 @@\n                     newParam.setVarArgs(false);\n                     newParam.setOptionalArg(true);\n                 }\n+                parametersNode.addChildToBack(newParam);\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+                Node newParam = paramBuilder.build();\n+                parametersNode.addChildToBack(newParam);\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n-        parametersNode = paramBuilder.build();\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            parametersNode.addChildToBack(newParam);\n+        }\n     }\n     return this;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                parametersNode.addChildToFront(newParam); // fixed line\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n                Node newParam = paramBuilder.build();\n                parametersNode.addChildToFront(newParam); // fixed line\n            }\n        }\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -28,12 +28,13 @@\n                     newParam.setVarArgs(false);\n                     newParam.setOptionalArg(true);\n                 }\n+                parametersNode.addChildToFront(newParam); // fixed line\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+                Node newParam = paramBuilder.build();\n+                parametersNode.addChildToFront(newParam); // fixed line\n             }\n         }\n-        // Clone any remaining params that aren't in the function literal.\n-        parametersNode = paramBuilder.build();\n     }\n     return this;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n                oldParamsListHitOptArgs = true;\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n        }\n        if (oldParamsListHitOptArgs) {\n            paramBuilder.markParameterAsOptional(paramBuilder.length() - 1);\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -30,9 +30,18 @@\n                 }\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+                oldParamsListHitOptArgs = true;\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n+        }\n+        if (oldParamsListHitOptArgs) {\n+            paramBuilder.markParameterAsOptional(paramBuilder.length() - 1);\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                parametersNode.addChildToBack(newParam);\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n            parametersNode.addChildToBack(newParam);\n        }\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -28,12 +28,18 @@\n                     newParam.setVarArgs(false);\n                     newParam.setOptionalArg(true);\n                 }\n+                parametersNode.addChildToBack(newParam);\n             } else {\n                 warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n-        parametersNode = paramBuilder.build();\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n+            parametersNode.addChildToBack(newParam);\n+        }\n     }\n     return this;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            oldParamsListHitOptArgs = oldParam.isVarArgs() || oldParam.isOptionalArg();\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@inferFromOverriddenFunction\n@@ -21,7 +21,7 @@\n             if (oldParams.hasNext()) {\n                 Node oldParam = oldParams.next();\n                 Node newParam = paramBuilder.newParameterFromNode(oldParam);\n-                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n+                oldParamsListHitOptArgs = oldParam.isVarArgs() || oldParam.isOptionalArg();\n                 // The subclass method might write its var_args as individual\n                 // arguments.\n                 if (currentParam.getNext() != null && newParam.isVarArgs()) {\n@@ -33,6 +33,11 @@\n             }\n         }\n         // Clone any remaining params that aren't in the function literal.\n+        while (oldParams.hasNext()) {\n+            Node oldParam = oldParams.next();\n+            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n+            oldParamsListHitOptArgs = oldParam.isVarArgs() || oldParam.isOptionalArg();\n+        }\n         parametersNode = paramBuilder.build();\n     }\n     return this;\n", "finish_reason": "stop", "valid": false, "num": 1}]