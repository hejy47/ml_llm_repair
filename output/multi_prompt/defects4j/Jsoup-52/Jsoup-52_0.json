[{"output": "// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the charset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    charsetName = detectCharsetFromBom(byteData, charsetName);\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        if (meta != null) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    } else {\n                        throw new UnsupportedCharsetException(meta.attr(\"charset\"));\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                } catch (UnsupportedCharsetException e) {\n                    foundCharset = null;\n                }\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n            // need to re-decode\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            byteData.rewind();\n            docData = Charset.forName(foundCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n    }\n    if (doc != null) {\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -1,5 +1,5 @@\n // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-// switching the chartset midstream when a meta http-equiv tag defines the charset.\n+// switching the charset midstream when a meta http-equiv tag defines the charset.\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n@@ -21,8 +21,12 @@\n                 try {\n                     if (Charset.isSupported(meta.attr(\"charset\"))) {\n                         foundCharset = meta.attr(\"charset\");\n+                    } else {\n+                        throw new UnsupportedCharsetException(meta.attr(\"charset\"));\n                     }\n                 } catch (IllegalCharsetNameException e) {\n+                    foundCharset = null;\n+                } catch (UnsupportedCharsetException e) {\n                     foundCharset = null;\n                 }\n             }\n@@ -41,15 +45,15 @@\n             charsetName = foundCharset;\n             byteData.rewind();\n             docData = Charset.forName(foundCharset).decode(byteData).toString();\n-            doc = null;\n+            doc = parser.parseInput(docData, baseUri);\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri);\n     }\n-    if (doc == null) {\n-        doc = parser.parseInput(docData, baseUri);\n+    if (doc != null) {\n         doc.outputSettings().charset(charsetName);\n     }\n     return doc;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    charsetName = detectCharsetFromBom(byteData, charsetName);\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        byteData.rewind(); // Add this to rewind the byte buffer to the beginning\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        if (meta != null) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n            // need to re-decode\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            byteData.rewind(); // Add this to rewind the byte buffer to the beginning\n            docData = Charset.forName(foundCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n    }\n    doc.outputSettings().charset(charsetName); // Moved this out of the if and else blocks to apply to both cases\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -8,6 +8,7 @@\n     if (charsetName == null) {\n         // determine from meta. safe first parse as UTF-8\n         // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n+        byteData.rewind(); // Add this to rewind the byte buffer to the beginning\n         docData = Charset.forName(defaultCharset).decode(byteData).toString();\n         doc = parser.parseInput(docData, baseUri);\n         Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n@@ -38,19 +39,16 @@\n         if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n             // need to re-decode\n             foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n-            charsetName = foundCharset;\n-            byteData.rewind();\n+            byteData.rewind(); // Add this to rewind the byte buffer to the beginning\n             docData = Charset.forName(foundCharset).decode(byteData).toString();\n-            doc = null;\n+            doc = parser.parseInput(docData, baseUri);\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri);\n     }\n-    if (doc == null) {\n-        doc = parser.parseInput(docData, baseUri);\n-        doc.outputSettings().charset(charsetName);\n-    }\n+    doc.outputSettings().charset(charsetName); // Moved this out of the if and else blocks to apply to both cases\n     return doc;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the charset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    charsetName = detectCharsetFromBom(byteData, charsetName);\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        if (meta != null) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                if (Charset.isSupported(meta.attr(\"charset\"))) { // only validate if and only if a charset is defined.\n                    foundCharset = meta.attr(\"charset\");\n                }\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n            // need to re-decode\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            byteData.rewind();\n            docData = Charset.forName(foundCharset).decode(byteData).toString();\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -1,5 +1,5 @@\n // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-// switching the chartset midstream when a meta http-equiv tag defines the charset.\n+// switching the charset midstream when a meta http-equiv tag defines the charset.\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n@@ -18,12 +18,8 @@\n                 foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n             }\n             if (foundCharset == null && meta.hasAttr(\"charset\")) {\n-                try {\n-                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n-                        foundCharset = meta.attr(\"charset\");\n-                    }\n-                } catch (IllegalCharsetNameException e) {\n-                    foundCharset = null;\n+                if (Charset.isSupported(meta.attr(\"charset\"))) { // only validate if and only if a charset is defined.\n+                    foundCharset = meta.attr(\"charset\");\n                 }\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    charsetName = detectCharsetFromBom(byteData, charsetName);\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        if (meta != null) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                // Check if the charset is supported before using it\n                if (Charset.isSupported(meta.attr(\"charset\"))) {\n                    foundCharset = meta.attr(\"charset\");\n                }\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n            // need to re-decode\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            byteData.rewind();\n            docData = Charset.forName(foundCharset).decode(byteData).toString();\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -18,17 +18,14 @@\n                 foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n             }\n             if (foundCharset == null && meta.hasAttr(\"charset\")) {\n-                try {\n-                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n-                        foundCharset = meta.attr(\"charset\");\n-                    }\n-                } catch (IllegalCharsetNameException e) {\n-                    foundCharset = null;\n+                // Check if the charset is supported before using it\n+                if (Charset.isSupported(meta.attr(\"charset\"))) {\n+                    foundCharset = meta.attr(\"charset\");\n                 }\n             }\n         }\n         // look for <?xml encoding='ISO-8859-1'?>\n-        if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n+        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n             XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n             if (prolog.name().equals(\"xml\")) {\n                 foundCharset = prolog.attr(\"encoding\");\n@@ -47,6 +44,7 @@\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri);\n     }\n     if (doc == null) {\n         doc = parser.parseInput(docData, baseUri);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the charset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    charsetName = detectCharsetFromBom(byteData, charsetName);\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        byteData.rewind();\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        if (meta != null) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n            // need to re-decode\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            byteData.rewind();\n            docData = Charset.forName(foundCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        byteData.rewind();\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -1,5 +1,5 @@\n // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-// switching the chartset midstream when a meta http-equiv tag defines the charset.\n+// switching the charset midstream when a meta http-equiv tag defines the charset.\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n@@ -8,6 +8,7 @@\n     if (charsetName == null) {\n         // determine from meta. safe first parse as UTF-8\n         // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n+        byteData.rewind();\n         docData = Charset.forName(defaultCharset).decode(byteData).toString();\n         doc = parser.parseInput(docData, baseUri);\n         Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n@@ -41,12 +42,14 @@\n             charsetName = foundCharset;\n             byteData.rewind();\n             docData = Charset.forName(foundCharset).decode(byteData).toString();\n-            doc = null;\n+            doc = parser.parseInput(docData, baseUri);\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n+        byteData.rewind();\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri);\n     }\n     if (doc == null) {\n         doc = parser.parseInput(docData, baseUri);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// reads bytes first into a buffer, then decodes with the appropriate charset. Done this way to support\n// switching the charset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    charsetName = detectCharsetFromBom(byteData, charsetName);\n    if (charsetName == null) {\n        // determine from meta. Safe first parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        if (meta != null) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                if (Charset.isSupported(meta.attr(\"charset\"))) {\n                    foundCharset = meta.attr(\"charset\");\n                }\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n            // need to re-decode\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            byteData.rewind();\n            docData = Charset.forName(foundCharset).decode(byteData).toString();\n            doc = null;\n            doc = parser.parseInput(docData, baseUri);\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n    }\n    doc.outputSettings().charset(charsetName);\n    return doc;\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the charset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    charsetName = detectCharsetFromBom(byteData, charsetName);\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        if (meta != null) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n            // need to re-decode\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            byteData.rewind();\n            docData = Charset.forName(foundCharset).decode(byteData).toString();\n            doc = null;\n            doc = parser.parseInput(docData, baseUri);\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -1,5 +1,5 @@\n // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-// switching the chartset midstream when a meta http-equiv tag defines the charset.\n+// switching the charset midstream when a meta http-equiv tag defines the charset.\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n@@ -42,11 +42,13 @@\n             byteData.rewind();\n             docData = Charset.forName(foundCharset).decode(byteData).toString();\n             doc = null;\n+            doc = parser.parseInput(docData, baseUri);\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri);\n     }\n     if (doc == null) {\n         doc = parser.parseInput(docData, baseUri);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the charset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    charsetName = detectCharsetFromBom(byteData, charsetName);\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        if (meta != null) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n            // need to re-decode\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            byteData.rewind();\n            docData = Charset.forName(foundCharset).decode(byteData).toString();\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n    }\n    if (doc != null) {\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -1,5 +1,5 @@\n // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-// switching the chartset midstream when a meta http-equiv tag defines the charset.\n+// switching the charset midstream when a meta http-equiv tag defines the charset.\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n@@ -28,7 +28,7 @@\n             }\n         }\n         // look for <?xml encoding='ISO-8859-1'?>\n-        if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n+        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n             XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n             if (prolog.name().equals(\"xml\")) {\n                 foundCharset = prolog.attr(\"encoding\");\n@@ -47,9 +47,9 @@\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri);\n     }\n-    if (doc == null) {\n-        doc = parser.parseInput(docData, baseUri);\n+    if (doc != null) {\n         doc.outputSettings().charset(charsetName);\n     }\n     return doc;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    charsetName = detectCharsetFromBom(byteData, charsetName);\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        if (meta != null) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (UnsupportedCharsetException e) { // changed IllegalCharsetNameException to UnsupportedCharsetException\n                    foundCharset = null;\n                }\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n            // need to re-decode\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            byteData.rewind();\n            docData = Charset.forName(foundCharset).decode(byteData).toString();\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -22,7 +22,7 @@\n                     if (Charset.isSupported(meta.attr(\"charset\"))) {\n                         foundCharset = meta.attr(\"charset\");\n                     }\n-                } catch (IllegalCharsetNameException e) {\n+                } catch (UnsupportedCharsetException e) { // changed IllegalCharsetNameException to UnsupportedCharsetException\n                     foundCharset = null;\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    charsetName = detectCharsetFromBom(byteData, charsetName);\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        if (meta != null) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n            // need to re-decode\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            byteData.rewind();\n            docData = Charset.forName(foundCharset).decode(byteData).toString();\n            doc = null;\n            // fix to include document element (root) encoding too\n            if (docData.startsWith(\"<?xml\")) {\n                // <?xml version=\"1.0\" encoding=\"UTF-8\" ?>, look to pull out encoding\n                int end = docData.indexOf(\"?>\");\n                if (end > -1) {\n                    Matcher matcher = charsetPattern.matcher(docData.substring(0, end));\n                    if (matcher.find()) {\n                        charsetName = matcher.group(1);\n                        doc.outputSettings().charset(charsetName);\n                    }\n                }\n            }\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -42,6 +42,18 @@\n             byteData.rewind();\n             docData = Charset.forName(foundCharset).decode(byteData).toString();\n             doc = null;\n+            // fix to include document element (root) encoding too\n+            if (docData.startsWith(\"<?xml\")) {\n+                // <?xml version=\"1.0\" encoding=\"UTF-8\" ?>, look to pull out encoding\n+                int end = docData.indexOf(\"?>\");\n+                if (end > -1) {\n+                    Matcher matcher = charsetPattern.matcher(docData.substring(0, end));\n+                    if (matcher.find()) {\n+                        charsetName = matcher.group(1);\n+                        doc.outputSettings().charset(charsetName);\n+                    }\n+                }\n+            }\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the charset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    charsetName = detectCharsetFromBom(byteData, charsetName);\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        if (meta != null) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n            // need to re-decode\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            Charset charset = Charset.forName(foundCharset);\n            byteData.rewind();\n            CharBuffer charData = charset.decode(byteData);\n            docData = charData.toString();\n            doc = null;\n\n            // re-parse with new charset\n            doc = parser.parseInput(docData, baseUri);\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -1,5 +1,5 @@\n // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-// switching the chartset midstream when a meta http-equiv tag defines the charset.\n+// switching the charset midstream when a meta http-equiv tag defines the charset.\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n@@ -38,10 +38,14 @@\n         if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n             // need to re-decode\n             foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n-            charsetName = foundCharset;\n+            Charset charset = Charset.forName(foundCharset);\n             byteData.rewind();\n-            docData = Charset.forName(foundCharset).decode(byteData).toString();\n+            CharBuffer charData = charset.decode(byteData);\n+            docData = charData.toString();\n             doc = null;\n+\n+            // re-parse with new charset\n+            doc = parser.parseInput(docData, baseUri);\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    charsetName = detectCharsetFromBom(byteData, charsetName);\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        if (meta != null) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n            // need to re-decode\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            byteData.rewind();\n            docData = Charset.forName(foundCharset).decode(byteData).toString();\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -47,6 +47,7 @@\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri);\n     }\n     if (doc == null) {\n         doc = parser.parseInput(docData, baseUri);\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    charsetName = detectCharsetFromBom(byteData, charsetName);\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Charset defaultCharsetObj = StandardCharsets.UTF_8;\n        docData = defaultCharsetObj.decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        if (meta != null) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equals(defaultCharsetObj.name())) {\n            // need to re-decode\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            byteData.rewind();\n            Charset foundCharsetObj = Charset.forName(foundCharset);\n            docData = foundCharsetObj.decode(byteData).toString();\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        Charset charsetObj = Charset.forName(charsetName);\n        docData = charsetObj.decode(byteData).toString();\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -8,7 +8,8 @@\n     if (charsetName == null) {\n         // determine from meta. safe first parse as UTF-8\n         // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n-        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n+        Charset defaultCharsetObj = StandardCharsets.UTF_8;\n+        docData = defaultCharsetObj.decode(byteData).toString();\n         doc = parser.parseInput(docData, baseUri);\n         Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n         // if not found, will keep utf-8 as best attempt\n@@ -35,18 +36,20 @@\n             }\n         }\n         foundCharset = validateCharset(foundCharset);\n-        if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n+        if (foundCharset != null && !foundCharset.equals(defaultCharsetObj.name())) {\n             // need to re-decode\n             foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n             charsetName = foundCharset;\n             byteData.rewind();\n-            docData = Charset.forName(foundCharset).decode(byteData).toString();\n+            Charset foundCharsetObj = Charset.forName(foundCharset);\n+            docData = foundCharsetObj.decode(byteData).toString();\n             doc = null;\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n-        docData = Charset.forName(charsetName).decode(byteData).toString();\n+        Charset charsetObj = Charset.forName(charsetName);\n+        docData = charsetObj.decode(byteData).toString();\n     }\n     if (doc == null) {\n         doc = parser.parseInput(docData, baseUri);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the charset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    charsetName = detectCharsetFromBom(byteData, charsetName);\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        if (meta != null) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                if (Charset.isSupported(meta.attr(\"charset\"))) {\n                    foundCharset = meta.attr(\"charset\");\n                }\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n            // need to re-decode\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            byteData.rewind();\n            docData = Charset.forName(foundCharset).decode(byteData).toString();\n            doc = parser.parseInput(docData, baseUri);\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n    }\n    doc.outputSettings().charset(charsetName);\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -1,5 +1,5 @@\n // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-// switching the chartset midstream when a meta http-equiv tag defines the charset.\n+// switching the charset midstream when a meta http-equiv tag defines the charset.\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n@@ -18,12 +18,8 @@\n                 foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n             }\n             if (foundCharset == null && meta.hasAttr(\"charset\")) {\n-                try {\n-                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n-                        foundCharset = meta.attr(\"charset\");\n-                    }\n-                } catch (IllegalCharsetNameException e) {\n-                    foundCharset = null;\n+                if (Charset.isSupported(meta.attr(\"charset\"))) {\n+                    foundCharset = meta.attr(\"charset\");\n                 }\n             }\n         }\n@@ -41,16 +37,14 @@\n             charsetName = foundCharset;\n             byteData.rewind();\n             docData = Charset.forName(foundCharset).decode(byteData).toString();\n-            doc = null;\n+            doc = parser.parseInput(docData, baseUri);\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n+        doc = parser.parseInput(docData, baseUri);\n     }\n-    if (doc == null) {\n-        doc = parser.parseInput(docData, baseUri);\n-        doc.outputSettings().charset(charsetName);\n-    }\n+    doc.outputSettings().charset(charsetName);\n     return doc;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the chartset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    charsetName = detectCharsetFromBom(byteData, charsetName);\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        if (meta != null) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n            // need to re-decode\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            byteData.rewind();\n            Charset charset = Charset.forName(foundCharset);\n            CharBuffer charBuffer = charset.decode(byteData);\n            docData = charBuffer.toString();\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -40,7 +40,9 @@\n             foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n             charsetName = foundCharset;\n             byteData.rewind();\n-            docData = Charset.forName(foundCharset).decode(byteData).toString();\n+            Charset charset = Charset.forName(foundCharset);\n+            CharBuffer charBuffer = charset.decode(byteData);\n+            docData = charBuffer.toString();\n             doc = null;\n         }\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the charset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    charsetName = detectCharsetFromBom(byteData, charsetName);\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        if (meta != null) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            byteData.rewind();\n            docData = Charset.forName(foundCharset).decode(byteData).toString();\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to the character set of the file to parse. Set to null to attempt to detect from HTML.\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -1,5 +1,5 @@\n // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-// switching the chartset midstream when a meta http-equiv tag defines the charset.\n+// switching the charset midstream when a meta http-equiv tag defines the charset.\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n@@ -35,7 +35,7 @@\n             }\n         }\n         foundCharset = validateCharset(foundCharset);\n-        if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n+        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n             // need to re-decode\n             foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n             charsetName = foundCharset;\n@@ -45,7 +45,7 @@\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n-        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n+        Validate.notEmpty(charsetName, \"Must set charset arg to the character set of the file to parse. Set to null to attempt to detect from HTML.\");\n         docData = Charset.forName(charsetName).decode(byteData).toString();\n     }\n     if (doc == null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "// reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n// switching the charset midstream when a meta http-equiv tag defines the charset.\nstatic Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n    String docData;\n    Document doc = null;\n    // look for BOM - overrides any other header or input\n    charsetName = detectCharsetFromBom(byteData, charsetName);\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        docData = Charset.forName(defaultCharset).decode(byteData).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        if (meta != null) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                try {\n                    if (Charset.isSupported(meta.attr(\"charset\"))) {\n                        foundCharset = meta.attr(\"charset\");\n                    }\n                } catch (IllegalCharsetNameException e) {\n                    foundCharset = null;\n                }\n            }\n        }\n\n        // Adding this to fix a bug in the code\n        foundCharset = validateCharset(foundCharset); \n\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n            XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n            if (prolog.name().equals(\"xml\")) {\n                foundCharset = prolog.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equals(defaultCharset)) {\n            // need to re-decode\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            byteData.rewind();\n            docData = Charset.forName(foundCharset).decode(byteData).toString();\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        docData = Charset.forName(charsetName).decode(byteData).toString();\n    }\n    if (doc == null) {\n        doc = parser.parseInput(docData, baseUri);\n        doc.outputSettings().charset(charsetName);\n    }\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseByteData\n+++ org/jsoup/helper/DataUtil.java@parseByteData\n@@ -1,5 +1,5 @@\n // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-// switching the chartset midstream when a meta http-equiv tag defines the charset.\n+// switching the charset midstream when a meta http-equiv tag defines the charset.\n static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n     String docData;\n     Document doc = null;\n@@ -27,8 +27,12 @@\n                 }\n             }\n         }\n+\n+        // Adding this to fix a bug in the code\n+        foundCharset = validateCharset(foundCharset); \n+\n         // look for <?xml encoding='ISO-8859-1'?>\n-        if (foundCharset == null && doc.childNode(0) instanceof XmlDeclaration) {\n+        if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n             XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n             if (prolog.name().equals(\"xml\")) {\n                 foundCharset = prolog.attr(\"encoding\");\n", "finish_reason": "stop", "valid": false, "num": 1}]