[{"output": "@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(1, i), port);\n            } else {\n                int ix = value.lastIndexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -53,9 +53,9 @@\n                 }\n                 int j = value.indexOf(':', i);\n                 int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n-                return new InetSocketAddress(value.substring(0, i + 1), port);\n+                return new InetSocketAddress(value.substring(1, i), port);\n             } else {\n-                int ix = value.indexOf(':');\n+                int ix = value.lastIndexOf(':');\n                 if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                     // host:port\n                     int port = Integer.parseInt(value.substring(ix + 1));\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,69 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(1, i), port);\n+            } else {\n+                int ix = value.lastIndexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "It is unclear what the specific bug is in this function, so a fixed version cannot be provided without further information.", "diff": "", "finish_reason": "stop", "valid": false, "num": 6}, {"output": "@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(1, i), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -53,7 +53,7 @@\n                 }\n                 int j = value.indexOf(':', i);\n                 int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n-                return new InetSocketAddress(value.substring(0, i + 1), port);\n+                return new InetSocketAddress(value.substring(1, i), port);\n             } else {\n                 int ix = value.indexOf(':');\n                 if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,69 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(1, i), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (ClassNotFoundException e) { // Catch specific exception\n                throw ctxt.instantiationException(_valueClass, e); // Only pass the exception as the cause\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -10,8 +10,8 @@\n         case STD_CLASS:\n             try {\n                 return ctxt.findClass(value);\n-            } catch (Exception e) {\n-                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            } catch (ClassNotFoundException e) { // Catch specific exception\n+                throw ctxt.instantiationException(_valueClass, e); // Only pass the exception as the cause\n             }\n         case STD_JAVA_TYPE:\n             return ctxt.getTypeFactory().constructFromCanonical(value);\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,69 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (ClassNotFoundException e) { // Catch specific exception\n+                throw ctxt.instantiationException(_valueClass, e); // Only pass the exception as the cause\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (ClassNotFoundException e) { // Fixed catch statement\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -10,7 +10,7 @@\n         case STD_CLASS:\n             try {\n                 return ctxt.findClass(value);\n-            } catch (Exception e) {\n+            } catch (ClassNotFoundException e) { // Fixed catch statement\n                 throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n             }\n         case STD_JAVA_TYPE:\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,69 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (ClassNotFoundException e) { // Fixed catch statement\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw ctxt.weirdStringException(value, InetSocketAddress.class, \"Bracketed IPv6 address must contain closing bracket\");\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.lastIndexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw ctxt.mappingException(\"Unsupported type \"+_kind);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -49,13 +49,13 @@\n                 // bracketed IPv6 (with port number)\n                 int i = value.lastIndexOf(']');\n                 if (i == -1) {\n-                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                    throw ctxt.weirdStringException(value, InetSocketAddress.class, \"Bracketed IPv6 address must contain closing bracket\");\n                 }\n                 int j = value.indexOf(':', i);\n                 int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                 return new InetSocketAddress(value.substring(0, i + 1), port);\n             } else {\n-                int ix = value.indexOf(':');\n+                int ix = value.lastIndexOf(':');\n                 if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                     // host:port\n                     int port = Integer.parseInt(value.substring(ix + 1));\n@@ -65,5 +65,5 @@\n                 return new InetSocketAddress(value, 0);\n             }\n     }\n-    throw new IllegalArgumentException();\n+    throw ctxt.mappingException(\"Unsupported type \"+_kind);\n }\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,69 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw ctxt.weirdStringException(value, InetSocketAddress.class, \"Bracketed IPv6 address must contain closing bracket\");\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.lastIndexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw ctxt.mappingException(\"Unsupported type \"+_kind);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.lastIndexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -55,7 +55,7 @@\n                 int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                 return new InetSocketAddress(value.substring(0, i + 1), port);\n             } else {\n-                int ix = value.indexOf(':');\n+                int ix = value.lastIndexOf(':');\n                 if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                     // host:port\n                     int port = Integer.parseInt(value.substring(ix + 1));\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,69 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.lastIndexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "The buggy function does not have a specific issue to fix. However, it is missing a default case in the switch statement, which can result in an IllegalArgumentException being thrown if none of the cases match. The fixed function includes a default case that throws a more informative exception message:\n\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n        default:\n            throw new IllegalArgumentException(\"Invalid _kind value: \" + _kind);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -64,6 +64,7 @@\n                 // host or unbracketed IPv6, without port number\n                 return new InetSocketAddress(value, 0);\n             }\n+        default:\n+            throw new IllegalArgumentException(\"Invalid _kind value: \" + _kind);\n     }\n-    throw new IllegalArgumentException();\n }\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,70 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n+        default:\n+            throw new IllegalArgumentException(\"Invalid _kind value: \" + _kind);\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i + 1);\n                int port;\n                if (j > -1) {\n                    port = Integer.parseInt(value.substring(j + 1));\n                } else {\n                    port = 0;\n                }\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.lastIndexOf(':');\n                if (ix >= 0 && ix == value.indexOf(':')) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -51,12 +51,17 @@\n                 if (i == -1) {\n                     throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                 }\n-                int j = value.indexOf(':', i);\n-                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                int j = value.indexOf(':', i + 1);\n+                int port;\n+                if (j > -1) {\n+                    port = Integer.parseInt(value.substring(j + 1));\n+                } else {\n+                    port = 0;\n+                }\n                 return new InetSocketAddress(value.substring(0, i + 1), port);\n             } else {\n-                int ix = value.indexOf(':');\n-                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                int ix = value.lastIndexOf(':');\n+                if (ix >= 0 && ix == value.indexOf(':')) {\n                     // host:port\n                     int port = Integer.parseInt(value.substring(ix + 1));\n                     return new InetSocketAddress(value.substring(0, ix), port);\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,74 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i + 1);\n+                int port;\n+                if (j > -1) {\n+                    port = Integer.parseInt(value.substring(j + 1));\n+                } else {\n+                    port = 0;\n+                }\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.lastIndexOf(':');\n+                if (ix >= 0 && ix == value.indexOf(':')) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String language = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(language, value);\n                }\n                String country = value.substring(0, ix);\n                return new Locale(language, country, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.lastIndexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -28,15 +28,15 @@\n                     // single argument\n                     return new Locale(value);\n                 }\n-                String first = value.substring(0, ix);\n+                String language = value.substring(0, ix);\n                 value = value.substring(ix + 1);\n                 ix = value.indexOf('_');\n                 if (ix < 0) {\n                     // two pieces\n-                    return new Locale(first, value);\n+                    return new Locale(language, value);\n                 }\n-                String second = value.substring(0, ix);\n-                return new Locale(first, second, value.substring(ix + 1));\n+                String country = value.substring(0, ix);\n+                return new Locale(language, country, value.substring(ix + 1));\n             }\n         case STD_CHARSET:\n             return Charset.forName(value);\n@@ -55,7 +55,7 @@\n                 int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                 return new InetSocketAddress(value.substring(0, i + 1), port);\n             } else {\n-                int ix = value.indexOf(':');\n+                int ix = value.lastIndexOf(':');\n                 if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                     // host:port\n                     int port = Integer.parseInt(value.substring(ix + 1));\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,69 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String language = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(language, value);\n+                }\n+                String country = value.substring(0, ix);\n+                return new Locale(language, country, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.lastIndexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.lastIndexOf(':');\n                if (ix > 0 && ix < value.length() - 1) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                } else {\n                    // host or unbracketed IPv6, without port number\n                    return new InetSocketAddress(value, 0);\n                }\n            }\n    }\n    throw new IllegalArgumentException();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -55,14 +55,15 @@\n                 int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                 return new InetSocketAddress(value.substring(0, i + 1), port);\n             } else {\n-                int ix = value.indexOf(':');\n-                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                int ix = value.lastIndexOf(':');\n+                if (ix > 0 && ix < value.length() - 1) {\n                     // host:port\n                     int port = Integer.parseInt(value.substring(ix + 1));\n                     return new InetSocketAddress(value.substring(0, ix), port);\n+                } else {\n+                    // host or unbracketed IPv6, without port number\n+                    return new InetSocketAddress(value, 0);\n                 }\n-                // host or unbracketed IPv6, without port number\n-                return new InetSocketAddress(value, 0);\n             }\n     }\n     throw new IllegalArgumentException();\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,70 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.lastIndexOf(':');\n+                if (ix > 0 && ix < value.length() - 1) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                } else {\n+                    // host or unbracketed IPv6, without port number\n+                    return new InetSocketAddress(value, 0);\n+                }\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (ClassNotFoundException e) {\n                throw ctxt.instantiationException(_valueClass, e);\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.indexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n        default:\n            throw new JsonParseException(\"Unexpected token\", ctxt.getCurrentLocation());\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -10,8 +10,8 @@\n         case STD_CLASS:\n             try {\n                 return ctxt.findClass(value);\n-            } catch (Exception e) {\n-                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            } catch (ClassNotFoundException e) {\n+                throw ctxt.instantiationException(_valueClass, e);\n             }\n         case STD_JAVA_TYPE:\n             return ctxt.getTypeFactory().constructFromCanonical(value);\n@@ -64,6 +64,7 @@\n                 // host or unbracketed IPv6, without port number\n                 return new InetSocketAddress(value, 0);\n             }\n+        default:\n+            throw new JsonParseException(\"Unexpected token\", ctxt.getCurrentLocation());\n     }\n-    throw new IllegalArgumentException();\n }\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,70 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (ClassNotFoundException e) {\n+                throw ctxt.instantiationException(_valueClass, e);\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.indexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n+        default:\n+            throw new JsonParseException(\"Unexpected token\", ctxt.getCurrentLocation());\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "The specific bug in the function is not clear from the provided code snippet. However, one general improvement for this function would be to add a default case in the switch statement that throws an IllegalArgumentException. This would make the function more robust and prevent unexpected behavior if it is called with an invalid argument.\n\nFixed Function with default case:\n\n@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        // existing cases...\n        default:\n            throw new IllegalArgumentException(\"Invalid argument: \" + _kind);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -1,69 +1,8 @@\n @Override\n protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n     switch(_kind) {\n-        case STD_FILE:\n-            return new File(value);\n-        case STD_URL:\n-            return new URL(value);\n-        case STD_URI:\n-            return URI.create(value);\n-        case STD_CLASS:\n-            try {\n-                return ctxt.findClass(value);\n-            } catch (Exception e) {\n-                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n-            }\n-        case STD_JAVA_TYPE:\n-            return ctxt.getTypeFactory().constructFromCanonical(value);\n-        case STD_CURRENCY:\n-            // will throw IAE if unknown:\n-            return Currency.getInstance(value);\n-        case STD_PATTERN:\n-            // will throw IAE (or its subclass) if malformed\n-            return Pattern.compile(value);\n-        case STD_LOCALE:\n-            {\n-                int ix = value.indexOf('_');\n-                if (ix < 0) {\n-                    // single argument\n-                    return new Locale(value);\n-                }\n-                String first = value.substring(0, ix);\n-                value = value.substring(ix + 1);\n-                ix = value.indexOf('_');\n-                if (ix < 0) {\n-                    // two pieces\n-                    return new Locale(first, value);\n-                }\n-                String second = value.substring(0, ix);\n-                return new Locale(first, second, value.substring(ix + 1));\n-            }\n-        case STD_CHARSET:\n-            return Charset.forName(value);\n-        case STD_TIME_ZONE:\n-            return TimeZone.getTimeZone(value);\n-        case STD_INET_ADDRESS:\n-            return InetAddress.getByName(value);\n-        case STD_INET_SOCKET_ADDRESS:\n-            if (value.startsWith(\"[\")) {\n-                // bracketed IPv6 (with port number)\n-                int i = value.lastIndexOf(']');\n-                if (i == -1) {\n-                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n-                }\n-                int j = value.indexOf(':', i);\n-                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n-                return new InetSocketAddress(value.substring(0, i + 1), port);\n-            } else {\n-                int ix = value.indexOf(':');\n-                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n-                    // host:port\n-                    int port = Integer.parseInt(value.substring(ix + 1));\n-                    return new InetSocketAddress(value.substring(0, ix), port);\n-                }\n-                // host or unbracketed IPv6, without port number\n-                return new InetSocketAddress(value, 0);\n-            }\n+        // existing cases...\n+        default:\n+            throw new IllegalArgumentException(\"Invalid argument: \" + _kind);\n     }\n-    throw new IllegalArgumentException();\n }\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,8 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        // existing cases...\n+        default:\n+            throw new IllegalArgumentException(\"Invalid argument: \" + _kind);\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch(_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix >= 0) {\n                    String second = value.substring(0, ix);\n                    return new Locale(first, second, value.substring(ix + 1));\n                } else {\n                    // two letter language code only (ISO 639)\n                    return new Locale(first, \"\");\n                }\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(0, i + 1), port);\n            } else {\n                int ix = value.lastIndexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -31,12 +31,13 @@\n                 String first = value.substring(0, ix);\n                 value = value.substring(ix + 1);\n                 ix = value.indexOf('_');\n-                if (ix < 0) {\n-                    // two pieces\n-                    return new Locale(first, value);\n+                if (ix >= 0) {\n+                    String second = value.substring(0, ix);\n+                    return new Locale(first, second, value.substring(ix + 1));\n+                } else {\n+                    // two letter language code only (ISO 639)\n+                    return new Locale(first, \"\");\n                 }\n-                String second = value.substring(0, ix);\n-                return new Locale(first, second, value.substring(ix + 1));\n             }\n         case STD_CHARSET:\n             return Charset.forName(value);\n@@ -55,7 +56,7 @@\n                 int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                 return new InetSocketAddress(value.substring(0, i + 1), port);\n             } else {\n-                int ix = value.indexOf(':');\n+                int ix = value.lastIndexOf(':');\n                 if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                     // host:port\n                     int port = Integer.parseInt(value.substring(ix + 1));\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,70 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch(_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix >= 0) {\n+                    String second = value.substring(0, ix);\n+                    return new Locale(first, second, value.substring(ix + 1));\n+                } else {\n+                    // two letter language code only (ISO 639)\n+                    return new Locale(first, \"\");\n+                }\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(0, i + 1), port);\n+            } else {\n+                int ix = value.lastIndexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nprotected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n    switch (_kind) {\n        case STD_FILE:\n            return new File(value);\n        case STD_URL:\n            return new URL(value);\n        case STD_URI:\n            return URI.create(value);\n        case STD_CLASS:\n            try {\n                return ctxt.findClass(value);\n            } catch (Exception e) {\n                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n            }\n        case STD_JAVA_TYPE:\n            return ctxt.getTypeFactory().constructFromCanonical(value);\n        case STD_CURRENCY:\n            // will throw IAE if unknown:\n            return Currency.getInstance(value);\n        case STD_PATTERN:\n            // will throw IAE (or its subclass) if malformed\n            return Pattern.compile(value);\n        case STD_LOCALE:\n            {\n                int ix = value.indexOf('_');\n                if (ix < 0) {\n                    // single argument\n                    return new Locale(value);\n                }\n                String first = value.substring(0, ix);\n                value = value.substring(ix + 1);\n                ix = value.indexOf('_');\n                if (ix < 0) {\n                    // two pieces\n                    return new Locale(first, value);\n                }\n                String second = value.substring(0, ix);\n                return new Locale(first, second, value.substring(ix + 1));\n            }\n        case STD_CHARSET:\n            return Charset.forName(value);\n        case STD_TIME_ZONE:\n            return TimeZone.getTimeZone(value);\n        case STD_INET_ADDRESS:\n            return InetAddress.getByName(value);\n        case STD_INET_SOCKET_ADDRESS:\n            if (value.startsWith(\"[\")) {\n                // bracketed IPv6 (with port number)\n                int i = value.lastIndexOf(']');\n                if (i == -1) {\n                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n                }\n                int j = value.indexOf(':', i);\n                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n                return new InetSocketAddress(value.substring(1, i), port);\n            } else {\n                int ix = value.lastIndexOf(':');\n                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                    // host:port\n                    int port = Integer.parseInt(value.substring(ix + 1));\n                    return new InetSocketAddress(value.substring(0, ix), port);\n                }\n                // host or unbracketed IPv6, without port number\n                return new InetSocketAddress(value, 0);\n            }\n    }\n    throw new IllegalArgumentException();\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserialize\n@@ -1,6 +1,6 @@\n @Override\n protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n-    switch(_kind) {\n+    switch (_kind) {\n         case STD_FILE:\n             return new File(value);\n         case STD_URL:\n@@ -53,9 +53,9 @@\n                 }\n                 int j = value.indexOf(':', i);\n                 int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n-                return new InetSocketAddress(value.substring(0, i + 1), port);\n+                return new InetSocketAddress(value.substring(1, i), port);\n             } else {\n-                int ix = value.indexOf(':');\n+                int ix = value.lastIndexOf(':');\n                 if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n                     // host:port\n                     int port = Integer.parseInt(value.substring(ix + 1));\n--- com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n+++ com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java@_deserializeFromEmptyString\n@@ -1,12 +1,69 @@\n @Override\n-protected Object _deserializeFromEmptyString() throws IOException {\n-    // As per [databind#398], URI requires special handling\n-    if (_kind == STD_URI) {\n-        return URI.create(\"\");\n+protected Object _deserialize(String value, DeserializationContext ctxt) throws IOException {\n+    switch (_kind) {\n+        case STD_FILE:\n+            return new File(value);\n+        case STD_URL:\n+            return new URL(value);\n+        case STD_URI:\n+            return URI.create(value);\n+        case STD_CLASS:\n+            try {\n+                return ctxt.findClass(value);\n+            } catch (Exception e) {\n+                throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e));\n+            }\n+        case STD_JAVA_TYPE:\n+            return ctxt.getTypeFactory().constructFromCanonical(value);\n+        case STD_CURRENCY:\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        case STD_PATTERN:\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        case STD_LOCALE:\n+            {\n+                int ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // single argument\n+                    return new Locale(value);\n+                }\n+                String first = value.substring(0, ix);\n+                value = value.substring(ix + 1);\n+                ix = value.indexOf('_');\n+                if (ix < 0) {\n+                    // two pieces\n+                    return new Locale(first, value);\n+                }\n+                String second = value.substring(0, ix);\n+                return new Locale(first, second, value.substring(ix + 1));\n+            }\n+        case STD_CHARSET:\n+            return Charset.forName(value);\n+        case STD_TIME_ZONE:\n+            return TimeZone.getTimeZone(value);\n+        case STD_INET_ADDRESS:\n+            return InetAddress.getByName(value);\n+        case STD_INET_SOCKET_ADDRESS:\n+            if (value.startsWith(\"[\")) {\n+                // bracketed IPv6 (with port number)\n+                int i = value.lastIndexOf(']');\n+                if (i == -1) {\n+                    throw new InvalidFormatException(ctxt.getParser(), \"Bracketed IPv6 address must contain closing bracket\", value, InetSocketAddress.class);\n+                }\n+                int j = value.indexOf(':', i);\n+                int port = j > -1 ? Integer.parseInt(value.substring(j + 1)) : 0;\n+                return new InetSocketAddress(value.substring(1, i), port);\n+            } else {\n+                int ix = value.lastIndexOf(':');\n+                if (ix >= 0 && value.indexOf(':', ix + 1) < 0) {\n+                    // host:port\n+                    int port = Integer.parseInt(value.substring(ix + 1));\n+                    return new InetSocketAddress(value.substring(0, ix), port);\n+                }\n+                // host or unbracketed IPv6, without port number\n+                return new InetSocketAddress(value, 0);\n+            }\n     }\n-    // As per [databind#1123], Locale too\n-    if (_kind == STD_LOCALE) {\n-        return Locale.ROOT;\n-    }\n-    return super._deserializeFromEmptyString();\n+    throw new IllegalArgumentException();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]