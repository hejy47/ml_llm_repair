[{"output": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.isCatch()) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && v.parentNode.getParent().getType() == Token.FUNCTION) {\n        if (v.getParentNode().getType() == Token.VAR) {\n            s.undeclare(v);\n            s.declare(name, n, n.getJSType(), v.input);\n            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n        }\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -7,7 +7,7 @@\n     // This deals with issues where a browser built-in is declared\n     // in one browser but not in another.\n     // If name is \"arguments\", Var maybe null.\n-    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+    if (v != null && v.isCatch()) {\n         // Redeclaration of a catch expression variable is hard to model\n         // without support for \"with\" expressions.\n         // The EcmaScript spec (section 12.14), declares that a catch\n@@ -23,7 +23,7 @@\n         // Use the name of the var before it was made unique.\n         name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n         compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n-    } else if (v != null && parent.getType() == Token.FUNCTION) {\n+    } else if (v != null && v.parentNode.getParent().getType() == Token.FUNCTION) {\n         if (v.getParentNode().getType() == Token.VAR) {\n             s.undeclare(v);\n             s.declare(name, n, n.getJSType(), v.input);\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,35 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.isCatch()) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && v.parentNode.getParent().getType() == Token.FUNCTION) {\n+        if (v.getParentNode().getType() == Token.VAR) {\n+            s.undeclare(v);\n+            s.declare(name, n, n.getJSType(), v.input);\n+            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n         }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    } else if (parent.getType() == Token.VAR) {\n+        Preconditions.checkState(parent.hasOneChild());\n+        replaceVarWithAssignment(n, parent, gramps);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION && v.getParentNode().getType() == Token.VAR) {\n        // Allow the redeclaration of a variable within a function as long\n        // as it was declared with \"var\".\n        s.undeclare(v);\n        s.declare(name, n, n.getJSType(), v.input);\n        replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -23,12 +23,12 @@\n         // Use the name of the var before it was made unique.\n         name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n         compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n-    } else if (v != null && parent.getType() == Token.FUNCTION) {\n-        if (v.getParentNode().getType() == Token.VAR) {\n-            s.undeclare(v);\n-            s.declare(name, n, n.getJSType(), v.input);\n-            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n-        }\n+    } else if (v != null && parent.getType() == Token.FUNCTION && v.getParentNode().getType() == Token.VAR) {\n+        // Allow the redeclaration of a variable within a function as long\n+        // as it was declared with \"var\".\n+        s.undeclare(v);\n+        s.declare(name, n, n.getJSType(), v.input);\n+        replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n     } else if (parent.getType() == Token.VAR) {\n         Preconditions.checkState(parent.hasOneChild());\n         replaceVarWithAssignment(n, parent, gramps);\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,35 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n-        }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && parent.getType() == Token.FUNCTION && v.getParentNode().getType() == Token.VAR) {\n+        // Allow the redeclaration of a variable within a function as long\n+        // as it was declared with \"var\".\n+        s.undeclare(v);\n+        s.declare(name, n, n.getJSType(), v.input);\n+        replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n+    } else if (parent.getType() == Token.VAR) {\n+        Preconditions.checkState(parent.hasOneChild());\n+        replaceVarWithAssignment(n, parent, gramps);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION && v.getParentNode().getType() != Token.PARAM_LIST) {\n        if (v.getParentNode().getType() == Token.VAR) {\n            s.undeclare(v);\n            s.declare(name, n, n.getJSType(), v.input);\n            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n        }\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -23,7 +23,7 @@\n         // Use the name of the var before it was made unique.\n         name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n         compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n-    } else if (v != null && parent.getType() == Token.FUNCTION) {\n+    } else if (v != null && parent.getType() == Token.FUNCTION && v.getParentNode().getType() != Token.PARAM_LIST) {\n         if (v.getParentNode().getType() == Token.VAR) {\n             s.undeclare(v);\n             s.declare(name, n, n.getJSType(), v.input);\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,35 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && parent.getType() == Token.FUNCTION && v.getParentNode().getType() != Token.PARAM_LIST) {\n+        if (v.getParentNode().getType() == Token.VAR) {\n+            s.undeclare(v);\n+            s.declare(name, n, n.getJSType(), v.input);\n+            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n         }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    } else if (parent.getType() == Token.VAR) {\n+        Preconditions.checkState(parent.hasOneChild());\n+        replaceVarWithAssignment(n, parent, gramps);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && v.getParentNode().getType() == Token.VAR) {\n        // Redeclaration of a variable declared in the variable statement\n        if (v.input.getLineno() == n.getLineno()) {\n            // Redeclaration refers to the same variable statement\n            // Change the variable declaration to an assignment.\n            replaceVarWithAssignment(n, v.getParentNode(), gramps);\n            return;\n        } else {\n            // Redeclaration refers to a different variable statement.\n            // Remove the previous declaration and create a new one.\n            // Note that removing the previous declaration can cause side effects.\n            // For example, it can cause the original variable to \"leak\" into the global scope.\n            // This is an unfortunate consequence of trying to keep the behavior of closure-compiler\n            // consistent with that of the built-in JS scope rules.\n            s.undeclare(v);\n        }\n    }\n    s.declare(name, n, n.getJSType(), input);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -23,14 +23,22 @@\n         // Use the name of the var before it was made unique.\n         name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n         compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n-    } else if (v != null && parent.getType() == Token.FUNCTION) {\n-        if (v.getParentNode().getType() == Token.VAR) {\n+    } else if (v != null && v.getParentNode().getType() == Token.VAR) {\n+        // Redeclaration of a variable declared in the variable statement\n+        if (v.input.getLineno() == n.getLineno()) {\n+            // Redeclaration refers to the same variable statement\n+            // Change the variable declaration to an assignment.\n+            replaceVarWithAssignment(n, v.getParentNode(), gramps);\n+            return;\n+        } else {\n+            // Redeclaration refers to a different variable statement.\n+            // Remove the previous declaration and create a new one.\n+            // Note that removing the previous declaration can cause side effects.\n+            // For example, it can cause the original variable to \"leak\" into the global scope.\n+            // This is an unfortunate consequence of trying to keep the behavior of closure-compiler\n+            // consistent with that of the built-in JS scope rules.\n             s.undeclare(v);\n-            s.declare(name, n, n.getJSType(), v.input);\n-            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n         }\n-    } else if (parent.getType() == Token.VAR) {\n-        Preconditions.checkState(parent.hasOneChild());\n-        replaceVarWithAssignment(n, parent, gramps);\n     }\n+    s.declare(name, n, n.getJSType(), input);\n }\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,43 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && v.getParentNode().getType() == Token.VAR) {\n+        // Redeclaration of a variable declared in the variable statement\n+        if (v.input.getLineno() == n.getLineno()) {\n+            // Redeclaration refers to the same variable statement\n+            // Change the variable declaration to an assignment.\n+            replaceVarWithAssignment(n, v.getParentNode(), gramps);\n             return;\n+        } else {\n+            // Redeclaration refers to a different variable statement.\n+            // Remove the previous declaration and create a new one.\n+            // Note that removing the previous declaration can cause side effects.\n+            // For example, it can cause the original variable to \"leak\" into the global scope.\n+            // This is an unfortunate consequence of trying to keep the behavior of closure-compiler\n+            // consistent with that of the built-in JS scope rules.\n+            s.undeclare(v);\n         }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n     }\n+    s.declare(name, n, n.getJSType(), input);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOriginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && v.getParentNode().getType() == Token.VAR) {\n        // Only remove the previously declared variable if it is not matching the current scope.\n        if (v.getScope() != s) {\n            s.undeclare(v);\n            s.declare(name, n, n.getJSType(), v.input);\n            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n        }\n    } else if (parent.getType() == Token.VAR) {\n        // We're dealing with a new var but the name was already declared in another scope. We'll assume a shadow for now\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -21,15 +21,17 @@\n         // TODO(johnlenz): Consider improving how scope handles catch\n         // expression.\n         // Use the name of the var before it was made unique.\n-        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOriginalName(name);\n         compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n-    } else if (v != null && parent.getType() == Token.FUNCTION) {\n-        if (v.getParentNode().getType() == Token.VAR) {\n+    } else if (v != null && v.getParentNode().getType() == Token.VAR) {\n+        // Only remove the previously declared variable if it is not matching the current scope.\n+        if (v.getScope() != s) {\n             s.undeclare(v);\n             s.declare(name, n, n.getJSType(), v.input);\n             replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n         }\n     } else if (parent.getType() == Token.VAR) {\n+        // We're dealing with a new var but the name was already declared in another scope. We'll assume a shadow for now\n         Preconditions.checkState(parent.hasOneChild());\n         replaceVarWithAssignment(n, parent, gramps);\n     }\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,37 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOriginalName(name);\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && v.getParentNode().getType() == Token.VAR) {\n+        // Only remove the previously declared variable if it is not matching the current scope.\n+        if (v.getScope() != s) {\n+            s.undeclare(v);\n+            s.declare(name, n, n.getJSType(), v.input);\n+            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n         }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    } else if (parent.getType() == Token.VAR) {\n+        // We're dealing with a new var but the name was already declared in another scope. We'll assume a shadow for now\n+        Preconditions.checkState(parent.hasOneChild());\n+        replaceVarWithAssignment(n, parent, gramps);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION && v.getParentNode().getType() == Token.VAR) {\n        Node assignment = IR.assign(IR.name(name), n.detach());\n        assignment.useSourceInfoFrom(n);\n        parent.replaceChild(n, assignment);\n        s.undeclare(v);\n        s.declare(name, assignment, n.getJSType(), v.input);\n    } else if (parent.getType() == Token.VAR) {\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -23,14 +23,13 @@\n         // Use the name of the var before it was made unique.\n         name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n         compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n-    } else if (v != null && parent.getType() == Token.FUNCTION) {\n-        if (v.getParentNode().getType() == Token.VAR) {\n-            s.undeclare(v);\n-            s.declare(name, n, n.getJSType(), v.input);\n-            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n-        }\n+    } else if (v != null && parent.getType() == Token.FUNCTION && v.getParentNode().getType() == Token.VAR) {\n+        Node assignment = IR.assign(IR.name(name), n.detach());\n+        assignment.useSourceInfoFrom(n);\n+        parent.replaceChild(n, assignment);\n+        s.undeclare(v);\n+        s.declare(name, assignment, n.getJSType(), v.input);\n     } else if (parent.getType() == Token.VAR) {\n-        Preconditions.checkState(parent.hasOneChild());\n         replaceVarWithAssignment(n, parent, gramps);\n     }\n }\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,34 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n-        }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && parent.getType() == Token.FUNCTION && v.getParentNode().getType() == Token.VAR) {\n+        Node assignment = IR.assign(IR.name(name), n.detach());\n+        assignment.useSourceInfoFrom(n);\n+        parent.replaceChild(n, assignment);\n+        s.undeclare(v);\n+        s.declare(name, assignment, n.getJSType(), v.input);\n+    } else if (parent.getType() == Token.VAR) {\n+        replaceVarWithAssignment(n, parent, gramps);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION && v.getParentNode().getType() == Token.VAR) {\n        s.undeclare(v);\n        s.declare(name, n, n.getJSType(), v.input);\n        replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -23,12 +23,10 @@\n         // Use the name of the var before it was made unique.\n         name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n         compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n-    } else if (v != null && parent.getType() == Token.FUNCTION) {\n-        if (v.getParentNode().getType() == Token.VAR) {\n-            s.undeclare(v);\n-            s.declare(name, n, n.getJSType(), v.input);\n-            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n-        }\n+    } else if (v != null && parent.getType() == Token.FUNCTION && v.getParentNode().getType() == Token.VAR) {\n+        s.undeclare(v);\n+        s.declare(name, n, n.getJSType(), v.input);\n+        replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n     } else if (parent.getType() == Token.VAR) {\n         Preconditions.checkState(parent.hasOneChild());\n         replaceVarWithAssignment(n, parent, gramps);\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,33 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n-        }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && parent.getType() == Token.FUNCTION && v.getParentNode().getType() == Token.VAR) {\n+        s.undeclare(v);\n+        s.declare(name, n, n.getJSType(), v.input);\n+        replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n+    } else if (parent.getType() == Token.VAR) {\n+        Preconditions.checkState(parent.hasOneChild());\n+        replaceVarWithAssignment(n, parent, gramps);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this, disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), n, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION && v.getParentNode().getType() == Token.VAR) {\n        s.undeclare(v);\n        s.declare(name, n, n.getJSType(), v.input);\n        replaceVarWithAssignment(v.getNameNode(), v, gramps);\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -14,7 +14,7 @@\n         // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n         // \"var e\" would refer to the scope variable, but any following\n         // reference would still refer to \"e\" of the catch expression.\n-        // Until we have support for this disallow it.\n+        // Until we have support for this, disallow it.\n         // Currently the Scope object adds the catch expression to the\n         // function scope, which is technically not true but a good\n         // approximation for most uses.\n@@ -22,13 +22,11 @@\n         // expression.\n         // Use the name of the var before it was made unique.\n         name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n-        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n-    } else if (v != null && parent.getType() == Token.FUNCTION) {\n-        if (v.getParentNode().getType() == Token.VAR) {\n-            s.undeclare(v);\n-            s.declare(name, n, n.getJSType(), v.input);\n-            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n-        }\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), n, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && parent.getType() == Token.FUNCTION && v.getParentNode().getType() == Token.VAR) {\n+        s.undeclare(v);\n+        s.declare(name, n, n.getJSType(), v.input);\n+        replaceVarWithAssignment(v.getNameNode(), v, gramps);\n     } else if (parent.getType() == Token.VAR) {\n         Preconditions.checkState(parent.hasOneChild());\n         replaceVarWithAssignment(n, parent, gramps);\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,33 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n-        }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this, disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), n, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && parent.getType() == Token.FUNCTION && v.getParentNode().getType() == Token.VAR) {\n+        s.undeclare(v);\n+        s.declare(name, n, n.getJSType(), v.input);\n+        replaceVarWithAssignment(v.getNameNode(), v, gramps);\n+    } else if (parent.getType() == Token.VAR) {\n+        Preconditions.checkState(parent.hasOneChild());\n+        replaceVarWithAssignment(n, parent, gramps);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION) { // v cannot be null here as it was checked above.\n        if (v.getParentNode() == null || v.getParentNode().getType() == Token.VAR) {\n            s.undeclare(v);\n            if (n.getJSType() != null) {\n                s.declare(name, n, n.getJSType(), v.input);\n            } else {\n                s.declare(name, n, null, v.input);\n            }\n            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode() != null ? v.getParentNode().getParent() : null);\n        }\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -23,11 +23,15 @@\n         // Use the name of the var before it was made unique.\n         name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n         compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n-    } else if (v != null && parent.getType() == Token.FUNCTION) {\n-        if (v.getParentNode().getType() == Token.VAR) {\n+    } else if (v != null && parent.getType() == Token.FUNCTION) { // v cannot be null here as it was checked above.\n+        if (v.getParentNode() == null || v.getParentNode().getType() == Token.VAR) {\n             s.undeclare(v);\n-            s.declare(name, n, n.getJSType(), v.input);\n-            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n+            if (n.getJSType() != null) {\n+                s.declare(name, n, n.getJSType(), v.input);\n+            } else {\n+                s.declare(name, n, null, v.input);\n+            }\n+            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode() != null ? v.getParentNode().getParent() : null);\n         }\n     } else if (parent.getType() == Token.VAR) {\n         Preconditions.checkState(parent.hasOneChild());\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,39 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && parent.getType() == Token.FUNCTION) { // v cannot be null here as it was checked above.\n+        if (v.getParentNode() == null || v.getParentNode().getType() == Token.VAR) {\n+            s.undeclare(v);\n+            if (n.getJSType() != null) {\n+                s.declare(name, n, n.getJSType(), v.input);\n+            } else {\n+                s.declare(name, n, null, v.input);\n+            }\n+            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode() != null ? v.getParentNode().getParent() : null);\n         }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    } else if (parent.getType() == Token.VAR) {\n+        Preconditions.checkState(parent.hasOneChild());\n+        replaceVarWithAssignment(n, parent, gramps);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        if (v.isCatch()) {\n            // Use the name of the var before it was made unique.\n            String originalName = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n            compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, originalName));\n        }\n    } else if (v != null && parent.getType() == Token.FUNCTION) {\n        if (v.getParentNode().getType() == Token.VAR) {\n            s.undeclare(v);\n            s.declare(name, n, n.getJSType(), v.input);\n            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n        }\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -20,9 +20,11 @@\n         // approximation for most uses.\n         // TODO(johnlenz): Consider improving how scope handles catch\n         // expression.\n-        // Use the name of the var before it was made unique.\n-        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n-        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n+        if (v.isCatch()) {\n+            // Use the name of the var before it was made unique.\n+            String originalName = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+            compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, originalName));\n+        }\n     } else if (v != null && parent.getType() == Token.FUNCTION) {\n         if (v.getParentNode().getType() == Token.VAR) {\n             s.undeclare(v);\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,37 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        if (v.isCatch()) {\n+            // Use the name of the var before it was made unique.\n+            String originalName = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+            compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, originalName));\n         }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n+    } else if (v != null && parent.getType() == Token.FUNCTION) {\n+        if (v.getParentNode().getType() == Token.VAR) {\n+            s.undeclare(v);\n+            s.declare(name, n, n.getJSType(), v.input);\n+            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n         }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    } else if (parent.getType() == Token.VAR) {\n+        Preconditions.checkState(parent.hasOneChild());\n+        replaceVarWithAssignment(n, parent, gramps);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION) {\n        if (v.getParentNode().getType() == Token.VAR) {\n            // Fixed\n            if (v.isParam()) {\n                // If the variable is a function parameter, it should not be redefined as a var\n                compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, REDECLARED_PARAM, name));\n            } else {\n                s.undeclare(v);\n                s.declare(name, n, n.getJSType(), v.input);\n                replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n            }\n        }\n        // Fixed\n        else if (v.getParentNode().getType() == Token.PARAM_LIST) {\n            // If the variable is a function parameter, it should not be redefined as a var\n            compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, REDECLARED_PARAM, name));\n        }\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -25,9 +25,20 @@\n         compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n     } else if (v != null && parent.getType() == Token.FUNCTION) {\n         if (v.getParentNode().getType() == Token.VAR) {\n-            s.undeclare(v);\n-            s.declare(name, n, n.getJSType(), v.input);\n-            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n+            // Fixed\n+            if (v.isParam()) {\n+                // If the variable is a function parameter, it should not be redefined as a var\n+                compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, REDECLARED_PARAM, name));\n+            } else {\n+                s.undeclare(v);\n+                s.declare(name, n, n.getJSType(), v.input);\n+                replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n+            }\n+        }\n+        // Fixed\n+        else if (v.getParentNode().getType() == Token.PARAM_LIST) {\n+            // If the variable is a function parameter, it should not be redefined as a var\n+            compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, REDECLARED_PARAM, name));\n         }\n     } else if (parent.getType() == Token.VAR) {\n         Preconditions.checkState(parent.hasOneChild());\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,46 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && parent.getType() == Token.FUNCTION) {\n+        if (v.getParentNode().getType() == Token.VAR) {\n+            // Fixed\n+            if (v.isParam()) {\n+                // If the variable is a function parameter, it should not be redefined as a var\n+                compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, REDECLARED_PARAM, name));\n+            } else {\n+                s.undeclare(v);\n+                s.declare(name, n, n.getJSType(), v.input);\n+                replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n+            }\n         }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n+        // Fixed\n+        else if (v.getParentNode().getType() == Token.PARAM_LIST) {\n+            // If the variable is a function parameter, it should not be redefined as a var\n+            compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, REDECLARED_PARAM, name));\n         }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    } else if (parent.getType() == Token.VAR) {\n+        Preconditions.checkState(parent.hasOneChild());\n+        replaceVarWithAssignment(n, parent, gramps);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode() != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION) {\n        if (v.getParentNode() != null && v.getParentNode().getType() == Token.VAR) {\n            s.undeclare(v);\n            s.declare(name, n, n.getJSType(), v.input);\n            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n        }\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -7,7 +7,7 @@\n     // This deals with issues where a browser built-in is declared\n     // in one browser but not in another.\n     // If name is \"arguments\", Var maybe null.\n-    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+    if (v != null && v.getParentNode() != null && v.getParentNode().getType() == Token.CATCH) {\n         // Redeclaration of a catch expression variable is hard to model\n         // without support for \"with\" expressions.\n         // The EcmaScript spec (section 12.14), declares that a catch\n@@ -24,7 +24,7 @@\n         name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n         compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n     } else if (v != null && parent.getType() == Token.FUNCTION) {\n-        if (v.getParentNode().getType() == Token.VAR) {\n+        if (v.getParentNode() != null && v.getParentNode().getType() == Token.VAR) {\n             s.undeclare(v);\n             s.declare(name, n, n.getJSType(), v.input);\n             replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,35 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.getParentNode() != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && parent.getType() == Token.FUNCTION) {\n+        if (v.getParentNode() != null && v.getParentNode().getType() == Token.VAR) {\n+            s.undeclare(v);\n+            s.declare(name, n, n.getJSType(), v.input);\n+            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n         }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    } else if (parent.getType() == Token.VAR) {\n+        Preconditions.checkState(parent.hasOneChild());\n+        replaceVarWithAssignment(n, parent, gramps);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION && v.getNameNode().getParent().getType() == Token.NAME) {\n        if (v.getParentNode().getType() == Token.VAR) {\n            s.undeclare(v);\n            s.declare(name, n, n.getJSType(), v.input);\n            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n        }\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -23,7 +23,7 @@\n         // Use the name of the var before it was made unique.\n         name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n         compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n-    } else if (v != null && parent.getType() == Token.FUNCTION) {\n+    } else if (v != null && parent.getType() == Token.FUNCTION && v.getNameNode().getParent().getType() == Token.NAME) {\n         if (v.getParentNode().getType() == Token.VAR) {\n             s.undeclare(v);\n             s.declare(name, n, n.getJSType(), v.input);\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,35 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && parent.getType() == Token.FUNCTION && v.getNameNode().getParent().getType() == Token.NAME) {\n+        if (v.getParentNode().getType() == Token.VAR) {\n+            s.undeclare(v);\n+            s.declare(name, n, n.getJSType(), v.input);\n+            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n         }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    } else if (parent.getType() == Token.VAR) {\n+        Preconditions.checkState(parent.hasOneChild());\n+        replaceVarWithAssignment(n, parent, gramps);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOriginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION && v.isDeclaredOrInferred()) {\n        if (v.getParentNode().getType() == Token.VAR) {\n            s.undeclare(v);\n            s.declare(name, n, n.getJSType(), v.input);\n            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n        } else if (v.getParentNode().getType() == Token.PARAM_LIST || v.getParentNode().getType() == Token.NAME) {\n            // Don't allow unsafe renames of formal parameters. See\n            // https://github.com/google/closure-compiler/issues/2873 for\n            // context. Simple workaround to keep renaming logic from being\n            // applied.\n            return;\n        }\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -21,13 +21,19 @@\n         // TODO(johnlenz): Consider improving how scope handles catch\n         // expression.\n         // Use the name of the var before it was made unique.\n-        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOriginalName(name);\n         compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n-    } else if (v != null && parent.getType() == Token.FUNCTION) {\n+    } else if (v != null && parent.getType() == Token.FUNCTION && v.isDeclaredOrInferred()) {\n         if (v.getParentNode().getType() == Token.VAR) {\n             s.undeclare(v);\n             s.declare(name, n, n.getJSType(), v.input);\n             replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n+        } else if (v.getParentNode().getType() == Token.PARAM_LIST || v.getParentNode().getType() == Token.NAME) {\n+            // Don't allow unsafe renames of formal parameters. See\n+            // https://github.com/google/closure-compiler/issues/2873 for\n+            // context. Simple workaround to keep renaming logic from being\n+            // applied.\n+            return;\n         }\n     } else if (parent.getType() == Token.VAR) {\n         Preconditions.checkState(parent.hasOneChild());\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,41 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOriginalName(name);\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && parent.getType() == Token.FUNCTION && v.isDeclaredOrInferred()) {\n+        if (v.getParentNode().getType() == Token.VAR) {\n+            s.undeclare(v);\n+            s.declare(name, n, n.getJSType(), v.input);\n+            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n+        } else if (v.getParentNode().getType() == Token.PARAM_LIST || v.getParentNode().getType() == Token.NAME) {\n+            // Don't allow unsafe renames of formal parameters. See\n+            // https://github.com/google/closure-compiler/issues/2873 for\n+            // context. Simple workaround to keep renaming logic from being\n+            // applied.\n             return;\n         }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    } else if (parent.getType() == Token.VAR) {\n+        Preconditions.checkState(parent.hasOneChild());\n+        replaceVarWithAssignment(n, parent, gramps);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOriginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && (parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST)) {\n        s.undeclare(v);\n        s.declare(name, n, n.getJSType(), v.input);\n        replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n    } else if (parent.getType() == Token.FUNCTION) {\n        Preconditions.checkState(parent.getFirstChild() == n && parent.getLastChild() == n, \"Invalid QName node found in FUNCTION node\");\n        replaceVarWithAssignment(n, parent, gramps);\n    } else {\n        throw new IllegalStateException(\"Unexpected parent: \" + parent);\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -21,16 +21,16 @@\n         // TODO(johnlenz): Consider improving how scope handles catch\n         // expression.\n         // Use the name of the var before it was made unique.\n-        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOriginalName(name);\n         compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n-    } else if (v != null && parent.getType() == Token.FUNCTION) {\n-        if (v.getParentNode().getType() == Token.VAR) {\n-            s.undeclare(v);\n-            s.declare(name, n, n.getJSType(), v.input);\n-            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n-        }\n-    } else if (parent.getType() == Token.VAR) {\n-        Preconditions.checkState(parent.hasOneChild());\n+    } else if (v != null && (parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST)) {\n+        s.undeclare(v);\n+        s.declare(name, n, n.getJSType(), v.input);\n+        replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n+    } else if (parent.getType() == Token.FUNCTION) {\n+        Preconditions.checkState(parent.getFirstChild() == n && parent.getLastChild() == n, \"Invalid QName node found in FUNCTION node\");\n         replaceVarWithAssignment(n, parent, gramps);\n+    } else {\n+        throw new IllegalStateException(\"Unexpected parent: \" + parent);\n     }\n }\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,35 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n-        }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOriginalName(name);\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && (parent.getType() == Token.VAR || parent.getType() == Token.LET || parent.getType() == Token.CONST)) {\n+        s.undeclare(v);\n+        s.declare(name, n, n.getJSType(), v.input);\n+        replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n+    } else if (parent.getType() == Token.FUNCTION) {\n+        Preconditions.checkState(parent.getFirstChild() == n && parent.getLastChild() == n, \"Invalid QName node found in FUNCTION node\");\n+        replaceVarWithAssignment(n, parent, gramps);\n+    } else {\n+        throw new IllegalStateException(\"Unexpected parent: \" + parent);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION && v.getParentNode().getType() == Token.VAR) {\n        // Changing this if-else-if block to a nested if block to remove the precondition\n        s.undeclare(v);\n        s.declare(name, n, n.getJSType(), v.input);\n        replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -23,12 +23,11 @@\n         // Use the name of the var before it was made unique.\n         name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n         compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n-    } else if (v != null && parent.getType() == Token.FUNCTION) {\n-        if (v.getParentNode().getType() == Token.VAR) {\n-            s.undeclare(v);\n-            s.declare(name, n, n.getJSType(), v.input);\n-            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n-        }\n+    } else if (v != null && parent.getType() == Token.FUNCTION && v.getParentNode().getType() == Token.VAR) {\n+        // Changing this if-else-if block to a nested if block to remove the precondition\n+        s.undeclare(v);\n+        s.declare(name, n, n.getJSType(), v.input);\n+        replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n     } else if (parent.getType() == Token.VAR) {\n         Preconditions.checkState(parent.hasOneChild());\n         replaceVarWithAssignment(n, parent, gramps);\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,34 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n-        }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && parent.getType() == Token.FUNCTION && v.getParentNode().getType() == Token.VAR) {\n+        // Changing this if-else-if block to a nested if block to remove the precondition\n+        s.undeclare(v);\n+        s.declare(name, n, n.getJSType(), v.input);\n+        replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n+    } else if (parent.getType() == Token.VAR) {\n+        Preconditions.checkState(parent.hasOneChild());\n+        replaceVarWithAssignment(n, parent, gramps);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" refers to the scope variable, but any following\n        // reference refers to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION) {\n        if (v.getParentNode().getType() == Token.VAR && v.getNameNode().getIntProp(Node.IS_NAMESPACE) == 0) {\n            // A var-declared variable of the same name takes precedence over a function-declared variable.\n            // This matches the order in which these are declared in the code.\n            s.undeclare(v);\n            s.declare(name, n, n.getJSType(), v.input);\n            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n        }\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -12,8 +12,8 @@\n         // without support for \"with\" expressions.\n         // The EcmaScript spec (section 12.14), declares that a catch\n         // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n-        // \"var e\" would refer to the scope variable, but any following\n-        // reference would still refer to \"e\" of the catch expression.\n+        // \"var e\" refers to the scope variable, but any following\n+        // reference refers to \"e\" of the catch expression.\n         // Until we have support for this disallow it.\n         // Currently the Scope object adds the catch expression to the\n         // function scope, which is technically not true but a good\n@@ -24,7 +24,9 @@\n         name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n         compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n     } else if (v != null && parent.getType() == Token.FUNCTION) {\n-        if (v.getParentNode().getType() == Token.VAR) {\n+        if (v.getParentNode().getType() == Token.VAR && v.getNameNode().getIntProp(Node.IS_NAMESPACE) == 0) {\n+            // A var-declared variable of the same name takes precedence over a function-declared variable.\n+            // This matches the order in which these are declared in the code.\n             s.undeclare(v);\n             s.declare(name, n, n.getJSType(), v.input);\n             replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,37 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" refers to the scope variable, but any following\n+        // reference refers to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && parent.getType() == Token.FUNCTION) {\n+        if (v.getParentNode().getType() == Token.VAR && v.getNameNode().getIntProp(Node.IS_NAMESPACE) == 0) {\n+            // A var-declared variable of the same name takes precedence over a function-declared variable.\n+            // This matches the order in which these are declared in the code.\n+            s.undeclare(v);\n+            s.declare(name, n, n.getJSType(), v.input);\n+            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n         }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    } else if (parent.getType() == Token.VAR) {\n+        Preconditions.checkState(parent.hasOneChild());\n+        replaceVarWithAssignment(n, parent, gramps);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Var v = s.getVar(name);\n    // We allow variables to be duplicate declared if one\n    // declaration appears in source and the other in externs.\n    // This deals with issues where a browser built-in is declared\n    // in one browser but not in another.\n    // If name is \"arguments\", Var maybe null.\n    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n    } else if (v != null && parent.getType() == Token.FUNCTION) {\n        if (v.getParentNode().getType() == Token.VAR) {\n            s.undeclare(v);\n            s.declare(name, n, n.getJSType(), v.input);\n            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n        }\n    } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(n.hasChildren() && n.getFirstChild().getNext() == null);\n        replaceVarWithAssignment(n, parent, gramps);\n    }\n}", "diff": "--- com/google/javascript/jscomp/Normalize.java@onRedeclaration\n+++ com/google/javascript/jscomp/Normalize.java@onRedeclaration\n@@ -30,7 +30,7 @@\n             replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n         }\n     } else if (parent.getType() == Token.VAR) {\n-        Preconditions.checkState(parent.hasOneChild());\n+        Preconditions.checkState(n.hasChildren() && n.getFirstChild().getNext() == null);\n         replaceVarWithAssignment(n, parent, gramps);\n     }\n }\n--- com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n+++ com/google/javascript/jscomp/SyntacticScopeCreator.java@onRedeclaration3\n@@ -1,24 +1,35 @@\n public void onRedeclaration(Scope s, String name, Node n, Node parent, Node gramps, Node nodeWithLineNumber) {\n-    // Don't allow multiple variables to be declared at the top level scope\n-    if (scope.isGlobal()) {\n-        Scope.Var origVar = scope.getVar(name);\n-        Node origParent = origVar.getParentNode();\n-        if (origParent.getType() == Token.CATCH && parent.getType() == Token.CATCH) {\n-            // Okay, both are 'catch(x)' variables.\n-            return;\n+    Preconditions.checkState(n.getType() == Token.NAME);\n+    Var v = s.getVar(name);\n+    // We allow variables to be duplicate declared if one\n+    // declaration appears in source and the other in externs.\n+    // This deals with issues where a browser built-in is declared\n+    // in one browser but not in another.\n+    // If name is \"arguments\", Var maybe null.\n+    if (v != null && v.getParentNode().getType() == Token.CATCH) {\n+        // Redeclaration of a catch expression variable is hard to model\n+        // without support for \"with\" expressions.\n+        // The EcmaScript spec (section 12.14), declares that a catch\n+        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n+        // \"var e\" would refer to the scope variable, but any following\n+        // reference would still refer to \"e\" of the catch expression.\n+        // Until we have support for this disallow it.\n+        // Currently the Scope object adds the catch expression to the\n+        // function scope, which is technically not true but a good\n+        // approximation for most uses.\n+        // TODO(johnlenz): Consider improving how scope handles catch\n+        // expression.\n+        // Use the name of the var before it was made unique.\n+        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(name);\n+        compiler.report(JSError.make(NodeUtil.getSourceName(nodeWithLineNumber), nodeWithLineNumber, CATCH_BLOCK_VAR_ERROR, name));\n+    } else if (v != null && parent.getType() == Token.FUNCTION) {\n+        if (v.getParentNode().getType() == Token.VAR) {\n+            s.undeclare(v);\n+            s.declare(name, n, n.getJSType(), v.input);\n+            replaceVarWithAssignment(v.getNameNode(), v.getParentNode(), v.getParentNode().getParent());\n         }\n-        boolean allowDupe = false;\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info == null) {\n-            info = parent.getJSDocInfo();\n-        }\n-        allowDupe = info != null && info.getSuppressions().contains(\"duplicate\");\n-        if (!allowDupe) {\n-            compiler.report(JSError.make(sourceName, n, VAR_MULTIPLY_DECLARED_ERROR, name, (origVar.input != null ? origVar.input.getName() : \"??\")));\n-        }\n-    } else if (name.equals(ARGUMENTS) && !NodeUtil.isVarDeclaration(n)) {\n-        // Disallow shadowing \"arguments\" as we can't handle with our current\n-        // scope modeling.\n-        compiler.report(JSError.make(sourceName, n, VAR_ARGUMENTS_SHADOWED_ERROR));\n+    } else if (parent.getType() == Token.VAR) {\n+        Preconditions.checkState(n.hasChildren() && n.getFirstChild().getNext() == null);\n+        replaceVarWithAssignment(n, parent, gramps);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]