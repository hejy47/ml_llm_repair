[{"output": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    try {\n        in.mark(signature.length);\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry() != null && tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, encoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -6,8 +6,8 @@\n         throw new IllegalArgumentException(\"Mark is not supported.\");\n     }\n     final byte[] signature = new byte[12];\n-    in.mark(signature.length);\n     try {\n+        in.mark(signature.length);\n         int signatureLength = IOUtils.readFully(in, signature);\n         in.reset();\n         if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n@@ -57,7 +57,7 @@\n             try {\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n-                if (tais.getNextTarEntry().isCheckSumOK()) {\n+                if (tais.getNextTarEntry() != null && tais.getNextTarEntry().isCheckSumOK()) {\n                     return new TarArchiveInputStream(in, encoding);\n                 }\n             } catch (Exception e) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        } else if (DumpArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new DumpArchiveInputStream(in, entryEncoding);\n            } else {\n                return new DumpArchiveInputStream(in);\n            }\n        } else if (TarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new TarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new TarArchiveInputStream(in);\n            }\n        } else {\n            // COMPRESS-117 - improve auto-recognition\n            if (signatureLength >= 512) {\n                final byte[] tarheader = new byte[512];\n                in.reset();\n                if (IOUtils.readFully(in, tarheader) == tarheader.length) {\n                    TarArchiveInputStream tais = null;\n                    try {\n                        tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                        // COMPRESS-191 - verify the header checksum\n                        if (tais.getNextTarEntry().isCheckSumOK()) {\n                            if (entryEncoding != null) {\n                                return new TarArchiveInputStream(in, encoding);\n                            } else {\n                                return new TarArchiveInputStream(in);\n                            }\n                        }\n                    } catch (Exception e) {\n                        // NOPMD\n                        // can generate IllegalArgumentException as well\n                        // as IOException\n                        // autodetection, simply not a TAR\n                        // ignored\n                    } finally {\n                        IOUtils.closeQuietly(tais);\n                    }\n                }\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -34,40 +34,45 @@\n             return new ArjArchiveInputStream(in);\n         } else if (SevenZFile.matches(signature, signatureLength)) {\n             throw new StreamingNotSupportedException(SEVEN_Z);\n-        }\n-        // Dump needs a bigger buffer to check the signature;\n-        final byte[] dumpsig = new byte[32];\n-        in.mark(dumpsig.length);\n-        signatureLength = IOUtils.readFully(in, dumpsig);\n-        in.reset();\n-        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n-            return new DumpArchiveInputStream(in, entryEncoding);\n-        }\n-        // Tar needs an even bigger buffer to check the signature; read the first block\n-        final byte[] tarheader = new byte[512];\n-        in.mark(tarheader.length);\n-        signatureLength = IOUtils.readFully(in, tarheader);\n-        in.reset();\n-        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n-            return new TarArchiveInputStream(in, entryEncoding);\n-        }\n-        // COMPRESS-117 - improve auto-recognition\n-        if (signatureLength >= 512) {\n-            TarArchiveInputStream tais = null;\n-            try {\n-                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n-                // COMPRESS-191 - verify the header checksum\n-                if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+        } else if (DumpArchiveInputStream.matches(signature, signatureLength)) {\n+            if (entryEncoding != null) {\n+                return new DumpArchiveInputStream(in, entryEncoding);\n+            } else {\n+                return new DumpArchiveInputStream(in);\n+            }\n+        } else if (TarArchiveInputStream.matches(signature, signatureLength)) {\n+            if (entryEncoding != null) {\n+                return new TarArchiveInputStream(in, entryEncoding);\n+            } else {\n+                return new TarArchiveInputStream(in);\n+            }\n+        } else {\n+            // COMPRESS-117 - improve auto-recognition\n+            if (signatureLength >= 512) {\n+                final byte[] tarheader = new byte[512];\n+                in.reset();\n+                if (IOUtils.readFully(in, tarheader) == tarheader.length) {\n+                    TarArchiveInputStream tais = null;\n+                    try {\n+                        tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n+                        // COMPRESS-191 - verify the header checksum\n+                        if (tais.getNextTarEntry().isCheckSumOK()) {\n+                            if (entryEncoding != null) {\n+                                return new TarArchiveInputStream(in, encoding);\n+                            } else {\n+                                return new TarArchiveInputStream(in);\n+                            }\n+                        }\n+                    } catch (Exception e) {\n+                        // NOPMD\n+                        // can generate IllegalArgumentException as well\n+                        // as IOException\n+                        // autodetection, simply not a TAR\n+                        // ignored\n+                    } finally {\n+                        IOUtils.closeQuietly(tais);\n+                    }\n                 }\n-            } catch (Exception e) {\n-                // NOPMD\n-                // can generate IllegalArgumentException as well\n-                // as IOException\n-                // autodetection, simply not a TAR\n-                // ignored\n-            } finally {\n-                IOUtils.closeQuietly(tais);\n             }\n         }\n     } catch (IOException e) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarHeader().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, encoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -57,7 +57,7 @@\n             try {\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n-                if (tais.getNextTarEntry().isCheckSumOK()) {\n+                if (tais.getNextTarHeader().isCheckSumOK()) {\n                     return new TarArchiveInputStream(in, encoding);\n                 }\n             } catch (Exception e) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        } else {\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[32];\n            in.reset(); // reset to read another signature\n            signatureLength = IOUtils.readFully(in, dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in, entryEncoding);\n            } else {\n                // Tar needs an even bigger buffer to check the signature; read the first block\n                final byte[] tarheader = new byte[512];\n                in.reset(); // reset again to read another signature\n                signatureLength = IOUtils.readFully(in, tarheader);\n                in.reset();\n                if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                    return new TarArchiveInputStream(in, entryEncoding);\n                } else {\n                    // COMPRESS-117 - improve auto-recognition\n                    if (signatureLength >= 512) {\n                        TarArchiveInputStream tais = null;\n                        try {\n                            tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                            // COMPRESS-191 - verify the header checksum\n                            if (tais.getNextTarEntry().isCheckSumOK()) {\n                                return new TarArchiveInputStream(in, encoding);\n                            }\n                        } catch (Exception e) {\n                            // NOPMD\n                            // can generate IllegalArgumentException as well\n                            // as IOException\n                            // autodetection, simply not a TAR\n                            // ignored\n                        } finally {\n                            IOUtils.closeQuietly(tais);\n                        }\n                    }\n                }\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -34,40 +34,43 @@\n             return new ArjArchiveInputStream(in);\n         } else if (SevenZFile.matches(signature, signatureLength)) {\n             throw new StreamingNotSupportedException(SEVEN_Z);\n-        }\n-        // Dump needs a bigger buffer to check the signature;\n-        final byte[] dumpsig = new byte[32];\n-        in.mark(dumpsig.length);\n-        signatureLength = IOUtils.readFully(in, dumpsig);\n-        in.reset();\n-        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n-            return new DumpArchiveInputStream(in, entryEncoding);\n-        }\n-        // Tar needs an even bigger buffer to check the signature; read the first block\n-        final byte[] tarheader = new byte[512];\n-        in.mark(tarheader.length);\n-        signatureLength = IOUtils.readFully(in, tarheader);\n-        in.reset();\n-        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n-            return new TarArchiveInputStream(in, entryEncoding);\n-        }\n-        // COMPRESS-117 - improve auto-recognition\n-        if (signatureLength >= 512) {\n-            TarArchiveInputStream tais = null;\n-            try {\n-                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n-                // COMPRESS-191 - verify the header checksum\n-                if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+        } else {\n+            // Dump needs a bigger buffer to check the signature;\n+            final byte[] dumpsig = new byte[32];\n+            in.reset(); // reset to read another signature\n+            signatureLength = IOUtils.readFully(in, dumpsig);\n+            in.reset();\n+            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n+                return new DumpArchiveInputStream(in, entryEncoding);\n+            } else {\n+                // Tar needs an even bigger buffer to check the signature; read the first block\n+                final byte[] tarheader = new byte[512];\n+                in.reset(); // reset again to read another signature\n+                signatureLength = IOUtils.readFully(in, tarheader);\n+                in.reset();\n+                if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n+                    return new TarArchiveInputStream(in, entryEncoding);\n+                } else {\n+                    // COMPRESS-117 - improve auto-recognition\n+                    if (signatureLength >= 512) {\n+                        TarArchiveInputStream tais = null;\n+                        try {\n+                            tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n+                            // COMPRESS-191 - verify the header checksum\n+                            if (tais.getNextTarEntry().isCheckSumOK()) {\n+                                return new TarArchiveInputStream(in, encoding);\n+                            }\n+                        } catch (Exception e) {\n+                            // NOPMD\n+                            // can generate IllegalArgumentException as well\n+                            // as IOException\n+                            // autodetection, simply not a TAR\n+                            // ignored\n+                        } finally {\n+                            IOUtils.closeQuietly(tais);\n+                        }\n+                    }\n                 }\n-            } catch (Exception e) {\n-                // NOPMD\n-                // can generate IllegalArgumentException as well\n-                // as IOException\n-                // autodetection, simply not a TAR\n-                // ignored\n-            } finally {\n-                IOUtils.closeQuietly(tais);\n             }\n         }\n     } catch (IOException e) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.reset(); // reset the stream to read the signature again\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.reset(); // reset the stream to read the signature again\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, encoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -37,6 +37,7 @@\n         }\n         // Dump needs a bigger buffer to check the signature;\n         final byte[] dumpsig = new byte[32];\n+        in.reset(); // reset the stream to read the signature again\n         in.mark(dumpsig.length);\n         signatureLength = IOUtils.readFully(in, dumpsig);\n         in.reset();\n@@ -45,6 +46,7 @@\n         }\n         // Tar needs an even bigger buffer to check the signature; read the first block\n         final byte[] tarheader = new byte[512];\n+        in.reset(); // reset the stream to read the signature again\n         in.mark(tarheader.length);\n         signatureLength = IOUtils.readFully(in, tarheader);\n         in.reset();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry() != null && tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, encoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -57,7 +57,7 @@\n             try {\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n-                if (tais.getNextTarEntry().isCheckSumOK()) {\n+                if (tais.getNextTarEntry() != null && tais.getNextTarEntry().isCheckSumOK()) {\n                     return new TarArchiveInputStream(in, encoding);\n                 }\n             } catch (Exception e) {\n", "finish_reason": "stop", "valid": false, "num": 4}, {"output": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.reset();\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.reset();\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, encoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -37,7 +37,7 @@\n         }\n         // Dump needs a bigger buffer to check the signature;\n         final byte[] dumpsig = new byte[32];\n-        in.mark(dumpsig.length);\n+        in.reset();\n         signatureLength = IOUtils.readFully(in, dumpsig);\n         in.reset();\n         if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n@@ -45,7 +45,7 @@\n         }\n         // Tar needs an even bigger buffer to check the signature; read the first block\n         final byte[] tarheader = new byte[512];\n-        in.mark(tarheader.length);\n+        in.reset();\n         signatureLength = IOUtils.readFully(in, tarheader);\n         in.reset();\n         if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        } else {\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[32];\n            in.reset();\n            in.mark(dumpsig.length);\n            signatureLength = IOUtils.readFully(in, dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in, entryEncoding);\n            } else {\n                // Tar needs an even bigger buffer to check the signature; read the first block\n                final byte[] tarheader = new byte[512];\n                in.reset();\n                in.mark(tarheader.length);\n                signatureLength = IOUtils.readFully(in, tarheader);\n                in.reset();\n                if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                    return new TarArchiveInputStream(in, entryEncoding);\n                } else {\n                    // COMPRESS-117 - improve auto-recognition\n                    if (signatureLength >= 512) {\n                        TarArchiveInputStream tais = null;\n                        try {\n                            tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                            // COMPRESS-191 - verify the header checksum\n                            if (tais.getNextTarEntry().isCheckSumOK()) {\n                                return new TarArchiveInputStream(in, encoding);\n                            }\n                        } catch (Exception e) {\n                            // NOPMD\n                            // can generate IllegalArgumentException as well\n                            // as IOException\n                            // autodetection, simply not a TAR\n                            // ignored\n                        } finally {\n                            IOUtils.closeQuietly(tais);\n                        }\n                    }\n                }\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -34,40 +34,45 @@\n             return new ArjArchiveInputStream(in);\n         } else if (SevenZFile.matches(signature, signatureLength)) {\n             throw new StreamingNotSupportedException(SEVEN_Z);\n-        }\n-        // Dump needs a bigger buffer to check the signature;\n-        final byte[] dumpsig = new byte[32];\n-        in.mark(dumpsig.length);\n-        signatureLength = IOUtils.readFully(in, dumpsig);\n-        in.reset();\n-        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n-            return new DumpArchiveInputStream(in, entryEncoding);\n-        }\n-        // Tar needs an even bigger buffer to check the signature; read the first block\n-        final byte[] tarheader = new byte[512];\n-        in.mark(tarheader.length);\n-        signatureLength = IOUtils.readFully(in, tarheader);\n-        in.reset();\n-        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n-            return new TarArchiveInputStream(in, entryEncoding);\n-        }\n-        // COMPRESS-117 - improve auto-recognition\n-        if (signatureLength >= 512) {\n-            TarArchiveInputStream tais = null;\n-            try {\n-                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n-                // COMPRESS-191 - verify the header checksum\n-                if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+        } else {\n+            // Dump needs a bigger buffer to check the signature;\n+            final byte[] dumpsig = new byte[32];\n+            in.reset();\n+            in.mark(dumpsig.length);\n+            signatureLength = IOUtils.readFully(in, dumpsig);\n+            in.reset();\n+            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n+                return new DumpArchiveInputStream(in, entryEncoding);\n+            } else {\n+                // Tar needs an even bigger buffer to check the signature; read the first block\n+                final byte[] tarheader = new byte[512];\n+                in.reset();\n+                in.mark(tarheader.length);\n+                signatureLength = IOUtils.readFully(in, tarheader);\n+                in.reset();\n+                if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n+                    return new TarArchiveInputStream(in, entryEncoding);\n+                } else {\n+                    // COMPRESS-117 - improve auto-recognition\n+                    if (signatureLength >= 512) {\n+                        TarArchiveInputStream tais = null;\n+                        try {\n+                            tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n+                            // COMPRESS-191 - verify the header checksum\n+                            if (tais.getNextTarEntry().isCheckSumOK()) {\n+                                return new TarArchiveInputStream(in, encoding);\n+                            }\n+                        } catch (Exception e) {\n+                            // NOPMD\n+                            // can generate IllegalArgumentException as well\n+                            // as IOException\n+                            // autodetection, simply not a TAR\n+                            // ignored\n+                        } finally {\n+                            IOUtils.closeQuietly(tais);\n+                        }\n+                    }\n                 }\n-            } catch (Exception e) {\n-                // NOPMD\n-                // can generate IllegalArgumentException as well\n-                // as IOException\n-                // autodetection, simply not a TAR\n-                // ignored\n-            } finally {\n-                IOUtils.closeQuietly(tais);\n             }\n         }\n     } catch (IOException e) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader), encoding);\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, encoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -55,7 +55,7 @@\n         if (signatureLength >= 512) {\n             TarArchiveInputStream tais = null;\n             try {\n-                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n+                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader), encoding);\n                 // COMPRESS-191 - verify the header checksum\n                 if (tais.getNextTarEntry().isCheckSumOK()) {\n                     return new TarArchiveInputStream(in, encoding);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset(); // reset to the original position of input stream \n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset(); // reset to the original position of input stream\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, encoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -39,7 +39,7 @@\n         final byte[] dumpsig = new byte[32];\n         in.mark(dumpsig.length);\n         signatureLength = IOUtils.readFully(in, dumpsig);\n-        in.reset();\n+        in.reset(); // reset to the original position of input stream \n         if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n             return new DumpArchiveInputStream(in, entryEncoding);\n         }\n@@ -47,7 +47,7 @@\n         final byte[] tarheader = new byte[512];\n         in.mark(tarheader.length);\n         signatureLength = IOUtils.readFully(in, tarheader);\n-        in.reset();\n+        in.reset(); // reset to the original position of input stream\n         if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n             return new TarArchiveInputStream(in, entryEncoding);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    if (entryEncoding != null) {\n                        return new TarArchiveInputStream(in, entryEncoding);\n                    } else {\n                        return new TarArchiveInputStream(in);\n                    }\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -58,7 +58,11 @@\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n                 if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+                    if (entryEncoding != null) {\n+                        return new TarArchiveInputStream(in, entryEncoding);\n+                    } else {\n+                        return new TarArchiveInputStream(in);\n+                    }\n                 }\n             } catch (Exception e) {\n                 // NOPMD\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n\n    /* Fix: Remove the check for markSupported and mark the stream unconditionally */\n    in.mark(Integer.MAX_VALUE);\n\n    final byte[] signature = new byte[12];\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, encoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -2,11 +2,11 @@\n     if (in == null) {\n         throw new IllegalArgumentException(\"Stream must not be null.\");\n     }\n-    if (!in.markSupported()) {\n-        throw new IllegalArgumentException(\"Mark is not supported.\");\n-    }\n+\n+    /* Fix: Remove the check for markSupported and mark the stream unconditionally */\n+    in.mark(Integer.MAX_VALUE);\n+\n     final byte[] signature = new byte[12];\n-    in.mark(signature.length);\n     try {\n         int signatureLength = IOUtils.readFully(in, signature);\n         in.reset();\n@@ -37,7 +37,6 @@\n         }\n         // Dump needs a bigger buffer to check the signature;\n         final byte[] dumpsig = new byte[32];\n-        in.mark(dumpsig.length);\n         signatureLength = IOUtils.readFully(in, dumpsig);\n         in.reset();\n         if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n@@ -45,7 +44,6 @@\n         }\n         // Tar needs an even bigger buffer to check the signature; read the first block\n         final byte[] tarheader = new byte[512];\n-        in.mark(tarheader.length);\n         signatureLength = IOUtils.readFully(in, tarheader);\n         in.reset();\n         if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry() != null && tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, entryEncoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -57,8 +57,8 @@\n             try {\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n-                if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+                if (tais.getNextTarEntry() != null && tais.getNextTarEntry().isCheckSumOK()) {\n+                    return new TarArchiveInputStream(in, entryEncoding);\n                 }\n             } catch (Exception e) {\n                 // NOPMD\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        } else {\n            // Fix: added an else block to handle unrecognized formats\n            throw new ArchiveException(\"Unrecognized format!\");\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, encoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -34,6 +34,9 @@\n             return new ArjArchiveInputStream(in);\n         } else if (SevenZFile.matches(signature, signatureLength)) {\n             throw new StreamingNotSupportedException(SEVEN_Z);\n+        } else {\n+            // Fix: added an else block to handle unrecognized formats\n+            throw new ArchiveException(\"Unrecognized format!\");\n         }\n         // Dump needs a bigger buffer to check the signature;\n         final byte[] dumpsig = new byte[32];\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        } else {\n            // Dump needs a bigger buffer to check the signature;\n            final byte[] dumpsig = new byte[32];\n            in.mark(dumpsig.length);\n            signatureLength = IOUtils.readFully(in, dumpsig);\n            in.reset();\n            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n                return new DumpArchiveInputStream(in, entryEncoding);\n            } else {\n                // Tar needs an even bigger buffer to check the signature; read the first block\n                final byte[] tarheader = new byte[512];\n                in.mark(tarheader.length);\n                signatureLength = IOUtils.readFully(in, tarheader);\n                in.reset();\n                if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                    return new TarArchiveInputStream(in, entryEncoding);\n                } else if (signatureLength >= 512) {\n                    // COMPRESS-117 - improve auto-recognition\n                    TarArchiveInputStream tais = null;\n                    try {\n                        tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                        // COMPRESS-191 - verify the header checksum\n                        if (tais.getNextTarHeader().isCheckSumOK()) {\n                            return new TarArchiveInputStream(in, encoding);\n                        }\n                    } catch (IOException e) {\n                        // autodetection, simply not a TAR\n                        // ignored\n                    } finally {\n                        IOUtils.closeQuietly(tais);\n                    }\n                }\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -34,40 +34,38 @@\n             return new ArjArchiveInputStream(in);\n         } else if (SevenZFile.matches(signature, signatureLength)) {\n             throw new StreamingNotSupportedException(SEVEN_Z);\n-        }\n-        // Dump needs a bigger buffer to check the signature;\n-        final byte[] dumpsig = new byte[32];\n-        in.mark(dumpsig.length);\n-        signatureLength = IOUtils.readFully(in, dumpsig);\n-        in.reset();\n-        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n-            return new DumpArchiveInputStream(in, entryEncoding);\n-        }\n-        // Tar needs an even bigger buffer to check the signature; read the first block\n-        final byte[] tarheader = new byte[512];\n-        in.mark(tarheader.length);\n-        signatureLength = IOUtils.readFully(in, tarheader);\n-        in.reset();\n-        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n-            return new TarArchiveInputStream(in, entryEncoding);\n-        }\n-        // COMPRESS-117 - improve auto-recognition\n-        if (signatureLength >= 512) {\n-            TarArchiveInputStream tais = null;\n-            try {\n-                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n-                // COMPRESS-191 - verify the header checksum\n-                if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+        } else {\n+            // Dump needs a bigger buffer to check the signature;\n+            final byte[] dumpsig = new byte[32];\n+            in.mark(dumpsig.length);\n+            signatureLength = IOUtils.readFully(in, dumpsig);\n+            in.reset();\n+            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n+                return new DumpArchiveInputStream(in, entryEncoding);\n+            } else {\n+                // Tar needs an even bigger buffer to check the signature; read the first block\n+                final byte[] tarheader = new byte[512];\n+                in.mark(tarheader.length);\n+                signatureLength = IOUtils.readFully(in, tarheader);\n+                in.reset();\n+                if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n+                    return new TarArchiveInputStream(in, entryEncoding);\n+                } else if (signatureLength >= 512) {\n+                    // COMPRESS-117 - improve auto-recognition\n+                    TarArchiveInputStream tais = null;\n+                    try {\n+                        tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n+                        // COMPRESS-191 - verify the header checksum\n+                        if (tais.getNextTarHeader().isCheckSumOK()) {\n+                            return new TarArchiveInputStream(in, encoding);\n+                        }\n+                    } catch (IOException e) {\n+                        // autodetection, simply not a TAR\n+                        // ignored\n+                    } finally {\n+                        IOUtils.closeQuietly(tais);\n+                    }\n                 }\n-            } catch (Exception e) {\n-                // NOPMD\n-                // can generate IllegalArgumentException as well\n-                // as IOException\n-                // autodetection, simply not a TAR\n-                // ignored\n-            } finally {\n-                IOUtils.closeQuietly(tais);\n             }\n         }\n     } catch (IOException e) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, encoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -57,7 +57,7 @@\n             try {\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n-                if (tais.getNextTarEntry().isCheckSumOK()) {\n+                if (tais.getNextEntry().isCheckSumOK()) {\n                     return new TarArchiveInputStream(in, encoding);\n                 }\n             } catch (Exception e) {\n", "finish_reason": "stop", "valid": false, "num": 1}]