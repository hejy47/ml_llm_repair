[{"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Use the current scope root instead of the last child\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Use the current scope root instead of the last child\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -9,16 +9,15 @@\n     }\n     // Compute the forward reaching definition.\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n+    // Use the current scope root instead of the last child\n     Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfa.process(null, t.getScopeRoot());\n     cfg = cfa.getCfg();\n     reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n     reachingDef.analyze();\n     candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    // Use the current scope root instead of the last child\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,39 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+public void enterScope(NodeTraversal t) {\n+    if (t.inGlobalScope()) {\n+        // Don't even bother. All global variables are likely escaped.\n+        return;\n     }\n-    return false;\n+    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n+        return;\n+    }\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    // Use the current scope root instead of the last child\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n+    cfa.process(null, t.getScopeRoot());\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+    // Use the current scope root instead of the last child\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot());\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+        if (c.canInline()) {\n+            c.inlineVariable();\n+            // If definition c has dependencies, then inlining it may have\n+            // introduced new dependencies for our other inlining candidates.\n+            //\n+            // MustBeReachingVariableDef uses this dependency graph in its\n+            // analysis, so some of these candidates may no longer be valid.\n+            // We keep track of when the variable dependency graph changed\n+            // so that we can back off appropriately.\n+            if (!c.defMetadata.depends.isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+            }\n+        }\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(c.defMetadata.var);\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -11,7 +11,7 @@\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n     // Process the body of the function.\n     Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfa.process(t.getScopeRoot().getLastChild());\n     cfg = cfa.getCfg();\n     reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n     reachingDef.analyze();\n@@ -33,7 +33,7 @@\n             // We keep track of when the variable dependency graph changed\n             // so that we can back off appropriately.\n             if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+                inlinedNewDependencies.add(c.defMetadata.var);\n             }\n         }\n     }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,40 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+public void enterScope(NodeTraversal t) {\n+    if (t.inGlobalScope()) {\n+        // Don't even bother. All global variables are likely escaped.\n+        return;\n     }\n-    return false;\n+    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n+        return;\n+    }\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    // Process the body of the function.\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n+    cfa.process(t.getScopeRoot().getLastChild());\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+    // Using the forward reaching definition search to find all the inline\n+    // candidates\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+        if (c.canInline()) {\n+            c.inlineVariable();\n+            // If definition c has dependencies, then inlining it may have\n+            // introduced new dependencies for our other inlining candidates.\n+            //\n+            // MustBeReachingVariableDef uses this dependency graph in its\n+            // analysis, so some of these candidates may no longer be valid.\n+            // We keep track of when the variable dependency graph changed\n+            // so that we can back off appropriately.\n+            if (!c.defMetadata.depends.isEmpty()) {\n+                inlinedNewDependencies.add(c.defMetadata.var);\n+            }\n+        }\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.dependencySet.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -32,7 +32,7 @@\n             // analysis, so some of these candidates may no longer be valid.\n             // We keep track of when the variable dependency graph changed\n             // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n+            if (!c.defMetadata.dependencySet.isEmpty()) {\n                 inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n             }\n         }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,40 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+public void enterScope(NodeTraversal t) {\n+    if (t.inGlobalScope()) {\n+        // Don't even bother. All global variables are likely escaped.\n+        return;\n     }\n-    return false;\n+    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n+        return;\n+    }\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    // Process the body of the function.\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n+    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+    // Using the forward reaching definition search to find all the inline\n+    // candidates\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+        if (c.canInline()) {\n+            c.inlineVariable();\n+            // If definition c has dependencies, then inlining it may have\n+            // introduced new dependencies for our other inlining candidates.\n+            //\n+            // MustBeReachingVariableDef uses this dependency graph in its\n+            // analysis, so some of these candidates may no longer be valid.\n+            // We keep track of when the variable dependency graph changed\n+            // so that we can back off appropriately.\n+            if (!c.defMetadata.dependencySet.isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+            }\n+        }\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.getScopeDepth() == 0) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    int varCount = t.getScope().getVarCount();\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < varCount) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates.\n    NodeTraversal.traverse(compiler, t.getScopeRoot().getLastChild(), new GatherCandiates(), t.getScope());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,10 +1,11 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+    if (t.getScopeDepth() == 0) {\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n+    int varCount = t.getScope().getVarCount();\n+    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < varCount) {\n         return;\n     }\n     // Compute the forward reaching definition.\n@@ -17,8 +18,8 @@\n     reachingDef.analyze();\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    // candidates.\n+    NodeTraversal.traverse(compiler, t.getScopeRoot().getLastChild(), new GatherCandiates(), t.getScope());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,41 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+public void enterScope(NodeTraversal t) {\n+    if (t.getScopeDepth() == 0) {\n+        // Don't even bother. All global variables are likely escaped.\n+        return;\n     }\n-    return false;\n+    int varCount = t.getScope().getVarCount();\n+    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < varCount) {\n+        return;\n+    }\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    // Process the body of the function.\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n+    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+    // Using the forward reaching definition search to find all the inline\n+    // candidates.\n+    NodeTraversal.traverse(compiler, t.getScopeRoot().getLastChild(), new GatherCandiates(), t.getScope());\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+        if (c.canInline()) {\n+            c.inlineVariable();\n+            // If definition c has dependencies, then inlining it may have\n+            // introduced new dependencies for our other inlining candidates.\n+            //\n+            // MustBeReachingVariableDef uses this dependency graph in its\n+            // analysis, so some of these candidates may no longer be valid.\n+            // We keep track of when the variable dependency graph changed\n+            // so that we can back off appropriately.\n+            if (!c.defMetadata.depends.isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+            }\n+        }\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.dependsOn.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -18,7 +18,7 @@\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n@@ -32,7 +32,7 @@\n             // analysis, so some of these candidates may no longer be valid.\n             // We keep track of when the variable dependency graph changed\n             // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n+            if (!c.defMetadata.dependsOn.isEmpty()) {\n                 inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n             }\n         }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,40 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+public void enterScope(NodeTraversal t) {\n+    if (t.inGlobalScope()) {\n+        // Don't even bother. All global variables are likely escaped.\n+        return;\n     }\n-    return false;\n+    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n+        return;\n+    }\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    // Process the body of the function.\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n+    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+    // Using the forward reaching definition search to find all the inline\n+    // candidates\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+        if (c.canInline()) {\n+            c.inlineVariable();\n+            // If definition c has dependencies, then inlining it may have\n+            // introduced new dependencies for our other inlining candidates.\n+            //\n+            // MustBeReachingVariableDef uses this dependency graph in its\n+            // analysis, so some of these candidates may no longer be valid.\n+            // We keep track of when the variable dependency graph changed\n+            // so that we can back off appropriately.\n+            if (!c.defMetadata.dependsOn.isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+            }\n+        }\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -11,14 +11,14 @@\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n     // Process the body of the function.\n     Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfa.process(null, t.getScopeRoot());\n     cfg = cfa.getCfg();\n     reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n     reachingDef.analyze();\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,40 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+public void enterScope(NodeTraversal t) {\n+    if (t.inGlobalScope()) {\n+        // Don't even bother. All global variables are likely escaped.\n+        return;\n     }\n-    return false;\n+    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n+        return;\n+    }\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    // Process the body of the function.\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n+    cfa.process(null, t.getScopeRoot());\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+    // Using the forward reaching definition search to find all the inline\n+    // candidates\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot());\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+        if (c.canInline()) {\n+            c.inlineVariable();\n+            // If definition c has dependencies, then inlining it may have\n+            // introduced new dependencies for our other inlining candidates.\n+            //\n+            // MustBeReachingVariableDef uses this dependency graph in its\n+            // analysis, so some of these candidates may no longer be valid.\n+            // We keep track of when the variable dependency graph changed\n+            // so that we can back off appropriately.\n+            if (!c.defMetadata.depends.isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+            }\n+        }\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,40 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+public void enterScope(NodeTraversal t) {\n+    if (t.inGlobalScope()) {\n+        // Don't even bother. All global variables are likely escaped.\n+        return;\n     }\n-    return false;\n+    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n+        return;\n+    }\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    // Process the body of the function.\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n+    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+    // Using the forward reaching definition search to find all the inline\n+    // candidates\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+        if (c.canInline()) {\n+            c.inlineVariable();\n+            // If definition c has dependencies, then inlining it may have\n+            // introduced new dependencies for our other inlining candidates.\n+            //\n+            // MustBeReachingVariableDef uses this dependency graph in its\n+            // analysis, so some of these candidates may no longer be valid.\n+            // We keep track of when the variable dependency graph changed\n+            // so that we can back off appropriately.\n+            if (!c.defMetadata.depends.isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+            }\n+        }\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    Node functionBody = t.getScopeRoot().getLastChild();\n    cfa.process(null, functionBody);\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(functionBody);\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,24 +1,26 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n         return;\n     }\n+\n     // Compute the forward reaching definition.\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n     // Process the body of the function.\n     Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n+    Node functionBody = t.getScopeRoot().getLastChild();\n+    cfa.process(null, functionBody);\n     cfg = cfa.getCfg();\n     reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n     reachingDef.analyze();\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(functionBody);\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,42 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+public void enterScope(NodeTraversal t) {\n+    if (t.inGlobalScope()) {\n+        // Don't even bother. All global variables are likely escaped.\n+        return;\n     }\n-    return false;\n+    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n+        return;\n+    }\n+\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    // Process the body of the function.\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n+    Node functionBody = t.getScopeRoot().getLastChild();\n+    cfa.process(null, functionBody);\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+    // Using the forward reaching definition search to find all the inline\n+    // candidates\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(functionBody);\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+        if (c.canInline()) {\n+            c.inlineVariable();\n+            // If definition c has dependencies, then inlining it may have\n+            // introduced new dependencies for our other inlining candidates.\n+            //\n+            // MustBeReachingVariableDef uses this dependency graph in its\n+            // analysis, so some of these candidates may no longer be valid.\n+            // We keep track of when the variable dependency graph changed\n+            // so that we can back off appropriately.\n+            if (!c.defMetadata.depends.isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+            }\n+        }\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.getScope().isGlobal()) {\n        // All global variables are likely escaped, so do not proceed with analysis\n        return;\n    }\n    if (t.getScope().getVarCount() > LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE) {\n        // If the number of variables in the scope is larger than the limit,\n        // skip the analysis to avoid performance issues\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,10 +1,12 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+    if (t.getScope().isGlobal()) {\n+        // All global variables are likely escaped, so do not proceed with analysis\n         return;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n+    if (t.getScope().getVarCount() > LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE) {\n+        // If the number of variables in the scope is larger than the limit,\n+        // skip the analysis to avoid performance issues\n         return;\n     }\n     // Compute the forward reaching definition.\n@@ -16,8 +18,7 @@\n     reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n     reachingDef.analyze();\n     candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n+    // Using the forward reaching definition search to find all the inline candidates\n     new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,41 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+public void enterScope(NodeTraversal t) {\n+    if (t.getScope().isGlobal()) {\n+        // All global variables are likely escaped, so do not proceed with analysis\n+        return;\n     }\n-    return false;\n+    if (t.getScope().getVarCount() > LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE) {\n+        // If the number of variables in the scope is larger than the limit,\n+        // skip the analysis to avoid performance issues\n+        return;\n+    }\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    // Process the body of the function.\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n+    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+    // Using the forward reaching definition search to find all the inline candidates\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+        if (c.canInline()) {\n+            c.inlineVariable();\n+            // If definition c has dependencies, then inlining it may have\n+            // introduced new dependencies for our other inlining candidates.\n+            //\n+            // MustBeReachingVariableDef uses this dependency graph in its\n+            // analysis, so some of these candidates may no longer be valid.\n+            // We keep track of when the variable dependency graph changed\n+            // so that we can back off appropriately.\n+            if (!c.defMetadata.depends.isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+            }\n+        }\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName), c.defMetadata.depends);\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -18,7 +18,7 @@\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n@@ -33,7 +33,7 @@\n             // We keep track of when the variable dependency graph changed\n             // so that we can back off appropriately.\n             if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+                inlinedNewDependencies.add(t.getScope().getVar(c.varName), c.defMetadata.depends);\n             }\n         }\n     }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,40 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+public void enterScope(NodeTraversal t) {\n+    if (t.inGlobalScope()) {\n+        // Don't even bother. All global variables are likely escaped.\n+        return;\n     }\n-    return false;\n+    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n+        return;\n+    }\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    // Process the body of the function.\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n+    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+    // Using the forward reaching definition search to find all the inline\n+    // candidates\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+        if (c.canInline()) {\n+            c.inlineVariable();\n+            // If definition c has dependencies, then inlining it may have\n+            // introduced new dependencies for our other inlining candidates.\n+            //\n+            // MustBeReachingVariableDef uses this dependency graph in its\n+            // analysis, so some of these candidates may no longer be valid.\n+            // We keep track of when the variable dependency graph changed\n+            // so that we can back off appropriately.\n+            if (!c.defMetadata.depends.isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.varName), c.defMetadata.depends);\n+            }\n+        }\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.getDefMetadata().getDepends().isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.getVarName()));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -18,7 +18,7 @@\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n@@ -32,8 +32,8 @@\n             // analysis, so some of these candidates may no longer be valid.\n             // We keep track of when the variable dependency graph changed\n             // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+            if (!c.getDefMetadata().getDepends().isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.getVarName()));\n             }\n         }\n     }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,40 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+public void enterScope(NodeTraversal t) {\n+    if (t.inGlobalScope()) {\n+        // Don't even bother. All global variables are likely escaped.\n+        return;\n     }\n-    return false;\n+    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n+        return;\n+    }\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    // Process the body of the function.\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n+    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+    // Using the forward reaching definition search to find all the inline\n+    // candidates\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+        if (c.canInline()) {\n+            c.inlineVariable();\n+            // If definition c has dependencies, then inlining it may have\n+            // introduced new dependencies for our other inlining candidates.\n+            //\n+            // MustBeReachingVariableDef uses this dependency graph in its\n+            // analysis, so some of these candidates may no longer be valid.\n+            // We keep track of when the variable dependency graph changed\n+            // so that we can back off appropriately.\n+            if (!c.getDefMetadata().getDepends().isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.getVarName()));\n+            }\n+        }\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.varDepends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -18,7 +18,7 @@\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n@@ -32,7 +32,7 @@\n             // analysis, so some of these candidates may no longer be valid.\n             // We keep track of when the variable dependency graph changed\n             // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n+            if (!c.varDepends.isEmpty()) {\n                 inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n             }\n         }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,40 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+public void enterScope(NodeTraversal t) {\n+    if (t.inGlobalScope()) {\n+        // Don't even bother. All global variables are likely escaped.\n+        return;\n     }\n-    return false;\n+    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n+        return;\n+    }\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    // Process the body of the function.\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n+    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+    // Using the forward reaching definition search to find all the inline\n+    // candidates\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot());\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+        if (c.canInline()) {\n+            c.inlineVariable();\n+            // If definition c has dependencies, then inlining it may have\n+            // introduced new dependencies for our other inlining candidates.\n+            //\n+            // MustBeReachingVariableDef uses this dependency graph in its\n+            // analysis, so some of these candidates may no longer be valid.\n+            // We keep track of when the variable dependency graph changed\n+            // so that we can back off appropriately.\n+            if (!c.varDepends.isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+            }\n+        }\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -11,7 +11,7 @@\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n     // Process the body of the function.\n     Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfa.process(t.getScopeRoot().getLastChild());\n     cfg = cfa.getCfg();\n     reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n     reachingDef.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,40 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+public void enterScope(NodeTraversal t) {\n+    if (t.inGlobalScope()) {\n+        // Don't even bother. All global variables are likely escaped.\n+        return;\n     }\n-    return false;\n+    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n+        return;\n+    }\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    // Process the body of the function.\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n+    cfa.process(t.getScopeRoot().getLastChild());\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+    // Using the forward reaching definition search to find all the inline\n+    // candidates\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+        if (c.canInline()) {\n+            c.inlineVariable();\n+            // If definition c has dependencies, then inlining it may have\n+            // introduced new dependencies for our other inlining candidates.\n+            //\n+            // MustBeReachingVariableDef uses this dependency graph in its\n+            // analysis, so some of these candidates may no longer be valid.\n+            // We keep track of when the variable dependency graph changed\n+            // so that we can back off appropriately.\n+            if (!c.defMetadata.depends.isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+            }\n+        }\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getCurrentNode().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -11,14 +11,14 @@\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n     // Process the body of the function.\n     Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfa.process(null, t.getScopeRoot());\n     cfg = cfa.getCfg();\n     reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n     reachingDef.analyze();\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getCurrentNode().getLastChild());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,40 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+public void enterScope(NodeTraversal t) {\n+    if (t.inGlobalScope()) {\n+        // Don't even bother. All global variables are likely escaped.\n+        return;\n     }\n-    return false;\n+    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n+        return;\n+    }\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    // Process the body of the function.\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n+    cfa.process(null, t.getScopeRoot());\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+    // Using the forward reaching definition search to find all the inline\n+    // candidates\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getCurrentNode().getLastChild());\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+        if (c.canInline()) {\n+            c.inlineVariable();\n+            // If definition c has dependencies, then inlining it may have\n+            // introduced new dependencies for our other inlining candidates.\n+            //\n+            // MustBeReachingVariableDef uses this dependency graph in its\n+            // analysis, so some of these candidates may no longer be valid.\n+            // We keep track of when the variable dependency graph changed\n+            // so that we can back off appropriately.\n+            if (!c.defMetadata.depends.isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+            }\n+        }\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -18,7 +18,7 @@\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,40 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+public void enterScope(NodeTraversal t) {\n+    if (t.inGlobalScope()) {\n+        // Don't even bother. All global variables are likely escaped.\n+        return;\n     }\n-    return false;\n+    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n+        return;\n+    }\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    // Process the body of the function.\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n+    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+    // Using the forward reaching definition search to find all the inline\n+    // candidates\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+        if (c.canInline()) {\n+            c.inlineVariable();\n+            // If definition c has dependencies, then inlining it may have\n+            // introduced new dependencies for our other inlining candidates.\n+            //\n+            // MustBeReachingVariableDef uses this dependency graph in its\n+            // analysis, so some of these candidates may no longer be valid.\n+            // We keep track of when the variable dependency graph changed\n+            // so that we can back off appropriately.\n+            if (!c.defMetadata.depends.isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+            }\n+        }\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(t.getScopeRoot());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -11,14 +11,14 @@\n     ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n     // Process the body of the function.\n     Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfa.process(t.getScopeRoot());\n     cfg = cfa.getCfg();\n     reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n     reachingDef.analyze();\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,40 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+public void enterScope(NodeTraversal t) {\n+    if (t.inGlobalScope()) {\n+        // Don't even bother. All global variables are likely escaped.\n+        return;\n     }\n-    return false;\n+    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n+        return;\n+    }\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    // Process the body of the function.\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n+    cfa.process(t.getScopeRoot());\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+    // Using the forward reaching definition search to find all the inline\n+    // candidates\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot());\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+        if (c.canInline()) {\n+            c.inlineVariable();\n+            // If definition c has dependencies, then inlining it may have\n+            // introduced new dependencies for our other inlining candidates.\n+            //\n+            // MustBeReachingVariableDef uses this dependency graph in its\n+            // analysis, so some of these candidates may no longer be valid.\n+            // We keep track of when the variable dependency graph changed\n+            // so that we can back off appropriately.\n+            if (!c.defMetadata.depends.isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+            }\n+        }\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.getDepends().isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -18,7 +18,7 @@\n     candidates = Lists.newLinkedList();\n     // Using the forward reaching definition search to find all the inline\n     // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n     // Compute the backward reaching use. The CFG can be reused.\n     reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n     reachingUses.analyze();\n@@ -32,7 +32,7 @@\n             // analysis, so some of these candidates may no longer be valid.\n             // We keep track of when the variable dependency graph changed\n             // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n+            if (!c.defMetadata.getDepends().isEmpty()) {\n                 inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n             }\n         }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,40 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+public void enterScope(NodeTraversal t) {\n+    if (t.inGlobalScope()) {\n+        // Don't even bother. All global variables are likely escaped.\n+        return;\n     }\n-    return false;\n+    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n+        return;\n+    }\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    // Process the body of the function.\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n+    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+    // Using the forward reaching definition search to find all the inline\n+    // candidates\n+    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+        if (c.canInline()) {\n+            c.inlineVariable();\n+            // If definition c has dependencies, then inlining it may have\n+            // introduced new dependencies for our other inlining candidates.\n+            //\n+            // MustBeReachingVariableDef uses this dependency graph in its\n+            // analysis, so some of these candidates may no longer be valid.\n+            // We keep track of when the variable dependency graph changed\n+            // so that we can back off appropriately.\n+            if (!c.defMetadata.getDepends().isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+            }\n+        }\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            // Fixed below\n            if (c.defMetadata != null && !c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,7 +1,7 @@\n @Override\n public void enterScope(NodeTraversal t) {\n     if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n+        // Don't even bother. All global variables are likely escaped.\n         return;\n     }\n     if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n@@ -32,7 +32,8 @@\n             // analysis, so some of these candidates may no longer be valid.\n             // We keep track of when the variable dependency graph changed\n             // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n+            // Fixed below\n+            if (c.defMetadata != null && !c.defMetadata.depends.isEmpty()) {\n                 inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n             }\n         }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,41 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+public void enterScope(NodeTraversal t) {\n+    if (t.inGlobalScope()) {\n+        // Don't even bother. All global variables are likely escaped.\n+        return;\n     }\n-    return false;\n+    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n+        return;\n+    }\n+    // Compute the forward reaching definition.\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+    // Process the body of the function.\n+    Preconditions.checkState(t.getScopeRoot().isFunction());\n+    cfa.process(null, t.getScopeRoot().getLastChild());\n+    cfg = cfa.getCfg();\n+    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n+    reachingDef.analyze();\n+    candidates = Lists.newLinkedList();\n+    // Using the forward reaching definition search to find all the inline\n+    // candidates\n+    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n+    // Compute the backward reaching use. The CFG can be reused.\n+    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n+    reachingUses.analyze();\n+    for (Candidate c : candidates) {\n+        if (c.canInline()) {\n+            c.inlineVariable();\n+            // If definition c has dependencies, then inlining it may have\n+            // introduced new dependencies for our other inlining candidates.\n+            //\n+            // MustBeReachingVariableDef uses this dependency graph in its\n+            // analysis, so some of these candidates may no longer be valid.\n+            // We keep track of when the variable dependency graph changed\n+            // so that we can back off appropriately.\n+            // Fixed below\n+            if (c.defMetadata != null && !c.defMetadata.depends.isEmpty()) {\n+                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+            }\n+        }\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]