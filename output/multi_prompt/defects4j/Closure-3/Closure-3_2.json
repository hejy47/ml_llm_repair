[{"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    int numUseWithinUseCfgNode = getNumUseInUseCfgNode(useCfgNode, null);\n    Node use = useCfgNode.getJSTreeNode();\n    // Definition was not found.\n    if (!getDefinition(getDefCfgNode(), null)) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    Predicate<Node> isUnsafeExpr = new Predicate<Node>() {\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.CALL:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    };\n    if (NodeUtil.has(def.getLastChild(), isUnsafeExpr, new Predicate<Node>() {\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !(NodeUtil.isFunction(input) || NodeUtil.isCall(input));\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,34 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.CALL:\n+                case Token.NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    };\n+    if (NodeUtil.has(def.getLastChild(), isUnsafeExpr, new Predicate<Node>() {\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !(NodeUtil.isFunction(input) || NodeUtil.isCall(input));\n+        }\n+    })) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n         }\n     }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n@@ -11,10 +11,10 @@\n             return false;\n         }\n     }\n-    getDefinition(getDefCfgNode(), null);\n-    getNumUseInUseCfgNode(useCfgNode, null);\n+    int numUseWithinUseCfgNode = getNumUseInUseCfgNode(useCfgNode, null);\n+    Node use = useCfgNode.getJSTreeNode();\n     // Definition was not found.\n-    if (def == null) {\n+    if (!getDefinition(getDefCfgNode(), null)) {\n         return false;\n     }\n     // Check that the assignment isn't used as a R-Value.\n@@ -67,27 +67,24 @@\n     // TODO(johnlenz): rework catch expression handling when we\n     // have lexical scope support so catch expressions don't\n     // need to be special cased.\n-    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n-\n+    Predicate<Node> isUnsafeExpr = new Predicate<Node>() {\n         @Override\n         public boolean apply(Node input) {\n             switch(input.getType()) {\n                 case Token.GETELEM:\n                 case Token.GETPROP:\n-                case Token.ARRAYLIT:\n-                case Token.OBJECTLIT:\n-                case Token.REGEXP:\n+                case Token.CALL:\n                 case Token.NEW:\n                     return true;\n             }\n             return false;\n         }\n-    }, new Predicate<Node>() {\n-\n+    };\n+    if (NodeUtil.has(def.getLastChild(), isUnsafeExpr, new Predicate<Node>() {\n         @Override\n         public boolean apply(Node input) {\n             // Recurse if the node is not a function.\n-            return !input.isFunction();\n+            return !(NodeUtil.isFunction(input) || NodeUtil.isCall(input));\n         }\n     })) {\n         return false;\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,34 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.CALL:\n+                case Token.NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    };\n+    if (NodeUtil.has(def.getLastChild(), isUnsafeExpr, new Predicate<Node>() {\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !(NodeUtil.isFunction(input) || NodeUtil.isCall(input));\n+        }\n+    })) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionResultUsed(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,36 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n         }\n     }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n@@ -19,7 +19,7 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionResultUsed(def.getParent())) {\n         return false;\n     }\n     // The right of the definition has side effect:\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,36 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,37 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n-    }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                    return true;\n+                default:\n+                    return false;\n             }\n         }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n@@ -79,8 +79,9 @@\n                 case Token.REGEXP:\n                 case Token.NEW:\n                     return true;\n+                default:\n+                    return false;\n             }\n-            return false;\n         }\n     }, new Predicate<Node>() {\n \n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,37 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                    return true;\n+                default:\n+                    return false;\n+            }\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object other than null.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                    return true;\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                    return !input.hasChildren();\n                case Token.NEW:\n                    return input.getFirstChild().isNull();\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,38 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                    return true;\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                    return !input.hasChildren();\n+                case Token.NEW:\n+                    return input.getFirstChild().isNull();\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n         }\n     }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n@@ -57,7 +57,7 @@\n     }\n     // We give up inlining stuff with R-Value that has:\n     // 1) GETPROP, GETELEM,\n-    // 2) anything that creates a new object.\n+    // 2) anything that creates a new object other than null.\n     // 3) a direct reference to a catch expression.\n     // Example:\n     // var x = a.b.c; j.c = 1; print(x);\n@@ -74,11 +74,13 @@\n             switch(input.getType()) {\n                 case Token.GETELEM:\n                 case Token.GETPROP:\n+                    return true;\n                 case Token.ARRAYLIT:\n                 case Token.OBJECTLIT:\n                 case Token.REGEXP:\n+                    return !input.hasChildren();\n                 case Token.NEW:\n-                    return true;\n+                    return input.getFirstChild().isNull();\n             }\n             return false;\n         }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,38 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                    return true;\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                    return !input.hasChildren();\n+                case Token.NEW:\n+                    return input.getFirstChild().isNull();\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && isExpressionAssignment(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !isFunction(input);\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,36 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !isFunction(input);\n+        }\n+    })) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n         }\n     }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n@@ -19,7 +19,7 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && isExpressionAssignment(def.getParent())) {\n         return false;\n     }\n     // The right of the definition has side effect:\n@@ -48,7 +48,7 @@\n         return false;\n     }\n     // Make sure that the name is not within a loop\n-    if (NodeUtil.isWithinLoop(use)) {\n+    if (isWithinLoop(use)) {\n         return false;\n     }\n     Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n@@ -67,7 +67,7 @@\n     // TODO(johnlenz): rework catch expression handling when we\n     // have lexical scope support so catch expressions don't\n     // need to be special cased.\n-    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n+    if (has(def.getLastChild(), new Predicate<Node>() {\n \n         @Override\n         public boolean apply(Node input) {\n@@ -87,14 +87,14 @@\n         @Override\n         public boolean apply(Node input) {\n             // Recurse if the node is not a function.\n-            return !input.isFunction();\n+            return !isFunction(input);\n         }\n     })) {\n         return false;\n     }\n     // We can skip the side effect check along the paths of two nodes if\n     // they are just next to each other.\n-    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+    if (isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n         // Similar side effect check as above but this time the side effect is\n         // else where along the path.\n         // x = readProp(b); while(modifyProp(b)) {}; print(x);\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,36 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !isFunction(input);\n+        }\n+    })) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                case Token.CLASS:\n                case Token.TAGGED_TEMPLATELIT:\n                case Token.TEMPLATELIT:\n                case Token.FUNCTION:\n                case Token.ARROWFUNCTION:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,41 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                case Token.CLASS:\n+                case Token.TAGGED_TEMPLATELIT:\n+                case Token.TEMPLATELIT:\n+                case Token.FUNCTION:\n+                case Token.ARROWFUNCTION:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n         }\n     }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n@@ -19,7 +19,7 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n         return false;\n     }\n     // The right of the definition has side effect:\n@@ -78,6 +78,11 @@\n                 case Token.OBJECTLIT:\n                 case Token.REGEXP:\n                 case Token.NEW:\n+                case Token.CLASS:\n+                case Token.TAGGED_TEMPLATELIT:\n+                case Token.TEMPLATELIT:\n+                case Token.FUNCTION:\n+                case Token.ARROWFUNCTION:\n                     return true;\n             }\n             return false;\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,41 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                case Token.CLASS:\n+                case Token.TAGGED_TEMPLATELIT:\n+                case Token.TEMPLATELIT:\n+                case Token.FUNCTION:\n+                case Token.ARROWFUNCTION:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                case Token.TEMPLATELIT:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,37 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                case Token.TEMPLATELIT:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n         }\n     }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n@@ -19,7 +19,7 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n         return false;\n     }\n     // The right of the definition has side effect:\n@@ -78,6 +78,7 @@\n                 case Token.OBJECTLIT:\n                 case Token.REGEXP:\n                 case Token.NEW:\n+                case Token.TEMPLATELIT:\n                     return true;\n             }\n             return false;\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,37 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                case Token.TEMPLATELIT:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch (input.getToken()) {\n                case GETELEM:\n                case GETPROP:\n                case ARRAYLIT:\n                case OBJECTLIT:\n                case REGEXP:\n                case NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,36 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+        public boolean apply(Node input) {\n+            switch (input.getToken()) {\n+                case GETELEM:\n+                case GETPROP:\n+                case ARRAYLIT:\n+                case OBJECTLIT:\n+                case REGEXP:\n+                case NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n         }\n     }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n@@ -19,7 +19,7 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n         return false;\n     }\n     // The right of the definition has side effect:\n@@ -71,13 +71,13 @@\n \n         @Override\n         public boolean apply(Node input) {\n-            switch(input.getType()) {\n-                case Token.GETELEM:\n-                case Token.GETPROP:\n-                case Token.ARRAYLIT:\n-                case Token.OBJECTLIT:\n-                case Token.REGEXP:\n-                case Token.NEW:\n+            switch (input.getToken()) {\n+                case GETELEM:\n+                case GETPROP:\n+                case ARRAYLIT:\n+                case OBJECTLIT:\n+                case REGEXP:\n+                case NEW:\n                     return true;\n             }\n             return false;\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,36 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+        public boolean apply(Node input) {\n+            switch (input.getToken()) {\n+                case GETELEM:\n+                case GETPROP:\n+                case ARRAYLIT:\n+                case OBJECTLIT:\n+                case REGEXP:\n+                case NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        ControlFlowGraph<Node> cfg = getCfg();\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,37 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        ControlFlowGraph<Node> cfg = getCfg();\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n         }\n     }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n@@ -19,7 +19,7 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n         return false;\n     }\n     // The right of the definition has side effect:\n@@ -98,6 +98,7 @@\n         // Similar side effect check as above but this time the side effect is\n         // else where along the path.\n         // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        ControlFlowGraph<Node> cfg = getCfg();\n         CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n         if (pathCheck.somePathsSatisfyPredicate()) {\n             return false;\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,37 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        ControlFlowGraph<Node> cfg = getCfg();\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler) &&\n            !NodeUtil.isImmutableValue(def.getLastChild())) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even though it is semantically\n    // correct, inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n\n    /*\n     * For expressions that are being used as part of a comma-delimited\n     * expression, like \"a = b(), console.log(a)\" we need to handle these\n     * specially, as the comma statement is counting as another use.\n     */\n    int use_count = 0;\n    for (Node node : uses) {\n        if (node.isComma()) {\n            Node parent = node.getParent();\n            if (parent.isExprResult()) {\n                use_count++;\n                continue;\n            }\n        }\n        use_count++;\n    }\n\n    if (use_count != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; console.log(x);\n    // Inlining console.log(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                    // NEW is not included in the list, as we do not want to\n                    // inline a method that creates an object.\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // elsewhere along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; console.log(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck =\n                new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg,\n                        cfg.getDirectedGraphNode(getDefCfgNode()),\n                        cfg.getDirectedGraphNode(useCfgNode),\n                        SIDE_EFFECT_PREDICATE,\n                        Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                        false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,43 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                    // NEW is not included in the list, as we do not want to\n+                    // inline a method that creates an object.\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // elsewhere along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; console.log(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck =\n+                new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg,\n+                        cfg.getDirectedGraphNode(getDefCfgNode()),\n+                        cfg.getDirectedGraphNode(useCfgNode),\n+                        SIDE_EFFECT_PREDICATE,\n+                        Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n+                        false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n         }\n     }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n@@ -37,13 +37,14 @@\n     // TODO(user): Side-effect is OK sometimes. As long as there are no\n     // side-effect function down all paths to the use. Once we have all the\n     // side-effect analysis tool.\n-    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n+    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler) &&\n+            !NodeUtil.isImmutableValue(def.getLastChild())) {\n         return false;\n     }\n     // TODO(user): We could inline all the uses if the expression is short.\n     // Finally we have to make sure that there are no more than one use\n-    // in the program and in the CFG node. Even when it is semantically\n-    // correctly inlining twice increases code size.\n+    // in the program and in the CFG node. Even though it is semantically\n+    // correct, inlining twice increases code size.\n     if (numUseWithinUseCfgNode != 1) {\n         return false;\n     }\n@@ -52,7 +53,25 @@\n         return false;\n     }\n     Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n-    if (uses.size() != 1) {\n+\n+    /*\n+     * For expressions that are being used as part of a comma-delimited\n+     * expression, like \"a = b(), console.log(a)\" we need to handle these\n+     * specially, as the comma statement is counting as another use.\n+     */\n+    int use_count = 0;\n+    for (Node node : uses) {\n+        if (node.isComma()) {\n+            Node parent = node.getParent();\n+            if (parent.isExprResult()) {\n+                use_count++;\n+                continue;\n+            }\n+        }\n+        use_count++;\n+    }\n+\n+    if (use_count != 1) {\n         return false;\n     }\n     // We give up inlining stuff with R-Value that has:\n@@ -60,8 +79,8 @@\n     // 2) anything that creates a new object.\n     // 3) a direct reference to a catch expression.\n     // Example:\n-    // var x = a.b.c; j.c = 1; print(x);\n-    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n+    // var x = a.b.c; j.c = 1; console.log(x);\n+    // Inlining console.log(a.b.c) is not safe consider j and be alias to a.b.\n     // TODO(user): We could get more accuracy by looking more in-detail\n     // what j is and what x is trying to into to.\n     // TODO(johnlenz): rework catch expression handling when we\n@@ -77,7 +96,8 @@\n                 case Token.ARRAYLIT:\n                 case Token.OBJECTLIT:\n                 case Token.REGEXP:\n-                case Token.NEW:\n+                    // NEW is not included in the list, as we do not want to\n+                    // inline a method that creates an object.\n                     return true;\n             }\n             return false;\n@@ -96,9 +116,15 @@\n     // they are just next to each other.\n     if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n         // Similar side effect check as above but this time the side effect is\n-        // else where along the path.\n-        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n-        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        // elsewhere along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; console.log(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck =\n+                new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg,\n+                        cfg.getDirectedGraphNode(getDefCfgNode()),\n+                        cfg.getDirectedGraphNode(useCfgNode),\n+                        SIDE_EFFECT_PREDICATE,\n+                        Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n+                        false);\n         if (pathCheck.somePathsSatisfyPredicate()) {\n             return false;\n         }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,43 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                    // NEW is not included in the list, as we do not want to\n+                    // inline a method that creates an object.\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // elsewhere along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; console.log(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck =\n+                new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg,\n+                        cfg.getDirectedGraphNode(getDefCfgNode()),\n+                        cfg.getDirectedGraphNode(useCfgNode),\n+                        SIDE_EFFECT_PREDICATE,\n+                        Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n+                        false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getToken()) {\n                case GETELEM:\n                case GETPROP:\n                case ARRAYLIT:\n                case OBJECTLIT:\n                case REGEXP:\n                case NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,36 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+        public boolean apply(Node input) {\n+            switch(input.getToken()) {\n+                case GETELEM:\n+                case GETPROP:\n+                case ARRAYLIT:\n+                case OBJECTLIT:\n+                case REGEXP:\n+                case NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n         }\n     }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n@@ -19,7 +19,7 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionAssign(def.getParent())) {\n         return false;\n     }\n     // The right of the definition has side effect:\n@@ -71,13 +71,13 @@\n \n         @Override\n         public boolean apply(Node input) {\n-            switch(input.getType()) {\n-                case Token.GETELEM:\n-                case Token.GETPROP:\n-                case Token.ARRAYLIT:\n-                case Token.OBJECTLIT:\n-                case Token.REGEXP:\n-                case Token.NEW:\n+            switch(input.getToken()) {\n+                case GETELEM:\n+                case GETPROP:\n+                case ARRAYLIT:\n+                case OBJECTLIT:\n+                case REGEXP:\n+                case NEW:\n                     return true;\n             }\n             return false;\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,36 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+        public boolean apply(Node input) {\n+            switch(input.getToken()) {\n+                case GETELEM:\n+                case GETPROP:\n+                case ARRAYLIT:\n+                case OBJECTLIT:\n+                case REGEXP:\n+                case NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                    // Updated to remove the ARRAYLIT and NEW token types\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,35 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                    // Updated to remove the ARRAYLIT and NEW token types\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n         }\n     }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n@@ -74,10 +74,9 @@\n             switch(input.getType()) {\n                 case Token.GETELEM:\n                 case Token.GETPROP:\n-                case Token.ARRAYLIT:\n                 case Token.OBJECTLIT:\n                 case Token.REGEXP:\n-                case Token.NEW:\n+                    // Updated to remove the ARRAYLIT and NEW token types\n                     return true;\n             }\n             return false;\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,35 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                    // Updated to remove the ARRAYLIT and NEW token types\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                case Token.CLASS:\n                case Token.TAGGED_TEMPLATELIT:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,38 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                case Token.CLASS:\n+                case Token.TAGGED_TEMPLATELIT:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n         }\n     }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n@@ -78,6 +78,8 @@\n                 case Token.OBJECTLIT:\n                 case Token.REGEXP:\n                 case Token.NEW:\n+                case Token.CLASS:\n+                case Token.TAGGED_TEMPLATELIT:\n                     return true;\n             }\n             return false;\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,38 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                case Token.CLASS:\n+                case Token.TAGGED_TEMPLATELIT:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)\n        // Don't inline if the last child has a side effect.\n        || NodeUtil.mayHaveSideEffects(use.getParent(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n            @Override\n            public boolean apply(Node input) {\n                switch(input.getType()) {\n                    case Token.GETELEM:\n                    case Token.GETPROP:\n                    case Token.ARRAYLIT:\n                    case Token.OBJECTLIT:\n                    case Token.REGEXP:\n                    case Token.NEW:\n                        return true;\n                }\n                return false;\n            }\n        }, new Predicate<Node>() {\n            @Override\n            public boolean apply(Node input) {\n                // Recurse if the node is not a function.\n                return !input.isFunction();\n            }\n        }) || NodeUtil.has(use.getParent(), new Predicate<Node>() {\n            @Override\n            public boolean apply(Node input) {\n                switch(input.getType()) {\n                    case Token.GETELEM:\n                    case Token.GETPROP:\n                    case Token.ARRAYLIT:\n                    case Token.OBJECTLIT:\n                    case Token.REGEXP:\n                    case Token.NEW:\n                        return true;\n                }\n                return false;\n            }\n        }, new Predicate<Node>() {\n            @Override\n            public boolean apply(Node input) {\n                // Recurse if the node is not a function.\n                return !input.isFunction();\n            }\n        })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,55 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+            public boolean apply(Node input) {\n+                switch(input.getType()) {\n+                    case Token.GETELEM:\n+                    case Token.GETPROP:\n+                    case Token.ARRAYLIT:\n+                    case Token.OBJECTLIT:\n+                    case Token.REGEXP:\n+                    case Token.NEW:\n+                        return true;\n+                }\n+                return false;\n+            }\n+        }, new Predicate<Node>() {\n+            @Override\n+            public boolean apply(Node input) {\n+                // Recurse if the node is not a function.\n+                return !input.isFunction();\n+            }\n+        }) || NodeUtil.has(use.getParent(), new Predicate<Node>() {\n+            @Override\n+            public boolean apply(Node input) {\n+                switch(input.getType()) {\n+                    case Token.GETELEM:\n+                    case Token.GETPROP:\n+                    case Token.ARRAYLIT:\n+                    case Token.OBJECTLIT:\n+                    case Token.REGEXP:\n+                    case Token.NEW:\n+                        return true;\n+                }\n+                return false;\n+            }\n+        }, new Predicate<Node>() {\n+            @Override\n+            public boolean apply(Node input) {\n+                // Recurse if the node is not a function.\n+                return !input.isFunction();\n+            }\n+        })) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n         }\n     }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n@@ -37,7 +37,9 @@\n     // TODO(user): Side-effect is OK sometimes. As long as there are no\n     // side-effect function down all paths to the use. Once we have all the\n     // side-effect analysis tool.\n-    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n+    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)\n+        // Don't inline if the last child has a side effect.\n+        || NodeUtil.mayHaveSideEffects(use.getParent(), compiler)) {\n         return false;\n     }\n     // TODO(user): We could inline all the uses if the expression is short.\n@@ -68,28 +70,46 @@\n     // have lexical scope support so catch expressions don't\n     // need to be special cased.\n     if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n-\n-        @Override\n-        public boolean apply(Node input) {\n-            switch(input.getType()) {\n-                case Token.GETELEM:\n-                case Token.GETPROP:\n-                case Token.ARRAYLIT:\n-                case Token.OBJECTLIT:\n-                case Token.REGEXP:\n-                case Token.NEW:\n-                    return true;\n+            @Override\n+            public boolean apply(Node input) {\n+                switch(input.getType()) {\n+                    case Token.GETELEM:\n+                    case Token.GETPROP:\n+                    case Token.ARRAYLIT:\n+                    case Token.OBJECTLIT:\n+                    case Token.REGEXP:\n+                    case Token.NEW:\n+                        return true;\n+                }\n+                return false;\n             }\n-            return false;\n-        }\n-    }, new Predicate<Node>() {\n-\n-        @Override\n-        public boolean apply(Node input) {\n-            // Recurse if the node is not a function.\n-            return !input.isFunction();\n-        }\n-    })) {\n+        }, new Predicate<Node>() {\n+            @Override\n+            public boolean apply(Node input) {\n+                // Recurse if the node is not a function.\n+                return !input.isFunction();\n+            }\n+        }) || NodeUtil.has(use.getParent(), new Predicate<Node>() {\n+            @Override\n+            public boolean apply(Node input) {\n+                switch(input.getType()) {\n+                    case Token.GETELEM:\n+                    case Token.GETPROP:\n+                    case Token.ARRAYLIT:\n+                    case Token.OBJECTLIT:\n+                    case Token.REGEXP:\n+                    case Token.NEW:\n+                        return true;\n+                }\n+                return false;\n+            }\n+        }, new Predicate<Node>() {\n+            @Override\n+            public boolean apply(Node input) {\n+                // Recurse if the node is not a function.\n+                return !input.isFunction();\n+            }\n+        })) {\n         return false;\n     }\n     // We can skip the side effect check along the paths of two nodes if\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,55 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+            public boolean apply(Node input) {\n+                switch(input.getType()) {\n+                    case Token.GETELEM:\n+                    case Token.GETPROP:\n+                    case Token.ARRAYLIT:\n+                    case Token.OBJECTLIT:\n+                    case Token.REGEXP:\n+                    case Token.NEW:\n+                        return true;\n+                }\n+                return false;\n+            }\n+        }, new Predicate<Node>() {\n+            @Override\n+            public boolean apply(Node input) {\n+                // Recurse if the node is not a function.\n+                return !input.isFunction();\n+            }\n+        }) || NodeUtil.has(use.getParent(), new Predicate<Node>() {\n+            @Override\n+            public boolean apply(Node input) {\n+                switch(input.getType()) {\n+                    case Token.GETELEM:\n+                    case Token.GETPROP:\n+                    case Token.ARRAYLIT:\n+                    case Token.OBJECTLIT:\n+                    case Token.REGEXP:\n+                    case Token.NEW:\n+                        return true;\n+                }\n+                return false;\n+            }\n+        }, new Predicate<Node>() {\n+            @Override\n+            public boolean apply(Node input) {\n+                // Recurse if the node is not a function.\n+                return !input.isFunction();\n+            }\n+        })) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild())) {\n        return false;\n    }\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,36 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n         }\n     }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n@@ -67,6 +67,9 @@\n     // TODO(johnlenz): rework catch expression handling when we\n     // have lexical scope support so catch expressions don't\n     // need to be special cased.\n+    if (NodeUtil.mayHaveSideEffects(def.getLastChild())) {\n+        return false;\n+    }\n     if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n \n         @Override\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,36 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,36 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n         }\n     }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,36 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                case Token.CATCH:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,37 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                case Token.CATCH:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n         }\n     }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n@@ -78,6 +78,7 @@\n                 case Token.OBJECTLIT:\n                 case Token.REGEXP:\n                 case Token.NEW:\n+                case Token.CATCH:\n                     return true;\n             }\n             return false;\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,37 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                case Token.CATCH:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                    return true;\n                case Token.NEW:\n                    return input.getFirstChild() != null\n                        && input.getFirstChild().matchesQualifiedName(\"Object\")\n                        && NodeUtil.isNewObjectLit(input.getFirstChild().getNext());\n                default:\n                    return false;\n            }\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,40 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n-    }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                    return true;\n+                case Token.NEW:\n+                    return input.getFirstChild() != null\n+                        && input.getFirstChild().matchesQualifiedName(\"Object\")\n+                        && NodeUtil.isNewObjectLit(input.getFirstChild().getNext());\n+                default:\n+                    return false;\n             }\n         }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n@@ -77,10 +77,14 @@\n                 case Token.ARRAYLIT:\n                 case Token.OBJECTLIT:\n                 case Token.REGEXP:\n+                    return true;\n                 case Token.NEW:\n-                    return true;\n+                    return input.getFirstChild() != null\n+                        && input.getFirstChild().matchesQualifiedName(\"Object\")\n+                        && NodeUtil.isNewObjectLit(input.getFirstChild().getNext());\n+                default:\n+                    return false;\n             }\n-            return false;\n         }\n     }, new Predicate<Node>() {\n \n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,40 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                    return true;\n+                case Token.NEW:\n+                    return input.getFirstChild() != null\n+                        && input.getFirstChild().matchesQualifiedName(\"Object\")\n+                        && NodeUtil.isNewObjectLit(input.getFirstChild().getNext());\n+                default:\n+                    return false;\n+            }\n+        }\n+    }, new Predicate<Node>() {\n+\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExpressionResultUsed(def)) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, Predicates.alwaysTrue())) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@enterScope\n@@ -1,40 +1,29 @@\n @Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, Predicates.alwaysTrue())) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n         }\n     }\n+    return true;\n }\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@canInline\n@@ -19,7 +19,7 @@\n     }\n     // Check that the assignment isn't used as a R-Value.\n     // TODO(user): Certain cases we can still inline.\n-    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+    if (def.isAssign() && !NodeUtil.isExpressionResultUsed(def)) {\n         return false;\n     }\n     // The right of the definition has side effect:\n@@ -82,14 +82,7 @@\n             }\n             return false;\n         }\n-    }, new Predicate<Node>() {\n-\n-        @Override\n-        public boolean apply(Node input) {\n-            // Recurse if the node is not a function.\n-            return !input.isFunction();\n-        }\n-    })) {\n+    }, Predicates.alwaysTrue())) {\n         return false;\n     }\n     // We can skip the side effect check along the paths of two nodes if\n--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.java@apply\n@@ -1,13 +1,29 @@\n @Override\n-public boolean apply(Node input) {\n-    switch(input.getType()) {\n-        case Token.GETELEM:\n-        case Token.GETPROP:\n-        case Token.ARRAYLIT:\n-        case Token.OBJECTLIT:\n-        case Token.REGEXP:\n-        case Token.NEW:\n-            return true;\n+        public boolean apply(Node input) {\n+            switch(input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, Predicates.alwaysTrue())) {\n+        return false;\n     }\n-    return false;\n+    // We can skip the side effect check along the paths of two nodes if\n+    // they are just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]