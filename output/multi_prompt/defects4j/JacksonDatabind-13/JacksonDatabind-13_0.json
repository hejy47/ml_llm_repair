[{"output": "@Override\npublic ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n        final ObjectIdGenerator.IdKey key = gen.key(id);\n    if (_objectIds == null) {\n        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n    } else {\n        ReadableObjectId entry = _objectIds.get(key);\n        if (entry != null) {\n            return entry;\n        }\n    }\n    // Not seen yet, must create entry and configure resolver.\n    ObjectIdResolver resolver = null;\n    if (_objectIdResolvers == null) {\n        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n    }\n\n    for (ObjectIdResolver res : _objectIdResolvers) {\n        if (res.canUseFor(resolverType)) {\n            resolver = res;\n            break;\n        }\n    }\n    if (resolver == null) {\n        resolver = resolverType.newForDeserialization(this);\n        _objectIdResolvers.add(resolver);\n    }\n    ReadableObjectId entry = new ReadableObjectId(key);\n    entry.setResolver(resolver);\n    _objectIds.put(key, entry);\n    return entry;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n+++ com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n@@ -13,21 +13,17 @@\n     ObjectIdResolver resolver = null;\n     if (_objectIdResolvers == null) {\n         _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n-    } else {\n-        for (ObjectIdResolver res : _objectIdResolvers) {\n-            if (res.canUseFor(resolverType)) {\n-                resolver = res;\n-                break;\n-            }\n+    }\n+\n+    for (ObjectIdResolver res : _objectIdResolvers) {\n+        if (res.canUseFor(resolverType)) {\n+            resolver = res;\n+            break;\n         }\n     }\n     if (resolver == null) {\n         resolver = resolverType.newForDeserialization(this);\n-        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n-        //   needed to clear state between calls.\n-        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n-        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n-                _objectIdResolvers.add(resolver);\n+        _objectIdResolvers.add(resolver);\n     }\n     ReadableObjectId entry = new ReadableObjectId(key);\n     entry.setResolver(resolver);\n--- com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n+++ com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n@@ -1,13 +1,32 @@\n @Override\n-public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n-    // note: no null checks (unlike usually); deserializer should fail if one found\n-    Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n-    roid.bindItem(instance);\n-    // also: may need to set a property value as well\n-    SettableBeanProperty idProp = _objectIdReader.idProperty;\n-    if (idProp != null) {\n-        return idProp.setAndReturn(instance, id);\n+public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n+        final ObjectIdGenerator.IdKey key = gen.key(id);\n+    if (_objectIds == null) {\n+        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n+    } else {\n+        ReadableObjectId entry = _objectIds.get(key);\n+        if (entry != null) {\n+            return entry;\n+        }\n     }\n-    return instance;\n+    // Not seen yet, must create entry and configure resolver.\n+    ObjectIdResolver resolver = null;\n+    if (_objectIdResolvers == null) {\n+        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+    }\n+\n+    for (ObjectIdResolver res : _objectIdResolvers) {\n+        if (res.canUseFor(resolverType)) {\n+            resolver = res;\n+            break;\n+        }\n+    }\n+    if (resolver == null) {\n+        resolver = resolverType.newForDeserialization(this);\n+        _objectIdResolvers.add(resolver);\n+    }\n+    ReadableObjectId entry = new ReadableObjectId(key);\n+    entry.setResolver(resolver);\n+    _objectIds.put(key, entry);\n+    return entry;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n    final ObjectIdGenerator.IdKey key = gen.key(id);\n    if (_objectIds == null) {\n        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n    }\n    ReadableObjectId entry = _objectIds.get(key);\n    if (entry != null) {\n        return entry;\n    }\n    // Not seen yet, must create entry and configure resolver.\n    ObjectIdResolver resolver = null;\n    if (_objectIdResolvers == null) {\n        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n    } else {\n        for (ObjectIdResolver res : _objectIdResolvers) {\n            if (res.canUseFor(resolverType)) {\n                resolver = res;\n                break;\n            }\n        }\n    }\n    if (resolver == null) {\n        resolver = resolverType.newForDeserialization(this);\n        _objectIdResolvers.add(resolver);\n    }\n    entry = new ReadableObjectId(key);\n    entry.setResolver(resolver);\n    _objectIds.put(key, entry);\n    return entry;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n+++ com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n@@ -1,13 +1,12 @@\n @Override\n public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n-        final ObjectIdGenerator.IdKey key = gen.key(id);\n+    final ObjectIdGenerator.IdKey key = gen.key(id);\n     if (_objectIds == null) {\n         _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n-    } else {\n-        ReadableObjectId entry = _objectIds.get(key);\n-        if (entry != null) {\n-            return entry;\n-        }\n+    }\n+    ReadableObjectId entry = _objectIds.get(key);\n+    if (entry != null) {\n+        return entry;\n     }\n     // Not seen yet, must create entry and configure resolver.\n     ObjectIdResolver resolver = null;\n@@ -23,13 +22,9 @@\n     }\n     if (resolver == null) {\n         resolver = resolverType.newForDeserialization(this);\n-        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n-        //   needed to clear state between calls.\n-        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n-        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n-                _objectIdResolvers.add(resolver);\n+        _objectIdResolvers.add(resolver);\n     }\n-    ReadableObjectId entry = new ReadableObjectId(key);\n+    entry = new ReadableObjectId(key);\n     entry.setResolver(resolver);\n     _objectIds.put(key, entry);\n     return entry;\n--- com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n+++ com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n@@ -1,13 +1,31 @@\n @Override\n-public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n-    // note: no null checks (unlike usually); deserializer should fail if one found\n-    Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n-    roid.bindItem(instance);\n-    // also: may need to set a property value as well\n-    SettableBeanProperty idProp = _objectIdReader.idProperty;\n-    if (idProp != null) {\n-        return idProp.setAndReturn(instance, id);\n+public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n+    final ObjectIdGenerator.IdKey key = gen.key(id);\n+    if (_objectIds == null) {\n+        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n     }\n-    return instance;\n+    ReadableObjectId entry = _objectIds.get(key);\n+    if (entry != null) {\n+        return entry;\n+    }\n+    // Not seen yet, must create entry and configure resolver.\n+    ObjectIdResolver resolver = null;\n+    if (_objectIdResolvers == null) {\n+        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+    } else {\n+        for (ObjectIdResolver res : _objectIdResolvers) {\n+            if (res.canUseFor(resolverType)) {\n+                resolver = res;\n+                break;\n+            }\n+        }\n+    }\n+    if (resolver == null) {\n+        resolver = resolverType.newForDeserialization(this);\n+        _objectIdResolvers.add(resolver);\n+    }\n+    entry = new ReadableObjectId(key);\n+    entry.setResolver(resolver);\n+    _objectIds.put(key, entry);\n+    return entry;\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n        final ObjectIdGenerator.IdKey key = gen.key(id);\n    if (_objectIds == null) {\n        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n    }\n    ReadableObjectId entry = _objectIds.get(key);\n    if (entry != null) {\n        return entry;\n    }\n    // Not seen yet, must create entry and configure resolver.\n    ObjectIdResolver resolver = null;\n    if (_objectIdResolvers == null) {\n        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n    }\n    for (ObjectIdResolver res : _objectIdResolvers) {\n        if (res.canUseFor(resolverType)) {\n            resolver = res;\n            break;\n        }\n    }\n    if (resolver == null) {\n        resolver = resolverType.newForDeserialization(this);\n        _objectIdResolvers.add(resolver);\n    }\n    entry = new ReadableObjectId(key);\n    entry.setResolver(resolver);\n    _objectIds.put(key, entry);\n    return entry;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n+++ com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n@@ -3,33 +3,27 @@\n         final ObjectIdGenerator.IdKey key = gen.key(id);\n     if (_objectIds == null) {\n         _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n-    } else {\n-        ReadableObjectId entry = _objectIds.get(key);\n-        if (entry != null) {\n-            return entry;\n-        }\n+    }\n+    ReadableObjectId entry = _objectIds.get(key);\n+    if (entry != null) {\n+        return entry;\n     }\n     // Not seen yet, must create entry and configure resolver.\n     ObjectIdResolver resolver = null;\n     if (_objectIdResolvers == null) {\n         _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n-    } else {\n-        for (ObjectIdResolver res : _objectIdResolvers) {\n-            if (res.canUseFor(resolverType)) {\n-                resolver = res;\n-                break;\n-            }\n+    }\n+    for (ObjectIdResolver res : _objectIdResolvers) {\n+        if (res.canUseFor(resolverType)) {\n+            resolver = res;\n+            break;\n         }\n     }\n     if (resolver == null) {\n         resolver = resolverType.newForDeserialization(this);\n-        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n-        //   needed to clear state between calls.\n-        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n-        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n-                _objectIdResolvers.add(resolver);\n+        _objectIdResolvers.add(resolver);\n     }\n-    ReadableObjectId entry = new ReadableObjectId(key);\n+    entry = new ReadableObjectId(key);\n     entry.setResolver(resolver);\n     _objectIds.put(key, entry);\n     return entry;\n--- com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n+++ com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n@@ -1,13 +1,30 @@\n @Override\n-public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n-    // note: no null checks (unlike usually); deserializer should fail if one found\n-    Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n-    roid.bindItem(instance);\n-    // also: may need to set a property value as well\n-    SettableBeanProperty idProp = _objectIdReader.idProperty;\n-    if (idProp != null) {\n-        return idProp.setAndReturn(instance, id);\n+public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n+        final ObjectIdGenerator.IdKey key = gen.key(id);\n+    if (_objectIds == null) {\n+        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n     }\n-    return instance;\n+    ReadableObjectId entry = _objectIds.get(key);\n+    if (entry != null) {\n+        return entry;\n+    }\n+    // Not seen yet, must create entry and configure resolver.\n+    ObjectIdResolver resolver = null;\n+    if (_objectIdResolvers == null) {\n+        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+    }\n+    for (ObjectIdResolver res : _objectIdResolvers) {\n+        if (res.canUseFor(resolverType)) {\n+            resolver = res;\n+            break;\n+        }\n+    }\n+    if (resolver == null) {\n+        resolver = resolverType.newForDeserialization(this);\n+        _objectIdResolvers.add(resolver);\n+    }\n+    entry = new ReadableObjectId(key);\n+    entry.setResolver(resolver);\n+    _objectIds.put(key, entry);\n+    return entry;\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n    final ObjectIdGenerator.IdKey key = gen.key(id);\n    if (_objectIds == null) {\n        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n    } else {\n        ReadableObjectId entry = _objectIds.get(key);\n        if (entry != null) {\n            return entry;\n        }\n    }\n    // Not seen yet, must create entry and configure resolver.\n    ObjectIdResolver resolver = null;\n    if (_objectIdResolvers == null) {\n        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n    }\n    for (ObjectIdResolver res : _objectIdResolvers) {\n        if (res.canUseFor(resolverType)) {\n            resolver = res;\n            break;\n        }\n    }\n    if (resolver == null) {\n        resolver = resolverType.newForDeserialization(this);\n        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n        //   needed to clear state between calls.\n        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n            _objectIdResolvers.add(resolver);\n    }\n    ReadableObjectId entry = new ReadableObjectId(key);\n    entry.setResolver(resolver);\n    _objectIds.put(key, entry);\n    return entry;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n+++ com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n@@ -1,6 +1,6 @@\n @Override\n public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n-        final ObjectIdGenerator.IdKey key = gen.key(id);\n+    final ObjectIdGenerator.IdKey key = gen.key(id);\n     if (_objectIds == null) {\n         _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n     } else {\n@@ -13,12 +13,11 @@\n     ObjectIdResolver resolver = null;\n     if (_objectIdResolvers == null) {\n         _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n-    } else {\n-        for (ObjectIdResolver res : _objectIdResolvers) {\n-            if (res.canUseFor(resolverType)) {\n-                resolver = res;\n-                break;\n-            }\n+    }\n+    for (ObjectIdResolver res : _objectIdResolvers) {\n+        if (res.canUseFor(resolverType)) {\n+            resolver = res;\n+            break;\n         }\n     }\n     if (resolver == null) {\n@@ -27,7 +26,7 @@\n         //   needed to clear state between calls.\n         // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n         //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n-                _objectIdResolvers.add(resolver);\n+            _objectIdResolvers.add(resolver);\n     }\n     ReadableObjectId entry = new ReadableObjectId(key);\n     entry.setResolver(resolver);\n--- com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n+++ com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n@@ -1,13 +1,35 @@\n @Override\n-public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n-    // note: no null checks (unlike usually); deserializer should fail if one found\n-    Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n-    roid.bindItem(instance);\n-    // also: may need to set a property value as well\n-    SettableBeanProperty idProp = _objectIdReader.idProperty;\n-    if (idProp != null) {\n-        return idProp.setAndReturn(instance, id);\n+public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n+    final ObjectIdGenerator.IdKey key = gen.key(id);\n+    if (_objectIds == null) {\n+        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n+    } else {\n+        ReadableObjectId entry = _objectIds.get(key);\n+        if (entry != null) {\n+            return entry;\n+        }\n     }\n-    return instance;\n+    // Not seen yet, must create entry and configure resolver.\n+    ObjectIdResolver resolver = null;\n+    if (_objectIdResolvers == null) {\n+        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+    }\n+    for (ObjectIdResolver res : _objectIdResolvers) {\n+        if (res.canUseFor(resolverType)) {\n+            resolver = res;\n+            break;\n+        }\n+    }\n+    if (resolver == null) {\n+        resolver = resolverType.newForDeserialization(this);\n+        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n+        //   needed to clear state between calls.\n+        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n+        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n+            _objectIdResolvers.add(resolver);\n+    }\n+    ReadableObjectId entry = new ReadableObjectId(key);\n+    entry.setResolver(resolver);\n+    _objectIds.put(key, entry);\n+    return entry;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n    final ObjectIdGenerator.IdKey key = gen.key(id);\n    if (_objectIds == null) {\n        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n    } else {\n        ReadableObjectId entry = _objectIds.get(key);\n        if (entry != null) {\n            return entry;\n        }\n    }\n    // Not seen yet, must create entry and configure resolver.\n    ObjectIdResolver resolver = null;\n    if (_objectIdResolvers == null) {\n        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n    }\n    for (ObjectIdResolver res : _objectIdResolvers) {\n        if (res.canUseFor(resolverType)) {\n            resolver = res;\n            break;\n        }\n    }\n    if (resolver == null) {\n        resolver = resolverType.newForDeserialization(this);\n        _objectIdResolvers.add(resolver);\n    }\n    ReadableObjectId entry = new ReadableObjectId(key);\n    entry.setResolver(resolver);\n    _objectIds.put(key, entry);\n    return entry;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n+++ com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n@@ -1,6 +1,6 @@\n @Override\n public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n-        final ObjectIdGenerator.IdKey key = gen.key(id);\n+    final ObjectIdGenerator.IdKey key = gen.key(id);\n     if (_objectIds == null) {\n         _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n     } else {\n@@ -13,21 +13,16 @@\n     ObjectIdResolver resolver = null;\n     if (_objectIdResolvers == null) {\n         _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n-    } else {\n-        for (ObjectIdResolver res : _objectIdResolvers) {\n-            if (res.canUseFor(resolverType)) {\n-                resolver = res;\n-                break;\n-            }\n+    }\n+    for (ObjectIdResolver res : _objectIdResolvers) {\n+        if (res.canUseFor(resolverType)) {\n+            resolver = res;\n+            break;\n         }\n     }\n     if (resolver == null) {\n         resolver = resolverType.newForDeserialization(this);\n-        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n-        //   needed to clear state between calls.\n-        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n-        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n-                _objectIdResolvers.add(resolver);\n+        _objectIdResolvers.add(resolver);\n     }\n     ReadableObjectId entry = new ReadableObjectId(key);\n     entry.setResolver(resolver);\n--- com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n+++ com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n@@ -1,13 +1,31 @@\n @Override\n-public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n-    // note: no null checks (unlike usually); deserializer should fail if one found\n-    Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n-    roid.bindItem(instance);\n-    // also: may need to set a property value as well\n-    SettableBeanProperty idProp = _objectIdReader.idProperty;\n-    if (idProp != null) {\n-        return idProp.setAndReturn(instance, id);\n+public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n+    final ObjectIdGenerator.IdKey key = gen.key(id);\n+    if (_objectIds == null) {\n+        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n+    } else {\n+        ReadableObjectId entry = _objectIds.get(key);\n+        if (entry != null) {\n+            return entry;\n+        }\n     }\n-    return instance;\n+    // Not seen yet, must create entry and configure resolver.\n+    ObjectIdResolver resolver = null;\n+    if (_objectIdResolvers == null) {\n+        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+    }\n+    for (ObjectIdResolver res : _objectIdResolvers) {\n+        if (res.canUseFor(resolverType)) {\n+            resolver = res;\n+            break;\n+        }\n+    }\n+    if (resolver == null) {\n+        resolver = resolverType.newForDeserialization(this);\n+        _objectIdResolvers.add(resolver);\n+    }\n+    ReadableObjectId entry = new ReadableObjectId(key);\n+    entry.setResolver(resolver);\n+    _objectIds.put(key, entry);\n+    return entry;\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n    final ObjectIdGenerator.IdKey key = gen.key(id);\n    if (_objectIds == null) {\n        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n    }\n\n    ReadableObjectId entry = _objectIds.get(key);\n    if (entry != null) {\n        return entry;\n    }\n\n    // Not seen yet, must create entry and configure resolver.\n    ObjectIdResolver resolver = null;\n    if (_objectIdResolvers == null) {\n        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n    } else {\n        for (ObjectIdResolver res : _objectIdResolvers) {\n            if (res.canUseFor(resolverType)) {\n                resolver = res;\n                break;\n            }\n        }\n    }\n    if (resolver == null) {\n        resolver = resolverType.newForDeserialization(this);\n        _objectIdResolvers.add(resolver);\n    }\n    entry = new ReadableObjectId(key);\n    entry.setResolver(resolver);\n    _objectIds.put(key, entry);\n    return entry;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n+++ com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n@@ -1,14 +1,15 @@\n @Override\n public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n-        final ObjectIdGenerator.IdKey key = gen.key(id);\n+    final ObjectIdGenerator.IdKey key = gen.key(id);\n     if (_objectIds == null) {\n         _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n-    } else {\n-        ReadableObjectId entry = _objectIds.get(key);\n-        if (entry != null) {\n-            return entry;\n-        }\n     }\n+\n+    ReadableObjectId entry = _objectIds.get(key);\n+    if (entry != null) {\n+        return entry;\n+    }\n+\n     // Not seen yet, must create entry and configure resolver.\n     ObjectIdResolver resolver = null;\n     if (_objectIdResolvers == null) {\n@@ -23,13 +24,9 @@\n     }\n     if (resolver == null) {\n         resolver = resolverType.newForDeserialization(this);\n-        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n-        //   needed to clear state between calls.\n-        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n-        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n-                _objectIdResolvers.add(resolver);\n+        _objectIdResolvers.add(resolver);\n     }\n-    ReadableObjectId entry = new ReadableObjectId(key);\n+    entry = new ReadableObjectId(key);\n     entry.setResolver(resolver);\n     _objectIds.put(key, entry);\n     return entry;\n--- com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n+++ com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n@@ -1,13 +1,33 @@\n @Override\n-public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n-    // note: no null checks (unlike usually); deserializer should fail if one found\n-    Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n-    roid.bindItem(instance);\n-    // also: may need to set a property value as well\n-    SettableBeanProperty idProp = _objectIdReader.idProperty;\n-    if (idProp != null) {\n-        return idProp.setAndReturn(instance, id);\n+public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n+    final ObjectIdGenerator.IdKey key = gen.key(id);\n+    if (_objectIds == null) {\n+        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n     }\n-    return instance;\n+\n+    ReadableObjectId entry = _objectIds.get(key);\n+    if (entry != null) {\n+        return entry;\n+    }\n+\n+    // Not seen yet, must create entry and configure resolver.\n+    ObjectIdResolver resolver = null;\n+    if (_objectIdResolvers == null) {\n+        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+    } else {\n+        for (ObjectIdResolver res : _objectIdResolvers) {\n+            if (res.canUseFor(resolverType)) {\n+                resolver = res;\n+                break;\n+            }\n+        }\n+    }\n+    if (resolver == null) {\n+        resolver = resolverType.newForDeserialization(this);\n+        _objectIdResolvers.add(resolver);\n+    }\n+    entry = new ReadableObjectId(key);\n+    entry.setResolver(resolver);\n+    _objectIds.put(key, entry);\n+    return entry;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n    final ObjectIdGenerator.IdKey key = gen.key(id);\n    if (_objectIds == null) {\n        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n    }\n    ReadableObjectId entry = _objectIds.get(key);\n    if (entry != null) {\n        return entry;\n    }\n    // Not seen yet, must create entry and configure resolver.\n    ObjectIdResolver resolver = null;\n    if (_objectIdResolvers != null) {\n        for (ObjectIdResolver res : _objectIdResolvers) {\n            if (res.canUseFor(resolverType)) {\n                resolver = res;\n                break;\n            }\n        }\n    }\n    if (resolver == null) {\n        resolver = resolverType.newForDeserialization(this);\n        if (_objectIdResolvers == null) {\n            _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n        }\n        _objectIdResolvers.add(resolver);\n    }\n    entry = new ReadableObjectId(key);\n    entry.setResolver(resolver);\n    _objectIds.put(key, entry);\n    return entry;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n+++ com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n@@ -1,19 +1,16 @@\n @Override\n public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n-        final ObjectIdGenerator.IdKey key = gen.key(id);\n+    final ObjectIdGenerator.IdKey key = gen.key(id);\n     if (_objectIds == null) {\n         _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n-    } else {\n-        ReadableObjectId entry = _objectIds.get(key);\n-        if (entry != null) {\n-            return entry;\n-        }\n+    }\n+    ReadableObjectId entry = _objectIds.get(key);\n+    if (entry != null) {\n+        return entry;\n     }\n     // Not seen yet, must create entry and configure resolver.\n     ObjectIdResolver resolver = null;\n-    if (_objectIdResolvers == null) {\n-        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n-    } else {\n+    if (_objectIdResolvers != null) {\n         for (ObjectIdResolver res : _objectIdResolvers) {\n             if (res.canUseFor(resolverType)) {\n                 resolver = res;\n@@ -23,13 +20,12 @@\n     }\n     if (resolver == null) {\n         resolver = resolverType.newForDeserialization(this);\n-        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n-        //   needed to clear state between calls.\n-        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n-        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n-                _objectIdResolvers.add(resolver);\n+        if (_objectIdResolvers == null) {\n+            _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+        }\n+        _objectIdResolvers.add(resolver);\n     }\n-    ReadableObjectId entry = new ReadableObjectId(key);\n+    entry = new ReadableObjectId(key);\n     entry.setResolver(resolver);\n     _objectIds.put(key, entry);\n     return entry;\n--- com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n+++ com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n@@ -1,13 +1,32 @@\n @Override\n-public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n-    // note: no null checks (unlike usually); deserializer should fail if one found\n-    Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n-    roid.bindItem(instance);\n-    // also: may need to set a property value as well\n-    SettableBeanProperty idProp = _objectIdReader.idProperty;\n-    if (idProp != null) {\n-        return idProp.setAndReturn(instance, id);\n+public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n+    final ObjectIdGenerator.IdKey key = gen.key(id);\n+    if (_objectIds == null) {\n+        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n     }\n-    return instance;\n+    ReadableObjectId entry = _objectIds.get(key);\n+    if (entry != null) {\n+        return entry;\n+    }\n+    // Not seen yet, must create entry and configure resolver.\n+    ObjectIdResolver resolver = null;\n+    if (_objectIdResolvers != null) {\n+        for (ObjectIdResolver res : _objectIdResolvers) {\n+            if (res.canUseFor(resolverType)) {\n+                resolver = res;\n+                break;\n+            }\n+        }\n+    }\n+    if (resolver == null) {\n+        resolver = resolverType.newForDeserialization(this);\n+        if (_objectIdResolvers == null) {\n+            _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+        }\n+        _objectIdResolvers.add(resolver);\n+    }\n+    entry = new ReadableObjectId(key);\n+    entry.setResolver(resolver);\n+    _objectIds.put(key, entry);\n+    return entry;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n    final ObjectIdGenerator.IdKey key = gen.key(id);\n    if (_objectIds == null) {\n        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n    }\n    ReadableObjectId entry = _objectIds.get(key);\n    if (entry != null) {\n        return entry;\n    }\n    // Not seen yet, must create entry and configure resolver.\n    ObjectIdResolver resolver = null;\n    if (_objectIdResolvers == null) {\n        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n    }\n    for (ObjectIdResolver res : _objectIdResolvers) {\n        if (res.canUseFor(resolverType)) {\n            resolver = res;\n            break;\n        }\n    }\n    if (resolver == null) {\n        resolver = resolverType.newForDeserialization(this);\n        _objectIdResolvers.add(resolver);\n    }\n    entry = new ReadableObjectId(key);\n    entry.setResolver(resolver);\n    _objectIds.put(key, entry);\n    return entry;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n+++ com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n@@ -1,35 +1,29 @@\n @Override\n public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n-        final ObjectIdGenerator.IdKey key = gen.key(id);\n+    final ObjectIdGenerator.IdKey key = gen.key(id);\n     if (_objectIds == null) {\n         _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n-    } else {\n-        ReadableObjectId entry = _objectIds.get(key);\n-        if (entry != null) {\n-            return entry;\n-        }\n+    }\n+    ReadableObjectId entry = _objectIds.get(key);\n+    if (entry != null) {\n+        return entry;\n     }\n     // Not seen yet, must create entry and configure resolver.\n     ObjectIdResolver resolver = null;\n     if (_objectIdResolvers == null) {\n         _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n-    } else {\n-        for (ObjectIdResolver res : _objectIdResolvers) {\n-            if (res.canUseFor(resolverType)) {\n-                resolver = res;\n-                break;\n-            }\n+    }\n+    for (ObjectIdResolver res : _objectIdResolvers) {\n+        if (res.canUseFor(resolverType)) {\n+            resolver = res;\n+            break;\n         }\n     }\n     if (resolver == null) {\n         resolver = resolverType.newForDeserialization(this);\n-        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n-        //   needed to clear state between calls.\n-        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n-        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n-                _objectIdResolvers.add(resolver);\n+        _objectIdResolvers.add(resolver);\n     }\n-    ReadableObjectId entry = new ReadableObjectId(key);\n+    entry = new ReadableObjectId(key);\n     entry.setResolver(resolver);\n     _objectIds.put(key, entry);\n     return entry;\n--- com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n+++ com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n@@ -1,13 +1,30 @@\n @Override\n-public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n-    // note: no null checks (unlike usually); deserializer should fail if one found\n-    Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n-    roid.bindItem(instance);\n-    // also: may need to set a property value as well\n-    SettableBeanProperty idProp = _objectIdReader.idProperty;\n-    if (idProp != null) {\n-        return idProp.setAndReturn(instance, id);\n+public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n+    final ObjectIdGenerator.IdKey key = gen.key(id);\n+    if (_objectIds == null) {\n+        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n     }\n-    return instance;\n+    ReadableObjectId entry = _objectIds.get(key);\n+    if (entry != null) {\n+        return entry;\n+    }\n+    // Not seen yet, must create entry and configure resolver.\n+    ObjectIdResolver resolver = null;\n+    if (_objectIdResolvers == null) {\n+        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+    }\n+    for (ObjectIdResolver res : _objectIdResolvers) {\n+        if (res.canUseFor(resolverType)) {\n+            resolver = res;\n+            break;\n+        }\n+    }\n+    if (resolver == null) {\n+        resolver = resolverType.newForDeserialization(this);\n+        _objectIdResolvers.add(resolver);\n+    }\n+    entry = new ReadableObjectId(key);\n+    entry.setResolver(resolver);\n+    _objectIds.put(key, entry);\n+    return entry;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n    final ObjectIdGenerator.IdKey key = gen.key(id);\n    if (_objectIds == null) {\n        _objectIds = new LinkedHashMap<>();\n    } else {\n        ReadableObjectId entry = _objectIds.get(key);\n        if (entry != null) {\n            return entry;\n        }\n    }\n    // Not seen yet, must create entry and configure resolver.\n    ObjectIdResolver resolver = null;\n    if (_objectIdResolvers == null) {\n        _objectIdResolvers = new ArrayList<>(8);\n    } else {\n        for (ObjectIdResolver res : _objectIdResolvers) {\n            if (res == null) {\n                continue;\n            }\n            if (res.canUseFor(resolverType)) {\n                resolver = res;\n                break;\n            }\n        }\n    }\n    if (resolver == null) {\n        resolver = resolverType.newForDeserialization(this);\n        _objectIdResolvers.add(resolver);\n    }\n    ReadableObjectId entry = new ReadableObjectId(key);\n    entry.setResolver(resolver);\n    _objectIds.put(key, entry);\n    return entry;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n+++ com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n@@ -1,8 +1,8 @@\n @Override\n public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n-        final ObjectIdGenerator.IdKey key = gen.key(id);\n+    final ObjectIdGenerator.IdKey key = gen.key(id);\n     if (_objectIds == null) {\n-        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n+        _objectIds = new LinkedHashMap<>();\n     } else {\n         ReadableObjectId entry = _objectIds.get(key);\n         if (entry != null) {\n@@ -12,9 +12,12 @@\n     // Not seen yet, must create entry and configure resolver.\n     ObjectIdResolver resolver = null;\n     if (_objectIdResolvers == null) {\n-        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+        _objectIdResolvers = new ArrayList<>(8);\n     } else {\n         for (ObjectIdResolver res : _objectIdResolvers) {\n+            if (res == null) {\n+                continue;\n+            }\n             if (res.canUseFor(resolverType)) {\n                 resolver = res;\n                 break;\n@@ -23,11 +26,7 @@\n     }\n     if (resolver == null) {\n         resolver = resolverType.newForDeserialization(this);\n-        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n-        //   needed to clear state between calls.\n-        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n-        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n-                _objectIdResolvers.add(resolver);\n+        _objectIdResolvers.add(resolver);\n     }\n     ReadableObjectId entry = new ReadableObjectId(key);\n     entry.setResolver(resolver);\n--- com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n+++ com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n@@ -1,13 +1,35 @@\n @Override\n-public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n-    // note: no null checks (unlike usually); deserializer should fail if one found\n-    Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n-    roid.bindItem(instance);\n-    // also: may need to set a property value as well\n-    SettableBeanProperty idProp = _objectIdReader.idProperty;\n-    if (idProp != null) {\n-        return idProp.setAndReturn(instance, id);\n+public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n+    final ObjectIdGenerator.IdKey key = gen.key(id);\n+    if (_objectIds == null) {\n+        _objectIds = new LinkedHashMap<>();\n+    } else {\n+        ReadableObjectId entry = _objectIds.get(key);\n+        if (entry != null) {\n+            return entry;\n+        }\n     }\n-    return instance;\n+    // Not seen yet, must create entry and configure resolver.\n+    ObjectIdResolver resolver = null;\n+    if (_objectIdResolvers == null) {\n+        _objectIdResolvers = new ArrayList<>(8);\n+    } else {\n+        for (ObjectIdResolver res : _objectIdResolvers) {\n+            if (res == null) {\n+                continue;\n+            }\n+            if (res.canUseFor(resolverType)) {\n+                resolver = res;\n+                break;\n+            }\n+        }\n+    }\n+    if (resolver == null) {\n+        resolver = resolverType.newForDeserialization(this);\n+        _objectIdResolvers.add(resolver);\n+    }\n+    ReadableObjectId entry = new ReadableObjectId(key);\n+    entry.setResolver(resolver);\n+    _objectIds.put(key, entry);\n+    return entry;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n        final ObjectIdGenerator.IdKey key = gen.key(id);\n    if (_objectIds == null) {\n        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n    } else {\n        ReadableObjectId entry = _objectIds.get(key);\n        if (entry != null) {\n            return entry;\n        }\n    }\n    // Not seen yet, must create entry and configure resolver.\n    ObjectIdResolver resolver = null;\n    if (_objectIdResolvers == null) {\n        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n    } else {\n        for (ObjectIdResolver res : _objectIdResolvers) {\n            if (resolverType.getClass().isAssignableFrom(res.getClass())) {\n                // resolverType can be used with res\n                resolver = res;\n                break;\n            }\n        }\n    }\n    if (resolver == null) {\n        resolver = resolverType.newForDeserialization(this);\n        _objectIdResolvers.add(resolver);\n    }\n    ReadableObjectId entry = new ReadableObjectId(key);\n    entry.setResolver(resolver);\n    _objectIds.put(key, entry);\n    return entry;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n+++ com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n@@ -15,7 +15,8 @@\n         _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n     } else {\n         for (ObjectIdResolver res : _objectIdResolvers) {\n-            if (res.canUseFor(resolverType)) {\n+            if (resolverType.getClass().isAssignableFrom(res.getClass())) {\n+                // resolverType can be used with res\n                 resolver = res;\n                 break;\n             }\n@@ -23,11 +24,7 @@\n     }\n     if (resolver == null) {\n         resolver = resolverType.newForDeserialization(this);\n-        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n-        //   needed to clear state between calls.\n-        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n-        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n-                _objectIdResolvers.add(resolver);\n+        _objectIdResolvers.add(resolver);\n     }\n     ReadableObjectId entry = new ReadableObjectId(key);\n     entry.setResolver(resolver);\n--- com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n+++ com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n@@ -1,13 +1,33 @@\n @Override\n-public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n-    // note: no null checks (unlike usually); deserializer should fail if one found\n-    Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n-    roid.bindItem(instance);\n-    // also: may need to set a property value as well\n-    SettableBeanProperty idProp = _objectIdReader.idProperty;\n-    if (idProp != null) {\n-        return idProp.setAndReturn(instance, id);\n+public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n+        final ObjectIdGenerator.IdKey key = gen.key(id);\n+    if (_objectIds == null) {\n+        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n+    } else {\n+        ReadableObjectId entry = _objectIds.get(key);\n+        if (entry != null) {\n+            return entry;\n+        }\n     }\n-    return instance;\n+    // Not seen yet, must create entry and configure resolver.\n+    ObjectIdResolver resolver = null;\n+    if (_objectIdResolvers == null) {\n+        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+    } else {\n+        for (ObjectIdResolver res : _objectIdResolvers) {\n+            if (resolverType.getClass().isAssignableFrom(res.getClass())) {\n+                // resolverType can be used with res\n+                resolver = res;\n+                break;\n+            }\n+        }\n+    }\n+    if (resolver == null) {\n+        resolver = resolverType.newForDeserialization(this);\n+        _objectIdResolvers.add(resolver);\n+    }\n+    ReadableObjectId entry = new ReadableObjectId(key);\n+    entry.setResolver(resolver);\n+    _objectIds.put(key, entry);\n+    return entry;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n    final ObjectIdGenerator.IdKey key = gen.key(id);\n    if (_objectIds == null) {\n        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n    } else {\n        ReadableObjectId entry = _objectIds.get(key);\n        if (entry != null) {\n            return entry;\n        }\n    }\n    // Not seen yet, must create entry and configure resolver.\n    ObjectIdResolver resolver = null;\n    if (_objectIdResolvers == null) {\n        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n    } else {\n        for (ObjectIdResolver res : _objectIdResolvers) {\n            if (resolverType.getClass().isAssignableFrom(res.getClass())) {\n                resolver = res;\n                break;\n            }\n        }\n    }\n    if (resolver == null) {\n        resolver = resolverType.newForDeserialization(this);\n        _objectIdResolvers.add(resolver);\n    }\n    ReadableObjectId entry = new ReadableObjectId(key);\n    entry.setResolver(resolver);\n    _objectIds.put(key, entry);\n    return entry;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n+++ com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n@@ -1,6 +1,6 @@\n @Override\n public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n-        final ObjectIdGenerator.IdKey key = gen.key(id);\n+    final ObjectIdGenerator.IdKey key = gen.key(id);\n     if (_objectIds == null) {\n         _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n     } else {\n@@ -15,7 +15,7 @@\n         _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n     } else {\n         for (ObjectIdResolver res : _objectIdResolvers) {\n-            if (res.canUseFor(resolverType)) {\n+            if (resolverType.getClass().isAssignableFrom(res.getClass())) {\n                 resolver = res;\n                 break;\n             }\n@@ -23,11 +23,7 @@\n     }\n     if (resolver == null) {\n         resolver = resolverType.newForDeserialization(this);\n-        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n-        //   needed to clear state between calls.\n-        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n-        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n-                _objectIdResolvers.add(resolver);\n+        _objectIdResolvers.add(resolver);\n     }\n     ReadableObjectId entry = new ReadableObjectId(key);\n     entry.setResolver(resolver);\n--- com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n+++ com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n@@ -1,13 +1,32 @@\n @Override\n-public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n-    // note: no null checks (unlike usually); deserializer should fail if one found\n-    Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n-    roid.bindItem(instance);\n-    // also: may need to set a property value as well\n-    SettableBeanProperty idProp = _objectIdReader.idProperty;\n-    if (idProp != null) {\n-        return idProp.setAndReturn(instance, id);\n+public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n+    final ObjectIdGenerator.IdKey key = gen.key(id);\n+    if (_objectIds == null) {\n+        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n+    } else {\n+        ReadableObjectId entry = _objectIds.get(key);\n+        if (entry != null) {\n+            return entry;\n+        }\n     }\n-    return instance;\n+    // Not seen yet, must create entry and configure resolver.\n+    ObjectIdResolver resolver = null;\n+    if (_objectIdResolvers == null) {\n+        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+    } else {\n+        for (ObjectIdResolver res : _objectIdResolvers) {\n+            if (resolverType.getClass().isAssignableFrom(res.getClass())) {\n+                resolver = res;\n+                break;\n+            }\n+        }\n+    }\n+    if (resolver == null) {\n+        resolver = resolverType.newForDeserialization(this);\n+        _objectIdResolvers.add(resolver);\n+    }\n+    ReadableObjectId entry = new ReadableObjectId(key);\n+    entry.setResolver(resolver);\n+    _objectIds.put(key, entry);\n+    return entry;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n    final ObjectIdGenerator.IdKey key = gen.key(id);\n    if (_objectIds == null) {\n        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n    } else {\n        ReadableObjectId entry = _objectIds.get(key);\n        if (entry != null) {\n            return entry;\n        }\n    }\n    // Not seen yet, must create entry and configure resolver.\n    ObjectIdResolver resolver = null;\n    if (_objectIdResolvers == null) {\n        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n        //   needed to clear state between calls.\n        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n        _objectIdResolvers.add(resolverType);\n        resolver = resolverType.newForDeserialization(this);\n        resolverType = null;\n    } else {\n        for (ObjectIdResolver res : _objectIdResolvers) {\n            if (res.canUseFor(resolverType)) {\n                resolver = res;\n                break;\n            }\n        }\n        if (resolver == null) {\n            resolver = resolverType.newForDeserialization(this);\n            _objectIdResolvers.add(resolver);\n            resolverType = null;\n        }\n    }\n    ReadableObjectId entry = new ReadableObjectId(key);\n    entry.setResolver(resolver);\n    _objectIds.put(key, entry);\n    return entry;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n+++ com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n@@ -1,6 +1,6 @@\n @Override\n public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n-        final ObjectIdGenerator.IdKey key = gen.key(id);\n+    final ObjectIdGenerator.IdKey key = gen.key(id);\n     if (_objectIds == null) {\n         _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n     } else {\n@@ -13,6 +13,13 @@\n     ObjectIdResolver resolver = null;\n     if (_objectIdResolvers == null) {\n         _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n+        //   needed to clear state between calls.\n+        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n+        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n+        _objectIdResolvers.add(resolverType);\n+        resolver = resolverType.newForDeserialization(this);\n+        resolverType = null;\n     } else {\n         for (ObjectIdResolver res : _objectIdResolvers) {\n             if (res.canUseFor(resolverType)) {\n@@ -20,14 +27,11 @@\n                 break;\n             }\n         }\n-    }\n-    if (resolver == null) {\n-        resolver = resolverType.newForDeserialization(this);\n-        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n-        //   needed to clear state between calls.\n-        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n-        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n-                _objectIdResolvers.add(resolver);\n+        if (resolver == null) {\n+            resolver = resolverType.newForDeserialization(this);\n+            _objectIdResolvers.add(resolver);\n+            resolverType = null;\n+        }\n     }\n     ReadableObjectId entry = new ReadableObjectId(key);\n     entry.setResolver(resolver);\n--- com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n+++ com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n@@ -1,13 +1,40 @@\n @Override\n-public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n-    // note: no null checks (unlike usually); deserializer should fail if one found\n-    Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n-    roid.bindItem(instance);\n-    // also: may need to set a property value as well\n-    SettableBeanProperty idProp = _objectIdReader.idProperty;\n-    if (idProp != null) {\n-        return idProp.setAndReturn(instance, id);\n+public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n+    final ObjectIdGenerator.IdKey key = gen.key(id);\n+    if (_objectIds == null) {\n+        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n+    } else {\n+        ReadableObjectId entry = _objectIds.get(key);\n+        if (entry != null) {\n+            return entry;\n+        }\n     }\n-    return instance;\n+    // Not seen yet, must create entry and configure resolver.\n+    ObjectIdResolver resolver = null;\n+    if (_objectIdResolvers == null) {\n+        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n+        //   needed to clear state between calls.\n+        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n+        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n+        _objectIdResolvers.add(resolverType);\n+        resolver = resolverType.newForDeserialization(this);\n+        resolverType = null;\n+    } else {\n+        for (ObjectIdResolver res : _objectIdResolvers) {\n+            if (res.canUseFor(resolverType)) {\n+                resolver = res;\n+                break;\n+            }\n+        }\n+        if (resolver == null) {\n+            resolver = resolverType.newForDeserialization(this);\n+            _objectIdResolvers.add(resolver);\n+            resolverType = null;\n+        }\n+    }\n+    ReadableObjectId entry = new ReadableObjectId(key);\n+    entry.setResolver(resolver);\n+    _objectIds.put(key, entry);\n+    return entry;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n        final ObjectIdGenerator.IdKey key = gen.key(id);\n    if (_objectIds == null) {\n        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n    }\n    ReadableObjectId entry = _objectIds.get(key); // moved outside the else block\n    if (entry != null) {\n        return entry;\n    } else {\n        // Not seen yet, must create entry and configure resolver.\n        ObjectIdResolver resolver = null;\n        if (_objectIdResolvers == null) {\n            _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n        }\n        for (ObjectIdResolver res : _objectIdResolvers) {\n            if (res.canUseFor(resolverType)) {\n                resolver = res;\n                break;\n            }\n        }\n        if (resolver == null) {\n            resolver = resolverType.newForDeserialization(this);\n            // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n            //   needed to clear state between calls.\n            // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n            //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n            _objectIdResolvers.add(resolver);\n        }\n        entry = new ReadableObjectId(key); // changed variable name & moved instantiation\n        entry.setResolver(resolver);\n        _objectIds.put(key, entry);\n        return entry;\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n+++ com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n@@ -3,34 +3,33 @@\n         final ObjectIdGenerator.IdKey key = gen.key(id);\n     if (_objectIds == null) {\n         _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n+    }\n+    ReadableObjectId entry = _objectIds.get(key); // moved outside the else block\n+    if (entry != null) {\n+        return entry;\n     } else {\n-        ReadableObjectId entry = _objectIds.get(key);\n-        if (entry != null) {\n-            return entry;\n+        // Not seen yet, must create entry and configure resolver.\n+        ObjectIdResolver resolver = null;\n+        if (_objectIdResolvers == null) {\n+            _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n         }\n-    }\n-    // Not seen yet, must create entry and configure resolver.\n-    ObjectIdResolver resolver = null;\n-    if (_objectIdResolvers == null) {\n-        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n-    } else {\n         for (ObjectIdResolver res : _objectIdResolvers) {\n             if (res.canUseFor(resolverType)) {\n                 resolver = res;\n                 break;\n             }\n         }\n+        if (resolver == null) {\n+            resolver = resolverType.newForDeserialization(this);\n+            // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n+            //   needed to clear state between calls.\n+            // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n+            //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n+            _objectIdResolvers.add(resolver);\n+        }\n+        entry = new ReadableObjectId(key); // changed variable name & moved instantiation\n+        entry.setResolver(resolver);\n+        _objectIds.put(key, entry);\n+        return entry;\n     }\n-    if (resolver == null) {\n-        resolver = resolverType.newForDeserialization(this);\n-        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n-        //   needed to clear state between calls.\n-        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n-        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n-                _objectIdResolvers.add(resolver);\n-    }\n-    ReadableObjectId entry = new ReadableObjectId(key);\n-    entry.setResolver(resolver);\n-    _objectIds.put(key, entry);\n-    return entry;\n }\n--- com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n+++ com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n@@ -1,13 +1,35 @@\n @Override\n-public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n-    // note: no null checks (unlike usually); deserializer should fail if one found\n-    Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n-    roid.bindItem(instance);\n-    // also: may need to set a property value as well\n-    SettableBeanProperty idProp = _objectIdReader.idProperty;\n-    if (idProp != null) {\n-        return idProp.setAndReturn(instance, id);\n+public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n+        final ObjectIdGenerator.IdKey key = gen.key(id);\n+    if (_objectIds == null) {\n+        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n     }\n-    return instance;\n+    ReadableObjectId entry = _objectIds.get(key); // moved outside the else block\n+    if (entry != null) {\n+        return entry;\n+    } else {\n+        // Not seen yet, must create entry and configure resolver.\n+        ObjectIdResolver resolver = null;\n+        if (_objectIdResolvers == null) {\n+            _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+        }\n+        for (ObjectIdResolver res : _objectIdResolvers) {\n+            if (res.canUseFor(resolverType)) {\n+                resolver = res;\n+                break;\n+            }\n+        }\n+        if (resolver == null) {\n+            resolver = resolverType.newForDeserialization(this);\n+            // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n+            //   needed to clear state between calls.\n+            // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n+            //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n+            _objectIdResolvers.add(resolver);\n+        }\n+        entry = new ReadableObjectId(key); // changed variable name & moved instantiation\n+        entry.setResolver(resolver);\n+        _objectIds.put(key, entry);\n+        return entry;\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n        final ObjectIdGenerator.IdKey key = gen.key(id);\n    if (_objectIds == null) {\n        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n    }\n    ReadableObjectId entry = _objectIds.get(key);\n    if (entry != null) {\n        return entry;\n    }\n    // Not seen yet, must create entry and configure resolver.\n    ObjectIdResolver resolver = null;\n    if (_objectIdResolvers == null) {\n        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n    }\n    for (ObjectIdResolver res : _objectIdResolvers) {\n        if (res.canUseFor(resolverType)) {\n            resolver = res;\n            break;\n        }\n    }\n    if (resolver == null) {\n        resolver = resolverType.newForDeserialization(this);\n        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n        //   needed to clear state between calls.\n        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n                _objectIdResolvers.add(resolver);\n    }\n    entry = new ReadableObjectId(key);\n    entry.setResolver(resolver);\n    _objectIds.put(key, entry);\n    return entry;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n+++ com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n@@ -3,22 +3,20 @@\n         final ObjectIdGenerator.IdKey key = gen.key(id);\n     if (_objectIds == null) {\n         _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n-    } else {\n-        ReadableObjectId entry = _objectIds.get(key);\n-        if (entry != null) {\n-            return entry;\n-        }\n+    }\n+    ReadableObjectId entry = _objectIds.get(key);\n+    if (entry != null) {\n+        return entry;\n     }\n     // Not seen yet, must create entry and configure resolver.\n     ObjectIdResolver resolver = null;\n     if (_objectIdResolvers == null) {\n         _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n-    } else {\n-        for (ObjectIdResolver res : _objectIdResolvers) {\n-            if (res.canUseFor(resolverType)) {\n-                resolver = res;\n-                break;\n-            }\n+    }\n+    for (ObjectIdResolver res : _objectIdResolvers) {\n+        if (res.canUseFor(resolverType)) {\n+            resolver = res;\n+            break;\n         }\n     }\n     if (resolver == null) {\n@@ -29,7 +27,7 @@\n         //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n                 _objectIdResolvers.add(resolver);\n     }\n-    ReadableObjectId entry = new ReadableObjectId(key);\n+    entry = new ReadableObjectId(key);\n     entry.setResolver(resolver);\n     _objectIds.put(key, entry);\n     return entry;\n--- com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n+++ com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n@@ -1,13 +1,34 @@\n @Override\n-public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n-    // note: no null checks (unlike usually); deserializer should fail if one found\n-    Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n-    roid.bindItem(instance);\n-    // also: may need to set a property value as well\n-    SettableBeanProperty idProp = _objectIdReader.idProperty;\n-    if (idProp != null) {\n-        return idProp.setAndReturn(instance, id);\n+public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n+        final ObjectIdGenerator.IdKey key = gen.key(id);\n+    if (_objectIds == null) {\n+        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n     }\n-    return instance;\n+    ReadableObjectId entry = _objectIds.get(key);\n+    if (entry != null) {\n+        return entry;\n+    }\n+    // Not seen yet, must create entry and configure resolver.\n+    ObjectIdResolver resolver = null;\n+    if (_objectIdResolvers == null) {\n+        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+    }\n+    for (ObjectIdResolver res : _objectIdResolvers) {\n+        if (res.canUseFor(resolverType)) {\n+            resolver = res;\n+            break;\n+        }\n+    }\n+    if (resolver == null) {\n+        resolver = resolverType.newForDeserialization(this);\n+        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n+        //   needed to clear state between calls.\n+        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n+        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n+                _objectIdResolvers.add(resolver);\n+    }\n+    entry = new ReadableObjectId(key);\n+    entry.setResolver(resolver);\n+    _objectIds.put(key, entry);\n+    return entry;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n        final ObjectIdGenerator.IdKey key = gen.key(id);\n    if (_objectIds == null) {\n        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n    }\n    // Fixed the else to include else if statement\n    else if (_objectIds.containsKey(key)) {\n        return _objectIds.get(key);\n    }\n    else {\n        // Not seen yet, must create entry and configure resolver.\n        ObjectIdResolver resolver = null;\n        if (_objectIdResolvers == null) {\n            _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n        } else {\n            for (ObjectIdResolver res : _objectIdResolvers) {\n                if (res.canUseFor(resolverType)) {\n                    resolver = res;\n                    break;\n                }\n            }\n        }\n        if (resolver == null) {\n            resolver = resolverType.newForDeserialization(this);\n            // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n            //   needed to clear state between calls.\n            // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n            //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n            _objectIdResolvers.add(resolver);\n        }\n        ReadableObjectId entry = new ReadableObjectId(key);\n        entry.setResolver(resolver);\n        _objectIds.put(key, entry);\n        return entry;\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n+++ com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n@@ -3,34 +3,35 @@\n         final ObjectIdGenerator.IdKey key = gen.key(id);\n     if (_objectIds == null) {\n         _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n-    } else {\n-        ReadableObjectId entry = _objectIds.get(key);\n-        if (entry != null) {\n-            return entry;\n-        }\n     }\n-    // Not seen yet, must create entry and configure resolver.\n-    ObjectIdResolver resolver = null;\n-    if (_objectIdResolvers == null) {\n-        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n-    } else {\n-        for (ObjectIdResolver res : _objectIdResolvers) {\n-            if (res.canUseFor(resolverType)) {\n-                resolver = res;\n-                break;\n+    // Fixed the else to include else if statement\n+    else if (_objectIds.containsKey(key)) {\n+        return _objectIds.get(key);\n+    }\n+    else {\n+        // Not seen yet, must create entry and configure resolver.\n+        ObjectIdResolver resolver = null;\n+        if (_objectIdResolvers == null) {\n+            _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+        } else {\n+            for (ObjectIdResolver res : _objectIdResolvers) {\n+                if (res.canUseFor(resolverType)) {\n+                    resolver = res;\n+                    break;\n+                }\n             }\n         }\n+        if (resolver == null) {\n+            resolver = resolverType.newForDeserialization(this);\n+            // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n+            //   needed to clear state between calls.\n+            // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n+            //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n+            _objectIdResolvers.add(resolver);\n+        }\n+        ReadableObjectId entry = new ReadableObjectId(key);\n+        entry.setResolver(resolver);\n+        _objectIds.put(key, entry);\n+        return entry;\n     }\n-    if (resolver == null) {\n-        resolver = resolverType.newForDeserialization(this);\n-        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n-        //   needed to clear state between calls.\n-        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n-        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n-                _objectIdResolvers.add(resolver);\n-    }\n-    ReadableObjectId entry = new ReadableObjectId(key);\n-    entry.setResolver(resolver);\n-    _objectIds.put(key, entry);\n-    return entry;\n }\n--- com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n+++ com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n@@ -1,13 +1,37 @@\n @Override\n-public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n-    // note: no null checks (unlike usually); deserializer should fail if one found\n-    Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n-    roid.bindItem(instance);\n-    // also: may need to set a property value as well\n-    SettableBeanProperty idProp = _objectIdReader.idProperty;\n-    if (idProp != null) {\n-        return idProp.setAndReturn(instance, id);\n+public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n+        final ObjectIdGenerator.IdKey key = gen.key(id);\n+    if (_objectIds == null) {\n+        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n     }\n-    return instance;\n+    // Fixed the else to include else if statement\n+    else if (_objectIds.containsKey(key)) {\n+        return _objectIds.get(key);\n+    }\n+    else {\n+        // Not seen yet, must create entry and configure resolver.\n+        ObjectIdResolver resolver = null;\n+        if (_objectIdResolvers == null) {\n+            _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+        } else {\n+            for (ObjectIdResolver res : _objectIdResolvers) {\n+                if (res.canUseFor(resolverType)) {\n+                    resolver = res;\n+                    break;\n+                }\n+            }\n+        }\n+        if (resolver == null) {\n+            resolver = resolverType.newForDeserialization(this);\n+            // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n+            //   needed to clear state between calls.\n+            // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n+            //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n+            _objectIdResolvers.add(resolver);\n+        }\n+        ReadableObjectId entry = new ReadableObjectId(key);\n+        entry.setResolver(resolver);\n+        _objectIds.put(key, entry);\n+        return entry;\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n        final ObjectIdGenerator.IdKey key = gen.key(id);\n    if (_objectIds == null) {\n        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n    } else {\n        ReadableObjectId entry = _objectIds.get(key);\n        if (entry != null) {\n            return entry;\n        }\n    }\n    // Not seen yet, must create entry and configure resolver.\n    ObjectIdResolver resolver = null;\n    if (_objectIdResolvers == null) {\n        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n    } else {\n        for (int i = 0; i < _objectIdResolvers.size(); i++) {\n            ObjectIdResolver res = _objectIdResolvers.get(i);\n            if (res.canUseFor(resolverType)) {\n                resolver = res;\n                break;\n            }\n        }\n    }\n    if (resolver == null) {\n        resolver = resolverType.newForDeserialization(this);\n        _objectIdResolvers.add(resolver);\n    }\n    ReadableObjectId entry = new ReadableObjectId(key);\n    entry.setResolver(resolver);\n    _objectIds.put(key, entry);\n    return entry;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n+++ com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n@@ -14,7 +14,8 @@\n     if (_objectIdResolvers == null) {\n         _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n     } else {\n-        for (ObjectIdResolver res : _objectIdResolvers) {\n+        for (int i = 0; i < _objectIdResolvers.size(); i++) {\n+            ObjectIdResolver res = _objectIdResolvers.get(i);\n             if (res.canUseFor(resolverType)) {\n                 resolver = res;\n                 break;\n@@ -23,11 +24,7 @@\n     }\n     if (resolver == null) {\n         resolver = resolverType.newForDeserialization(this);\n-        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n-        //   needed to clear state between calls.\n-        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n-        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n-                _objectIdResolvers.add(resolver);\n+        _objectIdResolvers.add(resolver);\n     }\n     ReadableObjectId entry = new ReadableObjectId(key);\n     entry.setResolver(resolver);\n--- com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n+++ com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n@@ -1,13 +1,33 @@\n @Override\n-public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n-    // note: no null checks (unlike usually); deserializer should fail if one found\n-    Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n-    roid.bindItem(instance);\n-    // also: may need to set a property value as well\n-    SettableBeanProperty idProp = _objectIdReader.idProperty;\n-    if (idProp != null) {\n-        return idProp.setAndReturn(instance, id);\n+public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n+        final ObjectIdGenerator.IdKey key = gen.key(id);\n+    if (_objectIds == null) {\n+        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n+    } else {\n+        ReadableObjectId entry = _objectIds.get(key);\n+        if (entry != null) {\n+            return entry;\n+        }\n     }\n-    return instance;\n+    // Not seen yet, must create entry and configure resolver.\n+    ObjectIdResolver resolver = null;\n+    if (_objectIdResolvers == null) {\n+        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+    } else {\n+        for (int i = 0; i < _objectIdResolvers.size(); i++) {\n+            ObjectIdResolver res = _objectIdResolvers.get(i);\n+            if (res.canUseFor(resolverType)) {\n+                resolver = res;\n+                break;\n+            }\n+        }\n+    }\n+    if (resolver == null) {\n+        resolver = resolverType.newForDeserialization(this);\n+        _objectIdResolvers.add(resolver);\n+    }\n+    ReadableObjectId entry = new ReadableObjectId(key);\n+    entry.setResolver(resolver);\n+    _objectIds.put(key, entry);\n+    return entry;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n        final ObjectIdGenerator.IdKey key = gen.key(id);\n    if (_objectIds == null) {\n        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n    }\n    // Check if object already exists in map, return if it does\n    ReadableObjectId entry = _objectIds.get(key);\n    if (entry != null) {\n        return entry;\n    }\n    \n    // Not seen yet, must create entry and configure resolver.\n    ObjectIdResolver resolver = null;\n    if (_objectIdResolvers == null) {\n        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n    } else {\n        for (ObjectIdResolver res : _objectIdResolvers) {\n            if (res.canUseFor(resolverType)) {\n                resolver = res;\n                break;\n            }\n        }\n    }\n    if (resolver == null) {\n        resolver = resolverType.newForDeserialization(this);\n        _objectIdResolvers.add(resolver);\n    }\n    entry = new ReadableObjectId(key);\n    entry.setResolver(resolver);\n    _objectIds.put(key, entry);\n    return entry;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n+++ com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java@findObjectId\n@@ -3,12 +3,13 @@\n         final ObjectIdGenerator.IdKey key = gen.key(id);\n     if (_objectIds == null) {\n         _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n-    } else {\n-        ReadableObjectId entry = _objectIds.get(key);\n-        if (entry != null) {\n-            return entry;\n-        }\n     }\n+    // Check if object already exists in map, return if it does\n+    ReadableObjectId entry = _objectIds.get(key);\n+    if (entry != null) {\n+        return entry;\n+    }\n+    \n     // Not seen yet, must create entry and configure resolver.\n     ObjectIdResolver resolver = null;\n     if (_objectIdResolvers == null) {\n@@ -23,13 +24,9 @@\n     }\n     if (resolver == null) {\n         resolver = resolverType.newForDeserialization(this);\n-        // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n-        //   needed to clear state between calls.\n-        // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n-        //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n-                _objectIdResolvers.add(resolver);\n+        _objectIdResolvers.add(resolver);\n     }\n-    ReadableObjectId entry = new ReadableObjectId(key);\n+    entry = new ReadableObjectId(key);\n     entry.setResolver(resolver);\n     _objectIds.put(key, entry);\n     return entry;\n--- com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n+++ com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java@deserializeSetAndReturn\n@@ -1,13 +1,33 @@\n @Override\n-public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n-    // note: no null checks (unlike usually); deserializer should fail if one found\n-    Object id = _valueDeserializer.deserialize(jp, ctxt);\n-        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n-    roid.bindItem(instance);\n-    // also: may need to set a property value as well\n-    SettableBeanProperty idProp = _objectIdReader.idProperty;\n-    if (idProp != null) {\n-        return idProp.setAndReturn(instance, id);\n+public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType) {\n+        final ObjectIdGenerator.IdKey key = gen.key(id);\n+    if (_objectIds == null) {\n+        _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey, ReadableObjectId>();\n     }\n-    return instance;\n+    // Check if object already exists in map, return if it does\n+    ReadableObjectId entry = _objectIds.get(key);\n+    if (entry != null) {\n+        return entry;\n+    }\n+    \n+    // Not seen yet, must create entry and configure resolver.\n+    ObjectIdResolver resolver = null;\n+    if (_objectIdResolvers == null) {\n+        _objectIdResolvers = new ArrayList<ObjectIdResolver>(8);\n+    } else {\n+        for (ObjectIdResolver res : _objectIdResolvers) {\n+            if (res.canUseFor(resolverType)) {\n+                resolver = res;\n+                break;\n+            }\n+        }\n+    }\n+    if (resolver == null) {\n+        resolver = resolverType.newForDeserialization(this);\n+        _objectIdResolvers.add(resolver);\n+    }\n+    entry = new ReadableObjectId(key);\n+    entry.setResolver(resolver);\n+    _objectIds.put(key, entry);\n+    return entry;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]