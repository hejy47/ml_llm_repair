[{"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n        boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n                    }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n                // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                break dummy_loop;\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n\n            boolean isValidStartOfNumber = false;\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                isValidStartOfNumber = true;\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (!isValidStartOfNumber) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                break dummy_loop;\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -52,6 +52,7 @@\n             // must be followed by sequence of ints, one minimum\n             if (fractLen == 0) {\n                 reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n+                break dummy_loop;\n             }\n         }\n         int expLen = 0;\n@@ -69,16 +70,20 @@\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n+\n+            boolean isValidStartOfNumber = false;\n             while (ch <= INT_9 && ch >= INT_0) {\n                 ++expLen;\n+                isValidStartOfNumber = true;\n                 if (ptr >= inputLen) {\n                     break dummy_loop;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n             // must be followed by sequence of ints, one minimum\n-            if (expLen == 0) {\n+            if (!isValidStartOfNumber) {\n                 reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n+                break dummy_loop;\n             }\n         }\n         // Got it all: let's add to text buffer for parsing, access\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n    boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n        // already got one\n        int intLen = 0;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n            if (ptr >= inputLen) {\n                ch = -1;\n                break int_loop;\n            }\n            ch = (int) _inputBuffer[ptr++];\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0 && intLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -1,5 +1,5 @@\n protected JsonToken _parseNumber(int ch) throws IOException {\n-        boolean negative = (ch == INT_MINUS);\n+    boolean negative = (ch == INT_MINUS);\n     int ptr = _inputPtr;\n     // to include sign/digit already read\n     int startPtr = ptr - 1;\n@@ -17,23 +17,24 @@\n                 _inputPtr = ptr;\n                 return _handleInvalidNumberStart(ch, true);\n             }\n-                    }\n+        }\n         // One special case, leading zero(es):\n         if (ch == INT_0) {\n             break dummy_loop;\n         }\n-                // already got one\n-        int intLen = 1;\n+        // already got one\n+        int intLen = 0;\n         // First let's get the obligatory integer part:\n         int_loop: while (true) {\n-            if (ptr >= _inputEnd) {\n-                break dummy_loop;\n-            }\n-            ch = (int) _inputBuffer[ptr++];\n             if (ch < INT_0 || ch > INT_9) {\n                 break int_loop;\n             }\n             ++intLen;\n+            if (ptr >= inputLen) {\n+                ch = -1;\n+                break int_loop;\n+            }\n+            ch = (int) _inputBuffer[ptr++];\n         }\n         int fractLen = 0;\n         // And then see if we get other parts\n@@ -50,7 +51,7 @@\n                 ++fractLen;\n             }\n             // must be followed by sequence of ints, one minimum\n-            if (fractLen == 0) {\n+            if (fractLen == 0 && intLen == 0) {\n                 reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n             }\n         }\n@@ -90,6 +91,6 @@\n         _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n         return reset(negative, intLen, fractLen, expLen);\n     } while (false);\n-    _inputPtr = negative ? (startPtr + 1) : startPtr;\n+    _inputPtr = startPtr;\n     return _parseNumber2(negative);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n        boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n                // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break int_loop;\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                --ptr; // fix: push pointer back\n                break int_loop;\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break fract_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    --ptr; // fix: push pointer back\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    break;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    // fix: push pointer back\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -17,7 +17,7 @@\n                 _inputPtr = ptr;\n                 return _handleInvalidNumberStart(ch, true);\n             }\n-                    }\n+        }\n         // One special case, leading zero(es):\n         if (ch == INT_0) {\n             break dummy_loop;\n@@ -27,10 +27,11 @@\n         // First let's get the obligatory integer part:\n         int_loop: while (true) {\n             if (ptr >= _inputEnd) {\n-                break dummy_loop;\n+                break int_loop;\n             }\n             ch = (int) _inputBuffer[ptr++];\n             if (ch < INT_0 || ch > INT_9) {\n+                --ptr; // fix: push pointer back\n                 break int_loop;\n             }\n             ++intLen;\n@@ -41,10 +42,11 @@\n             // yes, fraction\n             fract_loop: while (true) {\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break fract_loop;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n                 if (ch < INT_0 || ch > INT_9) {\n+                    --ptr; // fix: push pointer back\n                     break fract_loop;\n                 }\n                 ++fractLen;\n@@ -72,7 +74,7 @@\n             while (ch <= INT_9 && ch >= INT_0) {\n                 ++expLen;\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n@@ -90,6 +92,7 @@\n         _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n         return reset(negative, intLen, fractLen, expLen);\n     } while (false);\n+    // fix: push pointer back\n     _inputPtr = negative ? (startPtr + 1) : startPtr;\n     return _parseNumber2(negative);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n        boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n        // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break int_loop;\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                --ptr; // fix added\n                break int_loop;\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break fract_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    --ptr; // fix added\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    break;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -17,20 +17,21 @@\n                 _inputPtr = ptr;\n                 return _handleInvalidNumberStart(ch, true);\n             }\n-                    }\n+        }\n         // One special case, leading zero(es):\n         if (ch == INT_0) {\n             break dummy_loop;\n         }\n-                // already got one\n+        // already got one\n         int intLen = 1;\n         // First let's get the obligatory integer part:\n         int_loop: while (true) {\n             if (ptr >= _inputEnd) {\n-                break dummy_loop;\n+                break int_loop;\n             }\n             ch = (int) _inputBuffer[ptr++];\n             if (ch < INT_0 || ch > INT_9) {\n+                --ptr; // fix added\n                 break int_loop;\n             }\n             ++intLen;\n@@ -41,10 +42,11 @@\n             // yes, fraction\n             fract_loop: while (true) {\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break fract_loop;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n                 if (ch < INT_0 || ch > INT_9) {\n+                    --ptr; // fix added\n                     break fract_loop;\n                 }\n                 ++fractLen;\n@@ -72,7 +74,7 @@\n             while (ch <= INT_9 && ch >= INT_0) {\n                 ++expLen;\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n    boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n        // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                --ptr;\n                break int_loop;\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    --ptr;\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -1,5 +1,5 @@\n protected JsonToken _parseNumber(int ch) throws IOException {\n-        boolean negative = (ch == INT_MINUS);\n+    boolean negative = (ch == INT_MINUS);\n     int ptr = _inputPtr;\n     // to include sign/digit already read\n     int startPtr = ptr - 1;\n@@ -17,12 +17,12 @@\n                 _inputPtr = ptr;\n                 return _handleInvalidNumberStart(ch, true);\n             }\n-                    }\n+        }\n         // One special case, leading zero(es):\n         if (ch == INT_0) {\n             break dummy_loop;\n         }\n-                // already got one\n+        // already got one\n         int intLen = 1;\n         // First let's get the obligatory integer part:\n         int_loop: while (true) {\n@@ -31,6 +31,7 @@\n             }\n             ch = (int) _inputBuffer[ptr++];\n             if (ch < INT_0 || ch > INT_9) {\n+                --ptr;\n                 break int_loop;\n             }\n             ++intLen;\n@@ -45,6 +46,7 @@\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n                 if (ch < INT_0 || ch > INT_9) {\n+                    --ptr;\n                     break fract_loop;\n                 }\n                 ++fractLen;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n    boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n        // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break;\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                ptr--;\n                break;\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    ptr--;\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    break;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -1,5 +1,5 @@\n protected JsonToken _parseNumber(int ch) throws IOException {\n-        boolean negative = (ch == INT_MINUS);\n+    boolean negative = (ch == INT_MINUS);\n     int ptr = _inputPtr;\n     // to include sign/digit already read\n     int startPtr = ptr - 1;\n@@ -17,21 +17,22 @@\n                 _inputPtr = ptr;\n                 return _handleInvalidNumberStart(ch, true);\n             }\n-                    }\n+        }\n         // One special case, leading zero(es):\n         if (ch == INT_0) {\n             break dummy_loop;\n         }\n-                // already got one\n+        // already got one\n         int intLen = 1;\n         // First let's get the obligatory integer part:\n         int_loop: while (true) {\n             if (ptr >= _inputEnd) {\n-                break dummy_loop;\n+                break;\n             }\n             ch = (int) _inputBuffer[ptr++];\n             if (ch < INT_0 || ch > INT_9) {\n-                break int_loop;\n+                ptr--;\n+                break;\n             }\n             ++intLen;\n         }\n@@ -41,10 +42,11 @@\n             // yes, fraction\n             fract_loop: while (true) {\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n                 if (ch < INT_0 || ch > INT_9) {\n+                    ptr--;\n                     break fract_loop;\n                 }\n                 ++fractLen;\n@@ -58,21 +60,21 @@\n         if (ch == 'e' || ch == 'E') {\n             // and/or exponent\n             if (ptr >= inputLen) {\n-                break dummy_loop;\n+                break;\n             }\n             // Sign indicator?\n             ch = (int) _inputBuffer[ptr++];\n             if (ch == INT_MINUS || ch == INT_PLUS) {\n                 // yup, skip for now\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n             while (ch <= INT_9 && ch >= INT_0) {\n                 ++expLen;\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n    boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n        // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                // fixed bug: if ch is a period, break int_loop and continue on to fract_loop\n                if (ch == INT_PERIOD) {\n                    break int_loop;\n                } else {\n                    break dummy_loop;\n                }\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -1,5 +1,5 @@\n protected JsonToken _parseNumber(int ch) throws IOException {\n-        boolean negative = (ch == INT_MINUS);\n+    boolean negative = (ch == INT_MINUS);\n     int ptr = _inputPtr;\n     // to include sign/digit already read\n     int startPtr = ptr - 1;\n@@ -17,12 +17,12 @@\n                 _inputPtr = ptr;\n                 return _handleInvalidNumberStart(ch, true);\n             }\n-                    }\n+        }\n         // One special case, leading zero(es):\n         if (ch == INT_0) {\n             break dummy_loop;\n         }\n-                // already got one\n+        // already got one\n         int intLen = 1;\n         // First let's get the obligatory integer part:\n         int_loop: while (true) {\n@@ -31,7 +31,12 @@\n             }\n             ch = (int) _inputBuffer[ptr++];\n             if (ch < INT_0 || ch > INT_9) {\n-                break int_loop;\n+                // fixed bug: if ch is a period, break int_loop and continue on to fract_loop\n+                if (ch == INT_PERIOD) {\n+                    break int_loop;\n+                } else {\n+                    break dummy_loop;\n+                }\n             }\n             ++intLen;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n        boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n        // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break int_loop;\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break fract_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    break;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -17,17 +17,17 @@\n                 _inputPtr = ptr;\n                 return _handleInvalidNumberStart(ch, true);\n             }\n-                    }\n+        }\n         // One special case, leading zero(es):\n         if (ch == INT_0) {\n             break dummy_loop;\n         }\n-                // already got one\n+        // already got one\n         int intLen = 1;\n         // First let's get the obligatory integer part:\n         int_loop: while (true) {\n             if (ptr >= _inputEnd) {\n-                break dummy_loop;\n+                break int_loop;\n             }\n             ch = (int) _inputBuffer[ptr++];\n             if (ch < INT_0 || ch > INT_9) {\n@@ -41,7 +41,7 @@\n             // yes, fraction\n             fract_loop: while (true) {\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break fract_loop;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n                 if (ch < INT_0 || ch > INT_9) {\n@@ -72,7 +72,7 @@\n             while (ch <= INT_9 && ch >= INT_0) {\n                 ++expLen;\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n        boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n                    }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n                // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break int_loop;\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break fract_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    break;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -27,7 +27,7 @@\n         // First let's get the obligatory integer part:\n         int_loop: while (true) {\n             if (ptr >= _inputEnd) {\n-                break dummy_loop;\n+                break int_loop;\n             }\n             ch = (int) _inputBuffer[ptr++];\n             if (ch < INT_0 || ch > INT_9) {\n@@ -41,7 +41,7 @@\n             // yes, fraction\n             fract_loop: while (true) {\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break fract_loop;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n                 if (ch < INT_0 || ch > INT_9) {\n@@ -72,7 +72,7 @@\n             while (ch <= INT_9 && ch >= INT_0) {\n                 ++expLen;\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n    boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n        // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                return null;\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                return null;\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -1,5 +1,5 @@\n protected JsonToken _parseNumber(int ch) throws IOException {\n-        boolean negative = (ch == INT_MINUS);\n+    boolean negative = (ch == INT_MINUS);\n     int ptr = _inputPtr;\n     // to include sign/digit already read\n     int startPtr = ptr - 1;\n@@ -17,12 +17,12 @@\n                 _inputPtr = ptr;\n                 return _handleInvalidNumberStart(ch, true);\n             }\n-                    }\n+        }\n         // One special case, leading zero(es):\n         if (ch == INT_0) {\n             break dummy_loop;\n         }\n-                // already got one\n+        // already got one\n         int intLen = 1;\n         // First let's get the obligatory integer part:\n         int_loop: while (true) {\n@@ -52,6 +52,7 @@\n             // must be followed by sequence of ints, one minimum\n             if (fractLen == 0) {\n                 reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n+                return null;\n             }\n         }\n         int expLen = 0;\n@@ -79,6 +80,7 @@\n             // must be followed by sequence of ints, one minimum\n             if (expLen == 0) {\n                 reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n+                return null;\n             }\n         }\n         // Got it all: let's add to text buffer for parsing, access\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n        boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n                    }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n                // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break int_loop;\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break fract_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    break;  // fix: break out of while loop instead of dummy loop\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -27,7 +27,7 @@\n         // First let's get the obligatory integer part:\n         int_loop: while (true) {\n             if (ptr >= _inputEnd) {\n-                break dummy_loop;\n+                break int_loop;\n             }\n             ch = (int) _inputBuffer[ptr++];\n             if (ch < INT_0 || ch > INT_9) {\n@@ -41,7 +41,7 @@\n             // yes, fraction\n             fract_loop: while (true) {\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break fract_loop;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n                 if (ch < INT_0 || ch > INT_9) {\n@@ -72,7 +72,7 @@\n             while (ch <= INT_9 && ch >= INT_0) {\n                 ++expLen;\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break;  // fix: break out of while loop instead of dummy loop\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n        boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n                    }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n                // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                --ptr; // Fixes issue #479\n                break int_loop;\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    --ptr; // Fixes issue #479\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    break;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -31,6 +31,7 @@\n             }\n             ch = (int) _inputBuffer[ptr++];\n             if (ch < INT_0 || ch > INT_9) {\n+                --ptr; // Fixes issue #479\n                 break int_loop;\n             }\n             ++intLen;\n@@ -45,6 +46,7 @@\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n                 if (ch < INT_0 || ch > INT_9) {\n+                    --ptr; // Fixes issue #479\n                     break fract_loop;\n                 }\n                 ++fractLen;\n@@ -72,7 +74,7 @@\n             while (ch <= INT_9 && ch >= INT_0) {\n                 ++expLen;\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n        boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n                    }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n                // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            boolean hasDigits = false; // add check for digits after exponent sign\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                hasDigits = true;  // mark digit existence\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (!hasDigits) { // fix condition\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -69,15 +69,17 @@\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n+            boolean hasDigits = false; // add check for digits after exponent sign\n             while (ch <= INT_9 && ch >= INT_0) {\n                 ++expLen;\n+                hasDigits = true;  // mark digit existence\n                 if (ptr >= inputLen) {\n                     break dummy_loop;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n             // must be followed by sequence of ints, one minimum\n-            if (expLen == 0) {\n+            if (!hasDigits) { // fix condition\n                 reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n             }\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n        boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n        // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break;\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    break;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -17,17 +17,17 @@\n                 _inputPtr = ptr;\n                 return _handleInvalidNumberStart(ch, true);\n             }\n-                    }\n+        }\n         // One special case, leading zero(es):\n         if (ch == INT_0) {\n             break dummy_loop;\n         }\n-                // already got one\n+        // already got one\n         int intLen = 1;\n         // First let's get the obligatory integer part:\n         int_loop: while (true) {\n             if (ptr >= _inputEnd) {\n-                break dummy_loop;\n+                break;\n             }\n             ch = (int) _inputBuffer[ptr++];\n             if (ch < INT_0 || ch > INT_9) {\n@@ -41,7 +41,7 @@\n             // yes, fraction\n             fract_loop: while (true) {\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n                 if (ch < INT_0 || ch > INT_9) {\n@@ -72,7 +72,7 @@\n             while (ch <= INT_9 && ch >= INT_0) {\n                 ++expLen;\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n        boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n        // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break dummy_loop;  \n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break int_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    break;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -17,17 +17,17 @@\n                 _inputPtr = ptr;\n                 return _handleInvalidNumberStart(ch, true);\n             }\n-                    }\n+        }\n         // One special case, leading zero(es):\n         if (ch == INT_0) {\n             break dummy_loop;\n         }\n-                // already got one\n+        // already got one\n         int intLen = 1;\n         // First let's get the obligatory integer part:\n         int_loop: while (true) {\n             if (ptr >= _inputEnd) {\n-                break dummy_loop;\n+                break dummy_loop;  \n             }\n             ch = (int) _inputBuffer[ptr++];\n             if (ch < INT_0 || ch > INT_9) {\n@@ -41,7 +41,7 @@\n             // yes, fraction\n             fract_loop: while (true) {\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break int_loop;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n                 if (ch < INT_0 || ch > INT_9) {\n@@ -72,7 +72,7 @@\n             while (ch <= INT_9 && ch >= INT_0) {\n                 ++expLen;\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n        boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n                    }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n                // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.' || ch == ',') { // fixed issue: accept both ',' and '.' as decimal separator\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -37,7 +37,7 @@\n         }\n         int fractLen = 0;\n         // And then see if we get other parts\n-        if (ch == '.') {\n+        if (ch == '.' || ch == ',') { // fixed issue: accept both ',' and '.' as decimal separator\n             // yes, fraction\n             fract_loop: while (true) {\n                 if (ptr >= inputLen) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n        boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n                    }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n                // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                break dummy_loop;\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    break;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                break dummy_loop;\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -52,6 +52,7 @@\n             // must be followed by sequence of ints, one minimum\n             if (fractLen == 0) {\n                 reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n+                break dummy_loop;\n             }\n         }\n         int expLen = 0;\n@@ -72,13 +73,14 @@\n             while (ch <= INT_9 && ch >= INT_0) {\n                 ++expLen;\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n             // must be followed by sequence of ints, one minimum\n             if (expLen == 0) {\n                 reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n+                break dummy_loop;\n             }\n         }\n         // Got it all: let's add to text buffer for parsing, access\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n        boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n                    }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n                // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break int_loop;\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                _inputPtr = ptr - 1;\n                return _handleInvalidNumberStart(ch, true);\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break fract_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    _inputPtr = ptr - 1;\n                    return _handleUnexpectedValue(ch);\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    break;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -27,11 +27,12 @@\n         // First let's get the obligatory integer part:\n         int_loop: while (true) {\n             if (ptr >= _inputEnd) {\n-                break dummy_loop;\n+                break int_loop;\n             }\n             ch = (int) _inputBuffer[ptr++];\n             if (ch < INT_0 || ch > INT_9) {\n-                break int_loop;\n+                _inputPtr = ptr - 1;\n+                return _handleInvalidNumberStart(ch, true);\n             }\n             ++intLen;\n         }\n@@ -41,11 +42,12 @@\n             // yes, fraction\n             fract_loop: while (true) {\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break fract_loop;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n                 if (ch < INT_0 || ch > INT_9) {\n-                    break fract_loop;\n+                    _inputPtr = ptr - 1;\n+                    return _handleUnexpectedValue(ch);\n                 }\n                 ++fractLen;\n             }\n@@ -72,7 +74,7 @@\n             while (ch <= INT_9 && ch >= INT_0) {\n                 ++expLen;\n                 if (ptr >= inputLen) {\n-                    break dummy_loop;\n+                    break;\n                 }\n                 ch = (int) _inputBuffer[ptr++];\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int ch) throws IOException {\n        boolean negative = (ch == INT_MINUS);\n    int ptr = _inputPtr;\n    // to include sign/digit already read\n    int startPtr = ptr - 1;\n    final int inputLen = _inputEnd;\n    dummy_loop: do {\n        // dummy loop, to be able to break out\n        if (negative) {\n            // need to read the next digit\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = _inputBuffer[ptr++];\n            // First check: must have a digit to follow minus sign\n            if (ch > INT_9 || ch < INT_0) {\n                _inputPtr = ptr;\n                return _handleInvalidNumberStart(ch, true);\n            }\n        }\n        // One special case, leading zero(es):\n        if (ch == INT_0) {\n            break dummy_loop;\n        }\n        // already got one\n        int intLen = 1;\n        // First let's get the obligatory integer part:\n        int_loop: while (true) {\n            if (ptr >= _inputEnd) {\n                break dummy_loop;\n            }\n            ch = (int) _inputBuffer[ptr++];\n            if (ch < INT_0 || ch > INT_9) {\n                break int_loop;\n            }\n            ++intLen;\n        }\n        int fractLen = 0;\n        // And then see if we get other parts\n        if (ch == '.') {\n            // yes, fraction\n            fract_loop: while (true) {\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n                if (ch < INT_0 || ch > INT_9) {\n                    break fract_loop;\n                }\n                ++fractLen;\n            }\n            // must be followed by sequence of ints, one minimum\n            if (fractLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n                return null; // Added line of code to return null when a number is invalid\n            }\n        }\n        int expLen = 0;\n        if (ch == 'e' || ch == 'E') {\n            // and/or exponent\n            if (ptr >= inputLen) {\n                break dummy_loop;\n            }\n            // Sign indicator?\n            ch = (int) _inputBuffer[ptr++];\n            if (ch == INT_MINUS || ch == INT_PLUS) {\n                // yup, skip for now\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            while (ch <= INT_9 && ch >= INT_0) {\n                ++expLen;\n                if (ptr >= inputLen) {\n                    break dummy_loop;\n                }\n                ch = (int) _inputBuffer[ptr++];\n            }\n            // must be followed by sequence of ints, one minimum\n            if (expLen == 0) {\n                reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n                return null; // Added line of code to return null when a number is invalid\n            }\n        }\n        // Got it all: let's add to text buffer for parsing, access\n        // need to push back following separator\n        --ptr;\n        _inputPtr = ptr;\n        // As per #105, need separating space between root values; check here\n        int len = ptr - startPtr;\n        _textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n        return reset(negative, intLen, fractLen, expLen);\n    } while (false);\n    _inputPtr = negative ? (startPtr + 1) : startPtr;\n    return _parseNumber2(negative);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber\n@@ -17,12 +17,12 @@\n                 _inputPtr = ptr;\n                 return _handleInvalidNumberStart(ch, true);\n             }\n-                    }\n+        }\n         // One special case, leading zero(es):\n         if (ch == INT_0) {\n             break dummy_loop;\n         }\n-                // already got one\n+        // already got one\n         int intLen = 1;\n         // First let's get the obligatory integer part:\n         int_loop: while (true) {\n@@ -52,6 +52,7 @@\n             // must be followed by sequence of ints, one minimum\n             if (fractLen == 0) {\n                 reportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n+                return null; // Added line of code to return null when a number is invalid\n             }\n         }\n         int expLen = 0;\n@@ -79,6 +80,7 @@\n             // must be followed by sequence of ints, one minimum\n             if (expLen == 0) {\n                 reportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n+                return null; // Added line of code to return null when a number is invalid\n             }\n         }\n         // Got it all: let's add to text buffer for parsing, access\n", "finish_reason": "stop", "valid": false, "num": 1}]