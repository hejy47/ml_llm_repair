[{"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd && !loadMore()) { //FIXED: Used loadMore() instead of loadMoreGuaranteed()\n            reportUnexpectedNumberChar(c, \"Invalid exponent\");\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd && !loadMore()) { //FIXED: Used loadMore() instead of loadMoreGuaranteed()\n                reportUnexpectedNumberChar(c, \"Invalid exponent\");\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per #105, need separating space between root values; check here\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -35,8 +35,8 @@\n         }\n         outBuf[outPtr++] = (char) c;\n         // Not optional, can require that we get one more char\n-        if (_inputPtr >= _inputEnd) {\n-            loadMoreGuaranteed();\n+        if (_inputPtr >= _inputEnd && !loadMore()) { //FIXED: Used loadMore() instead of loadMoreGuaranteed()\n+            reportUnexpectedNumberChar(c, \"Invalid exponent\");\n         }\n         c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         // Sign indicator?\n@@ -47,8 +47,8 @@\n             }\n             outBuf[outPtr++] = (char) c;\n             // Likewise, non optional:\n-            if (_inputPtr >= _inputEnd) {\n-                loadMoreGuaranteed();\n+            if (_inputPtr >= _inputEnd && !loadMore()) { //FIXED: Used loadMore() instead of loadMoreGuaranteed()\n+                reportUnexpectedNumberChar(c, \"Invalid exponent\");\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            if(!loadMore()) {\n                throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n            }\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                if(!loadMore()) {\n                    throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n                }\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per #105, need separating space between root values; check here\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -36,7 +36,9 @@\n         outBuf[outPtr++] = (char) c;\n         // Not optional, can require that we get one more char\n         if (_inputPtr >= _inputEnd) {\n-            loadMoreGuaranteed();\n+            if(!loadMore()) {\n+                throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n+            }\n         }\n         c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         // Sign indicator?\n@@ -48,7 +50,9 @@\n             outBuf[outPtr++] = (char) c;\n             // Likewise, non optional:\n             if (_inputPtr >= _inputEnd) {\n-                loadMoreGuaranteed();\n+                if(!loadMore()) {\n+                    throw _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n+                }\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            if(!loadMore()) { // fix: check if loadMore returns false, then throw exception\n                reportUnexpectedNumberChar(c, \"Unexpected end-of-input when parsing exponent value\");\n            }\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                if(!loadMore()) { // fix: check if loadMore returns false, then throw exception\n                    reportUnexpectedNumberChar(c, \"Unexpected end-of-input when parsing exponent value\");\n                }\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per #105, need separating space between root values; check here\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -36,7 +36,9 @@\n         outBuf[outPtr++] = (char) c;\n         // Not optional, can require that we get one more char\n         if (_inputPtr >= _inputEnd) {\n-            loadMoreGuaranteed();\n+            if(!loadMore()) { // fix: check if loadMore returns false, then throw exception\n+                reportUnexpectedNumberChar(c, \"Unexpected end-of-input when parsing exponent value\");\n+            }\n         }\n         c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         // Sign indicator?\n@@ -48,7 +50,9 @@\n             outBuf[outPtr++] = (char) c;\n             // Likewise, non optional:\n             if (_inputPtr >= _inputEnd) {\n-                loadMoreGuaranteed();\n+                if(!loadMore()) { // fix: check if loadMore returns false, then throw exception\n+                    reportUnexpectedNumberChar(c, \"Unexpected end-of-input when parsing exponent value\");\n+                }\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < '0' || c > '9') {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= '9' && c >= '0') {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per #105, need separating space between root values; check here\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -11,7 +11,7 @@\n                 break fract_loop;\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n-            if (c < INT_0 || c > INT_9) {\n+            if (c < '0' || c > '9') {\n                 break fract_loop;\n             }\n             ++fractLen;\n@@ -52,7 +52,7 @@\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c <= '9' && c >= '0') {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        //noinspection PointlessBooleanExpression,ConstantConditions\n        if (_inputPtr >= _inputEnd) {\n            c = getNextChar(\"expected a digit for number exponent\");\n        }\n        c = _inputBuffer[_inputPtr++];\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            //noinspection PointlessBooleanExpression,ConstantConditions\n            if (_inputPtr >= _inputEnd) {\n                c = getNextChar(\"expected a digit for number exponent\");\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -35,10 +35,11 @@\n         }\n         outBuf[outPtr++] = (char) c;\n         // Not optional, can require that we get one more char\n+        //noinspection PointlessBooleanExpression,ConstantConditions\n         if (_inputPtr >= _inputEnd) {\n-            loadMoreGuaranteed();\n+            c = getNextChar(\"expected a digit for number exponent\");\n         }\n-        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+        c = _inputBuffer[_inputPtr++];\n         // Sign indicator?\n         if (c == '-' || c == '+') {\n             if (outPtr >= outBuf.length) {\n@@ -47,12 +48,13 @@\n             }\n             outBuf[outPtr++] = (char) c;\n             // Likewise, non optional:\n+            //noinspection PointlessBooleanExpression,ConstantConditions\n             if (_inputPtr >= _inputEnd) {\n-                loadMoreGuaranteed();\n+                c = getNextChar(\"expected a digit for number exponent\");\n             }\n-            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n+            c = _inputBuffer[_inputPtr++];\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        while (c <= INT_9 && c >= INT_0) {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n@@ -61,7 +63,7 @@\n             outBuf[outPtr++] = (char) c;\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n                 eof = true;\n-                break exp_loop;\n+                break;\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n@@ -73,7 +75,6 @@\n     // Ok; unless we hit end-of-input, need to push last char read back\n     if (!eof) {\n         --_inputPtr;\n-        // As per #105, need separating space between root values; check here\n     }\n     _textBuffer.setCurrentLength(outPtr);\n     // And there we have it!\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                throw _constructError(\"Unexpected end-of-input when binding data into ArrayNode\");\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per #105, need separating space between root values; check here\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -48,7 +48,7 @@\n             outBuf[outPtr++] = (char) c;\n             // Likewise, non optional:\n             if (_inputPtr >= _inputEnd) {\n-                loadMoreGuaranteed();\n+                throw _constructError(\"Unexpected end-of-input when binding data into ArrayNode\");\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                reportUnexpectedNumberChar(c, \"invalid number\");\n            }\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    reportUnexpectedNumberChar(c, \"invalid number\");\n                }\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per #105, need separating space between root values; check here\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -36,7 +36,9 @@\n         outBuf[outPtr++] = (char) c;\n         // Not optional, can require that we get one more char\n         if (_inputPtr >= _inputEnd) {\n-            loadMoreGuaranteed();\n+            if (!loadMore()) {\n+                reportUnexpectedNumberChar(c, \"invalid number\");\n+            }\n         }\n         c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         // Sign indicator?\n@@ -48,7 +50,9 @@\n             outBuf[outPtr++] = (char) c;\n             // Likewise, non optional:\n             if (_inputPtr >= _inputEnd) {\n-                loadMoreGuaranteed();\n+                if (!loadMore()) {\n+                    reportUnexpectedNumberChar(c, \"invalid number\");\n+                }\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) { // fix here\n                reportInvalidEOF(\" in a number\"); // fix here\n            }\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // fix here\n                    reportInvalidEOF(\" in a number\"); // fix here\n                }\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per #105, need separating space between root values; check here\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -36,7 +36,9 @@\n         outBuf[outPtr++] = (char) c;\n         // Not optional, can require that we get one more char\n         if (_inputPtr >= _inputEnd) {\n-            loadMoreGuaranteed();\n+            if (!loadMore()) { // fix here\n+                reportInvalidEOF(\" in a number\"); // fix here\n+            }\n         }\n         c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         // Sign indicator?\n@@ -48,7 +50,9 @@\n             outBuf[outPtr++] = (char) c;\n             // Likewise, non optional:\n             if (_inputPtr >= _inputEnd) {\n-                loadMoreGuaranteed();\n+                if (!loadMore()) { // fix here\n+                    reportInvalidEOF(\" in a number\"); // fix here\n+                }\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                --_inputPtr; // fix: push last char back\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per #105, need separating space between root values; check here\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -12,6 +12,7 @@\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n             if (c < INT_0 || c > INT_9) {\n+                --_inputPtr; // fix: push last char back\n                 break fract_loop;\n             }\n             ++fractLen;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per #105, need separating space between root values; check here\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -59,9 +59,11 @@\n                 outPtr = 0;\n             }\n             outBuf[outPtr++] = (char) c;\n-            if (_inputPtr >= _inputEnd && !loadMore()) {\n-                eof = true;\n-                break exp_loop;\n+            if (_inputPtr >= _inputEnd) {\n+                if (!loadMore()) {\n+                    eof = true;\n+                    break exp_loop;\n+                }\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per #105, need separating space between root values; check here\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < '0' || c > '9') { // fixed typo from INT_0 and INT_9 to '0' and '9'\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= '9' && c >= '0') { // fixed typo from INT_0 and INT_9 to '0' and '9'\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per #105, need separating space between root values; check here\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -11,7 +11,7 @@\n                 break fract_loop;\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n-            if (c < INT_0 || c > INT_9) {\n+            if (c < '0' || c > '9') { // fixed typo from INT_0 and INT_9 to '0' and '9'\n                 break fract_loop;\n             }\n             ++fractLen;\n@@ -52,7 +52,7 @@\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c <= '9' && c >= '0') { // fixed typo from INT_0 and INT_9 to '0' and '9'\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            if(!loadMore()) {\n                reportUnexpectedNumberChar(c, \"Unexpected end-of-input when processing exponent value\");\n            }\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    reportUnexpectedNumberChar(c, \"Unexpected end-of-input when processing exponent value\");\n                }\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd) {\n                if(!loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -36,7 +36,9 @@\n         outBuf[outPtr++] = (char) c;\n         // Not optional, can require that we get one more char\n         if (_inputPtr >= _inputEnd) {\n-            loadMoreGuaranteed();\n+            if(!loadMore()) {\n+                reportUnexpectedNumberChar(c, \"Unexpected end-of-input when processing exponent value\");\n+            }\n         }\n         c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         // Sign indicator?\n@@ -48,7 +50,9 @@\n             outBuf[outPtr++] = (char) c;\n             // Likewise, non optional:\n             if (_inputPtr >= _inputEnd) {\n-                loadMoreGuaranteed();\n+                if (!loadMore()) {\n+                    reportUnexpectedNumberChar(c, \"Unexpected end-of-input when processing exponent value\");\n+                }\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n@@ -59,9 +63,11 @@\n                 outPtr = 0;\n             }\n             outBuf[outPtr++] = (char) c;\n-            if (_inputPtr >= _inputEnd && !loadMore()) {\n-                eof = true;\n-                break exp_loop;\n+            if (_inputPtr >= _inputEnd) {\n+                if(!loadMore()) {\n+                    eof = true;\n+                    break exp_loop;\n+                }\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n@@ -73,7 +79,6 @@\n     // Ok; unless we hit end-of-input, need to push last char read back\n     if (!eof) {\n         --_inputPtr;\n-        // As per #105, need separating space between root values; check here\n     }\n     _textBuffer.setCurrentLength(outPtr);\n     // And there we have it!\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                reportUnexpectedNumberChar(c, \"Unexpected end-of-input when trying to parse exponent value\");\n            }\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    reportUnexpectedNumberChar(c, \"Unexpected end-of-input when trying to parse exponent value\");\n                }\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -36,7 +36,9 @@\n         outBuf[outPtr++] = (char) c;\n         // Not optional, can require that we get one more char\n         if (_inputPtr >= _inputEnd) {\n-            loadMoreGuaranteed();\n+            if (!loadMore()) {\n+                reportUnexpectedNumberChar(c, \"Unexpected end-of-input when trying to parse exponent value\");\n+            }\n         }\n         c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         // Sign indicator?\n@@ -48,7 +50,9 @@\n             outBuf[outPtr++] = (char) c;\n             // Likewise, non optional:\n             if (_inputPtr >= _inputEnd) {\n-                loadMoreGuaranteed();\n+                if (!loadMore()) {\n+                    reportUnexpectedNumberChar(c, \"Unexpected end-of-input when trying to parse exponent value\");\n+                }\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n@@ -73,7 +77,6 @@\n     // Ok; unless we hit end-of-input, need to push last char read back\n     if (!eof) {\n         --_inputPtr;\n-        // As per #105, need separating space between root values; check here\n     }\n     _textBuffer.setCurrentLength(outPtr);\n     // And there we have it!\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            reportUnexpectedNumberChar(c, \"Unexpected end-of-input when parsing exponent\");\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                reportUnexpectedNumberChar(c, \"Unexpected end-of-input when parsing exponent\");\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c >= INT_0 && c <= INT_9) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    if (!eof) {\n        --_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -35,8 +35,8 @@\n         }\n         outBuf[outPtr++] = (char) c;\n         // Not optional, can require that we get one more char\n-        if (_inputPtr >= _inputEnd) {\n-            loadMoreGuaranteed();\n+        if (_inputPtr >= _inputEnd && !loadMore()) {\n+            reportUnexpectedNumberChar(c, \"Unexpected end-of-input when parsing exponent\");\n         }\n         c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         // Sign indicator?\n@@ -47,12 +47,12 @@\n             }\n             outBuf[outPtr++] = (char) c;\n             // Likewise, non optional:\n-            if (_inputPtr >= _inputEnd) {\n-                loadMoreGuaranteed();\n+            if (_inputPtr >= _inputEnd && !loadMore()) {\n+                reportUnexpectedNumberChar(c, \"Unexpected end-of-input when parsing exponent\");\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c >= INT_0 && c <= INT_9) {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n@@ -65,17 +65,13 @@\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n-        // must be followed by sequence of ints, one minimum\n         if (expLen == 0) {\n             reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n         }\n     }\n-    // Ok; unless we hit end-of-input, need to push last char read back\n     if (!eof) {\n         --_inputPtr;\n-        // As per #105, need separating space between root values; check here\n     }\n     _textBuffer.setCurrentLength(outPtr);\n-    // And there we have it!\n     return resetFloat(negative, integerPartLength, fractLen, expLen);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                reportUnexpectedNumberChar(c, \"Unexpected end-of-input when processing exponent\");\n            }\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    reportUnexpectedNumberChar(c, \"Unexpected end-of-input when processing exponent\");\n                }\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per #105, need separating space between root values; check here\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -36,7 +36,9 @@\n         outBuf[outPtr++] = (char) c;\n         // Not optional, can require that we get one more char\n         if (_inputPtr >= _inputEnd) {\n-            loadMoreGuaranteed();\n+            if (!loadMore()) {\n+                reportUnexpectedNumberChar(c, \"Unexpected end-of-input when processing exponent\");\n+            }\n         }\n         c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         // Sign indicator?\n@@ -48,7 +50,9 @@\n             outBuf[outPtr++] = (char) c;\n             // Likewise, non optional:\n             if (_inputPtr >= _inputEnd) {\n-                loadMoreGuaranteed();\n+                if (!loadMore()) {\n+                    reportUnexpectedNumberChar(c, \"Unexpected end-of-input when processing exponent\");\n+                }\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) {\n                reportUnexpectedNumberChar(c, \"Missing a digit after exponent sign\");\n            }\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) {\n                    reportUnexpectedNumberChar(c, \"Missing a digit after exponent sign\");\n                }\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per #105, need separating space between root values; check here\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -8,7 +8,7 @@\n         fract_loop: while (true) {\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n                 eof = true;\n-                break fract_loop;\n+                break;\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n             if (c < INT_0 || c > INT_9) {\n@@ -36,7 +36,9 @@\n         outBuf[outPtr++] = (char) c;\n         // Not optional, can require that we get one more char\n         if (_inputPtr >= _inputEnd) {\n-            loadMoreGuaranteed();\n+            if (!loadMore()) {\n+                reportUnexpectedNumberChar(c, \"Missing a digit after exponent sign\");\n+            }\n         }\n         c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         // Sign indicator?\n@@ -48,7 +50,9 @@\n             outBuf[outPtr++] = (char) c;\n             // Likewise, non optional:\n             if (_inputPtr >= _inputEnd) {\n-                loadMoreGuaranteed();\n+                if (!loadMore()) {\n+                    reportUnexpectedNumberChar(c, \"Missing a digit after exponent sign\");\n+                }\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            if (!loadMore()) { // fixed this\n                reportUnexpectedNumberChar(c, \"Unexpected end-of-input with exponent indicator\");\n            }\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                if (!loadMore()) { // fixed this\n                    reportUnexpectedNumberChar(c, \"Unexpected end-of-input with exponent sign\");\n                }\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per #105, need separating space between root values; check here\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -36,7 +36,9 @@\n         outBuf[outPtr++] = (char) c;\n         // Not optional, can require that we get one more char\n         if (_inputPtr >= _inputEnd) {\n-            loadMoreGuaranteed();\n+            if (!loadMore()) { // fixed this\n+                reportUnexpectedNumberChar(c, \"Unexpected end-of-input with exponent indicator\");\n+            }\n         }\n         c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         // Sign indicator?\n@@ -48,7 +50,9 @@\n             outBuf[outPtr++] = (char) c;\n             // Likewise, non optional:\n             if (_inputPtr >= _inputEnd) {\n-                loadMoreGuaranteed();\n+                if (!loadMore()) { // fixed this\n+                    reportUnexpectedNumberChar(c, \"Unexpected end-of-input with exponent sign\");\n+                }\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd) {\n                if(!loadMore()) {\n                    eof = true;\n                    break exp_loop;\n                }\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per #105, need separating space between root values; check here\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -59,9 +59,11 @@\n                 outPtr = 0;\n             }\n             outBuf[outPtr++] = (char) c;\n-            if (_inputPtr >= _inputEnd && !loadMore()) {\n-                eof = true;\n-                break exp_loop;\n+            if (_inputPtr >= _inputEnd) {\n+                if(!loadMore()) {\n+                    eof = true;\n+                    break exp_loop;\n+                }\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseFloat(char[] outBuf, int outPtr, int c, boolean negative, int integerPartLength) throws IOException, JsonParseException {\n    int fractLen = 0;\n    boolean eof = false;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = (char) c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n            if (c < '0' || c > '9') { // fix: use char literals instead of INT_ constants\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                loadMoreGuaranteed();\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        exp_loop: while (c <= '9' && c >= '0') { // fix: use char literals instead of INT_ constants\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = (char) c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n        // As per #105, need separating space between root values; check here\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return resetFloat(negative, integerPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseFloat\n@@ -11,7 +11,7 @@\n                 break fract_loop;\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n-            if (c < INT_0 || c > INT_9) {\n+            if (c < '0' || c > '9') { // fix: use char literals instead of INT_ constants\n                 break fract_loop;\n             }\n             ++fractLen;\n@@ -52,7 +52,7 @@\n             }\n             c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c <= '9' && c >= '0') { // fix: use char literals instead of INT_ constants\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n", "finish_reason": "stop", "valid": false, "num": 1}]