[{"output": "private JsonToken _parseNumber2(boolean negative) throws IOException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        reportInvalidNumber(\"Missing integer part (next char \" + _getCharDesc(c) + \")\");\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof && _inputPtr > 0) {\n        --_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(negative, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -97,7 +97,7 @@\n         }\n     }\n     // Ok; unless we hit end-of-input, need to push last char read back\n-    if (!eof) {\n+    if (!eof && _inputPtr > 0) {\n         --_inputPtr;\n     }\n     _textBuffer.setCurrentLength(outPtr);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseNumber2(boolean negative) throws IOException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        reportInvalidNumber(\"Missing integer part (next char \" + _getCharDesc(c) + \")\");\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(negative, intLen, fractLen, expLen);\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 7}, {"output": "private JsonToken _parseNumber2(boolean negative) throws IOException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = getNextChar(\"No digit following minus sign\");\n    // Added check for leading zeroes\n    if (c == '0') {\n        intLen++;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            _textBuffer.setCurrentLength(outPtr);\n            return reset(negative, intLen, 0, 0);\n        }\n        c = _inputBuffer[_inputPtr++];\n        if (c < INT_0 || c > INT_9) {\n            outBuf[outPtr++] = '0';\n            if (c == '.' || c == 'e' || c == 'E') {\n                outBuf[outPtr++] = c;\n                return _parseFloat(outBuf, outPtr, c, negative, intLen);\n            }\n            reportInvalidNumber(\"Leading zeroes are not allowed\");\n        }\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        reportInvalidNumber(\"Missing integer part (next char \" + _getCharDesc(c) + \")\");\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    // Added handling for exponent without fraction\n    else if (c == 'e' || c == 'E') {\n        outBuf[outPtr++] = c;\n        return _parseFloat(outBuf, outPtr, c, negative, intLen);\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(negative, intLen, fractLen, expLen);\n}\n\nprivate JsonToken _parseFloat(char[] outBuf, int outPtr, char c, boolean negative, int intPartLength) throws IOException {\n    int fractLen = 0;\n    if (c == '-' || c == '+') {\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Likewise, non optional:\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n    }\n    while (c >= '0' && c <= '9') {\n        ++fractLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            break;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    if (fractLen == 0) {\n        reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        while (c >= '0' && c <= '9') {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                // EOF is legal\n                c = CHAR_NULL;\n                break;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (c != CHAR_NULL) {\n        --_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(negative, intPartLength, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -7,9 +7,23 @@\n     }\n     // This is the place to do leading-zero check(s) too:\n     int intLen = 0;\n-    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n+    char c = getNextChar(\"No digit following minus sign\");\n+    // Added check for leading zeroes\n     if (c == '0') {\n-        c = _verifyNoLeadingZeroes();\n+        intLen++;\n+        if (_inputPtr >= _inputEnd && !loadMore()) {\n+            _textBuffer.setCurrentLength(outPtr);\n+            return reset(negative, intLen, 0, 0);\n+        }\n+        c = _inputBuffer[_inputPtr++];\n+        if (c < INT_0 || c > INT_9) {\n+            outBuf[outPtr++] = '0';\n+            if (c == '.' || c == 'e' || c == 'E') {\n+                outBuf[outPtr++] = c;\n+                return _parseFloat(outBuf, outPtr, c, negative, intLen);\n+            }\n+            reportInvalidNumber(\"Leading zeroes are not allowed\");\n+        }\n     }\n     boolean eof = false;\n     // Ok, first the obligatory integer part:\n@@ -58,6 +72,11 @@\n             reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n         }\n     }\n+    // Added handling for exponent without fraction\n+    else if (c == 'e' || c == 'E') {\n+        outBuf[outPtr++] = c;\n+        return _parseFloat(outBuf, outPtr, c, negative, intLen);\n+    }\n     int expLen = 0;\n     if (c == 'e' || c == 'E') {\n         // exponent?\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseNumber2(boolean negative) throws IOException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        // Check for leading zeroes in integer part\n        c = _verifyNoLeadingZeroes();\n        // Check if we have a non-zero digit after the leading zeroes\n        if (c >= '0' && c <= '9') {\n            reportInvalidNumber(\"Leading zeroes are not allowed\");\n        }\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        reportInvalidNumber(\"Missing integer part (next char \" + _getCharDesc(c) + \")\");\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(negative, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -9,7 +9,12 @@\n     int intLen = 0;\n     char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n     if (c == '0') {\n+        // Check for leading zeroes in integer part\n         c = _verifyNoLeadingZeroes();\n+        // Check if we have a non-zero digit after the leading zeroes\n+        if (c >= '0' && c <= '9') {\n+            reportInvalidNumber(\"Leading zeroes are not allowed\");\n+        }\n     }\n     boolean eof = false;\n     // Ok, first the obligatory integer part:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseNumber2(boolean negative) throws IOException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        reportInvalidNumber(\"Missing integer part (next char \" + _getCharDesc(c) + \")\");\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < '0' || c > '9') { // Fixed: changed INT_0 and INT_9 to '0' and '9'\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= '9' && c >= '0') { // Fixed: changed INT_9 and INT_0 to '9' and '0'\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(negative, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -22,7 +22,6 @@\n         outBuf[outPtr++] = c;\n         if (_inputPtr >= _inputEnd && !loadMore()) {\n             // EOF is legal for main level int values\n-            c = CHAR_NULL;\n             eof = true;\n             break int_loop;\n         }\n@@ -43,7 +42,7 @@\n                 break fract_loop;\n             }\n             c = _inputBuffer[_inputPtr++];\n-            if (c < INT_0 || c > INT_9) {\n+            if (c < '0' || c > '9') { // Fixed: changed INT_0 and INT_9 to '0' and '9'\n                 break fract_loop;\n             }\n             ++fractLen;\n@@ -78,7 +77,7 @@\n             // Likewise, non optional:\n             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c <= '9' && c >= '0') { // Fixed: changed INT_9 and INT_0 to '9' and '0'\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseNumber2(boolean negative) throws IOException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        reportInvalidNumber(\"Missing integer part (next char \" + _getCharDesc(c) + \")\");\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c >= INT_0 && c <= INT_9) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(negative, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -78,7 +78,7 @@\n             // Likewise, non optional:\n             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c >= INT_0 && c <= INT_9) {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private JsonToken _parseNumber2(boolean negative) throws IOException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        reportInvalidNumber(\"Missing integer part (next char \" + _getCharDesc(c) + \")\");\n    }\n\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n    }\n\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(negative, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -12,6 +12,7 @@\n         c = _verifyNoLeadingZeroes();\n     }\n     boolean eof = false;\n+\n     // Ok, first the obligatory integer part:\n     int_loop: while (c >= '0' && c <= '9') {\n         ++intLen;\n@@ -21,7 +22,6 @@\n         }\n         outBuf[outPtr++] = c;\n         if (_inputPtr >= _inputEnd && !loadMore()) {\n-            // EOF is legal for main level int values\n             c = CHAR_NULL;\n             eof = true;\n             break int_loop;\n@@ -32,10 +32,15 @@\n     if (intLen == 0) {\n         reportInvalidNumber(\"Missing integer part (next char \" + _getCharDesc(c) + \")\");\n     }\n+\n     int fractLen = 0;\n     // And then see if we get other parts\n     if (c == '.') {\n         // yes, fraction\n+        if (outPtr >= outBuf.length) {\n+            outBuf = _textBuffer.finishCurrentSegment();\n+            outPtr = 0;\n+        }\n         outBuf[outPtr++] = c;\n         fract_loop: while (true) {\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n@@ -58,6 +63,7 @@\n             reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n         }\n     }\n+\n     int expLen = 0;\n     if (c == 'e' || c == 'E') {\n         // exponent?\n@@ -66,8 +72,10 @@\n             outPtr = 0;\n         }\n         outBuf[outPtr++] = c;\n+\n         // Not optional, can require that we get one more char\n         c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n+\n         // Sign indicator?\n         if (c == '-' || c == '+') {\n             if (outPtr >= outBuf.length) {\n@@ -75,9 +83,11 @@\n                 outPtr = 0;\n             }\n             outBuf[outPtr++] = c;\n+\n             // Likewise, non optional:\n             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n         }\n+\n         exp_loop: while (c <= INT_9 && c >= INT_0) {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n@@ -96,10 +106,12 @@\n             reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n         }\n     }\n+\n     // Ok; unless we hit end-of-input, need to push last char read back\n     if (!eof) {\n         --_inputPtr;\n     }\n+\n     _textBuffer.setCurrentLength(outPtr);\n     // And there we have it!\n     return reset(negative, intLen, fractLen, expLen);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseNumber2(boolean negative) throws IOException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        reportInvalidNumber(\"Missing integer part (next char \" + _getCharDesc(c) + \")\");\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c >= '0' && c <= '9') {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(negative, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -78,7 +78,7 @@\n             // Likewise, non optional:\n             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n         }\n-        exp_loop: while (c <= INT_9 && c >= INT_0) {\n+        exp_loop: while (c >= '0' && c <= '9') {\n             ++expLen;\n             if (outPtr >= outBuf.length) {\n                 outBuf = _textBuffer.finishCurrentSegment();\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private JsonToken _parseNumber2(boolean negative) throws IOException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        reportInvalidNumber(\"Missing integer part (next char \" + _getCharDesc(c) + \")\");\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(negative, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -36,6 +36,10 @@\n     // And then see if we get other parts\n     if (c == '.') {\n         // yes, fraction\n+        if (outPtr >= outBuf.length) {\n+            outBuf = _textBuffer.finishCurrentSegment();\n+            outPtr = 0;\n+        }\n         outBuf[outPtr++] = c;\n         fract_loop: while (true) {\n             if (_inputPtr >= _inputEnd && !loadMore()) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseNumber2(boolean negative) throws IOException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        reportInvalidNumber(\"Missing integer part (next char \" + _getCharDesc(c) + \")\");\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n    } else {\n        // Fix to properly assign NULL when reaching EOF\n        c = CHAR_NULL;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(negative, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -99,6 +99,9 @@\n     // Ok; unless we hit end-of-input, need to push last char read back\n     if (!eof) {\n         --_inputPtr;\n+    } else {\n+        // Fix to properly assign NULL when reaching EOF\n+        c = CHAR_NULL;\n     }\n     _textBuffer.setCurrentLength(outPtr);\n     // And there we have it!\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseNumber2(boolean negative) throws IOException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    } else if (c < '1' || c > '9') {\n        reportInvalidNumber(\"Invalid lead character: \" + c + \" (while parsing number)\");\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        reportInvalidNumber(\"Missing integer part (next char \" + _getCharDesc(c) + \")\");\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(negative, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -10,6 +10,8 @@\n     char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n     if (c == '0') {\n         c = _verifyNoLeadingZeroes();\n+    } else if (c < '1' || c > '9') {\n+        reportInvalidNumber(\"Invalid lead character: \" + c + \" (while parsing number)\");\n     }\n     boolean eof = false;\n     // Ok, first the obligatory integer part:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private JsonToken _parseNumber2(boolean negative) throws IOException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n    }\n    // This is the place to do leading-zero check(s) too:\n    int intLen = 0;\n    char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\n    if (c == '0') {\n        c = _verifyNoLeadingZeroes();\n    }\n    boolean eof = false;\n    // Ok, first the obligatory integer part:\n    int_loop: while (c >= '0' && c <= '9') {\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        if (_inputPtr >= _inputEnd && !loadMore()) {\n            // EOF is legal for main level int values\n            c = CHAR_NULL;\n            eof = true;\n            break int_loop;\n        }\n        c = _inputBuffer[_inputPtr++];\n    }\n    // Also, integer part is not optional\n    if (intLen == 0) {\n        reportInvalidNumber(\"Missing integer part (next char \" + _getCharDesc(c) + \")\");\n    }\n    int fractLen = 0;\n    // And then see if we get other parts\n    if (c == '.') {\n        // yes, fraction\n        outBuf[outPtr++] = c;\n        fract_loop: while (true) {\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break fract_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n            if (c < INT_0 || c > INT_9) {\n                break fract_loop;\n            }\n            ++fractLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n        }\n        // must be followed by sequence of ints, one minimum\n        if (fractLen == 0) {\n            reportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n        }\n    }\n    int expLen = 0;\n    if (c == 'e' || c == 'E') {\n        // exponent?\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = c;\n        // Not optional, can require that we get one more char\n        if (_inputPtr >= _inputEnd) {\n            c = getNextChar(\"expected a digit for number exponent\");\n        } else {\n            c = _inputBuffer[_inputPtr++];\n        }\n        // Sign indicator?\n        if (c == '-' || c == '+') {\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            // Likewise, non optional:\n            if (_inputPtr >= _inputEnd) {\n                c = getNextChar(\"expected a digit for number exponent\");\n            } else {\n                c = _inputBuffer[_inputPtr++];\n            }\n        }\n        exp_loop: while (c <= INT_9 && c >= INT_0) {\n            ++expLen;\n            if (outPtr >= outBuf.length) {\n                outBuf = _textBuffer.finishCurrentSegment();\n                outPtr = 0;\n            }\n            outBuf[outPtr++] = c;\n            if (_inputPtr >= _inputEnd && !loadMore()) {\n                eof = true;\n                break exp_loop;\n            }\n            c = _inputBuffer[_inputPtr++];\n        }\n        // must be followed by sequence of ints, one minimum\n        if (expLen == 0) {\n            reportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n        }\n    }\n    // Ok; unless we hit end-of-input, need to push last char read back\n    if (!eof) {\n        --_inputPtr;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    // And there we have it!\n    return reset(negative, intLen, fractLen, expLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@_parseNumber2\n@@ -67,7 +67,11 @@\n         }\n         outBuf[outPtr++] = c;\n         // Not optional, can require that we get one more char\n-        c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n+        if (_inputPtr >= _inputEnd) {\n+            c = getNextChar(\"expected a digit for number exponent\");\n+        } else {\n+            c = _inputBuffer[_inputPtr++];\n+        }\n         // Sign indicator?\n         if (c == '-' || c == '+') {\n             if (outPtr >= outBuf.length) {\n@@ -76,7 +80,11 @@\n             }\n             outBuf[outPtr++] = c;\n             // Likewise, non optional:\n-            c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"expected a digit for number exponent\");\n+            if (_inputPtr >= _inputEnd) {\n+                c = getNextChar(\"expected a digit for number exponent\");\n+            } else {\n+                c = _inputBuffer[_inputPtr++];\n+            }\n         }\n         exp_loop: while (c <= INT_9 && c >= INT_0) {\n             ++expLen;\n", "finish_reason": "stop", "valid": false, "num": 1}]