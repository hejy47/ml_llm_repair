[{"output": "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    boolean negative = (c == INT_MINUS);\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n    }\n    // One special case: if first char is 0, must not be followed by a digit\n    if (c == INT_0) {\n        c = _verifyNoLeadingZeroes();\n    }\n    // Ok: we can first just add digit we saw first:\n    outBuf[outPtr++] = (char) c;\n    int intLen = 1;\n    // And then figure out how far we can read without further checks:\n    int end = Math.min(_inputEnd, _inputPtr + outBuf.length);\n    while (true) {\n        if (_inputPtr >= end) {\n            // Long enough to be split across boundary, so:\n            return _parserNumber2(outBuf, outPtr, negative, intLen);\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        if (c < INT_0 || c > INT_9) {\n            break;\n        }\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n    }\n    if (c == '.' || c == 'e' || c == 'E') {\n        return _parseFloat(outBuf, outPtr, c, negative, intLen);\n    }\n    // to push back trailing char (comma etc)\n    --_inputPtr;\n    _textBuffer.setCurrentLength(outPtr);\n    // As per #105, need separating space between root values; check here\n    // And there we have it!\n    return resetInt(negative, intLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n@@ -23,11 +23,7 @@\n     outBuf[outPtr++] = (char) c;\n     int intLen = 1;\n     // And then figure out how far we can read without further checks:\n-    int end = _inputPtr + outBuf.length;\n-    if (end > _inputEnd) {\n-        end = _inputEnd;\n-    }\n-    // With this, we have a nice and tight loop:\n+    int end = Math.min(_inputEnd, _inputPtr + outBuf.length);\n     while (true) {\n         if (_inputPtr >= end) {\n             // Long enough to be split across boundary, so:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    boolean negative = (c == INT_MINUS);\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n    }\n    // One special case: if first char is 0, must not be followed by a digit\n    if (c == INT_0) {\n        c = _verifyNoLeadingZeroes();\n    }\n    // Ok: we can first just add digit we saw first:\n    outBuf[outPtr++] = (char) c;\n    int intLen = 1;\n    // And then figure out how far we can read without further checks:\n    int end = _inputPtr + outBuf.length;\n    if (end > _inputEnd) {\n        end = _inputEnd;\n    }\n    // With this, we have a nice and tight loop:\n    while (true) {\n        if (_inputPtr >= end) {\n            // Long enough to be split across boundary, so:\n            return _parserNumber2(outBuf, outPtr, negative, intLen);\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        if (c < INT_0 || c > INT_9) {\n            break;\n        }\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n    }\n    if (c == '.' || c == 'e' || c == 'E') {\n        // Move end pointer one step back to avoid skipping digits after dot (.)\n        if(end-1 > _inputEnd){\n            end = _inputEnd;\n        }\n        return _parseFloat(outBuf, outPtr, c, negative, intLen, end);\n    }\n    // to push back trailing char (comma etc)\n    --_inputPtr;\n    _textBuffer.setCurrentLength(outPtr);\n    // As per #105, need separating space between root values; check here\n    // And there we have it!\n    return resetInt(negative, intLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n@@ -45,7 +45,11 @@\n         outBuf[outPtr++] = (char) c;\n     }\n     if (c == '.' || c == 'e' || c == 'E') {\n-        return _parseFloat(outBuf, outPtr, c, negative, intLen);\n+        // Move end pointer one step back to avoid skipping digits after dot (.)\n+        if(end-1 > _inputEnd){\n+            end = _inputEnd;\n+        }\n+        return _parseFloat(outBuf, outPtr, c, negative, intLen, end);\n     }\n     // to push back trailing char (comma etc)\n     --_inputPtr;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    boolean negative = (c == INT_MINUS);\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n    }\n    // One special case: if first char is 0, must not be followed by a digit\n    if (c == INT_0) {\n        c = _verifyNoLeadingZeroes();\n        // If c is not a valid digit, return a token with zero value\n        if (c < INT_0 || c > INT_9) {\n            outBuf[outPtr++] = '0';\n            _textBuffer.setCurrentLength(outPtr);\n            return resetInt(false, 1);\n        }\n    }\n    // Ok: we can first just add digit we saw first:\n    outBuf[outPtr++] = (char) c;\n    int intLen = 1;\n    // And then figure out how far we can read without further checks:\n    int end = _inputPtr + outBuf.length;\n    if (end > _inputEnd) {\n        end = _inputEnd;\n    }\n    // With this, we have a nice and tight loop:\n    while (true) {\n        if (_inputPtr >= end) {\n            // Long enough to be split across boundary, so:\n            return _parserNumber2(outBuf, outPtr, negative, intLen);\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        if (c < INT_0 || c > INT_9) {\n            break;\n        }\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n    }\n    if (c == '.' || c == 'e' || c == 'E') {\n        return _parseFloat(outBuf, outPtr, c, negative, intLen);\n    }\n    // to push back trailing char (comma etc)\n    --_inputPtr;\n    _textBuffer.setCurrentLength(outPtr);\n    // As per #105, need separating space between root values; check here\n    // And there we have it!\n    return resetInt(negative, intLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n@@ -18,6 +18,12 @@\n     // One special case: if first char is 0, must not be followed by a digit\n     if (c == INT_0) {\n         c = _verifyNoLeadingZeroes();\n+        // If c is not a valid digit, return a token with zero value\n+        if (c < INT_0 || c > INT_9) {\n+            outBuf[outPtr++] = '0';\n+            _textBuffer.setCurrentLength(outPtr);\n+            return resetInt(false, 1);\n+        }\n     }\n     // Ok: we can first just add digit we saw first:\n     outBuf[outPtr++] = (char) c;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    boolean negative = (c == INT_MINUS);\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n    }\n    // One special case: if first char is 0, must not be followed by a digit\n    if (c == INT_0) {\n        c = _verifyNoLeadingZeroes();\n    }\n    // Ok: we can first just add digit we saw first:\n    outBuf[outPtr++] = (char) c;\n    int intLen = 1;\n    // And then figure out how far we can read without further checks:\n    int end = _inputPtr + outBuf.length - outPtr;\n    if (end > _inputEnd) {\n        end = _inputEnd;\n    }\n    // With this, we have a nice and tight loop:\n    while (true) {\n        if (_inputPtr >= end) {\n            // Long enough to be split across boundary, so:\n            return _parserNumber2(outBuf, outPtr, negative, intLen);\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        if (c < INT_0 || c > INT_9) {\n            break;\n        }\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n    }\n    if (c == '.' || c == 'e' || c == 'E') {\n        return _parseFloat(outBuf, outPtr, c, negative, intLen);\n    }\n    // to push back trailing char (comma etc)\n    --_inputPtr;\n    _textBuffer.setCurrentLength(outPtr);\n    // As per #105, need separating space between root values; check here\n    // And there we have it!\n    return resetInt(negative, intLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n@@ -23,7 +23,7 @@\n     outBuf[outPtr++] = (char) c;\n     int intLen = 1;\n     // And then figure out how far we can read without further checks:\n-    int end = _inputPtr + outBuf.length;\n+    int end = _inputPtr + outBuf.length - outPtr;\n     if (end > _inputEnd) {\n         end = _inputEnd;\n     }\n", "finish_reason": "stop", "valid": false, "num": 6}, {"output": "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    boolean negative = (c == INT_MINUS);\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n    }\n    // One special case: if first char is 0, must not be followed by a digit\n    if (c == INT_0) {\n        c = _verifyNoLeadingZeroes();\n    }\n    // Ok: we can first just add digit we saw first:\n    outBuf[outPtr++] = (char) c;\n    int intLen = 1;\n    // And then figure out how far we can read without further checks:\n    int end = _inputPtr + outBuf.length;\n    if (end > _inputEnd) {\n        end = _inputEnd;\n    }\n    // With this, we have a nice and tight loop:\n    while (true) {\n        if (_inputPtr >= end) {\n            if (!loadMore()) {\n                return _parserNumber2(outBuf, outPtr, negative, intLen);\n            }\n            end = _inputEnd;\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        if (c < INT_0 || c > INT_9) {\n            break;\n        }\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n    }\n    if (c == '.' || c == 'e' || c == 'E') {\n        return _parseFloat(outBuf, outPtr, c, negative, intLen);\n    }\n    // to push back trailing char (comma etc)\n    --_inputPtr;\n    _textBuffer.setCurrentLength(outPtr);\n    // As per #105, need separating space between root values; check here\n    // And there we have it!\n    return resetInt(negative, intLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n@@ -30,8 +30,10 @@\n     // With this, we have a nice and tight loop:\n     while (true) {\n         if (_inputPtr >= end) {\n-            // Long enough to be split across boundary, so:\n-            return _parserNumber2(outBuf, outPtr, negative, intLen);\n+            if (!loadMore()) {\n+                return _parserNumber2(outBuf, outPtr, negative, intLen);\n+            }\n+            end = _inputEnd;\n         }\n         c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n         if (c < INT_0 || c > INT_9) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    boolean negative = (c == INT_MINUS);\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n    }\n    // One special case: if first char is 0, must not be followed by a digit\n    if (c == INT_0) {\n        c = _verifyNoLeadingZeroes();\n    }\n    // Ok: we can first just add digit we saw first:\n    outBuf[outPtr++] = (char) c;\n    int intLen = 1;\n    // And then figure out how far we can read without further checks:\n    int end = _inputPtr + outBuf.length;\n    if (end > _inputEnd) {\n        end = _inputEnd;\n    }\n    // With this, we have a nice and tight loop:\n    while (true) {\n        if (_inputPtr >= end) {\n            // Long enough to be split across boundary, so:\n            return _parserNumber2(outBuf, outPtr, negative, intLen);\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        if (c < INT_0 || c > INT_9) {\n            break;\n        }\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n    }\n    if (c == '.' || c == 'e' || c == 'E') {\n        _textBuffer.setCurrentLength(outPtr);\n        return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n    }\n    // to push back trailing char (comma etc)\n    --_inputPtr;\n    _textBuffer.setCurrentLength(outPtr);\n    // As per #105, need separating space between root values; check here\n    // And there we have it!\n    return resetInt(negative, intLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n@@ -45,7 +45,8 @@\n         outBuf[outPtr++] = (char) c;\n     }\n     if (c == '.' || c == 'e' || c == 'E') {\n-        return _parseFloat(outBuf, outPtr, c, negative, intLen);\n+        _textBuffer.setCurrentLength(outPtr);\n+        return _parseFloatText(outBuf, outPtr, c, negative, intLen);\n     }\n     // to push back trailing char (comma etc)\n     --_inputPtr;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    boolean negative = (c == INT_MINUS);\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n    }\n    // One special case: if first char is 0, must not be followed by a digit\n    if (c == INT_0) {\n        c = _verifyNoLeadingZeroes();\n    }\n    // Ok: we can first just add digit we saw first:\n    outBuf[outPtr++] = (char) c;\n    int intLen = 1;\n    // And then figure out how far we can read without further checks:\n    int end = _inputPtr + outBuf.length;\n    if (end > _inputEnd) {\n        end = _inputEnd;\n    }\n    // With this, we have a nice and tight loop:\n    while (true) {\n        if (_inputPtr >= end) {\n            // Long enough to be split across boundary, so:\n            return _parserNumber2(outBuf, outPtr, negative, intLen);\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        if (c < INT_0 || c > INT_9) {\n            break;\n        }\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n    }\n    if (c == '.' || c == 'e' || c == 'E' || c == '-' || c == '+') {\n        return _parseFloat(outBuf, outPtr, c, negative, intLen);\n    }\n    // to push back trailing char (comma etc)\n    --_inputPtr;\n    _textBuffer.setCurrentLength(outPtr);\n    // As per #105, need separating space between root values; check here\n    // And there we have it!\n    return resetInt(negative, intLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n@@ -44,7 +44,7 @@\n         }\n         outBuf[outPtr++] = (char) c;\n     }\n-    if (c == '.' || c == 'e' || c == 'E') {\n+    if (c == '.' || c == 'e' || c == 'E' || c == '-' || c == '+') {\n         return _parseFloat(outBuf, outPtr, c, negative, intLen);\n     }\n     // to push back trailing char (comma etc)\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    boolean negative = (c == INT_MINUS);\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n    }\n    // One special case: if first char is 0, must not be followed by a digit\n    if (c == INT_0) {\n        c = _verifyNoLeadingZeroes();\n    }\n    // Ok: we can first just add digit we saw first:\n    outBuf[outPtr++] = (char) c;\n    int intLen = 1;\n    // And then figure out how far we can read without further checks:\n    int end = _inputPtr + outBuf.length;\n    if (end > _inputEnd) {\n        end = _inputEnd;\n    }\n    // With this, we have a nice and tight loop:\n    while (true) {\n        if (_inputPtr >= end) {\n            // Long enough to be split across boundary, so:\n            return _parserNumber2(outBuf, outPtr, negative, intLen);\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        if (c < INT_0 || c > INT_9) {\n            break;\n        }\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n    }\n    if (c == '.' || c == 'e' || c == 'E') {\n        return _parseFloat(outBuf, outPtr, c, negative, intLen);\n    }\n    // to push back trailing char (comma etc)\n    --_inputPtr;\n    _textBuffer.setCurrentLength(outPtr);\n    // As per #105, need separating space between root values; check here\n    // And there we have it!\n    return reset(negative, intLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n@@ -52,5 +52,5 @@\n     _textBuffer.setCurrentLength(outPtr);\n     // As per #105, need separating space between root values; check here\n     // And there we have it!\n-    return resetInt(negative, intLen);\n+    return reset(negative, intLen);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    boolean negative = (c == INT_MINUS);\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n    }\n    // One special case: if first char is 0, must not be followed by a digit\n    if (c == INT_0) {\n        c = _verifyNoLeadingZeroes();\n    }\n    // Ok: we can first just add digit we saw first:\n    outBuf[outPtr++] = (char) c;\n    int intLen = 1;\n    // And then figure out how far we can read without further checks:\n    int end = _inputPtr + outBuf.length;\n    if (end > _inputEnd) {\n        end = _inputEnd;\n    }\n    // With this, we have a nice and tight loop:\n    while (true) {\n        if (_inputPtr >= end) {\n            // Long enough to be split across boundary, so:\n            return _parserNumber2(outBuf, outPtr, negative, intLen);\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        if (c < INT_0 || c > INT_9) {\n            break;\n        }\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n    }\n    if (c == '.' || c == 'e' || c == 'E') {\n        --_inputPtr;\n        return _parseFloat(outBuf, outPtr, c, negative, intLen);\n    }\n    // to push back trailing char (comma etc)\n    --_inputPtr;\n    _textBuffer.setCurrentLength(outPtr);\n    // As per #105, need separating space between root values; check here\n    // And there we have it!\n    return resetInt(negative, intLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n@@ -45,6 +45,7 @@\n         outBuf[outPtr++] = (char) c;\n     }\n     if (c == '.' || c == 'e' || c == 'E') {\n+        --_inputPtr;\n         return _parseFloat(outBuf, outPtr, c, negative, intLen);\n     }\n     // to push back trailing char (comma etc)\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    boolean negative = (c == INT_MINUS);\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n    }\n    // One special case: if first char is 0, must not be followed by a digit\n    if (c == INT_0) {\n        c = _verifyNoLeadingZeroes();\n    }\n    // Ok: we can first just add digit we saw first:\n    outBuf[outPtr++] = (char) c;\n    int intLen = 1;\n    // And then figure out how far we can read without further checks:\n    int end = _inputPtr + outBuf.length;\n    if (end > _inputEnd) {\n        loadMoreGuaranteed();\n        end = (_inputPtr + outBuf.length < _inputEnd) ? _inputPtr + outBuf.length : _inputEnd;\n    }\n    // With this, we have a nice and tight loop:\n    while (true) {\n        if (_inputPtr >= end) {\n            // Long enough to be split across boundary, so:\n            return _parserNumber2(outBuf, outPtr, negative, intLen);\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        if (c < INT_0 || c > INT_9) {\n            break;\n        }\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n    }\n    if (c == '.' || c == 'e' || c == 'E') {\n        return _parseFloat(outBuf, outPtr, c, negative, intLen);\n    }\n    // to push back trailing char (comma etc)\n    --_inputPtr;\n    _textBuffer.setCurrentLength(outPtr);\n    // As per #105, need separating space between root values; check here\n    // And there we have it!\n    return resetInt(negative, intLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n@@ -25,7 +25,8 @@\n     // And then figure out how far we can read without further checks:\n     int end = _inputPtr + outBuf.length;\n     if (end > _inputEnd) {\n-        end = _inputEnd;\n+        loadMoreGuaranteed();\n+        end = (_inputPtr + outBuf.length < _inputEnd) ? _inputPtr + outBuf.length : _inputEnd;\n     }\n     // With this, we have a nice and tight loop:\n     while (true) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "It's difficult to provide an exact fix without knowing the specific bug, but some possible fixes to improve the code could be:\n\n- Adding more error handling cases for when unexpected characters or situations happen while parsing a number, instead of relying on a single catch-all error handler.\n- Using more descriptive variable names to make the code easier to read and reason about.\n- Simplifying some of the logic by removing unnecessary conditions or redundant checks.\n- Refactoring parts of the function into smaller, more focused functions that can be tested and maintained separately.", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    boolean negative = (c == INT_MINUS);\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n    }\n    // One special case: if first char is 0, must not be followed by a digit\n    if (c == INT_0) {\n        // Verify that no leading zeroes follow\n        c = _verifyNoLeadingZeroes();\n        // If there are leading zeroes, add them to the output buffer\n        if (c == INT_0) {\n            outBuf[outPtr++] = '0';\n            // Check if there are any more leading zeroes\n            while (_inputPtr < _inputEnd) {\n                c = (int) _inputBuffer[_inputPtr] & 0xFF;\n                if (c == INT_0) {\n                    outBuf[outPtr++] = '0';\n                    ++_inputPtr;\n                } else if (c >= INT_1 && c <= INT_9) {\n                    // If we find a non-zero digit after leading zeroes, continue with parsing\n                    break;\n                } else {\n                    // If we find any other character, it's an invalid number\n                    return _handleInvalidNumberStart(c, true);\n                }\n            }\n        }\n    }\n    // Ok: we can first just add digit we saw first:\n    outBuf[outPtr++] = (char) c;\n    int intLen = 1;\n    // And then figure out how far we can read without further checks:\n    int end = _inputPtr + outBuf.length;\n    if (end > _inputEnd) {\n        end = _inputEnd;\n    }\n    // With this, we have a nice and tight loop:\n    while (true) {\n        if (_inputPtr >= end) {\n            // Long enough to be split across boundary, so:\n            return _parserNumber2(outBuf, outPtr, negative, intLen);\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        if (c < INT_0 || c > INT_9) {\n            break;\n        }\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n    }\n    if (c == '.' || c == 'e' || c == 'E') {\n        return _parseFloat(outBuf, outPtr, c, negative, intLen);\n    }\n    // to push back trailing char (comma etc)\n    --_inputPtr;\n    _textBuffer.setCurrentLength(outPtr);\n    // As per #105, need separating space between root values; check here\n    // And there we have it!\n    return resetInt(negative, intLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n@@ -17,7 +17,26 @@\n     }\n     // One special case: if first char is 0, must not be followed by a digit\n     if (c == INT_0) {\n+        // Verify that no leading zeroes follow\n         c = _verifyNoLeadingZeroes();\n+        // If there are leading zeroes, add them to the output buffer\n+        if (c == INT_0) {\n+            outBuf[outPtr++] = '0';\n+            // Check if there are any more leading zeroes\n+            while (_inputPtr < _inputEnd) {\n+                c = (int) _inputBuffer[_inputPtr] & 0xFF;\n+                if (c == INT_0) {\n+                    outBuf[outPtr++] = '0';\n+                    ++_inputPtr;\n+                } else if (c >= INT_1 && c <= INT_9) {\n+                    // If we find a non-zero digit after leading zeroes, continue with parsing\n+                    break;\n+                } else {\n+                    // If we find any other character, it's an invalid number\n+                    return _handleInvalidNumberStart(c, true);\n+                }\n+            }\n+        }\n     }\n     // Ok: we can first just add digit we saw first:\n     outBuf[outPtr++] = (char) c;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    boolean negative = (c == INT_MINUS);\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n    }\n    // One special case: if first char is 0, must not be followed by a digit\n    if (c == INT_0) {\n        c = _verifyNoLeadingZeroes();\n    }\n    // Ok: we can first just add digit we saw first:\n    outBuf[outPtr++] = (char) c;\n    int intLen = 1;\n    // And then figure out how far we can read without further checks:\n    int end = _inputPtr + outBuf.length;\n    if (end > _inputEnd) {\n        loadMoreGuaranteed();\n        end = Math.min(_inputEnd, _inputPtr + outBuf.length);\n    }\n    // With this, we have a nice and tight loop:\n    while (true) {\n        if (_inputPtr >= end) {\n            // Long enough to be split across boundary, so:\n            return _parserNumber2(outBuf, outPtr, negative, intLen);\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        if (c < INT_0 || c > INT_9) {\n            break;\n        }\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n    }\n    if (c == '.' || c == 'e' || c == 'E') {\n        return _parseFloat(outBuf, outPtr, c, negative, intLen);\n    }\n    // to push back trailing char (comma etc)\n    --_inputPtr;\n    _textBuffer.setCurrentLength(outPtr);\n    // As per #105, need separating space between root values; check here\n    // And there we have it!\n    return resetInt(negative, intLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n@@ -25,7 +25,8 @@\n     // And then figure out how far we can read without further checks:\n     int end = _inputPtr + outBuf.length;\n     if (end > _inputEnd) {\n-        end = _inputEnd;\n+        loadMoreGuaranteed();\n+        end = Math.min(_inputEnd, _inputPtr + outBuf.length);\n     }\n     // With this, we have a nice and tight loop:\n     while (true) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonToken _parseNumber(int c) throws IOException, JsonParseException {\n    char[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n    int outPtr = 0;\n    boolean negative = (c == INT_MINUS);\n    // Need to prepend sign?\n    if (negative) {\n        outBuf[outPtr++] = '-';\n        // Must have something after sign too\n        if (_inputPtr >= _inputEnd) {\n            loadMoreGuaranteed();\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        // Note: must be followed by a digit\n        if (c < INT_0 || c > INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n    }\n    // One special case: if first char is 0, must not be followed by a digit\n    if (c == INT_0) {\n        c = _verifyNoLeadingZeroes();\n        // Check if the next character is a digit\n        if (c >= INT_0 && c <= INT_9) {\n            return _handleInvalidNumberStart(c, true);\n        }\n    }\n    // Ok: we can first just add digit we saw first:\n    outBuf[outPtr++] = (char) c;\n    int intLen = 1;\n    // And then figure out how far we can read without further checks:\n    int end = _inputPtr + outBuf.length;\n    if (end > _inputEnd) {\n        end = _inputEnd;\n    }\n    // With this, we have a nice and tight loop:\n    while (true) {\n        if (_inputPtr >= end) {\n            // Long enough to be split across boundary, so:\n            return _parserNumber2(outBuf, outPtr, negative, intLen);\n        }\n        c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n        if (c < INT_0 || c > INT_9) {\n            break;\n        }\n        ++intLen;\n        if (outPtr >= outBuf.length) {\n            outBuf = _textBuffer.finishCurrentSegment();\n            outPtr = 0;\n        }\n        outBuf[outPtr++] = (char) c;\n    }\n    if (c == '.' || c == 'e' || c == 'E') {\n        return _parseFloat(outBuf, outPtr, c, negative, intLen);\n    }\n    // to push back trailing char (comma etc)\n    --_inputPtr;\n    _textBuffer.setCurrentLength(outPtr);\n    // As per #105, need separating space between root values; check here\n    // And there we have it!\n    return resetInt(negative, intLen);\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@_parseNumber\n@@ -18,6 +18,10 @@\n     // One special case: if first char is 0, must not be followed by a digit\n     if (c == INT_0) {\n         c = _verifyNoLeadingZeroes();\n+        // Check if the next character is a digit\n+        if (c >= INT_0 && c <= INT_9) {\n+            return _handleInvalidNumberStart(c, true);\n+        }\n     }\n     // Ok: we can first just add digit we saw first:\n     outBuf[outPtr++] = (char) c;\n", "finish_reason": "stop", "valid": false, "num": 1}]