[{"output": "private void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node varNode = new Node(Token.VAR, nameNode);\n    varNode.setDeclaredTypeExpression(new Node(Token.ANY_TYPE));\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n@@ -9,6 +9,8 @@\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node varNode = new Node(Token.VAR, nameNode);\n+    varNode.setDeclaredTypeExpression(new Node(Token.ANY_TYPE));\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    getSynthesizedExternsRoot().addChildToBack(IR.var(nameNode));\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n@@ -1,5 +1,5 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n     // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n@@ -9,6 +9,6 @@\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    getSynthesizedExternsRoot().addChildToBack(IR.var(nameNode));\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "private void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        IR.var(nameNode).setAddJSDocInfo(true);\n    }\n    getSynthesizedExternsRoot().addChildToBack(IR.var(nameNode));\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n@@ -1,5 +1,5 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n     // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n@@ -7,8 +7,8 @@\n     // compile with undeclaredVars as errors. We have some test\n     // cases for this configuration though, and it makes them happier.\n     if (compiler.getCodingConvention().isConstant(varName)) {\n-        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        IR.var(nameNode).setAddJSDocInfo(true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    getSynthesizedExternsRoot().addChildToBack(IR.var(nameNode));\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        getSynthesizedExternsRoot().addChildToBack(varNode);\n    }\n    else {\n        getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n    }\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n@@ -7,8 +7,12 @@\n     // compile with undeclaredVars as errors. We have some test\n     // cases for this configuration though, and it makes them happier.\n     if (compiler.getCodingConvention().isConstant(varName)) {\n-        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        Node varNode = new Node(Token.VAR, nameNode);\n+        varNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        getSynthesizedExternsRoot().addChildToBack(varNode);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    else {\n+        getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    }\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, I'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    } else {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, false);\n    }\n    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n@@ -2,12 +2,14 @@\n     Node nameNode = Node.newString(Token.NAME, varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n-    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n+    // NOTE(nicksantos): honestly, I'm not sure how much this matters.\n     // AFAIK, all people who use the CONST coding convention also\n     // compile with undeclaredVars as errors. We have some test\n     // cases for this configuration though, and it makes them happier.\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+    } else {\n+        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, false);\n     }\n     getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n     varsToDeclareInExterns.remove(varName);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    } else {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, false); // add this line to fix the bug\n    }\n    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n@@ -8,6 +8,8 @@\n     // cases for this configuration though, and it makes them happier.\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+    } else {\n+        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, false); // add this line to fix the bug\n     }\n     getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n     varsToDeclareInExterns.remove(varName);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (!varsToDeclareInExterns.contains(varName)\n        && compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n@@ -6,7 +6,8 @@\n     // AFAIK, all people who use the CONST coding convention also\n     // compile with undeclaredVars as errors. We have some test\n     // cases for this configuration though, and it makes them happier.\n-    if (compiler.getCodingConvention().isConstant(varName)) {\n+    if (!varsToDeclareInExterns.contains(varName)\n+        && compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n     getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node varNode = new Node(Token.VAR, nameNode);\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n@@ -9,6 +9,7 @@\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node varNode = new Node(Token.VAR, nameNode);\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node varNode = IR.var(nameNode);\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n@@ -1,5 +1,5 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n     // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n@@ -9,6 +9,7 @@\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node varNode = IR.var(nameNode);\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "private void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, I'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    getSynthesizedExternsRoot().addChildToBack(new Node(Token.NAME, nameNode)); // changed Token.VAR to Token.NAME\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n@@ -2,13 +2,13 @@\n     Node nameNode = Node.newString(Token.NAME, varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n-    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n+    // NOTE(nicksantos): honestly, I'm not sure how much this matters.\n     // AFAIK, all people who use the CONST coding convention also\n     // compile with undeclaredVars as errors. We have some test\n     // cases for this configuration though, and it makes them happier.\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    getSynthesizedExternsRoot().addChildToBack(new Node(Token.NAME, nameNode)); // changed Token.VAR to Token.NAME\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putProp(Node.IS_CONSTANT_NAME, true);\n    }\n    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n@@ -7,7 +7,7 @@\n     // compile with undeclaredVars as errors. We have some test\n     // cases for this configuration though, and it makes them happier.\n     if (compiler.getCodingConvention().isConstant(varName)) {\n-        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        nameNode.putProp(Node.IS_CONSTANT_NAME, true);\n     }\n     getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n     varsToDeclareInExterns.remove(varName);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    getSynthesizedExternsRoot().addChildToFront(IR.var(nameNode));\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n@@ -1,5 +1,5 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n     // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n@@ -9,6 +9,6 @@\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    getSynthesizedExternsRoot().addChildToFront(IR.var(nameNode));\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName); // use IR factory method to create a name node\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    getSynthesizedExternsRoot().addChildToBack(IR.var(nameNode)); // use IR factory method to create a var node\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n@@ -1,14 +1,10 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName); // use IR factory method to create a name node\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n-    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n-    // AFAIK, all people who use the CONST coding convention also\n-    // compile with undeclaredVars as errors. We have some test\n-    // cases for this configuration though, and it makes them happier.\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    getSynthesizedExternsRoot().addChildToBack(IR.var(nameNode)); // use IR factory method to create a var node\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node varNode = IR.var(nameNode).setDeclaredTypeExpression(IR.anyType());\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n@@ -1,5 +1,5 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n     // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n@@ -9,6 +9,7 @@\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node varNode = IR.var(nameNode).setDeclaredTypeExpression(IR.anyType());\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        nameNode.putIntProp(Node.FREE_CALL, 1);\n    } else {\n        nameNode.putIntProp(Node.FREE_CALL, 0);\n    }\n    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.java@createSynthesizedExternVar\n@@ -8,6 +8,9 @@\n     // cases for this configuration though, and it makes them happier.\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+        nameNode.putIntProp(Node.FREE_CALL, 1);\n+    } else {\n+        nameNode.putIntProp(Node.FREE_CALL, 0);\n     }\n     getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n     varsToDeclareInExterns.remove(varName);\n", "finish_reason": "stop", "valid": false, "num": 1}]