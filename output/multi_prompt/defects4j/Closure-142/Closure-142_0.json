[{"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color(coloring.getPrecolored()); //color precolored nodes first\n    coloring.color();\n    colorings.push(coloring);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -17,6 +17,7 @@\n     liveness.analyze();\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n+    coloring.color(coloring.getPrecolored()); //color precolored nodes first\n     coloring.color();\n     colorings.push(coloring);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    try {\n        coloring.color();\n    } catch (GraphColoring.ConflictingColorsException e) {\n        // Fallback to SimpleGraphColoring when ColorException occurs\n        coloring = new SimpleGraphColoring<>(interferenceGraph, coloringTieBreaker);\n        coloring.color();\n    }\n    colorings.push(coloring);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -1,22 +1,20 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    // TODO(user): We CAN do this in the global scope, just need to be\n-    // careful when something is exported. Liveness uses bit-vector for live\n-    // sets so I don't see compilation time will be a problem for running this\n-    // pass in the global scope.\n     Scope scope = t.getScope();\n     if (scope.isGlobal()) {\n         return;\n     }\n     ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n     LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n-    // If the function has exactly 2 params, mark them as escaped. This is\n-    // a work-around for an IE bug where it throws an exception if you\n-    // write to the parameters of the callback in a sort(). See:\n-    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n-    coloring.color();\n+    try {\n+        coloring.color();\n+    } catch (GraphColoring.ConflictingColorsException e) {\n+        // Fallback to SimpleGraphColoring when ColorException occurs\n+        coloring = new SimpleGraphColoring<>(interferenceGraph, coloringTieBreaker);\n+        coloring.color();\n+    }\n     colorings.push(coloring);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    Set<Var> escapedLocals = liveness.getEscapedLocals();\n    if (escapedLocals == null) {\n        escapedLocals = Collections.emptySet();\n    }\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, escapedLocals);\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -1,9 +1,5 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    // TODO(user): We CAN do this in the global scope, just need to be\n-    // careful when something is exported. Liveness uses bit-vector for live\n-    // sets so I don't see compilation time will be a problem for running this\n-    // pass in the global scope.\n     Scope scope = t.getScope();\n     if (scope.isGlobal()) {\n         return;\n@@ -15,7 +11,11 @@\n     // write to the parameters of the callback in a sort(). See:\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n-    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n+    Set<Var> escapedLocals = liveness.getEscapedLocals();\n+    if (escapedLocals == null) {\n+        escapedLocals = Collections.emptySet();\n+    }\n+    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, escapedLocals);\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n     coloring.color();\n     colorings.push(coloring);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    if (scope.isGlobal() || scope.isModuleScope()) {\n        // If the scope is global or module scope, we don't need to perform\n        // liveness analysis and graph coloring.\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -1,11 +1,9 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    // TODO(user): We CAN do this in the global scope, just need to be\n-    // careful when something is exported. Liveness uses bit-vector for live\n-    // sets so I don't see compilation time will be a problem for running this\n-    // pass in the global scope.\n     Scope scope = t.getScope();\n-    if (scope.isGlobal()) {\n+    if (scope.isGlobal() || scope.isModuleScope()) {\n+        // If the scope is global or module scope, we don't need to perform\n+        // liveness analysis and graph coloring.\n         return;\n     }\n     ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    if (interferenceGraph == null) {\n        // Early exit since we can't compute the interference graph.\n        return;\n    }\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -1,9 +1,5 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    // TODO(user): We CAN do this in the global scope, just need to be\n-    // careful when something is exported. Liveness uses bit-vector for live\n-    // sets so I don't see compilation time will be a problem for running this\n-    // pass in the global scope.\n     Scope scope = t.getScope();\n     if (scope.isGlobal()) {\n         return;\n@@ -16,6 +12,10 @@\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n+    if (interferenceGraph == null) {\n+        // Early exit since we can't compute the interference graph.\n+        return;\n+    }\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n     coloring.color();\n     colorings.push(coloring);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    Set<Var> escapedLocals = liveness.getEscapedLocals();\n    if (escapedLocals != null) {\n        UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, escapedLocals);\n        GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n        coloring.color();\n        colorings.push(coloring);\n    }\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -15,8 +15,11 @@\n     // write to the parameters of the callback in a sort(). See:\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n-    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n-    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n-    coloring.color();\n-    colorings.push(coloring);\n+    Set<Var> escapedLocals = liveness.getEscapedLocals();\n+    if (escapedLocals != null) {\n+        UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, escapedLocals);\n+        GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n+        coloring.color();\n+        colorings.push(coloring);\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    try {\n        coloring.color();\n    } catch (GraphColoring.TooManyColorsException e) {\n        // If there are too many colors, switch to a backtracking graph coloring algorithm\n        BacktrackingGraphColoring<Var, Void> backtrackingColoring = new BacktrackingGraphColoring<>(interferenceGraph,\n            coloringTieBreaker, 10, IMPOSSIBLE_COLORING_FUNCTION);\n        backtrackingColoring.color();\n        colorings.push(backtrackingColoring);\n        return;\n    }\n    colorings.push(coloring);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -1,9 +1,5 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    // TODO(user): We CAN do this in the global scope, just need to be\n-    // careful when something is exported. Liveness uses bit-vector for live\n-    // sets so I don't see compilation time will be a problem for running this\n-    // pass in the global scope.\n     Scope scope = t.getScope();\n     if (scope.isGlobal()) {\n         return;\n@@ -17,6 +13,15 @@\n     liveness.analyze();\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n-    coloring.color();\n+    try {\n+        coloring.color();\n+    } catch (GraphColoring.TooManyColorsException e) {\n+        // If there are too many colors, switch to a backtracking graph coloring algorithm\n+        BacktrackingGraphColoring<Var, Void> backtrackingColoring = new BacktrackingGraphColoring<>(interferenceGraph,\n+            coloringTieBreaker, 10, IMPOSSIBLE_COLORING_FUNCTION);\n+        backtrackingColoring.color();\n+        colorings.push(backtrackingColoring);\n+        return;\n+    }\n     colorings.push(coloring);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    liveness.analyze();\n    Set<Var> escapedLocals = liveness.getEscapedLocals();\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    for (Var param : scope.getParameters()) {\n        if (param.isParam() && !param.getParentNode().isFunction()) {\n            escapedLocals.add(param);\n        }\n    }\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, escapedLocals);\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -10,12 +10,18 @@\n     }\n     ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n     LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n+    liveness.analyze();\n+    Set<Var> escapedLocals = liveness.getEscapedLocals();\n     // If the function has exactly 2 params, mark them as escaped. This is\n     // a work-around for an IE bug where it throws an exception if you\n     // write to the parameters of the callback in a sort(). See:\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n-    liveness.analyze();\n-    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n+    for (Var param : scope.getParameters()) {\n+        if (param.isParam() && !param.getParentNode().isFunction()) {\n+            escapedLocals.add(param);\n+        }\n+    }\n+    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, escapedLocals);\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n     coloring.color();\n     colorings.push(coloring);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    interferenceGraph = applyOptimizations(interferenceGraph); // Adding optimization\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}\n\n// Newly added function to optimize our interferenceGraph\npublic UndiGraph<Var, Void> applyOptimizations(UndiGraph<Var, Void> interferenceGraph) {\n    // Applying optimizations\n    // ...\n    return interferenceGraph;\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -16,6 +16,7 @@\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n+    interferenceGraph = applyOptimizations(interferenceGraph); // Adding optimization\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n     coloring.color();\n     colorings.push(coloring);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    // Ensure that the graph has nodes before calling the graph coloring algorithm.\n    if (interferenceGraph.getNodes().isEmpty()) {\n        return;\n    }\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -10,12 +10,12 @@\n     }\n     ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n     LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n-    // If the function has exactly 2 params, mark them as escaped. This is\n-    // a work-around for an IE bug where it throws an exception if you\n-    // write to the parameters of the callback in a sort(). See:\n-    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n+    // Ensure that the graph has nodes before calling the graph coloring algorithm.\n+    if (interferenceGraph.getNodes().isEmpty()) {\n+        return;\n+    }\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n     coloring.color();\n     colorings.push(coloring);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    liveness.analyze();\n    Set<Var> escapedLocals = liveness.getEscapedLocals();\n    escapedLocals.addAll(scope.getArgumentsShadowedInScope());\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, escapedLocals);\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -10,12 +10,10 @@\n     }\n     ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n     LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n-    // If the function has exactly 2 params, mark them as escaped. This is\n-    // a work-around for an IE bug where it throws an exception if you\n-    // write to the parameters of the callback in a sort(). See:\n-    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n-    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n+    Set<Var> escapedLocals = liveness.getEscapedLocals();\n+    escapedLocals.addAll(scope.getArgumentsShadowedInScope());\n+    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, escapedLocals);\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n     coloring.color();\n     colorings.push(coloring);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    // The coloringTieBreaker field should have been declared in the class as private\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<>(interferenceGraph, this.coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -16,7 +16,8 @@\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n-    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n+    // The coloringTieBreaker field should have been declared in the class as private\n+    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<>(interferenceGraph, this.coloringTieBreaker);\n     coloring.color();\n     colorings.push(coloring);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, colorMap -> Collections.emptySet(), coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -16,7 +16,7 @@\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n-    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n+    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, colorMap -> Collections.emptySet(), coloringTieBreaker);\n     coloring.color();\n     colorings.push(coloring);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n    // Fix: create a new Liveness object for each analysis\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    liveness.analyze();\n\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -9,12 +9,15 @@\n         return;\n     }\n     ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n+\n+    // Fix: create a new Liveness object for each analysis\n     LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n+    liveness.analyze();\n+\n     // If the function has exactly 2 params, mark them as escaped. This is\n     // a work-around for an IE bug where it throws an exception if you\n     // write to the parameters of the callback in a sort(). See:\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n-    liveness.analyze();\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n     coloring.color();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph);\n    // Use the coloringTieBreaker only if it is not null\n    if (coloringTieBreaker != null) {\n        coloring.color(coloringTieBreaker);\n    } else {\n        coloring.color();\n    }\n    colorings.push(coloring);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -16,7 +16,12 @@\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n-    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n-    coloring.color();\n+    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph);\n+    // Use the coloringTieBreaker only if it is not null\n+    if (coloringTieBreaker != null) {\n+        coloring.color(coloringTieBreaker);\n+    } else {\n+        coloring.color();\n+    }\n     colorings.push(coloring);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color(interferenceGraph.getNodes());\n    colorings.push(coloring);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -17,6 +17,6 @@\n     liveness.analyze();\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n-    coloring.color();\n+    coloring.color(interferenceGraph.getNodes());\n     colorings.push(coloring);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    Set<Var> escapedLocals = liveness.getEscapedLocals();\n    if (escapedLocals != null && !escapedLocals.isEmpty()) {\n        UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, escapedLocals);\n        GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n        coloring.color();\n        colorings.push(coloring);\n    }\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -15,8 +15,11 @@\n     // write to the parameters of the callback in a sort(). See:\n     // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n-    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n-    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n-    coloring.color();\n-    colorings.push(coloring);\n+    Set<Var> escapedLocals = liveness.getEscapedLocals();\n+    if (escapedLocals != null && !escapedLocals.isEmpty()) {\n+        UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, escapedLocals);\n+        GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n+        coloring.color();\n+        colorings.push(coloring);\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n     // Fix: exclude function parameters from the escaped locals set\n    liveness.setEscapedLocals(Sets.difference(liveness.getEscapedLocals(), scope.getScopeRoot().getDeclaredParams()));\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -10,6 +10,8 @@\n     }\n     ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n     LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n+     // Fix: exclude function parameters from the escaped locals set\n+    liveness.setEscapedLocals(Sets.difference(liveness.getEscapedLocals(), scope.getScopeRoot().getDeclaredParams()));\n     // If the function has exactly 2 params, mark them as escaped. This is\n     // a work-around for an IE bug where it throws an exception if you\n     // write to the parameters of the callback in a sort(). See:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    liveness.analyze();\n    if (scope.isFunctionBlockScope() && scope.getRootNode().getChildCount() == 3) {\n        for (Var var : scope.getVars()) {\n            if (var.isParam()) {\n                liveness.getEscapedLocals().add(var);\n            }\n        }\n    }\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -10,11 +10,14 @@\n     }\n     ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n     LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n-    // If the function has exactly 2 params, mark them as escaped. This is\n-    // a work-around for an IE bug where it throws an exception if you\n-    // write to the parameters of the callback in a sort(). See:\n-    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n     liveness.analyze();\n+    if (scope.isFunctionBlockScope() && scope.getRootNode().getChildCount() == 3) {\n+        for (Var var : scope.getVars()) {\n+            if (var.isParam()) {\n+                liveness.getEscapedLocals().add(var);\n+            }\n+        }\n+    }\n     UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n     GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n     coloring.color();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n        return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler, t.getModule());\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    liveness.analyze();\n    UndiGraph<Var, Void> interferenceGraph = computeVariableNamesInterferenceGraph(t, cfg, liveness.getEscapedLocals());\n    GraphColoring<Var, Void> coloring = new GreedyGraphColoring<Var, Void>(interferenceGraph, coloringTieBreaker);\n    coloring.color();\n    colorings.push(coloring);\n}", "diff": "--- com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n+++ com/google/javascript/jscomp/CoalesceVariableNames.java@enterScope\n@@ -9,7 +9,7 @@\n         return;\n     }\n     ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n-    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n+    LiveVariablesAnalysis liveness = new LiveVariablesAnalysis(cfg, scope, compiler, t.getModule());\n     // If the function has exactly 2 params, mark them as escaped. This is\n     // a work-around for an IE bug where it throws an exception if you\n     // write to the parameters of the callback in a sort(). See:\n", "finish_reason": "stop", "valid": false, "num": 1}]