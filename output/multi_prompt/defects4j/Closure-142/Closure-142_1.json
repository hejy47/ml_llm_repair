[{"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                ignoreStar = true;\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = false;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -26,12 +26,13 @@\n                     builder.append('*');\n                 }\n                 token = next();\n+                ignoreStar = true;\n                 continue;\n             case EOL:\n                 if (option != WhitespaceOption.SINGLE_LINE) {\n                     builder.append(\"\\n\");\n                 }\n-                ignoreStar = true;\n+                ignoreStar = false;\n                 token = next();\n                 continue;\n             case ANNOTATION:\n@@ -49,7 +50,6 @@\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n                 return new ExtractionInfo(multilineText, token);\n-            // FALL THROUGH\n             default:\n                 ignoreStar = false;\n                 state = State.SEARCHING_ANNOTATION;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno() + line.length(); // add the length of the last line\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -44,7 +44,7 @@\n                     multilineText = multilineText.trim();\n                 }\n                 int endLineno = stream.getLineno();\n-                int endCharno = stream.getCharno();\n+                int endCharno = stream.getCharno() + line.length(); // add the length of the last line\n                 if (multilineText.length() > 0) {\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0 && builder.charAt(builder.length()-1) != ' ') {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0 && builder.charAt(builder.length()-1) != ' ') {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -20,7 +20,7 @@\n         switch(token) {\n             case STAR:\n                 if (!ignoreStar) {\n-                    if (builder.length() > 0) {\n+                    if (builder.length() > 0 && builder.charAt(builder.length()-1) != ' ') {\n                         builder.append(' ');\n                     }\n                     builder.append('*');\n@@ -53,7 +53,7 @@\n             default:\n                 ignoreStar = false;\n                 state = State.SEARCHING_ANNOTATION;\n-                if (builder.length() > 0) {\n+                if (builder.length() > 0 && builder.charAt(builder.length()-1) != ' ') {\n                     builder.append(' ');\n                 }\n                 builder.append(toString(token));\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n                // FALL THROUGH\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -35,6 +35,7 @@\n                 token = next();\n                 continue;\n             case ANNOTATION:\n+                // FALL THROUGH\n             case EOC:\n             case EOF:\n                 // When we're capturing a license block, annotations\n@@ -49,7 +50,6 @@\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n                 return new ExtractionInfo(multilineText, token);\n-            // FALL THROUGH\n             default:\n                 ignoreStar = false;\n                 state = State.SEARCHING_ANNOTATION;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno() + line.length() + 1;\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -44,7 +44,7 @@\n                     multilineText = multilineText.trim();\n                 }\n                 int endLineno = stream.getLineno();\n-                int endCharno = stream.getCharno();\n+                int endCharno = stream.getCharno() + line.length() + 1;\n                 if (multilineText.length() > 0) {\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ') {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ') {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -20,7 +20,7 @@\n         switch(token) {\n             case STAR:\n                 if (!ignoreStar) {\n-                    if (builder.length() > 0) {\n+                    if (builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ') {\n                         builder.append(' ');\n                     }\n                     builder.append('*');\n@@ -53,7 +53,7 @@\n             default:\n                 ignoreStar = false;\n                 state = State.SEARCHING_ANNOTATION;\n-                if (builder.length() > 0) {\n+                if (builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ') {\n                     builder.append(' ');\n                 }\n                 builder.append(toString(token));\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n                // FALL THROUGH\n            case BLOCKTAG:\n                // FALL THROUGH\n            case INLINE_TAG_START:\n                // FALL THROUGH\n            case INLINE_TAG_END:\n                // FALL THROUGH\n            case TYPE:\n                // FALL THROUGH\n            case PARAM:\n                // FALL THROUGH\n            case METHOD:\n                // FALL THROUGH\n            case FIELD:\n                // FALL THROUGH\n            case TEMPLATE_TYPE:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -35,6 +35,22 @@\n                 token = next();\n                 continue;\n             case ANNOTATION:\n+                // FALL THROUGH\n+            case BLOCKTAG:\n+                // FALL THROUGH\n+            case INLINE_TAG_START:\n+                // FALL THROUGH\n+            case INLINE_TAG_END:\n+                // FALL THROUGH\n+            case TYPE:\n+                // FALL THROUGH\n+            case PARAM:\n+                // FALL THROUGH\n+            case METHOD:\n+                // FALL THROUGH\n+            case FIELD:\n+                // FALL THROUGH\n+            case TEMPLATE_TYPE:\n             case EOC:\n             case EOF:\n                 // When we're capturing a license block, annotations\n@@ -49,7 +65,6 @@\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n                 return new ExtractionInfo(multilineText, token);\n-            // FALL THROUGH\n             default:\n                 ignoreStar = false;\n                 state = State.SEARCHING_ANNOTATION;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                ignoreStar = true;\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = false;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -26,12 +26,13 @@\n                     builder.append('*');\n                 }\n                 token = next();\n+                ignoreStar = true;\n                 continue;\n             case EOL:\n                 if (option != WhitespaceOption.SINGLE_LINE) {\n                     builder.append(\"\\n\");\n                 }\n-                ignoreStar = true;\n+                ignoreStar = false;\n                 token = next();\n                 continue;\n             case ANNOTATION:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                break; // fix: added break to exit the switch\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                break; // fix: added break to exit the switch\n        }\n        token = next(); // fix: moved next() to the end of loop\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -6,7 +6,7 @@\n     stream.update();\n     int startLineno = stream.getLineno();\n     int startCharno = stream.getCharno() + 1;\n-    // Read the content from the first line.\n+    // Read the content from the first line\n     String line = stream.getRemainingJSDocLine();\n     if (option != WhitespaceOption.PRESERVE) {\n         line = line.trim();\n@@ -32,8 +32,7 @@\n                     builder.append(\"\\n\");\n                 }\n                 ignoreStar = true;\n-                token = next();\n-                continue;\n+                break; // fix: added break to exit the switch\n             case ANNOTATION:\n             case EOC:\n             case EOF:\n@@ -49,7 +48,6 @@\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n                 return new ExtractionInfo(multilineText, token);\n-            // FALL THROUGH\n             default:\n                 ignoreStar = false;\n                 state = State.SEARCHING_ANNOTATION;\n@@ -62,7 +60,8 @@\n                     line = trimEnd(line);\n                 }\n                 builder.append(line);\n-                token = next();\n+                break; // fix: added break to exit the switch\n         }\n+        token = next(); // fix: moved next() to the end of loop\n     } while (true);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    State state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                ignoreStar = true;\n                token = next();\n                break;\n            case EOL:\n                if (option == WhitespaceOption.SINGLE_LINE) {\n                    state = State.SEARCHING_ANNOTATION;\n                } else {\n                    if (builder.length() > 0) {\n                        builder.append('\\n');\n                    }\n                }\n                ignoreStar = true;\n                token = next();\n                break;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno() - 1;\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            default:\n                ignoreStar = false;\n                if (state != State.CAPTURE) {\n                    state = State.SEARCHING_ANNOTATION;\n                }\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = line.trim();\n                }\n                builder.append(line);\n                token = next();\n                break;\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -13,7 +13,7 @@\n     }\n     StringBuilder builder = new StringBuilder();\n     builder.append(line);\n-    state = State.SEARCHING_ANNOTATION;\n+    State state = State.SEARCHING_ANNOTATION;\n     token = next();\n     boolean ignoreStar = false;\n     do {\n@@ -25,15 +25,20 @@\n                     }\n                     builder.append('*');\n                 }\n+                ignoreStar = true;\n                 token = next();\n-                continue;\n+                break;\n             case EOL:\n-                if (option != WhitespaceOption.SINGLE_LINE) {\n-                    builder.append(\"\\n\");\n+                if (option == WhitespaceOption.SINGLE_LINE) {\n+                    state = State.SEARCHING_ANNOTATION;\n+                } else {\n+                    if (builder.length() > 0) {\n+                        builder.append('\\n');\n+                    }\n                 }\n                 ignoreStar = true;\n                 token = next();\n-                continue;\n+                break;\n             case ANNOTATION:\n             case EOC:\n             case EOF:\n@@ -44,25 +49,27 @@\n                     multilineText = multilineText.trim();\n                 }\n                 int endLineno = stream.getLineno();\n-                int endCharno = stream.getCharno();\n+                int endCharno = stream.getCharno() - 1;\n                 if (multilineText.length() > 0) {\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n                 return new ExtractionInfo(multilineText, token);\n-            // FALL THROUGH\n             default:\n                 ignoreStar = false;\n-                state = State.SEARCHING_ANNOTATION;\n+                if (state != State.CAPTURE) {\n+                    state = State.SEARCHING_ANNOTATION;\n+                }\n                 if (builder.length() > 0) {\n                     builder.append(' ');\n                 }\n                 builder.append(toString(token));\n                 line = stream.getRemainingJSDocLine();\n                 if (option != WhitespaceOption.PRESERVE) {\n-                    line = trimEnd(line);\n+                    line = line.trim();\n                 }\n                 builder.append(line);\n                 token = next();\n+                break;\n         }\n     } while (true);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                ignoreStar = false;\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -25,6 +25,7 @@\n                     }\n                     builder.append('*');\n                 }\n+                ignoreStar = false;\n                 token = next();\n                 continue;\n             case EOL:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n                // FALL THROUGH\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -35,6 +35,7 @@\n                 token = next();\n                 continue;\n             case ANNOTATION:\n+                // FALL THROUGH\n             case EOC:\n             case EOF:\n                 // When we're capturing a license block, annotations\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                ignoreStar = true; // fixed: ignoreStar should be set to true after processing '*'\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -26,6 +26,7 @@\n                     builder.append('*');\n                 }\n                 token = next();\n+                ignoreStar = true; // fixed: ignoreStar should be set to true after processing '*'\n                 continue;\n             case EOL:\n                 if (option != WhitespaceOption.SINGLE_LINE) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    boolean ignoreStar = false;\n    do {\n        token = next();\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            default:\n                ignoreStar = false;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -13,10 +13,9 @@\n     }\n     StringBuilder builder = new StringBuilder();\n     builder.append(line);\n-    state = State.SEARCHING_ANNOTATION;\n-    token = next();\n     boolean ignoreStar = false;\n     do {\n+        token = next();\n         switch(token) {\n             case STAR:\n                 if (!ignoreStar) {\n@@ -25,14 +24,12 @@\n                     }\n                     builder.append('*');\n                 }\n-                token = next();\n                 continue;\n             case EOL:\n                 if (option != WhitespaceOption.SINGLE_LINE) {\n                     builder.append(\"\\n\");\n                 }\n                 ignoreStar = true;\n-                token = next();\n                 continue;\n             case ANNOTATION:\n             case EOC:\n@@ -49,10 +46,8 @@\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n                 return new ExtractionInfo(multilineText, token);\n-            // FALL THROUGH\n             default:\n                 ignoreStar = false;\n-                state = State.SEARCHING_ANNOTATION;\n                 if (builder.length() > 0) {\n                     builder.append(' ');\n                 }\n@@ -62,7 +57,6 @@\n                     line = trimEnd(line);\n                 }\n                 builder.append(line);\n-                token = next();\n         }\n     } while (true);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                ignoreStar = false; // Fix: reset the flag to false\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno(); // Fix: get the correct endCharno\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -25,6 +25,7 @@\n                     }\n                     builder.append('*');\n                 }\n+                ignoreStar = false; // Fix: reset the flag to false\n                 token = next();\n                 continue;\n             case EOL:\n@@ -44,7 +45,7 @@\n                     multilineText = multilineText.trim();\n                 }\n                 int endLineno = stream.getLineno();\n-                int endCharno = stream.getCharno();\n+                int endCharno = stream.getCharno(); // Fix: get the correct endCharno\n                 if (multilineText.length() > 0) {\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                ignoreStar = true;\n                break;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = false;\n                token = next();\n                break;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -26,14 +26,15 @@\n                     builder.append('*');\n                 }\n                 token = next();\n-                continue;\n+                ignoreStar = true;\n+                break;\n             case EOL:\n                 if (option != WhitespaceOption.SINGLE_LINE) {\n                     builder.append(\"\\n\");\n                 }\n-                ignoreStar = true;\n+                ignoreStar = false;\n                 token = next();\n-                continue;\n+                break;\n             case ANNOTATION:\n             case EOC:\n             case EOF:\n@@ -49,7 +50,6 @@\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n                 return new ExtractionInfo(multilineText, token);\n-            // FALL THROUGH\n             default:\n                 ignoreStar = false;\n                 state = State.SEARCHING_ANNOTATION;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0) {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                continue;\n            case EOL:\n                if (option == WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\\\n\");\n                } else {\n                    builder.append('\\n');\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            case ANNOTATION:\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (multilineText.length() > 0) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            // FALL THROUGH\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0) {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                line = stream.getRemainingJSDocLine();\n                if (option != WhitespaceOption.PRESERVE) {\n                    line = trimEnd(line);\n                }\n                builder.append(line);\n                token = next();\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -28,8 +28,10 @@\n                 token = next();\n                 continue;\n             case EOL:\n-                if (option != WhitespaceOption.SINGLE_LINE) {\n-                    builder.append(\"\\n\");\n+                if (option == WhitespaceOption.SINGLE_LINE) {\n+                    builder.append(\"\\\\n\");\n+                } else {\n+                    builder.append('\\n');\n                 }\n                 ignoreStar = true;\n                 token = next();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"fallthrough\")\nprivate ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n        return new ExtractionInfo(\"\", token);\n    }\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n    if (option != WhitespaceOption.PRESERVE) {\n        line = line.trim();\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n    boolean ignoreStar = false;\n    do {\n        switch(token) {\n            case STAR:\n                if (!ignoreStar) {\n                    if (builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ') {\n                        builder.append(' ');\n                    }\n                    builder.append('*');\n                }\n                token = next();\n                ignoreStar = true;\n                continue;\n            case EOC:\n            case EOF:\n                // When we're capturing a license block, annotations\n                // in the block are ok.\n                String multilineText = builder.toString();\n                if (option != WhitespaceOption.PRESERVE) {\n                    multilineText = multilineText.trim();\n                }\n                int endLineno = stream.getLineno();\n                int endCharno = stream.getCharno();\n                if (!\"\".equals(multilineText)) {\n                    jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                }\n                return new ExtractionInfo(multilineText, token);\n            case ANNOTATION:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ') {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                token = next();\n                continue;\n            case EOL:\n                if (option != WhitespaceOption.SINGLE_LINE) {\n                    builder.append(\"\\n\");\n                }\n                ignoreStar = true;\n                token = next();\n                continue;\n            default:\n                ignoreStar = false;\n                state = State.SEARCHING_ANNOTATION;\n                if (builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ') {\n                    builder.append(' ');\n                }\n                builder.append(toString(token));\n                token = next();\n                continue;\n        }\n    } while (true);\n}", "diff": "--- com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n+++ com/google/javascript/jscomp/parsing/JsDocInfoParser.java@extractMultilineTextualBlock\n@@ -20,21 +20,14 @@\n         switch(token) {\n             case STAR:\n                 if (!ignoreStar) {\n-                    if (builder.length() > 0) {\n+                    if (builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ') {\n                         builder.append(' ');\n                     }\n                     builder.append('*');\n                 }\n                 token = next();\n+                ignoreStar = true;\n                 continue;\n-            case EOL:\n-                if (option != WhitespaceOption.SINGLE_LINE) {\n-                    builder.append(\"\\n\");\n-                }\n-                ignoreStar = true;\n-                token = next();\n-                continue;\n-            case ANNOTATION:\n             case EOC:\n             case EOF:\n                 // When we're capturing a license block, annotations\n@@ -45,24 +38,35 @@\n                 }\n                 int endLineno = stream.getLineno();\n                 int endCharno = stream.getCharno();\n-                if (multilineText.length() > 0) {\n+                if (!\"\".equals(multilineText)) {\n                     jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n                 }\n                 return new ExtractionInfo(multilineText, token);\n-            // FALL THROUGH\n+            case ANNOTATION:\n+                ignoreStar = false;\n+                state = State.SEARCHING_ANNOTATION;\n+                if (builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ') {\n+                    builder.append(' ');\n+                }\n+                builder.append(toString(token));\n+                token = next();\n+                continue;\n+            case EOL:\n+                if (option != WhitespaceOption.SINGLE_LINE) {\n+                    builder.append(\"\\n\");\n+                }\n+                ignoreStar = true;\n+                token = next();\n+                continue;\n             default:\n                 ignoreStar = false;\n                 state = State.SEARCHING_ANNOTATION;\n-                if (builder.length() > 0) {\n+                if (builder.length() > 0 && builder.charAt(builder.length() - 1) != ' ') {\n                     builder.append(' ');\n                 }\n                 builder.append(toString(token));\n-                line = stream.getRemainingJSDocLine();\n-                if (option != WhitespaceOption.PRESERVE) {\n-                    line = trimEnd(line);\n-                }\n-                builder.append(line);\n                 token = next();\n+                continue;\n         }\n     } while (true);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]