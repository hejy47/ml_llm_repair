[{"output": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n            if (!typeA.isPropertyTypeDeclared(property)) {\n                // If one inferred property isn't a subtype,\n                // then the whole record isn't covariant.\n                if (!propA.isSubtype(propB)) {\n                    return false;\n                }\n            } else {\n                // If one declared property isn't invariant,\n                // then the whole record isn't covariant.\n                if (!propA.isInvariant(propB)) {\n                    return false;\n                }\n            }\n        }\n    }\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n+++ com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n@@ -1,4 +1,26 @@\n static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n+    for (String property : typeB.properties.keySet()) {\n+        if (!typeA.hasProperty(property)) {\n+            return false;\n+        }\n+        JSType propA = typeA.getPropertyType(property);\n+        JSType propB = typeB.getPropertyType(property);\n+        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n+            if (!typeA.isPropertyTypeDeclared(property)) {\n+                // If one inferred property isn't a subtype,\n+                // then the whole record isn't covariant.\n+                if (!propA.isSubtype(propB)) {\n+                    return false;\n+                }\n+            } else {\n+                // If one declared property isn't invariant,\n+                // then the whole record isn't covariant.\n+                if (!propA.isInvariant(propB)) {\n+                    return false;\n+                }\n+            }\n+        }\n+    }\n     // typeA is a subtype of record type typeB iff:\n     // 1) typeA has all the properties declared in typeB.\n     // 2) And for each property of typeB,\n@@ -16,27 +38,5 @@\n     // properties. But z can be assigned to x. Even though z and y are the\n     // same type, the properties of z are inferred--and so an assignment\n     // to the property of z would not violate any restrictions on it.\n-    for (String property : typeB.properties.keySet()) {\n-        if (!typeA.hasProperty(property)) {\n-            return false;\n-        }\n-        JSType propA = typeA.getPropertyType(property);\n-        JSType propB = typeB.getPropertyType(property);\n-        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n-            if (typeA.isPropertyTypeDeclared(property)) {\n-                // If one declared property isn't invariant,\n-                // then the whole record isn't covariant.\n-                if (!propA.isInvariant(propB)) {\n-                    return false;\n-                }\n-            } else {\n-                // If one inferred property isn't a subtype,\n-                // then the whole record isn't covariant.\n-                if (!propA.isSubtype(propB)) {\n-                    return false;\n-                }\n-            }\n-        }\n-    }\n     return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n            if (typeA.isPropertyTypeDeclared(property) || typeB.isPropertyTypeDeclared(property)) {\n                // If one declared property isn't invariant,\n                // then the whole record isn't covariant.\n                if (!propA.isInvariant(propB)) {\n                    return false;\n                }\n            } else {\n                // If one inferred property isn't a subtype,\n                // then the whole record isn't covariant.\n                if (!propA.isSubtype(propB)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n+++ com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n@@ -23,7 +23,7 @@\n         JSType propA = typeA.getPropertyType(property);\n         JSType propB = typeB.getPropertyType(property);\n         if (!propA.isUnknownType() && !propB.isUnknownType()) {\n-            if (typeA.isPropertyTypeDeclared(property)) {\n+            if (typeA.isPropertyTypeDeclared(property) || typeB.isPropertyTypeDeclared(property)) {\n                 // If one declared property isn't invariant,\n                 // then the whole record isn't covariant.\n                 if (!propA.isInvariant(propB)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        // Fix: allow unknown types to be considered as subtypes\n        if (propA.isUnknownType() || propB.isUnknownType()) {\n            continue;\n        }\n        if (typeA.isPropertyTypeDeclared(property)) {\n            // If one declared property isn't invariant,\n            // then the whole record isn't covariant.\n            if (!propA.isInvariant(propB)) {\n                return false;\n            }\n        } else {\n            // If one inferred property isn't a subtype,\n            // then the whole record isn't covariant.\n            if (!propA.isSubtype(propB)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n+++ com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n@@ -22,19 +22,21 @@\n         }\n         JSType propA = typeA.getPropertyType(property);\n         JSType propB = typeB.getPropertyType(property);\n-        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n-            if (typeA.isPropertyTypeDeclared(property)) {\n-                // If one declared property isn't invariant,\n-                // then the whole record isn't covariant.\n-                if (!propA.isInvariant(propB)) {\n-                    return false;\n-                }\n-            } else {\n-                // If one inferred property isn't a subtype,\n-                // then the whole record isn't covariant.\n-                if (!propA.isSubtype(propB)) {\n-                    return false;\n-                }\n+        // Fix: allow unknown types to be considered as subtypes\n+        if (propA.isUnknownType() || propB.isUnknownType()) {\n+            continue;\n+        }\n+        if (typeA.isPropertyTypeDeclared(property)) {\n+            // If one declared property isn't invariant,\n+            // then the whole record isn't covariant.\n+            if (!propA.isInvariant(propB)) {\n+                return false;\n+            }\n+        } else {\n+            // If one inferred property isn't a subtype,\n+            // then the whole record isn't covariant.\n+            if (!propA.isSubtype(propB)) {\n+                return false;\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        // Check only if property type is not unknown or null\n        if (!propB.isNullType() && !propB.isUnknownType()) {\n            // If typeB's property is declared, check for invariance of types\n            if (typeB.isPropertyTypeDeclared(property)) {\n                // If one declared property isn't invariant,\n                // then the whole record isn't covariant.\n                if (!propA.isInvariant(propB)) {\n                    return false;\n                }\n            } else {\n                // If one inferred property isn't a subtype,\n                // then the whole record isn't covariant.\n                if (!propA.isSubtype(propB)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n+++ com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n@@ -1,29 +1,14 @@\n static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n-    // typeA is a subtype of record type typeB iff:\n-    // 1) typeA has all the properties declared in typeB.\n-    // 2) And for each property of typeB,\n-    //    2a) if the property of typeA is declared, it must be equal\n-    //        to the type of the property of typeB,\n-    //    2b) otherwise, it must be a subtype of the property of typeB.\n-    //\n-    // To figure out why this is true, consider the following pseudo-code:\n-    // /** @type {{a: (Object,null)}} */ var x;\n-    // /** @type {{a: !Object}} */ var y;\n-    // var z = {a: {}};\n-    // x.a = null;\n-    //\n-    // y cannot be assigned to x, because line 4 would violate y's declared\n-    // properties. But z can be assigned to x. Even though z and y are the\n-    // same type, the properties of z are inferred--and so an assignment\n-    // to the property of z would not violate any restrictions on it.\n     for (String property : typeB.properties.keySet()) {\n         if (!typeA.hasProperty(property)) {\n             return false;\n         }\n         JSType propA = typeA.getPropertyType(property);\n         JSType propB = typeB.getPropertyType(property);\n-        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n-            if (typeA.isPropertyTypeDeclared(property)) {\n+        // Check only if property type is not unknown or null\n+        if (!propB.isNullType() && !propB.isUnknownType()) {\n+            // If typeB's property is declared, check for invariance of types\n+            if (typeB.isPropertyTypeDeclared(property)) {\n                 // If one declared property isn't invariant,\n                 // then the whole record isn't covariant.\n                 if (!propA.isInvariant(propB)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n            if (typeA.isPropertyTypeDeclared(property)) {\n                // Check if declared property is a subtype\n                if (!propB.isSubtype(propA)) {\n                    return false;\n                }\n            } else {\n                // Check if inferred property is a subtype\n                if (!propA.isSubtype(propB)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n+++ com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n@@ -1,21 +1,4 @@\n static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n-    // typeA is a subtype of record type typeB iff:\n-    // 1) typeA has all the properties declared in typeB.\n-    // 2) And for each property of typeB,\n-    //    2a) if the property of typeA is declared, it must be equal\n-    //        to the type of the property of typeB,\n-    //    2b) otherwise, it must be a subtype of the property of typeB.\n-    //\n-    // To figure out why this is true, consider the following pseudo-code:\n-    // /** @type {{a: (Object,null)}} */ var x;\n-    // /** @type {{a: !Object}} */ var y;\n-    // var z = {a: {}};\n-    // x.a = null;\n-    //\n-    // y cannot be assigned to x, because line 4 would violate y's declared\n-    // properties. But z can be assigned to x. Even though z and y are the\n-    // same type, the properties of z are inferred--and so an assignment\n-    // to the property of z would not violate any restrictions on it.\n     for (String property : typeB.properties.keySet()) {\n         if (!typeA.hasProperty(property)) {\n             return false;\n@@ -24,14 +7,12 @@\n         JSType propB = typeB.getPropertyType(property);\n         if (!propA.isUnknownType() && !propB.isUnknownType()) {\n             if (typeA.isPropertyTypeDeclared(property)) {\n-                // If one declared property isn't invariant,\n-                // then the whole record isn't covariant.\n-                if (!propA.isInvariant(propB)) {\n+                // Check if declared property is a subtype\n+                if (!propB.isSubtype(propA)) {\n                     return false;\n                 }\n             } else {\n-                // If one inferred property isn't a subtype,\n-                // then the whole record isn't covariant.\n+                // Check if inferred property is a subtype\n                 if (!propA.isSubtype(propB)) {\n                     return false;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n            if (typeA.isPropertyTypeDeclared(property)) {\n                // If one declared property isn't invariant,\n                // then the whole record isn't covariant.\n                if (!propB.isInvariant(propA)) {\n                    return false;\n                }\n            } else {\n                // If one inferred property isn't a subtype,\n                // then the whole record isn't covariant.\n                if (!propB.isSubtype(propA)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n+++ com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n@@ -26,13 +26,13 @@\n             if (typeA.isPropertyTypeDeclared(property)) {\n                 // If one declared property isn't invariant,\n                 // then the whole record isn't covariant.\n-                if (!propA.isInvariant(propB)) {\n+                if (!propB.isInvariant(propA)) {\n                     return false;\n                 }\n             } else {\n                 // If one inferred property isn't a subtype,\n                 // then the whole record isn't covariant.\n-                if (!propA.isSubtype(propB)) {\n+                if (!propB.isSubtype(propA)) {\n                     return false;\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!(propA.isUnknownType() || propB.isUnknownType())) { // fixed line here\n            if (typeA.isPropertyTypeDeclared(property)) {\n                // If one declared property isn't invariant,\n                // then the whole record isn't covariant.\n                if (!propA.isInvariant(propB)) {\n                    return false;\n                }\n            } else {\n                // If one inferred property isn't a subtype,\n                // then the whole record isn't covariant.\n                if (!propA.isSubtype(propB)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n+++ com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n@@ -22,7 +22,7 @@\n         }\n         JSType propA = typeA.getPropertyType(property);\n         JSType propB = typeB.getPropertyType(property);\n-        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n+        if (!(propA.isUnknownType() || propB.isUnknownType())) { // fixed line here\n             if (typeA.isPropertyTypeDeclared(property)) {\n                 // If one declared property isn't invariant,\n                 // then the whole record isn't covariant.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n            if (typeA.isPropertyTypeDeclared(property)) {\n                // If the whole record is non-invariant, then it\n                // isn't covariant\n                if (!typeA.isInvariant() && !propA.isInvariant(propB)) {\n                    return false;\n                }\n            } else {\n                // If one inferred property isn't a subtype,\n                // then the whole record isn't covariant.\n                if (!propA.isSubtype(propB)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n+++ com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n@@ -24,9 +24,9 @@\n         JSType propB = typeB.getPropertyType(property);\n         if (!propA.isUnknownType() && !propB.isUnknownType()) {\n             if (typeA.isPropertyTypeDeclared(property)) {\n-                // If one declared property isn't invariant,\n-                // then the whole record isn't covariant.\n-                if (!propA.isInvariant(propB)) {\n+                // If the whole record is non-invariant, then it\n+                // isn't covariant\n+                if (!typeA.isInvariant() && !propA.isInvariant(propB)) {\n                     return false;\n                 }\n             } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n            if (typeA.isPropertyTypeDeclared(property)) {\n                // If the declared property is not covariant or contravariant,\n                // then the whole record isn't covariant.\n                if (!propB.isSubtype(propA) && !propA.isSubtype(propB)) {\n                    return false;\n                }\n            } else {\n                // If one inferred property isn't a subtype,\n                // then the whole record isn't covariant.\n                if (!propA.isSubtype(propB)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n+++ com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n@@ -24,9 +24,9 @@\n         JSType propB = typeB.getPropertyType(property);\n         if (!propA.isUnknownType() && !propB.isUnknownType()) {\n             if (typeA.isPropertyTypeDeclared(property)) {\n-                // If one declared property isn't invariant,\n+                // If the declared property is not covariant or contravariant,\n                 // then the whole record isn't covariant.\n-                if (!propA.isInvariant(propB)) {\n+                if (!propB.isSubtype(propA) && !propA.isSubtype(propB)) {\n                     return false;\n                 }\n             } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n            // Adding an extra check for Object types.\n            if (propA.isObjectType() && propB.isObjectType()) {\n              // If one declared property isn't invariant,\n              // then the whole record isn't covariant.\n              if (!propA.isSubtype(propB)) {\n                return false;\n              }\n            } else {\n              if (typeA.isPropertyTypeDeclared(property)) {\n                // If one declared property isn't invariant,\n                // then the whole record isn't covariant.\n                if (!propA.isInvariant(propB)) {\n                  return false;\n                }\n              } else {\n                // If one inferred property isn't a subtype,\n                // then the whole record isn't covariant.\n                if (!propA.isSubtype(propB)) {\n                  return false;\n                }\n              }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n+++ com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n@@ -23,18 +23,27 @@\n         JSType propA = typeA.getPropertyType(property);\n         JSType propB = typeB.getPropertyType(property);\n         if (!propA.isUnknownType() && !propB.isUnknownType()) {\n-            if (typeA.isPropertyTypeDeclared(property)) {\n+            // Adding an extra check for Object types.\n+            if (propA.isObjectType() && propB.isObjectType()) {\n+              // If one declared property isn't invariant,\n+              // then the whole record isn't covariant.\n+              if (!propA.isSubtype(propB)) {\n+                return false;\n+              }\n+            } else {\n+              if (typeA.isPropertyTypeDeclared(property)) {\n                 // If one declared property isn't invariant,\n                 // then the whole record isn't covariant.\n                 if (!propA.isInvariant(propB)) {\n-                    return false;\n+                  return false;\n                 }\n-            } else {\n+              } else {\n                 // If one inferred property isn't a subtype,\n                 // then the whole record isn't covariant.\n                 if (!propA.isSubtype(propB)) {\n-                    return false;\n+                  return false;\n                 }\n+              }\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (propB.isUnknownType()) {\n            continue;\n        }\n        if (!propA.isSubtype(propB)) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n+++ com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n@@ -22,20 +22,11 @@\n         }\n         JSType propA = typeA.getPropertyType(property);\n         JSType propB = typeB.getPropertyType(property);\n-        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n-            if (typeA.isPropertyTypeDeclared(property)) {\n-                // If one declared property isn't invariant,\n-                // then the whole record isn't covariant.\n-                if (!propA.isInvariant(propB)) {\n-                    return false;\n-                }\n-            } else {\n-                // If one inferred property isn't a subtype,\n-                // then the whole record isn't covariant.\n-                if (!propA.isSubtype(propB)) {\n-                    return false;\n-                }\n-            }\n+        if (propB.isUnknownType()) {\n+            continue;\n+        }\n+        if (!propA.isSubtype(propB)) {\n+            return false;\n         }\n     }\n     return true;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n            if (typeA.isPropertyTypeDeclared(property)) {\n                // If one declared property isn't invariant,\n                // then the whole record isn't covariant.\n                if (!propB.isInvariant(propA)) { // Invariant types were swapped\n                    return false;\n                }\n            } else {\n                // If one inferred property isn't a subtype,\n                // then the whole record isn't covariant.\n                if (!propB.isSubtype(propA)) { // Supertype and subtype were swapped\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n+++ com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n@@ -26,13 +26,13 @@\n             if (typeA.isPropertyTypeDeclared(property)) {\n                 // If one declared property isn't invariant,\n                 // then the whole record isn't covariant.\n-                if (!propA.isInvariant(propB)) {\n+                if (!propB.isInvariant(propA)) { // Invariant types were swapped\n                     return false;\n                 }\n             } else {\n                 // If one inferred property isn't a subtype,\n                 // then the whole record isn't covariant.\n-                if (!propA.isSubtype(propB)) {\n+                if (!propB.isSubtype(propA)) { // Supertype and subtype were swapped\n                     return false;\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n            if (typeA.isPropertyTypeDeclared(property)) {\n                // If one declared property isn't invariant,\n                // then the whole record isn't covariant.\n                if (!propA.isEqualTo(propB) && !propA.isSubtype(propB)) {\n                    return false;\n                }\n            } else {\n                // If one inferred property isn't a subtype,\n                // then the whole record isn't covariant.\n                if (!propA.isSubtype(propB)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n+++ com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n@@ -26,7 +26,7 @@\n             if (typeA.isPropertyTypeDeclared(property)) {\n                 // If one declared property isn't invariant,\n                 // then the whole record isn't covariant.\n-                if (!propA.isInvariant(propB)) {\n+                if (!propA.isEqualTo(propB) && !propA.isSubtype(propB)) {\n                     return false;\n                 }\n             } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object|null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n            if (typeA.isPropertyTypeDeclared(property) && typeB.isPropertyTypeDeclared(property)) {\n                // If one declared property isn't invariant,\n                // then the whole record isn't covariant.\n                if (!propA.isInvariant(propB)) {\n                    return false;\n                }\n            } else {\n                // If one inferred property isn't a subtype,\n                // then the whole record isn't covariant.\n                if (!propA.isSubtype(propB)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n+++ com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n@@ -7,7 +7,7 @@\n     //    2b) otherwise, it must be a subtype of the property of typeB.\n     //\n     // To figure out why this is true, consider the following pseudo-code:\n-    // /** @type {{a: (Object,null)}} */ var x;\n+    // /** @type {{a: (Object|null)}} */ var x;\n     // /** @type {{a: !Object}} */ var y;\n     // var z = {a: {}};\n     // x.a = null;\n@@ -23,7 +23,7 @@\n         JSType propA = typeA.getPropertyType(property);\n         JSType propB = typeB.getPropertyType(property);\n         if (!propA.isUnknownType() && !propB.isUnknownType()) {\n-            if (typeA.isPropertyTypeDeclared(property)) {\n+            if (typeA.isPropertyTypeDeclared(property) && typeB.isPropertyTypeDeclared(property)) {\n                 // If one declared property isn't invariant,\n                 // then the whole record isn't covariant.\n                 if (!propA.isInvariant(propB)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!(propA.isUnknownType() || propB.isUnknownType())) {\n            if (typeA.isPropertyTypeDeclared(property)) {\n                // If one declared property isn't invariant,\n                // then the whole record isn't covariant.\n                if (!propA.isInvariant(propB)) {\n                    return false;\n                }\n            } else {\n                // If one inferred property isn't a subtype,\n                // then the whole record isn't covariant.\n                if (!propA.isSubtype(propB)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n+++ com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n@@ -22,7 +22,7 @@\n         }\n         JSType propA = typeA.getPropertyType(property);\n         JSType propB = typeB.getPropertyType(property);\n-        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n+        if (!(propA.isUnknownType() || propB.isUnknownType())) {\n             if (typeA.isPropertyTypeDeclared(property)) {\n                 // If one declared property isn't invariant,\n                 // then the whole record isn't covariant.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n            if (typeB.isPropertyTypeDeclared(property)) {\n                // If one declared property isn't invariant,\n                // then the whole record isn't covariant.\n                if (!propB.isInvariant(propA)) {\n                    return false;\n                }\n            } else {\n                // If one inferred property isn't a subtype,\n                // then the whole record isn't covariant.\n                if (!propB.isSubtype(propA)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n+++ com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n@@ -23,16 +23,16 @@\n         JSType propA = typeA.getPropertyType(property);\n         JSType propB = typeB.getPropertyType(property);\n         if (!propA.isUnknownType() && !propB.isUnknownType()) {\n-            if (typeA.isPropertyTypeDeclared(property)) {\n+            if (typeB.isPropertyTypeDeclared(property)) {\n                 // If one declared property isn't invariant,\n                 // then the whole record isn't covariant.\n-                if (!propA.isInvariant(propB)) {\n+                if (!propB.isInvariant(propA)) {\n                     return false;\n                 }\n             } else {\n                 // If one inferred property isn't a subtype,\n                 // then the whole record isn't covariant.\n-                if (!propA.isSubtype(propB)) {\n+                if (!propB.isSubtype(propA)) {\n                     return false;\n                 }\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n            if (typeA.isPropertyTypeDeclared(property)) {\n                // If one declared property isn't invariant,\n                // then the whole record isn't covariant.\n                if (!propB.isInvariant(propA)) {  // swapped propB and propA\n                    return false;\n                }\n            } else {\n                // If one inferred property isn't a subtype,\n                // then the whole record isn't covariant.\n                if (!propA.isSubtype(propB)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n+++ com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n@@ -26,7 +26,7 @@\n             if (typeA.isPropertyTypeDeclared(property)) {\n                 // If one declared property isn't invariant,\n                 // then the whole record isn't covariant.\n-                if (!propA.isInvariant(propB)) {\n+                if (!propB.isInvariant(propA)) {  // swapped propB and propA\n                     return false;\n                 }\n             } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n        if (!typeA.hasProperty(property)) {\n            return false;\n        }\n        JSType propA = typeA.getPropertyType(property);\n        JSType propB = typeB.getPropertyType(property);\n        if (!propA.isUnknownType() && !propB.isUnknownType()) {\n            if (typeA.isPropertyTypeDeclared(property) || typeB.isPropertyTypeDeclared(property)) {\n                // If one declared property isn't invariant or doesn't match,\n                // then the whole record isn't covariant.\n                if (!propA.isInvariant(propB)) {\n                    return false;\n                }\n            } else {\n                // If one inferred property isn't a subtype,\n                // then the whole record isn't covariant.\n                if (!propA.isSubtype(propB)) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n+++ com/google/javascript/rhino/jstype/RecordType.java@isSubtype\n@@ -23,8 +23,8 @@\n         JSType propA = typeA.getPropertyType(property);\n         JSType propB = typeB.getPropertyType(property);\n         if (!propA.isUnknownType() && !propB.isUnknownType()) {\n-            if (typeA.isPropertyTypeDeclared(property)) {\n-                // If one declared property isn't invariant,\n+            if (typeA.isPropertyTypeDeclared(property) || typeB.isPropertyTypeDeclared(property)) {\n+                // If one declared property isn't invariant or doesn't match,\n                 // then the whole record isn't covariant.\n                 if (!propA.isInvariant(propB)) {\n                     return false;\n", "finish_reason": "stop", "valid": false, "num": 1}]