[{"output": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -20,20 +20,13 @@\n     //store method in local variable to prevent multiple method calls\n     final int zipMethod = ze.getMethod();\n     final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n-    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n     generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n     // compression method\n     putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n     ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n     // CRC\n-    if (phased) {\n-        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n-        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n-    } else {\n-        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n-    }\n+    putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n     // compressed length\n     // uncompressed length\n     if (hasZip64Extra(entry.entry)) {\n@@ -42,15 +35,8 @@\n         // stream is seekable\n         ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n         ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (phased) {\n+    } else {\n         putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n-        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n-        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n-        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n-    } else {\n-        // Stored\n-        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n         putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n     }\n     // file name length\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraFieldHeader.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor).encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    // last mod file time\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed/uncompressed length\n    if (hasZip64Extra(entry.entry)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.putLong(ZipLong.ZIP64_MAGIC, buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.putLong(ZipLong.ZIP64_MAGIC, buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -9,7 +9,7 @@\n     }\n     if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n         int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n-        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n+        int padding = (int) ((-archiveOffset - oldLength - ZipExtraFieldHeader.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n         ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n     }\n     final byte[] extra = ze.getLocalFileDataExtra();\n@@ -20,11 +20,10 @@\n     //store method in local variable to prevent multiple method calls\n     final int zipMethod = ze.getMethod();\n     final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n-    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n-    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n-    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n+    getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor).encode(buf, LFH_GPB_OFFSET);\n     // compression method\n     putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n+    // last mod file time\n     ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n     // CRC\n     if (phased) {\n@@ -34,14 +33,13 @@\n     } else {\n         putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n     }\n-    // compressed length\n-    // uncompressed length\n+    // compressed/uncompressed length\n     if (hasZip64Extra(entry.entry)) {\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n-        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n-        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n+        ZipLong.putLong(ZipLong.ZIP64_MAGIC, buf, LFH_COMPRESSED_SIZE_OFFSET);\n+        ZipLong.putLong(ZipLong.ZIP64_MAGIC, buf, LFH_ORIGINAL_SIZE_OFFSET);\n     } else if (phased) {\n         putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n         putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ResourceAlignmentExtraField.HEADER_ID_SIZE - ResourceAlignmentExtraField.DATA_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(ze)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -9,7 +9,7 @@\n     }\n     if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n         int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n-        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n+        int padding = (int) ((-archiveOffset - oldLength - ResourceAlignmentExtraField.HEADER_ID_SIZE - ResourceAlignmentExtraField.DATA_SIZE) & (alignment - 1));\n         ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n     }\n     final byte[] extra = ze.getLocalFileDataExtra();\n@@ -36,7 +36,7 @@\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n+    if (hasZip64Extra(ze)) {\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "It is not clear what the bug is in the provided code, therefore a fix cannot be provided.", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -20,7 +20,6 @@\n     //store method in local variable to prevent multiple method calls\n     final int zipMethod = ze.getMethod();\n     final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n-    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n     generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n     // compression method\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (!phased && zipMethod == DEFLATED && hasZip64Extra(ze)) {\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n    } else {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n    }\n    if (!phased && hasZip64Extra(ze)) {\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else {\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -20,7 +20,6 @@\n     //store method in local variable to prevent multiple method calls\n     final int zipMethod = ze.getMethod();\n     final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n-    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n     generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n     // compression method\n@@ -36,21 +35,14 @@\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n-        // point to ZIP64 extended information extra field for\n-        // sizes, may get rewritten once sizes are known if\n-        // stream is seekable\n+    if (!phased && zipMethod == DEFLATED && hasZip64Extra(ze)) {\n         ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n+    } else {\n+        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n+    }\n+    if (!phased && hasZip64Extra(ze)) {\n         ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (phased) {\n-        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n-        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n-        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n-        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n     } else {\n-        // Stored\n-        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n         putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n     }\n     // file name length\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(ze)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -36,7 +36,7 @@\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n+    if (hasZip64Extra(ze)) {\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n", "finish_reason": "stop", "valid": false, "num": 4}, {"output": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -20,11 +20,11 @@\n     //store method in local variable to prevent multiple method calls\n     final int zipMethod = ze.getMethod();\n     final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n-    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n     generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n     // compression method\n     putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n+    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n     // CRC\n     if (phased) {\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.remaining();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else {\n        switch (zipMethod) {\n            case DEFLATED:\n                System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n                System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n                System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n                break;\n            default:\n                putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n                putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n                putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n                break;\n        }\n    }\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    System.arraycopy(name.array(), name.arrayOffset() + name.position(), buf, LFH_FILENAME_OFFSET, nameLen);\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -13,53 +13,38 @@\n         ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n     }\n     final byte[] extra = ze.getLocalFileDataExtra();\n-    final int nameLen = name.limit() - name.position();\n+    final int nameLen = name.remaining();\n     final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n     final byte[] buf = new byte[len];\n     System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n-    //store method in local variable to prevent multiple method calls\n     final int zipMethod = ze.getMethod();\n     final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n     putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n     generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n-    // compression method\n     putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n     ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n-    // CRC\n     if (phased) {\n         putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n-        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n-    } else {\n-        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n-    }\n-    // compressed length\n-    // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n-        // point to ZIP64 extended information extra field for\n-        // sizes, may get rewritten once sizes are known if\n-        // stream is seekable\n-        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n-        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (phased) {\n         putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n         putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n-        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n-        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n     } else {\n-        // Stored\n-        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n-        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n+        switch (zipMethod) {\n+            case DEFLATED:\n+                System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n+                System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n+                System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n+                break;\n+            default:\n+                putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n+                putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n+                putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n+                break;\n+        }\n     }\n-    // file name length\n     putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n-    // extra field length\n     putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n-    // file name\n-    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n-    // extra fields\n+    System.arraycopy(name.array(), name.arrayOffset() + name.position(), buf, LFH_FILENAME_OFFSET, nameLen);\n     System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n     return buf;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    //version needed to extract\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(ze)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -20,11 +20,12 @@\n     //store method in local variable to prevent multiple method calls\n     final int zipMethod = ze.getMethod();\n     final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n-    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n     generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n     // compression method\n     putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n+    //version needed to extract\n+    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n     // CRC\n     if (phased) {\n@@ -36,7 +37,7 @@\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n+    if (hasZip64Extra(ze)) {\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.HEADER_ID_AND_DATA_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(ze)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -9,7 +9,7 @@\n     }\n     if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n         int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n-        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n+        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.HEADER_ID_AND_DATA_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n         ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n     }\n     final byte[] extra = ze.getLocalFileDataExtra();\n@@ -36,7 +36,7 @@\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n+    if (hasZip64Extra(ze)) {\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRA_FIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.remaining(); // Changed from limit() - position()\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(ze.entry)) { // Updated from entry.entry to ze.entry\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset() + name.position(), buf, LFH_FILENAME_OFFSET, nameLen); // Changed from using array() to arrayOffset() + position()\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -9,11 +9,11 @@\n     }\n     if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n         int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n-        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n+        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRA_FIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n         ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n     }\n     final byte[] extra = ze.getLocalFileDataExtra();\n-    final int nameLen = name.limit() - name.position();\n+    final int nameLen = name.remaining(); // Changed from limit() - position()\n     final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n     final byte[] buf = new byte[len];\n     System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n@@ -36,7 +36,7 @@\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n+    if (hasZip64Extra(ze.entry)) { // Updated from entry.entry to ze.entry\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n@@ -58,7 +58,7 @@\n     // extra field length\n     putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n     // file name\n-    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n+    System.arraycopy(name.array(), name.arrayOffset() + name.position(), buf, LFH_FILENAME_OFFSET, nameLen); // Changed from using array() to arrayOffset() + position()\n     // extra fields\n     System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n     return buf;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // version needed to extract\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(ze)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -20,9 +20,10 @@\n     //store method in local variable to prevent multiple method calls\n     final int zipMethod = ze.getMethod();\n     final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n-    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n     generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n+    // version needed to extract\n+    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     // compression method\n     putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n     ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n@@ -36,15 +37,12 @@\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n+    if (hasZip64Extra(ze)) {\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n         ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n         ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (phased) {\n-        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n-        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n     } else if (zipMethod == DEFLATED || channel != null) {\n         System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n         System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);    \n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || ze.getCompressedSize() < 0 || ze.getSize() < 0) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased || ze.getCompressedSize() < 0 || ze.getSize() < 0) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -20,16 +20,16 @@\n     //store method in local variable to prevent multiple method calls\n     final int zipMethod = ze.getMethod();\n     final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n-    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n     generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n+    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);    \n     // compression method\n     putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n     ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n     // CRC\n     if (phased) {\n         putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n+    } else if (zipMethod == DEFLATED || ze.getCompressedSize() < 0 || ze.getSize() < 0) {\n         System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n     } else {\n         putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n@@ -42,15 +42,12 @@\n         // stream is seekable\n         ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n         ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (phased) {\n-        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n-        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n+    } else if (phased || ze.getCompressedSize() < 0 || ze.getSize() < 0) {\n         System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n         System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n     } else {\n         // Stored\n-        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n+        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n         putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n     }\n     // file name length\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod != STORED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(ze)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod != STORED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -20,7 +20,6 @@\n     //store method in local variable to prevent multiple method calls\n     final int zipMethod = ze.getMethod();\n     final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n-    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n     generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n     // compression method\n@@ -29,14 +28,14 @@\n     // CRC\n     if (phased) {\n         putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n+    } else if (zipMethod != STORED || channel != null) {\n         System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n     } else {\n         putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n+    if (hasZip64Extra(ze)) {\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n@@ -45,7 +44,7 @@\n     } else if (phased) {\n         putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n         putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n+    } else if (zipMethod != STORED || channel != null) {\n         System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n         System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else {\n        if (zipMethod == DEFLATED || channel != null) {\n            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        } else {\n            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        }\n    }\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -17,49 +17,31 @@\n     final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n     final byte[] buf = new byte[len];\n     System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n-    //store method in local variable to prevent multiple method calls\n     final int zipMethod = ze.getMethod();\n     final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n-    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n     generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n-    // compression method\n+    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n     ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n-    // CRC\n     if (phased) {\n         putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n-        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n-    } else {\n-        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n-    }\n-    // compressed length\n-    // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n-        // point to ZIP64 extended information extra field for\n-        // sizes, may get rewritten once sizes are known if\n-        // stream is seekable\n-        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n-        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (phased) {\n         putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n         putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n-        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n-        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n     } else {\n-        // Stored\n-        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n-        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n+        if (zipMethod == DEFLATED || channel != null) {\n+            System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n+            System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n+            System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n+        } else {\n+            putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n+            putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n+            putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n+        }\n     }\n-    // file name length\n     putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n-    // extra field length\n     putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n-    // file name\n     System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n-    // extra fields\n     System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n     return buf;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]