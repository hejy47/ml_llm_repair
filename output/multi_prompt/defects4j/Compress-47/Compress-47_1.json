[{"output": "@Override\npublic int read(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (current == null) {\n        return -1;\n    }\n    // avoid int overflow, check null buffer\n    if (offset < 0 || length < 0 || buffer.length - offset < length) {\n        throw new ArrayIndexOutOfBoundsException();\n    }\n    if (offset > buffer.length) {\n        throw new IndexOutOfBoundsException();\n    }\n    ZipUtil.checkRequestedFeatures(current.entry);\n    if (!supportsDataDescriptorFor(current.entry)) {\n        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n    }\n    int read;\n    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n        read = readStored(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n        read = readDeflated(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n        read = current.in.read(buffer, offset, length);\n    } else {\n        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n    }\n    if (read >= 0) {\n        current.crc.update(buffer, offset, read);\n    }\n    return read;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n@@ -1,8 +1,34 @@\n @Override\n-public boolean canReadEntryData(final ArchiveEntry ae) {\n-    if (ae instanceof ZipArchiveEntry) {\n-        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n-        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);\n+public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n+    if (closed) {\n+        throw new IOException(\"The stream is closed\");\n     }\n-    return false;\n+    if (current == null) {\n+        return -1;\n+    }\n+    // avoid int overflow, check null buffer\n+    if (offset < 0 || length < 0 || buffer.length - offset < length) {\n+        throw new ArrayIndexOutOfBoundsException();\n+    }\n+    if (offset > buffer.length) {\n+        throw new IndexOutOfBoundsException();\n+    }\n+    ZipUtil.checkRequestedFeatures(current.entry);\n+    if (!supportsDataDescriptorFor(current.entry)) {\n+        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n+    }\n+    int read;\n+    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n+        read = readStored(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n+        read = readDeflated(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n+        read = current.in.read(buffer, offset, length);\n+    } else {\n+        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n+    }\n+    if (read >= 0) {\n+        current.crc.update(buffer, offset, read);\n+    }\n+    return read;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n@@ -7,8 +7,11 @@\n         return -1;\n     }\n     // avoid int overflow, check null buffer\n-    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n+    if (offset < 0 || length < 0 || buffer.length - offset < length) {\n         throw new ArrayIndexOutOfBoundsException();\n+    }\n+    if (offset > buffer.length) {\n+        throw new IndexOutOfBoundsException();\n     }\n     ZipUtil.checkRequestedFeatures(current.entry);\n     if (!supportsDataDescriptorFor(current.entry)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic int read(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (current == null) {\n        return -1;\n    }\n    // avoid int overflow, check null buffer\n    if (offset < 0 || length < 0 || offset + length > buffer.length) {\n        throw new ArrayIndexOutOfBoundsException();\n    }\n    ZipUtil.checkRequestedFeatures(current.entry);\n    if (!supportsDataDescriptorFor(current.entry)) {\n        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n    }\n    int read;\n    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n        read = readStored(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n        read = readDeflated(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n        read = current.in.read(buffer, offset, length);\n    } else {\n        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n    }\n    if (read >= 0) {\n        current.crc.update(buffer, offset, read);\n    }\n    return read;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n@@ -1,8 +1,31 @@\n @Override\n-public boolean canReadEntryData(final ArchiveEntry ae) {\n-    if (ae instanceof ZipArchiveEntry) {\n-        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n-        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);\n+public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n+    if (closed) {\n+        throw new IOException(\"The stream is closed\");\n     }\n-    return false;\n+    if (current == null) {\n+        return -1;\n+    }\n+    // avoid int overflow, check null buffer\n+    if (offset < 0 || length < 0 || offset + length > buffer.length) {\n+        throw new ArrayIndexOutOfBoundsException();\n+    }\n+    ZipUtil.checkRequestedFeatures(current.entry);\n+    if (!supportsDataDescriptorFor(current.entry)) {\n+        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n+    }\n+    int read;\n+    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n+        read = readStored(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n+        read = readDeflated(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n+        read = current.in.read(buffer, offset, length);\n+    } else {\n+        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n+    }\n+    if (read >= 0) {\n+        current.crc.update(buffer, offset, read);\n+    }\n+    return read;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n@@ -7,7 +7,7 @@\n         return -1;\n     }\n     // avoid int overflow, check null buffer\n-    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n+    if (offset < 0 || length < 0 || offset + length > buffer.length) {\n         throw new ArrayIndexOutOfBoundsException();\n     }\n     ZipUtil.checkRequestedFeatures(current.entry);\n", "finish_reason": "stop", "valid": false, "num": 7}, {"output": "@Override\npublic int read(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (current == null) {\n        return -1;\n    }\n    // avoid int overflow, check null buffer\n    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n        throw new ArrayIndexOutOfBoundsException();\n    }\n    ZipUtil.checkRequestedFeatures(current.entry);\n    if (!supportsDataDescriptorFor(current.entry)) {\n        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n    }\n    int read;\n    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n        read = readStored(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n        read = readDeflated(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n        read = current.in.read(buffer, offset, length);\n        // update CRC only if bytes were read successfully\n        if (read >= 0) {\n            current.crc.update(buffer, offset, read);\n        }\n    } else {\n        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n    }\n    return read;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n@@ -1,8 +1,32 @@\n @Override\n-public boolean canReadEntryData(final ArchiveEntry ae) {\n-    if (ae instanceof ZipArchiveEntry) {\n-        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n-        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);\n+public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n+    if (closed) {\n+        throw new IOException(\"The stream is closed\");\n     }\n-    return false;\n+    if (current == null) {\n+        return -1;\n+    }\n+    // avoid int overflow, check null buffer\n+    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n+        throw new ArrayIndexOutOfBoundsException();\n+    }\n+    ZipUtil.checkRequestedFeatures(current.entry);\n+    if (!supportsDataDescriptorFor(current.entry)) {\n+        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n+    }\n+    int read;\n+    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n+        read = readStored(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n+        read = readDeflated(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n+        read = current.in.read(buffer, offset, length);\n+        // update CRC only if bytes were read successfully\n+        if (read >= 0) {\n+            current.crc.update(buffer, offset, read);\n+        }\n+    } else {\n+        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n+    }\n+    return read;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n@@ -21,11 +21,12 @@\n         read = readDeflated(buffer, offset, length);\n     } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n         read = current.in.read(buffer, offset, length);\n+        // update CRC only if bytes were read successfully\n+        if (read >= 0) {\n+            current.crc.update(buffer, offset, read);\n+        }\n     } else {\n         throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n     }\n-    if (read >= 0) {\n-        current.crc.update(buffer, offset, read);\n-    }\n     return read;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic int read(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (current == null) {\n        return -1;\n    }\n    // avoid int overflow, check null buffer\n    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n        throw new ArrayIndexOutOfBoundsException();\n    }\n    ZipUtil.checkRequestedFeatures(current.entry);\n    if (!supportsDataDescriptorFor(current.entry)) {\n        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n    }\n    int read;\n    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n        read = readStored(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n        read = readDeflated(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n        read = current.in.read(buffer, offset, length);\n    } else {\n        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n    }\n    if (read > 0) { //fix - change from read >= 0 to read > 0 to avoid including trailing 0s\n        current.crc.update(buffer, offset, read);\n    }\n    return read;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n@@ -1,8 +1,31 @@\n @Override\n-public boolean canReadEntryData(final ArchiveEntry ae) {\n-    if (ae instanceof ZipArchiveEntry) {\n-        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n-        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);\n+public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n+    if (closed) {\n+        throw new IOException(\"The stream is closed\");\n     }\n-    return false;\n+    if (current == null) {\n+        return -1;\n+    }\n+    // avoid int overflow, check null buffer\n+    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n+        throw new ArrayIndexOutOfBoundsException();\n+    }\n+    ZipUtil.checkRequestedFeatures(current.entry);\n+    if (!supportsDataDescriptorFor(current.entry)) {\n+        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n+    }\n+    int read;\n+    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n+        read = readStored(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n+        read = readDeflated(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n+        read = current.in.read(buffer, offset, length);\n+    } else {\n+        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n+    }\n+    if (read > 0) { //fix - change from read >= 0 to read > 0 to avoid including trailing 0s\n+        current.crc.update(buffer, offset, read);\n+    }\n+    return read;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n@@ -24,7 +24,7 @@\n     } else {\n         throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n     }\n-    if (read >= 0) {\n+    if (read > 0) { //fix - change from read >= 0 to read > 0 to avoid including trailing 0s\n         current.crc.update(buffer, offset, read);\n     }\n     return read;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic int read(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (current == null) {\n        return -1;\n    }\n    // avoid int overflow, check null buffer\n    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n        throw new ArrayIndexOutOfBoundsException();\n    }\n    ZipUtil.checkRequestedFeatures(current.entry);\n    if (!supportsDataDescriptorFor(current.entry)) {\n        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n    }\n    int read;\n    // Fixed condition to check for ZipMethod.UNSHRINKING\n    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n        read = readStored(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n        read = readDeflated(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getMethodCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getMethodCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getMethodCode() || current.entry.getMethod() == ZipMethod.BZIP2.getMethodCode()) {\n        read = current.in.read(buffer, offset, length);\n    } else {\n        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n    }\n    if (read >= 0) {\n        current.crc.update(buffer, offset, read);\n    }\n    return read;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n@@ -1,8 +1,32 @@\n @Override\n-public boolean canReadEntryData(final ArchiveEntry ae) {\n-    if (ae instanceof ZipArchiveEntry) {\n-        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n-        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);\n+public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n+    if (closed) {\n+        throw new IOException(\"The stream is closed\");\n     }\n-    return false;\n+    if (current == null) {\n+        return -1;\n+    }\n+    // avoid int overflow, check null buffer\n+    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n+        throw new ArrayIndexOutOfBoundsException();\n+    }\n+    ZipUtil.checkRequestedFeatures(current.entry);\n+    if (!supportsDataDescriptorFor(current.entry)) {\n+        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n+    }\n+    int read;\n+    // Fixed condition to check for ZipMethod.UNSHRINKING\n+    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n+        read = readStored(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n+        read = readDeflated(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getMethodCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getMethodCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getMethodCode() || current.entry.getMethod() == ZipMethod.BZIP2.getMethodCode()) {\n+        read = current.in.read(buffer, offset, length);\n+    } else {\n+        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n+    }\n+    if (read >= 0) {\n+        current.crc.update(buffer, offset, read);\n+    }\n+    return read;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n@@ -15,11 +15,12 @@\n         throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n     }\n     int read;\n+    // Fixed condition to check for ZipMethod.UNSHRINKING\n     if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n         read = readStored(buffer, offset, length);\n     } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n         read = readDeflated(buffer, offset, length);\n-    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n+    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getMethodCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getMethodCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getMethodCode() || current.entry.getMethod() == ZipMethod.BZIP2.getMethodCode()) {\n         read = current.in.read(buffer, offset, length);\n     } else {\n         throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic int read(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (current == null) {\n        return -1;\n    }\n    // avoid int overflow, check null buffer\n    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n        throw new ArrayIndexOutOfBoundsException();\n    }\n    ZipUtil.checkRequestedFeatures(current.entry);\n    if (!supportsDataDescriptorFor(current.entry)) {\n        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n    }\n    int read;\n    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n        read = readStored(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n        read = readDeflated(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n        read = current.in.read(buffer, offset, length);\n        if (read >= 0) {\n            current.crc.update(buffer, offset, read);\n        }\n    } else {\n        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n    }\n    return read;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n@@ -1,8 +1,31 @@\n @Override\n-public boolean canReadEntryData(final ArchiveEntry ae) {\n-    if (ae instanceof ZipArchiveEntry) {\n-        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n-        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);\n+public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n+    if (closed) {\n+        throw new IOException(\"The stream is closed\");\n     }\n-    return false;\n+    if (current == null) {\n+        return -1;\n+    }\n+    // avoid int overflow, check null buffer\n+    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n+        throw new ArrayIndexOutOfBoundsException();\n+    }\n+    ZipUtil.checkRequestedFeatures(current.entry);\n+    if (!supportsDataDescriptorFor(current.entry)) {\n+        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n+    }\n+    int read;\n+    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n+        read = readStored(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n+        read = readDeflated(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n+        read = current.in.read(buffer, offset, length);\n+        if (read >= 0) {\n+            current.crc.update(buffer, offset, read);\n+        }\n+    } else {\n+        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n+    }\n+    return read;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n@@ -21,11 +21,11 @@\n         read = readDeflated(buffer, offset, length);\n     } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n         read = current.in.read(buffer, offset, length);\n+        if (read >= 0) {\n+            current.crc.update(buffer, offset, read);\n+        }\n     } else {\n         throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n     }\n-    if (read >= 0) {\n-        current.crc.update(buffer, offset, read);\n-    }\n     return read;\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic int read(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (current == null) {\n        return -1;\n    }\n    // avoid int overflow, check null buffer\n    if (offset < 0 || length < 0 || offset > buffer.length - length) {\n        throw new ArrayIndexOutOfBoundsException();\n    }\n    ZipUtil.checkRequestedFeatures(current.entry);\n    if (!supportsDataDescriptorFor(current.entry)) {\n        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n    }\n    int read;\n    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n        read = readStored(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n        read = readDeflated(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n        read = current.in.read(buffer, offset, length);\n    } else {\n        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n    }\n    if (read >= 0) {\n        current.crc.update(buffer, offset, read);\n    }\n    return read;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n@@ -1,8 +1,31 @@\n @Override\n-public boolean canReadEntryData(final ArchiveEntry ae) {\n-    if (ae instanceof ZipArchiveEntry) {\n-        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n-        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);\n+public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n+    if (closed) {\n+        throw new IOException(\"The stream is closed\");\n     }\n-    return false;\n+    if (current == null) {\n+        return -1;\n+    }\n+    // avoid int overflow, check null buffer\n+    if (offset < 0 || length < 0 || offset > buffer.length - length) {\n+        throw new ArrayIndexOutOfBoundsException();\n+    }\n+    ZipUtil.checkRequestedFeatures(current.entry);\n+    if (!supportsDataDescriptorFor(current.entry)) {\n+        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n+    }\n+    int read;\n+    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n+        read = readStored(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n+        read = readDeflated(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n+        read = current.in.read(buffer, offset, length);\n+    } else {\n+        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n+    }\n+    if (read >= 0) {\n+        current.crc.update(buffer, offset, read);\n+    }\n+    return read;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n@@ -7,7 +7,7 @@\n         return -1;\n     }\n     // avoid int overflow, check null buffer\n-    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n+    if (offset < 0 || length < 0 || offset > buffer.length - length) {\n         throw new ArrayIndexOutOfBoundsException();\n     }\n     ZipUtil.checkRequestedFeatures(current.entry);\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic int read(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (current == null) {\n        return -1;\n    }\n    // avoid int overflow, check null buffer\n    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n        throw new IndexOutOfBoundsException();\n    }\n    ZipUtil.checkRequestedFeatures(current.entry);\n    if (!supportsDataDescriptorFor(current.entry)) {\n        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n    }\n    int read;\n    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n        read = readStored(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n        read = readDeflated(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n        read = current.in.read(buffer, offset, length);\n    } else {\n        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n    }\n    if (read >= 0) {\n        current.crc.update(buffer, offset, read);\n    }\n    return read;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n@@ -1,8 +1,31 @@\n @Override\n-public boolean canReadEntryData(final ArchiveEntry ae) {\n-    if (ae instanceof ZipArchiveEntry) {\n-        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n-        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);\n+public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n+    if (closed) {\n+        throw new IOException(\"The stream is closed\");\n     }\n-    return false;\n+    if (current == null) {\n+        return -1;\n+    }\n+    // avoid int overflow, check null buffer\n+    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n+        throw new IndexOutOfBoundsException();\n+    }\n+    ZipUtil.checkRequestedFeatures(current.entry);\n+    if (!supportsDataDescriptorFor(current.entry)) {\n+        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n+    }\n+    int read;\n+    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n+        read = readStored(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n+        read = readDeflated(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n+        read = current.in.read(buffer, offset, length);\n+    } else {\n+        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n+    }\n+    if (read >= 0) {\n+        current.crc.update(buffer, offset, read);\n+    }\n+    return read;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n@@ -8,7 +8,7 @@\n     }\n     // avoid int overflow, check null buffer\n     if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n-        throw new ArrayIndexOutOfBoundsException();\n+        throw new IndexOutOfBoundsException();\n     }\n     ZipUtil.checkRequestedFeatures(current.entry);\n     if (!supportsDataDescriptorFor(current.entry)) {\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic int read(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (current == null) {\n        return -1;\n    }\n    // avoid int overflow, check null buffer\n    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n        throw new ArrayIndexOutOfBoundsException();\n    }\n    ZipUtil.checkRequestedFeatures(current.entry);\n    if (!supportsDataDescriptorFor(current.entry)) {\n        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n    }\n    int read;\n    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n        read = readStored(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n        read = readDeflated(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n        read = current.in.read(buffer, offset, length);\n    } else {\n        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n    }\n    if (read > 0) { // change condition to only update crc if data was actually read\n        current.crc.update(buffer, offset, read); // move the update inside the if condition\n    }\n    return read;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n@@ -1,8 +1,31 @@\n @Override\n-public boolean canReadEntryData(final ArchiveEntry ae) {\n-    if (ae instanceof ZipArchiveEntry) {\n-        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n-        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);\n+public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n+    if (closed) {\n+        throw new IOException(\"The stream is closed\");\n     }\n-    return false;\n+    if (current == null) {\n+        return -1;\n+    }\n+    // avoid int overflow, check null buffer\n+    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n+        throw new ArrayIndexOutOfBoundsException();\n+    }\n+    ZipUtil.checkRequestedFeatures(current.entry);\n+    if (!supportsDataDescriptorFor(current.entry)) {\n+        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n+    }\n+    int read;\n+    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n+        read = readStored(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n+        read = readDeflated(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n+        read = current.in.read(buffer, offset, length);\n+    } else {\n+        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n+    }\n+    if (read > 0) { // change condition to only update crc if data was actually read\n+        current.crc.update(buffer, offset, read); // move the update inside the if condition\n+    }\n+    return read;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n@@ -24,8 +24,8 @@\n     } else {\n         throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n     }\n-    if (read >= 0) {\n-        current.crc.update(buffer, offset, read);\n+    if (read > 0) { // change condition to only update crc if data was actually read\n+        current.crc.update(buffer, offset, read); // move the update inside the if condition\n     }\n     return read;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic int read(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (current == null) {\n        return -1;\n    }\n    // avoid int overflow, check null buffer\n    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n        throw new ArrayIndexOutOfBoundsException();\n    }\n    ZipUtil.checkRequestedFeatures(current.entry);\n    if (!supportsDataDescriptorFor(current.entry)) {\n        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n    }\n    int read;\n    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n        read = readStored(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n        read = readDeflated(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n        // use correct offset in the input stream\n        read = current.in.read(buffer, offset, length);\n    } else {\n        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n    }\n    if (read >= 0) {\n        // update CRC with correct offset and length\n        current.crc.update(buffer, offset, read);\n    }\n    return read;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n@@ -1,8 +1,33 @@\n @Override\n-public boolean canReadEntryData(final ArchiveEntry ae) {\n-    if (ae instanceof ZipArchiveEntry) {\n-        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n-        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);\n+public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n+    if (closed) {\n+        throw new IOException(\"The stream is closed\");\n     }\n-    return false;\n+    if (current == null) {\n+        return -1;\n+    }\n+    // avoid int overflow, check null buffer\n+    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n+        throw new ArrayIndexOutOfBoundsException();\n+    }\n+    ZipUtil.checkRequestedFeatures(current.entry);\n+    if (!supportsDataDescriptorFor(current.entry)) {\n+        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n+    }\n+    int read;\n+    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n+        read = readStored(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n+        read = readDeflated(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n+        // use correct offset in the input stream\n+        read = current.in.read(buffer, offset, length);\n+    } else {\n+        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n+    }\n+    if (read >= 0) {\n+        // update CRC with correct offset and length\n+        current.crc.update(buffer, offset, read);\n+    }\n+    return read;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n@@ -20,11 +20,13 @@\n     } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n         read = readDeflated(buffer, offset, length);\n     } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n+        // use correct offset in the input stream\n         read = current.in.read(buffer, offset, length);\n     } else {\n         throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n     }\n     if (read >= 0) {\n+        // update CRC with correct offset and length\n         current.crc.update(buffer, offset, read);\n     }\n     return read;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic int read(final byte[] buffer, final int offset, final int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (current == null) {\n        return -1;\n    }\n    // avoid int overflow, check null buffer\n    if (offset < 0 || length < 0 || offset + length > buffer.length) { // fixed the buffer index check condition\n        throw new ArrayIndexOutOfBoundsException();\n    }\n    ZipUtil.checkRequestedFeatures(current.entry);\n    if (!supportsDataDescriptorFor(current.entry)) {\n        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n    }\n    int read;\n    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n        read = readStored(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n        read = readDeflated(buffer, offset, length);\n    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n        read = current.in.read(buffer, offset, length);\n    } else {\n        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n    }\n    if (read >= 0) {\n        current.crc.update(buffer, offset, read);\n    }\n    return read;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@canReadEntryData\n@@ -1,8 +1,31 @@\n @Override\n-public boolean canReadEntryData(final ArchiveEntry ae) {\n-    if (ae instanceof ZipArchiveEntry) {\n-        final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n-        return ZipUtil.canHandleEntryData(ze) && supportsDataDescriptorFor(ze);\n+public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n+    if (closed) {\n+        throw new IOException(\"The stream is closed\");\n     }\n-    return false;\n+    if (current == null) {\n+        return -1;\n+    }\n+    // avoid int overflow, check null buffer\n+    if (offset < 0 || length < 0 || offset + length > buffer.length) { // fixed the buffer index check condition\n+        throw new ArrayIndexOutOfBoundsException();\n+    }\n+    ZipUtil.checkRequestedFeatures(current.entry);\n+    if (!supportsDataDescriptorFor(current.entry)) {\n+        throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR, current.entry);\n+    }\n+    int read;\n+    if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n+        read = readStored(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n+        read = readDeflated(buffer, offset, length);\n+    } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode() || current.entry.getMethod() == ZipMethod.IMPLODING.getCode() || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode() || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n+        read = current.in.read(buffer, offset, length);\n+    } else {\n+        throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()), current.entry);\n+    }\n+    if (read >= 0) {\n+        current.crc.update(buffer, offset, read);\n+    }\n+    return read;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@read\n@@ -7,7 +7,7 @@\n         return -1;\n     }\n     // avoid int overflow, check null buffer\n-    if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n+    if (offset < 0 || length < 0 || offset + length > buffer.length) { // fixed the buffer index check condition\n         throw new ArrayIndexOutOfBoundsException();\n     }\n     ZipUtil.checkRequestedFeatures(current.entry);\n", "finish_reason": "stop", "valid": false, "num": 1}]