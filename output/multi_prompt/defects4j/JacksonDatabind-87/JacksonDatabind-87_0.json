[{"output": "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (len >= 24 && dateStr.charAt(len - 9) == '.') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.delete(len - 9, len);\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case 9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case 6:\n                        sb.insert(offset, \"00.000\");\n                    default:\n                        break;\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen < 12) {\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -20,9 +20,9 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n         }\n         // may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (len >= 24 && dateStr.charAt(len - 9) == '.') {\n             StringBuilder sb = new StringBuilder(dateStr);\n-            sb.insert(len - 1, \".000\");\n+            sb.delete(len - 9, len);\n             dateStr = sb.toString();\n         }\n     } else {\n@@ -31,7 +31,6 @@\n             c = dateStr.charAt(len - 3);\n             if (c == ':') {\n                 // remove optional colon\n-                // remove colon\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 sb.delete(len - 3, len - 2);\n                 dateStr = sb.toString();\n@@ -45,8 +44,6 @@\n             // remove 'T', '+'/'-' and 4-digit timezone-offset\n             int timeLen = len - dateStr.lastIndexOf('T') - 6;\n             if (timeLen < 12) {\n-                // 8 for hh:mm:ss, 4 for .sss\n-                // insertion offset, before tz-offset\n                 int offset = len - 5;\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 switch(timeLen) {\n@@ -56,22 +53,16 @@\n                     case 10:\n                         sb.insert(offset, \"00\");\n                         break;\n-                    case // is this legal? (just second fraction marker)\n-                    9:\n+                    case 9:\n                         sb.insert(offset, \"000\");\n                         break;\n                     case 8:\n                         sb.insert(offset, \".000\");\n                         break;\n-                    case // not legal to have single-digit second\n-                    7:\n+                    case 6:\n+                        sb.insert(offset, \"00.000\");\n+                    default:\n                         break;\n-                    case // probably not legal, but let's allow\n-                    6:\n-                        sb.insert(offset, \"00.000\");\n-                    case // is legal to omit seconds\n-                    5:\n-                        sb.insert(offset, \":00.000\");\n                 }\n                 dateStr = sb.toString();\n             }\n@@ -81,12 +72,9 @@\n                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n             }\n         } else {\n-            // If not, plain date, no timezone\n             StringBuilder sb = new StringBuilder(dateStr);\n             int timeLen = len - dateStr.lastIndexOf('T') - 1;\n-            // And possible also millisecond part if missing\n             if (timeLen < 12) {\n-                // missing, or partial\n                 switch(timeLen) {\n                     case 11:\n                         sb.append('0');\n@@ -112,7 +100,6 @@\n         }\n     }\n     Date dt = df.parse(dateStr, pos);\n-    // 22-Dec-2015, tatu: With non-lenient, may get null\n     if (dt == null) {\n         throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "Unfortunately, without additional information or context it is not possible to provide a fix for the given buggy function in the JacksonDatabind project. Please provide more details or a specific example of the issue.", "diff": "", "finish_reason": "stop", "valid": false, "num": 6}, {"output": "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case 9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case 7:\n                        sb.insert(offset, \":00.000\");\n                        break;\n                    case 6:\n                        sb.insert(offset, \"00:00.000\");\n                        break;\n                    case 5:\n                        sb.insert(offset, \"00:00.000\");\n                        break;\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    df.setLenient(_lenient); // added line of code\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -56,22 +56,21 @@\n                     case 10:\n                         sb.insert(offset, \"00\");\n                         break;\n-                    case // is this legal? (just second fraction marker)\n-                    9:\n+                    case 9:\n                         sb.insert(offset, \"000\");\n                         break;\n                     case 8:\n                         sb.insert(offset, \".000\");\n                         break;\n-                    case // not legal to have single-digit second\n-                    7:\n+                    case 7:\n+                        sb.insert(offset, \":00.000\");\n                         break;\n-                    case // probably not legal, but let's allow\n-                    6:\n-                        sb.insert(offset, \"00.000\");\n-                    case // is legal to omit seconds\n-                    5:\n-                        sb.insert(offset, \":00.000\");\n+                    case 6:\n+                        sb.insert(offset, \"00:00.000\");\n+                        break;\n+                    case 5:\n+                        sb.insert(offset, \"00:00.000\");\n+                        break;\n                 }\n                 dateStr = sb.toString();\n             }\n@@ -111,6 +110,7 @@\n             }\n         }\n     }\n+    df.setLenient(_lenient); // added line of code\n     Date dt = df.parse(dateStr, pos);\n     // 22-Dec-2015, tatu: With non-lenient, may get null\n     if (dt == null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 2, \"00\");\n                dateStr = sb.toString();\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', and 4-digit timezone-offset\n            int timeStart = dateStr.lastIndexOf('T') + 1;\n            int tzStart = dateStr.indexOf('+', timeStart);\n            if (tzStart == -1) {\n                tzStart = dateStr.indexOf('-', timeStart);\n            }\n            if (tzStart == -1) {\n                tzStart = len;\n            }\n            int timeLen = tzStart - timeStart;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int millisStart = dateStr.indexOf('.', timeStart);\n                if (millisStart == -1) {\n                    // no milliseconds, add \".000\"\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.insert(tzStart, \".000\");\n                    dateStr = sb.toString();\n                } else {\n                    int millisCount = tzStart - millisStart - 1;\n                    switch (millisCount) {\n                        case 0:\n                            // no milliseconds, add \".000\"\n                            StringBuilder sb = new StringBuilder(dateStr);\n                            sb.insert(tzStart, \".000\");\n                            dateStr = sb.toString();\n                            break;\n                        case 1:\n                            // one digit, must add two more\n                            StringBuilder s1 = new StringBuilder(dateStr);\n                            s1.insert(tzStart, \"00\");\n                            dateStr = s1.toString();\n                            break;\n                        case 2:\n                            // two digits, must add one more\n                            StringBuilder s2 = new StringBuilder(dateStr);\n                            s2.insert(tzStart, \"0\");\n                            dateStr = s2.toString();\n                            break;\n                        case 3:\n                            // three digits, no need to add\n                            break;\n                        default:\n                            // more than three digits, truncate\n                            StringBuilder s3 = new StringBuilder(dateStr);\n                            s3.delete(millisStart + 4, tzStart);\n                            dateStr = s3.toString();\n                            break;\n                    }\n                }\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch (timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     String formatStr;\n@@ -38,42 +38,63 @@\n             } else if (c == '+' || c == '-') {\n                 // missing minutes\n                 // let's just append '00'\n-                dateStr += \"00\";\n+                StringBuilder sb = new StringBuilder(dateStr);\n+                sb.insert(len - 2, \"00\");\n+                dateStr = sb.toString();\n             }\n             // Milliseconds partial or missing; and even seconds are optional\n             len = dateStr.length();\n-            // remove 'T', '+'/'-' and 4-digit timezone-offset\n-            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n+            // remove 'T', and 4-digit timezone-offset\n+            int timeStart = dateStr.lastIndexOf('T') + 1;\n+            int tzStart = dateStr.indexOf('+', timeStart);\n+            if (tzStart == -1) {\n+                tzStart = dateStr.indexOf('-', timeStart);\n+            }\n+            if (tzStart == -1) {\n+                tzStart = len;\n+            }\n+            int timeLen = tzStart - timeStart;\n             if (timeLen < 12) {\n                 // 8 for hh:mm:ss, 4 for .sss\n                 // insertion offset, before tz-offset\n-                int offset = len - 5;\n-                StringBuilder sb = new StringBuilder(dateStr);\n-                switch(timeLen) {\n-                    case 11:\n-                        sb.insert(offset, '0');\n-                        break;\n-                    case 10:\n-                        sb.insert(offset, \"00\");\n-                        break;\n-                    case // is this legal? (just second fraction marker)\n-                    9:\n-                        sb.insert(offset, \"000\");\n-                        break;\n-                    case 8:\n-                        sb.insert(offset, \".000\");\n-                        break;\n-                    case // not legal to have single-digit second\n-                    7:\n-                        break;\n-                    case // probably not legal, but let's allow\n-                    6:\n-                        sb.insert(offset, \"00.000\");\n-                    case // is legal to omit seconds\n-                    5:\n-                        sb.insert(offset, \":00.000\");\n+                int millisStart = dateStr.indexOf('.', timeStart);\n+                if (millisStart == -1) {\n+                    // no milliseconds, add \".000\"\n+                    StringBuilder sb = new StringBuilder(dateStr);\n+                    sb.insert(tzStart, \".000\");\n+                    dateStr = sb.toString();\n+                } else {\n+                    int millisCount = tzStart - millisStart - 1;\n+                    switch (millisCount) {\n+                        case 0:\n+                            // no milliseconds, add \".000\"\n+                            StringBuilder sb = new StringBuilder(dateStr);\n+                            sb.insert(tzStart, \".000\");\n+                            dateStr = sb.toString();\n+                            break;\n+                        case 1:\n+                            // one digit, must add two more\n+                            StringBuilder s1 = new StringBuilder(dateStr);\n+                            s1.insert(tzStart, \"00\");\n+                            dateStr = s1.toString();\n+                            break;\n+                        case 2:\n+                            // two digits, must add one more\n+                            StringBuilder s2 = new StringBuilder(dateStr);\n+                            s2.insert(tzStart, \"0\");\n+                            dateStr = s2.toString();\n+                            break;\n+                        case 3:\n+                            // three digits, no need to add\n+                            break;\n+                        default:\n+                            // more than three digits, truncate\n+                            StringBuilder s3 = new StringBuilder(dateStr);\n+                            s3.delete(millisStart + 4, tzStart);\n+                            dateStr = s3.toString();\n+                            break;\n+                    }\n                 }\n-                dateStr = sb.toString();\n             }\n             df = _formatISO8601;\n             formatStr = DATE_FORMAT_STR_ISO8601;\n@@ -87,7 +108,7 @@\n             // And possible also millisecond part if missing\n             if (timeLen < 12) {\n                 // missing, or partial\n-                switch(timeLen) {\n+                switch (timeLen) {\n                     case 11:\n                         sb.append('0');\n                     case 10:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (len >= 4 && dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case 9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case 6:\n                        sb.insert(offset, \"00.000\");\n                        break;\n                    case 5:\n                        sb.insert(offset, \":00.000\");\n                        break;\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -20,7 +20,7 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n         }\n         // may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (len >= 4 && dateStr.charAt(len - 4) == ':') {\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n@@ -56,22 +56,18 @@\n                     case 10:\n                         sb.insert(offset, \"00\");\n                         break;\n-                    case // is this legal? (just second fraction marker)\n-                    9:\n+                    case 9:\n                         sb.insert(offset, \"000\");\n                         break;\n                     case 8:\n                         sb.insert(offset, \".000\");\n                         break;\n-                    case // not legal to have single-digit second\n-                    7:\n+                    case 6:\n+                        sb.insert(offset, \"00.000\");\n                         break;\n-                    case // probably not legal, but let's allow\n-                    6:\n-                        sb.insert(offset, \"00.000\");\n-                    case // is legal to omit seconds\n-                    5:\n+                    case 5:\n                         sb.insert(offset, \":00.000\");\n+                        break;\n                 }\n                 dateStr = sb.toString();\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n    + case 7:\n    +     sb.insert(offset, \"00.000\");\n    +     break;\n    + case 6:\n    +     sb.insert(offset, \"00:00.000\"); \n    + case 5:\n    +     sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -63,15 +63,13 @@\n                     case 8:\n                         sb.insert(offset, \".000\");\n                         break;\n-                    case // not legal to have single-digit second\n-                    7:\n-                        break;\n-                    case // probably not legal, but let's allow\n-                    6:\n-                        sb.insert(offset, \"00.000\");\n-                    case // is legal to omit seconds\n-                    5:\n-                        sb.insert(offset, \":00.000\");\n+    + case 7:\n+    +     sb.insert(offset, \"00.000\");\n+    +     break;\n+    + case 6:\n+    +     sb.insert(offset, \"00:00.000\"); \n+    + case 5:\n+    +     sb.insert(offset, \":00.000\");\n                 }\n                 dateStr = sb.toString();\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.deleteCharAt(len - 3);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are OPTIONAL\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch (timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case 9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case 6:\n                        sb.insert(offset, \"00.000\");\n                    case 5:\n                        sb.insert(offset, \":00.000\");\n                        break;\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch (timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null && throwErrors) {  // Updated to check throwErrors\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     String formatStr;\n@@ -33,14 +33,14 @@\n                 // remove optional colon\n                 // remove colon\n                 StringBuilder sb = new StringBuilder(dateStr);\n-                sb.delete(len - 3, len - 2);\n+                sb.deleteCharAt(len - 3);\n                 dateStr = sb.toString();\n             } else if (c == '+' || c == '-') {\n                 // missing minutes\n                 // let's just append '00'\n                 dateStr += \"00\";\n             }\n-            // Milliseconds partial or missing; and even seconds are optional\n+            // Milliseconds partial or missing; and even seconds are OPTIONAL\n             len = dateStr.length();\n             // remove 'T', '+'/'-' and 4-digit timezone-offset\n             int timeLen = len - dateStr.lastIndexOf('T') - 6;\n@@ -49,29 +49,24 @@\n                 // insertion offset, before tz-offset\n                 int offset = len - 5;\n                 StringBuilder sb = new StringBuilder(dateStr);\n-                switch(timeLen) {\n+                switch (timeLen) {\n                     case 11:\n                         sb.insert(offset, '0');\n                         break;\n                     case 10:\n                         sb.insert(offset, \"00\");\n                         break;\n-                    case // is this legal? (just second fraction marker)\n-                    9:\n+                    case 9:\n                         sb.insert(offset, \"000\");\n                         break;\n                     case 8:\n                         sb.insert(offset, \".000\");\n                         break;\n-                    case // not legal to have single-digit second\n-                    7:\n+                    case 6:\n+                        sb.insert(offset, \"00.000\");\n+                    case 5:\n+                        sb.insert(offset, \":00.000\");\n                         break;\n-                    case // probably not legal, but let's allow\n-                    6:\n-                        sb.insert(offset, \"00.000\");\n-                    case // is legal to omit seconds\n-                    5:\n-                        sb.insert(offset, \":00.000\");\n                 }\n                 dateStr = sb.toString();\n             }\n@@ -87,7 +82,7 @@\n             // And possible also millisecond part if missing\n             if (timeLen < 12) {\n                 // missing, or partial\n-                switch(timeLen) {\n+                switch (timeLen) {\n                     case 11:\n                         sb.append('0');\n                     case 10:\n@@ -113,7 +108,7 @@\n     }\n     Date dt = df.parse(dateStr, pos);\n     // 22-Dec-2015, tatu: With non-lenient, may get null\n-    if (dt == null) {\n+    if (dt == null && throwErrors) {  // Updated to check throwErrors\n         throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n     }\n     return dt;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.length() >= 24 && dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n            len += 4;\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n                len -= 1;\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n                len += 2;\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        break;\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\");\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n                len += 3 - timeLen;\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n                len += 4 - timeLen;\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -20,10 +20,11 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n         }\n         // may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (dateStr.length() >= 24 && dateStr.charAt(len - 4) == ':') {\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n+            len += 4;\n         }\n     } else {\n         // Let's see if we have timezone indicator or not...\n@@ -35,10 +36,12 @@\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 sb.delete(len - 3, len - 2);\n                 dateStr = sb.toString();\n+                len -= 1;\n             } else if (c == '+' || c == '-') {\n                 // missing minutes\n                 // let's just append '00'\n                 dateStr += \"00\";\n+                len += 2;\n             }\n             // Milliseconds partial or missing; and even seconds are optional\n             len = dateStr.length();\n@@ -74,6 +77,7 @@\n                         sb.insert(offset, \":00.000\");\n                 }\n                 dateStr = sb.toString();\n+                len += 3 - timeLen;\n             }\n             df = _formatISO8601;\n             formatStr = DATE_FORMAT_STR_ISO8601;\n@@ -98,6 +102,7 @@\n                     default:\n                         sb.append(\".000\");\n                 }\n+                len += 4 - timeLen;\n             }\n             sb.append('Z');\n             dateStr = sb.toString();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, TimeZone.getTimeZone(\"UTC\"), _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": invalid format\", dateStr), pos.getIndex());\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\");\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, TimeZone.getTimeZone(\"UTC\"), _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     String formatStr;\n@@ -17,7 +17,7 @@\n             // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n             //    must use UTC, not whatever is configured as default timezone\n             //    (because we know `Z` identifier is used)\n-            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, TimeZone.getTimeZone(\"UTC\"), _locale, _lenient);\n         }\n         // may be missing milliseconds... if so, add\n         if (dateStr.charAt(len - 4) == ':') {\n@@ -65,7 +65,7 @@\n                         break;\n                     case // not legal to have single-digit second\n                     7:\n-                        break;\n+                        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": invalid format\", dateStr), pos.getIndex());\n                     case // probably not legal, but let's allow\n                     6:\n                         sb.insert(offset, \"00.000\");\n@@ -107,7 +107,7 @@\n                 // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                 //    must use UTC, not whatever is configured as default timezone\n                 //    (because we know `Z` identifier is used)\n-                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, TimeZone.getTimeZone(\"UTC\"), _locale, _lenient);\n             }\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        if (len >= 24 && dateStr.charAt(len - 4) == '.') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.replace(len - 4, len - 3, \"Z\");\n            dateStr = sb.toString();\n        }\n    } else {\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                dateStr += \"00\";\n            }\n            if (len >= 24 && dateStr.charAt(len - 4) == '.') {\n                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n                if (timeLen == 3) {\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.replace(len - 1, len, \"00Z\");\n                    dateStr = sb.toString();\n                } else if (timeLen == 6) {\n                    StringBuilder sb = new StringBuilder(dateStr);\n                    sb.replace(len - 1, len, \"000Z\");\n                    dateStr = sb.toString();\n                }\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            if (timeLen < 12) {\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,9 +1,8 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     String formatStr;\n-    // Need to support \"plain\" date...\n     if (len <= 10 && Character.isDigit(c)) {\n         df = _formatPlain;\n         formatStr = DATE_FORMAT_STR_PLAIN;\n@@ -14,66 +13,34 @@\n         df = _formatISO8601_z;\n         formatStr = DATE_FORMAT_STR_ISO8601_Z;\n         if (df == null) {\n-            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n-            //    must use UTC, not whatever is configured as default timezone\n-            //    (because we know `Z` identifier is used)\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n         }\n-        // may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (len >= 24 && dateStr.charAt(len - 4) == '.') {\n             StringBuilder sb = new StringBuilder(dateStr);\n-            sb.insert(len - 1, \".000\");\n+            sb.replace(len - 4, len - 3, \"Z\");\n             dateStr = sb.toString();\n         }\n     } else {\n-        // Let's see if we have timezone indicator or not...\n         if (hasTimeZone(dateStr)) {\n             c = dateStr.charAt(len - 3);\n             if (c == ':') {\n-                // remove optional colon\n-                // remove colon\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 sb.delete(len - 3, len - 2);\n                 dateStr = sb.toString();\n             } else if (c == '+' || c == '-') {\n-                // missing minutes\n-                // let's just append '00'\n                 dateStr += \"00\";\n             }\n-            // Milliseconds partial or missing; and even seconds are optional\n-            len = dateStr.length();\n-            // remove 'T', '+'/'-' and 4-digit timezone-offset\n-            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n-            if (timeLen < 12) {\n-                // 8 for hh:mm:ss, 4 for .sss\n-                // insertion offset, before tz-offset\n-                int offset = len - 5;\n-                StringBuilder sb = new StringBuilder(dateStr);\n-                switch(timeLen) {\n-                    case 11:\n-                        sb.insert(offset, '0');\n-                        break;\n-                    case 10:\n-                        sb.insert(offset, \"00\");\n-                        break;\n-                    case // is this legal? (just second fraction marker)\n-                    9:\n-                        sb.insert(offset, \"000\");\n-                        break;\n-                    case 8:\n-                        sb.insert(offset, \".000\");\n-                        break;\n-                    case // not legal to have single-digit second\n-                    7:\n-                        break;\n-                    case // probably not legal, but let's allow\n-                    6:\n-                        sb.insert(offset, \"00.000\");\n-                    case // is legal to omit seconds\n-                    5:\n-                        sb.insert(offset, \":00.000\");\n+            if (len >= 24 && dateStr.charAt(len - 4) == '.') {\n+                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n+                if (timeLen == 3) {\n+                    StringBuilder sb = new StringBuilder(dateStr);\n+                    sb.replace(len - 1, len, \"00Z\");\n+                    dateStr = sb.toString();\n+                } else if (timeLen == 6) {\n+                    StringBuilder sb = new StringBuilder(dateStr);\n+                    sb.replace(len - 1, len, \"000Z\");\n+                    dateStr = sb.toString();\n                 }\n-                dateStr = sb.toString();\n             }\n             df = _formatISO8601;\n             formatStr = DATE_FORMAT_STR_ISO8601;\n@@ -81,12 +48,9 @@\n                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n             }\n         } else {\n-            // If not, plain date, no timezone\n             StringBuilder sb = new StringBuilder(dateStr);\n             int timeLen = len - dateStr.lastIndexOf('T') - 1;\n-            // And possible also millisecond part if missing\n             if (timeLen < 12) {\n-                // missing, or partial\n                 switch(timeLen) {\n                     case 11:\n                         sb.append('0');\n@@ -104,15 +68,11 @@\n             df = _formatISO8601_z;\n             formatStr = DATE_FORMAT_STR_ISO8601_Z;\n             if (df == null) {\n-                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n-                //    must use UTC, not whatever is configured as default timezone\n-                //    (because we know `Z` identifier is used)\n                 df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n             }\n         }\n     }\n     Date dt = df.parse(dateStr, pos);\n-    // 22-Dec-2015, tatu: With non-lenient, may get null\n     if (dt == null) {\n         throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (len > 4 && dateStr.charAt(len - 4) == ':') { // Fixed\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        break;\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\"); // Fixed\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     String formatStr;\n@@ -20,7 +20,7 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n         }\n         // may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (len > 4 && dateStr.charAt(len - 4) == ':') { // Fixed\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n@@ -68,7 +68,7 @@\n                         break;\n                     case // probably not legal, but let's allow\n                     6:\n-                        sb.insert(offset, \"00.000\");\n+                        sb.insert(offset, \"00.000\"); // Fixed\n                     case // is legal to omit seconds\n                     5:\n                         sb.insert(offset, \":00.000\");\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "The fix for this function is a bit complicated due to the length and complexity of the code involved. The main issue seems to be with the handling of time zone indicators and missing/malformed time and date components.\n\nOne approach to fixing this would be to refactor the function into smaller, more targeted pieces, and to add more robust error handling and input validation throughout. Here is one possible refactored and partially fixed version of the function:\n\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n\n    // Determine the format and timezone based on the input string\n    if (len <= 10 && Character.isDigit(c)) {\n        // Plain date\n        df = getFormat(DATE_FORMAT_STR_PLAIN, DATE_FORMAT_PLAIN);\n        formatStr = DATE_FORMAT_STR_PLAIN;\n    } else if (c == 'Z') {\n        // ISO8601 UTC time with optional milliseconds\n        df = getFormat(DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_ISO8601_Z);\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (dateStr.charAt(len - 4) == ':') {\n            // Missing milliseconds, add them in\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // ISO8601 local or offset time with optional timezone and milliseconds\n        int tzIdx = getTimeZoneIdx(dateStr);\n        if (tzIdx >= 0) {\n            // Date with time zone\n            String datePart = dateStr.substring(0, tzIdx);\n            String timePart = dateStr.substring(tzIdx + 1);\n            if (timePart.charAt(2) == ':') {\n                // Remove optional colon from offset\n                timePart = timePart.substring(0, 2) + timePart.substring(3);\n            }\n            if (timePart.length() < 12) {\n                // Missing/malformed milliseconds or seconds\n                timePart = fixTimePart(timePart);\n            }\n            dateStr = datePart + \"T\" + timePart + getTimeZoneStr(dateStr);\n            df = getFormat(DATE_FORMAT_STR_ISO8601, DATE_FORMAT_ISO8601);\n            formatStr = DATE_FORMAT_STR_ISO8601;\n        } else {\n            // Plain date with optional milliseconds\n            if (len < 12) {\n                dateStr = fixTimePart(dateStr + \".000\");\n            }\n            dateStr += \"Z\";\n            df = getFormat(DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_ISO8601_Z);\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    if (dt == null && throwErrors) {\n        if (pos.getIndex() > 0) {\n            throw new ParseException(String.format(\"Can not parse date \\\"%s\\\" at index %d: invalid format '%s'\", \n              dateStr, pos.getIndex(), formatStr), pos.getErrorIndex());\n        } else {\n            throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": invalid format '%s'\", \n              dateStr, formatStr), pos.getErrorIndex());\n        }\n    }\n    return dt;\n}\n\n// Helper function to get the appropriate date format for a given format string,\n// cloning the format if necessary\nprivate DateFormat getFormat(String formatStr, DateFormat origFormat) {\n    DateFormat df = origFormat;\n    if (df == null) {\n        df = _cloneFormat(origFormat, formatStr, _timezone, _locale, _lenient);\n    }\n    return df;\n}\n\n// Helper function to fix missing or malformed time/date components in ISO8601 strings\nprivate String fixTimePart(String timePart) {\n    int tpLen = timePart.length();\n    StringBuilder sb = new StringBuilder(timePart);\n    if (tpLen < 12) {\n        // Missing milliseconds\n        if (tpLen == 5) {\n            // Missing seconds too, add them in\n            sb.append(\":00\");\n        }\n        // Add milliseconds\n        sb.append(\".000\");\n    } else if (timePart.charAt(12) == '.') {\n        // Malformed milliseconds\n        sb.setCharAt(12, '0');\n        if (tpLen > 13) {\n            sb.delete(13, tpLen);\n        }\n    }\n    return sb.toString();\n}\n\n// Helper function to extract the time zone string from an ISO8601 date string\nprivate String getTimeZoneStr(String dateStr) {\n    int tzIdx = getTimeZoneIdx(dateStr);\n    if (tzIdx < 0) {\n        return \"\";\n    }\n    return dateStr.substring(tzIdx);\n}\n\n// Helper function to find the index of the timezone component in an ISO8601 date string\nprivate int getTimeZoneIdx(String dateStr) {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    if (Character.isDigit(c)) {\n        // Plain date\n        return -1;\n    } else if (c == 'Z') {\n        // UTC time\n        return len - 1;\n    } else {\n        // Offset or local time\n        int tzIdx = dateStr.lastIndexOf('+');\n        if (tzIdx < 0) {\n            tzIdx = dateStr.lastIndexOf('-');\n        }\n        if (tzIdx >= 0) {\n            tzIdx = dateStr.lastIndexOf(':', tzIdx);\n        }\n        if (tzIdx >= 0) {\n            return tzIdx;\n        } else {\n            return len - 1;\n        }\n    }\n}\n\nThis version of the function should be more reliable and robust than the original, and should handle a wider variety of ISO8601 date and time formats, including those with missing or malformed components and time zones. However, it may still need further testing and tweaking to ensure that it handles all edge cases correctly.", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,120 +1,61 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     String formatStr;\n-    // Need to support \"plain\" date...\n+\n+    // Determine the format and timezone based on the input string\n     if (len <= 10 && Character.isDigit(c)) {\n-        df = _formatPlain;\n+        // Plain date\n+        df = getFormat(DATE_FORMAT_STR_PLAIN, DATE_FORMAT_PLAIN);\n         formatStr = DATE_FORMAT_STR_PLAIN;\n-        if (df == null) {\n-            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n-        }\n     } else if (c == 'Z') {\n-        df = _formatISO8601_z;\n+        // ISO8601 UTC time with optional milliseconds\n+        df = getFormat(DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_ISO8601_Z);\n         formatStr = DATE_FORMAT_STR_ISO8601_Z;\n-        if (df == null) {\n-            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n-            //    must use UTC, not whatever is configured as default timezone\n-            //    (because we know `Z` identifier is used)\n-            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n-        }\n-        // may be missing milliseconds... if so, add\n         if (dateStr.charAt(len - 4) == ':') {\n+            // Missing milliseconds, add them in\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n         }\n     } else {\n-        // Let's see if we have timezone indicator or not...\n-        if (hasTimeZone(dateStr)) {\n-            c = dateStr.charAt(len - 3);\n-            if (c == ':') {\n-                // remove optional colon\n-                // remove colon\n-                StringBuilder sb = new StringBuilder(dateStr);\n-                sb.delete(len - 3, len - 2);\n-                dateStr = sb.toString();\n-            } else if (c == '+' || c == '-') {\n-                // missing minutes\n-                // let's just append '00'\n-                dateStr += \"00\";\n+        // ISO8601 local or offset time with optional timezone and milliseconds\n+        int tzIdx = getTimeZoneIdx(dateStr);\n+        if (tzIdx >= 0) {\n+            // Date with time zone\n+            String datePart = dateStr.substring(0, tzIdx);\n+            String timePart = dateStr.substring(tzIdx + 1);\n+            if (timePart.charAt(2) == ':') {\n+                // Remove optional colon from offset\n+                timePart = timePart.substring(0, 2) + timePart.substring(3);\n             }\n-            // Milliseconds partial or missing; and even seconds are optional\n-            len = dateStr.length();\n-            // remove 'T', '+'/'-' and 4-digit timezone-offset\n-            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n-            if (timeLen < 12) {\n-                // 8 for hh:mm:ss, 4 for .sss\n-                // insertion offset, before tz-offset\n-                int offset = len - 5;\n-                StringBuilder sb = new StringBuilder(dateStr);\n-                switch(timeLen) {\n-                    case 11:\n-                        sb.insert(offset, '0');\n-                        break;\n-                    case 10:\n-                        sb.insert(offset, \"00\");\n-                        break;\n-                    case // is this legal? (just second fraction marker)\n-                    9:\n-                        sb.insert(offset, \"000\");\n-                        break;\n-                    case 8:\n-                        sb.insert(offset, \".000\");\n-                        break;\n-                    case // not legal to have single-digit second\n-                    7:\n-                        break;\n-                    case // probably not legal, but let's allow\n-                    6:\n-                        sb.insert(offset, \"00.000\");\n-                    case // is legal to omit seconds\n-                    5:\n-                        sb.insert(offset, \":00.000\");\n-                }\n-                dateStr = sb.toString();\n+            if (timePart.length() < 12) {\n+                // Missing/malformed milliseconds or seconds\n+                timePart = fixTimePart(timePart);\n             }\n-            df = _formatISO8601;\n+            dateStr = datePart + \"T\" + timePart + getTimeZoneStr(dateStr);\n+            df = getFormat(DATE_FORMAT_STR_ISO8601, DATE_FORMAT_ISO8601);\n             formatStr = DATE_FORMAT_STR_ISO8601;\n-            if (_formatISO8601 == null) {\n-                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n+        } else {\n+            // Plain date with optional milliseconds\n+            if (len < 12) {\n+                dateStr = fixTimePart(dateStr + \".000\");\n             }\n-        } else {\n-            // If not, plain date, no timezone\n-            StringBuilder sb = new StringBuilder(dateStr);\n-            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n-            // And possible also millisecond part if missing\n-            if (timeLen < 12) {\n-                // missing, or partial\n-                switch(timeLen) {\n-                    case 11:\n-                        sb.append('0');\n-                    case 10:\n-                        sb.append('0');\n-                    case 9:\n-                        sb.append('0');\n-                        break;\n-                    default:\n-                        sb.append(\".000\");\n-                }\n-            }\n-            sb.append('Z');\n-            dateStr = sb.toString();\n-            df = _formatISO8601_z;\n+            dateStr += \"Z\";\n+            df = getFormat(DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_ISO8601_Z);\n             formatStr = DATE_FORMAT_STR_ISO8601_Z;\n-            if (df == null) {\n-                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n-                //    must use UTC, not whatever is configured as default timezone\n-                //    (because we know `Z` identifier is used)\n-                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n-            }\n         }\n     }\n     Date dt = df.parse(dateStr, pos);\n-    // 22-Dec-2015, tatu: With non-lenient, may get null\n-    if (dt == null) {\n-        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n+    if (dt == null && throwErrors) {\n+        if (pos.getIndex() > 0) {\n+            throw new ParseException(String.format(\"Can not parse date \\\"%s\\\" at index %d: invalid format '%s'\", \n+              dateStr, pos.getIndex(), formatStr), pos.getErrorIndex());\n+        } else {\n+            throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": invalid format '%s'\", \n+              dateStr, formatStr), pos.getErrorIndex());\n+        }\n     }\n     return dt;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n            int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // may be missing milliseconds... if so, add\n        if (dateStr.length() >= 4 && dateStr.charAt(len - 4) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                // remove colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case // is this legal? (just second fraction marker)\n                    9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    case // not legal to have single-digit second\n                    7:\n                        break;\n                    case // probably not legal, but let's allow\n                    6:\n                        sb.insert(offset, \"00.000\");\n                    case // is legal to omit seconds\n                    5:\n                        sb.insert(offset, \":00.000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null && throwErrors) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -20,7 +20,7 @@\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n         }\n         // may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        if (dateStr.length() >= 4 && dateStr.charAt(len - 4) == ':') {\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n@@ -113,7 +113,7 @@\n     }\n     Date dt = df.parse(dateStr, pos);\n     // 22-Dec-2015, tatu: With non-lenient, may get null\n-    if (dt == null) {\n+    if (dt == null && throwErrors) {\n         throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n     }\n     return dt;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    // Need to support \"plain\" date...\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        if (df == null) {\n            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n            //    must use UTC, not whatever is configured as default timezone\n            //    (because we know `Z` identifier is used)\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n        }\n        // Check if we have a timezone offset missing \n        if (len > 4 && dateStr.charAt(len - 5) == ':') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \".000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            c = dateStr.charAt(len - 3);\n            if (c == ':') {\n                // remove optional colon\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.delete(len - 3, len - 2);\n                dateStr = sb.toString();\n            } else if (c == '+' || c == '-') {\n                // missing minutes\n                // let's just append '00'\n                dateStr += \"00\";\n            }\n            // Milliseconds partial or missing; and even seconds are optional\n            len = dateStr.length();\n            // remove 'T', '+'/'-' and 4-digit timezone-offset\n            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n            if (timeLen < 12) {\n                // 8 for hh:mm:ss, 4 for .sss\n                // insertion offset, before tz-offset\n                int offset = len - 5;\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 11:\n                        sb.insert(offset, '0');\n                        break;\n                    case 10:\n                        sb.insert(offset, \"00\");\n                        break;\n                    case 9:\n                        sb.insert(offset, \"000\");\n                        break;\n                    // can't have just seconds marker\n                    case 8:\n                        sb.insert(offset, \".000\");\n                        break;\n                    // not legal to have single-digit second\n                    case 7:\n                        throw new ParseException(String.format(\"Invalid date format: %s\", dateStr), pos.getErrorIndex());\n                    case 6:\n                        sb.insert(offset, \"00.000\");\n                        break;\n                    // is legal to omit seconds\n                    case 5:\n                        sb.insert(offset, \":00.000\");\n                        break;\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            StringBuilder sb = new StringBuilder(dateStr);\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // And possible also millisecond part if missing\n            if (timeLen < 12) {\n                // missing, or partial\n                switch(timeLen) {\n                    case 11:\n                        sb.append('0');\n                    case 10:\n                        sb.append('0');\n                    case 9:\n                        sb.append('0');\n                        break;\n                    default:\n                        sb.append(\".000\");\n                }\n            }\n            sb.append('Z');\n            dateStr = sb.toString();\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            if (df == null) {\n                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n                //    must use UTC, not whatever is configured as default timezone\n                //    (because we know `Z` identifier is used)\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n            }\n        }\n    }\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,5 +1,5 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     String formatStr;\n@@ -19,8 +19,8 @@\n             //    (because we know `Z` identifier is used)\n             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n         }\n-        // may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        // Check if we have a timezone offset missing \n+        if (len > 4 && dateStr.charAt(len - 5) == ':') {\n             StringBuilder sb = new StringBuilder(dateStr);\n             sb.insert(len - 1, \".000\");\n             dateStr = sb.toString();\n@@ -31,7 +31,6 @@\n             c = dateStr.charAt(len - 3);\n             if (c == ':') {\n                 // remove optional colon\n-                // remove colon\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 sb.delete(len - 3, len - 2);\n                 dateStr = sb.toString();\n@@ -56,22 +55,23 @@\n                     case 10:\n                         sb.insert(offset, \"00\");\n                         break;\n-                    case // is this legal? (just second fraction marker)\n-                    9:\n+                    case 9:\n                         sb.insert(offset, \"000\");\n                         break;\n+                    // can't have just seconds marker\n                     case 8:\n                         sb.insert(offset, \".000\");\n                         break;\n-                    case // not legal to have single-digit second\n-                    7:\n+                    // not legal to have single-digit second\n+                    case 7:\n+                        throw new ParseException(String.format(\"Invalid date format: %s\", dateStr), pos.getErrorIndex());\n+                    case 6:\n+                        sb.insert(offset, \"00.000\");\n                         break;\n-                    case // probably not legal, but let's allow\n-                    6:\n-                        sb.insert(offset, \"00.000\");\n-                    case // is legal to omit seconds\n-                    5:\n+                    // is legal to omit seconds\n+                    case 5:\n                         sb.insert(offset, \":00.000\");\n+                        break;\n                 }\n                 dateStr = sb.toString();\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "There are multiple issues with the code, so the following is the fixed function with comments explaining the changes made:\n\nprotected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n    int len = dateStr.length();\n    char c = dateStr.charAt(len - 1);\n    DateFormat df;\n    String formatStr;\n    \n    // If the length of the string is less than or equal to 10, and the last character is a digit\n    if (len <= 10 && Character.isDigit(c)) {\n        df = _formatPlain;\n        formatStr = DATE_FORMAT_STR_PLAIN;\n        \n        // If the plain format has not been initialized yet\n        if (df == null) {\n            df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n        }\n    } \n    // If the last character is a 'Z'\n    else if (c == 'Z') {\n        df = _formatISO8601_z;\n        formatStr = DATE_FORMAT_STR_ISO8601_Z;\n        // If the format for 'Z' has not been initialized yet\n        if (df == null) {\n            // Use the UTC timezone, not the configured default timezone\n            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, TimeZone.getTimeZone(\"UTC\"), _locale, _lenient);\n        }\n        // Check if milliseconds are missing, and add them if necessary\n        if (len >= 5 && dateStr.charAt(len - 5) == '.') {\n            StringBuilder sb = new StringBuilder(dateStr);\n            sb.insert(len - 1, \"000\");\n            dateStr = sb.toString();\n        }\n    } else {\n        // Let's see if we have timezone indicator or not...\n        if (hasTimeZone(dateStr)) {\n            // Check if colon is missing from timezone offset, and add it if necessary\n            if (len >= 6 && dateStr.charAt(len - 3) == '+' || dateStr.charAt(len - 3) == '-') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 2, ':');\n                dateStr = sb.toString();\n            }\n            // Check if minutes are missing from timezone offset, and add them if necessary\n            if (len >= 3 && dateStr.charAt(len - 3) == '+') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 1, \"00\");\n                dateStr = sb.toString();\n            } else if (len >= 4 && (dateStr.charAt(len - 4) == '+' || dateStr.charAt(len - 4) == '-')) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                sb.insert(len - 2, \"00\");\n                dateStr = sb.toString();\n            }\n            // Check if milliseconds are missing, and add them if necessary\n            if (len >= 5 && dateStr.charAt(len - 5) == '.') {\n                StringBuilder sb = new StringBuilder(dateStr);\n                int offset = dateStr.lastIndexOf('T') + 9;\n                int timeLen = len - offset;\n                switch(timeLen) {\n                    case 1:\n                        sb.insert(len - 1, \"00\");\n                        break;\n                    case 2:\n                        sb.insert(len - 1, \"0\");\n                        break;\n                    case 3:\n                        break;\n                    default:\n                        sb.insert(len - 1, \".000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601;\n            formatStr = DATE_FORMAT_STR_ISO8601;\n            if (_formatISO8601 == null) {\n                df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, formatStr, _timezone, _locale, _lenient);\n            }\n        } else {\n            // If not, plain date, no timezone\n            int timeLen = len - dateStr.lastIndexOf('T') - 1;\n            // Check if milliseconds are missing, and add them if necessary\n            if (timeLen < 3) {\n                StringBuilder sb = new StringBuilder(dateStr);\n                switch(timeLen) {\n                    case 2:\n                        sb.append('0');\n                    case 1:\n                        sb.append(\"00\");\n                    default:\n                        sb.append(\".000\");\n                }\n                dateStr = sb.toString();\n            }\n            df = _formatISO8601_z;\n            formatStr = DATE_FORMAT_STR_ISO8601_Z;\n            // If the format for 'Z' has not been initialized yet\n            if (df == null) {\n                // Use the UTC timezone, not the configured default timezone\n                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, TimeZone.getTimeZone(\"UTC\"), _locale, _lenient);\n            }\n        }\n    }\n    \n    // Use the initialized format to parse the string\n    Date dt = df.parse(dateStr, pos);\n    // 22-Dec-2015, tatu: With non-lenient, may get null\n    if (dt == null && throwErrors) {\n        throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n    }\n    return dt;\n}", "diff": "--- com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n+++ com/fasterxml/jackson/databind/util/StdDateFormat.java@parseAsISO8601\n@@ -1,77 +1,69 @@\n protected Date parseAsISO8601(String dateStr, ParsePosition pos, boolean throwErrors) throws ParseException {\n-            int len = dateStr.length();\n+    int len = dateStr.length();\n     char c = dateStr.charAt(len - 1);\n     DateFormat df;\n     String formatStr;\n-    // Need to support \"plain\" date...\n+    \n+    // If the length of the string is less than or equal to 10, and the last character is a digit\n     if (len <= 10 && Character.isDigit(c)) {\n         df = _formatPlain;\n         formatStr = DATE_FORMAT_STR_PLAIN;\n+        \n+        // If the plain format has not been initialized yet\n         if (df == null) {\n             df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN, formatStr, _timezone, _locale, _lenient);\n         }\n-    } else if (c == 'Z') {\n+    } \n+    // If the last character is a 'Z'\n+    else if (c == 'Z') {\n         df = _formatISO8601_z;\n         formatStr = DATE_FORMAT_STR_ISO8601_Z;\n+        // If the format for 'Z' has not been initialized yet\n         if (df == null) {\n-            // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n-            //    must use UTC, not whatever is configured as default timezone\n-            //    (because we know `Z` identifier is used)\n-            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+            // Use the UTC timezone, not the configured default timezone\n+            df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, TimeZone.getTimeZone(\"UTC\"), _locale, _lenient);\n         }\n-        // may be missing milliseconds... if so, add\n-        if (dateStr.charAt(len - 4) == ':') {\n+        // Check if milliseconds are missing, and add them if necessary\n+        if (len >= 5 && dateStr.charAt(len - 5) == '.') {\n             StringBuilder sb = new StringBuilder(dateStr);\n-            sb.insert(len - 1, \".000\");\n+            sb.insert(len - 1, \"000\");\n             dateStr = sb.toString();\n         }\n     } else {\n         // Let's see if we have timezone indicator or not...\n         if (hasTimeZone(dateStr)) {\n-            c = dateStr.charAt(len - 3);\n-            if (c == ':') {\n-                // remove optional colon\n-                // remove colon\n+            // Check if colon is missing from timezone offset, and add it if necessary\n+            if (len >= 6 && dateStr.charAt(len - 3) == '+' || dateStr.charAt(len - 3) == '-') {\n                 StringBuilder sb = new StringBuilder(dateStr);\n-                sb.delete(len - 3, len - 2);\n+                sb.insert(len - 2, ':');\n                 dateStr = sb.toString();\n-            } else if (c == '+' || c == '-') {\n-                // missing minutes\n-                // let's just append '00'\n-                dateStr += \"00\";\n             }\n-            // Milliseconds partial or missing; and even seconds are optional\n-            len = dateStr.length();\n-            // remove 'T', '+'/'-' and 4-digit timezone-offset\n-            int timeLen = len - dateStr.lastIndexOf('T') - 6;\n-            if (timeLen < 12) {\n-                // 8 for hh:mm:ss, 4 for .sss\n-                // insertion offset, before tz-offset\n-                int offset = len - 5;\n+            // Check if minutes are missing from timezone offset, and add them if necessary\n+            if (len >= 3 && dateStr.charAt(len - 3) == '+') {\n                 StringBuilder sb = new StringBuilder(dateStr);\n+                sb.insert(len - 1, \"00\");\n+                dateStr = sb.toString();\n+            } else if (len >= 4 && (dateStr.charAt(len - 4) == '+' || dateStr.charAt(len - 4) == '-')) {\n+                StringBuilder sb = new StringBuilder(dateStr);\n+                sb.insert(len - 2, \"00\");\n+                dateStr = sb.toString();\n+            }\n+            // Check if milliseconds are missing, and add them if necessary\n+            if (len >= 5 && dateStr.charAt(len - 5) == '.') {\n+                StringBuilder sb = new StringBuilder(dateStr);\n+                int offset = dateStr.lastIndexOf('T') + 9;\n+                int timeLen = len - offset;\n                 switch(timeLen) {\n-                    case 11:\n-                        sb.insert(offset, '0');\n+                    case 1:\n+                        sb.insert(len - 1, \"00\");\n                         break;\n-                    case 10:\n-                        sb.insert(offset, \"00\");\n+                    case 2:\n+                        sb.insert(len - 1, \"0\");\n                         break;\n-                    case // is this legal? (just second fraction marker)\n-                    9:\n-                        sb.insert(offset, \"000\");\n+                    case 3:\n                         break;\n-                    case 8:\n-                        sb.insert(offset, \".000\");\n-                        break;\n-                    case // not legal to have single-digit second\n-                    7:\n-                        break;\n-                    case // probably not legal, but let's allow\n-                    6:\n-                        sb.insert(offset, \"00.000\");\n-                    case // is legal to omit seconds\n-                    5:\n-                        sb.insert(offset, \":00.000\");\n+                    default:\n+                        sb.insert(len - 1, \".000\");\n                 }\n                 dateStr = sb.toString();\n             }\n@@ -82,38 +74,34 @@\n             }\n         } else {\n             // If not, plain date, no timezone\n-            StringBuilder sb = new StringBuilder(dateStr);\n             int timeLen = len - dateStr.lastIndexOf('T') - 1;\n-            // And possible also millisecond part if missing\n-            if (timeLen < 12) {\n-                // missing, or partial\n+            // Check if milliseconds are missing, and add them if necessary\n+            if (timeLen < 3) {\n+                StringBuilder sb = new StringBuilder(dateStr);\n                 switch(timeLen) {\n-                    case 11:\n+                    case 2:\n                         sb.append('0');\n-                    case 10:\n-                        sb.append('0');\n-                    case 9:\n-                        sb.append('0');\n-                        break;\n+                    case 1:\n+                        sb.append(\"00\");\n                     default:\n                         sb.append(\".000\");\n                 }\n+                dateStr = sb.toString();\n             }\n-            sb.append('Z');\n-            dateStr = sb.toString();\n             df = _formatISO8601_z;\n             formatStr = DATE_FORMAT_STR_ISO8601_Z;\n+            // If the format for 'Z' has not been initialized yet\n             if (df == null) {\n-                // 10-Jun-2017, tatu: As per [databind#1651], when using this format,\n-                //    must use UTC, not whatever is configured as default timezone\n-                //    (because we know `Z` identifier is used)\n-                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, DEFAULT_TIMEZONE, _locale, _lenient);\n+                // Use the UTC timezone, not the configured default timezone\n+                df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z, formatStr, TimeZone.getTimeZone(\"UTC\"), _locale, _lenient);\n             }\n         }\n     }\n+    \n+    // Use the initialized format to parse the string\n     Date dt = df.parse(dateStr, pos);\n     // 22-Dec-2015, tatu: With non-lenient, may get null\n-    if (dt == null) {\n+    if (dt == null && throwErrors) {\n         throw new ParseException(String.format(\"Can not parse date \\\"%s\\\": while it seems to fit format '%s', parsing fails (leniency? %s)\", dateStr, formatStr, _lenient), pos.getErrorIndex());\n     }\n     return dt;\n", "finish_reason": "stop", "valid": false, "num": 1}]