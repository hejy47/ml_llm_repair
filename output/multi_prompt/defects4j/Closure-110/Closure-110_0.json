[{"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? n.removeFirstChild() : null;\n            Node varNode = parent;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            // If this is a VAR, we can just detach the expression and\n            // the tree will still be valid.\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -14,7 +14,7 @@\n             // error.\n         } else if (isVar) {\n             Node grandparent = parent.getParent();\n-            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n+            Node value = n.hasChildren() ? n.removeFirstChild() : null;\n             Node varNode = parent;\n             String name = n.getString();\n             int nameCount = scopedAliasNames.count(name);\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.PARAM_LIST) { // fix: changed Token.LP to Token.PARAM_LIST\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n            Node varNode = parent;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            // If this is a VAR, we can just detach the expression and\n            // the tree will still be valid.\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -9,7 +9,7 @@\n         } else if (v.isBleedingFunction()) {\n             // Bleeding functions already get a BAD_PARAMETERS error, so just\n             // do nothing.\n-        } else if (parent.getType() == Token.LP) {\n+        } else if (parent.getType() == Token.PARAM_LIST) { // fix: changed Token.LP to Token.PARAM_LIST\n             // Parameters of the scope function also get a BAD_PARAMETERS\n             // error.\n         } else if (isVar) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (v.isLocal()) { // fix\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n            Node varNode = parent;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            // If this is a VAR, we can just detach the expression and\n            // the tree will still be valid.\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -12,7 +12,7 @@\n         } else if (parent.getType() == Token.LP) {\n             // Parameters of the scope function also get a BAD_PARAMETERS\n             // error.\n-        } else if (isVar) {\n+        } else if (v.isLocal()) { // fix\n             Node grandparent = parent.getParent();\n             Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n             Node varNode = parent;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n            Node varNode = parent;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            // If this is a VAR, we can just detach the expression and\n            // the tree will still be valid.\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                grandparent.addChildBefore(newDecl, varNode);\n            } else {\n                // If there is no initial value or JSDoc, just create a variable declaration for the aliased name.\n                Node newDecl = NodeUtil.newNameDeclaration(name, NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, compiler.getCurrInpFileNameTree()), NodeUtil.emptyBlock()).useSourceInfoIfMissingFromForTree(n);\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -39,6 +39,10 @@\n                 Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                 NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                 grandparent.addChildBefore(newDecl, varNode);\n+            } else {\n+                // If there is no initial value or JSDoc, just create a variable declaration for the aliased name.\n+                Node newDecl = NodeUtil.newNameDeclaration(name, NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, compiler.getCurrInpFileNameTree()), NodeUtil.emptyBlock()).useSourceInfoIfMissingFromForTree(n);\n+                grandparent.addChildBefore(newDecl, varNode);\n             }\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n             v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar() || parent.isCatch();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n            Node varNode = parent;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            // If this is a VAR, we can just detach the expression and\n            // the tree will still be valid.\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -3,7 +3,7 @@\n     for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         Node parent = n.getParent();\n-        boolean isVar = parent.isVar();\n+        boolean isVar = parent.isVar() || parent.isCatch();\n         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n             recordAlias(v);\n         } else if (v.isBleedingFunction()) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n            Node varNode = parent;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME = NAME || function() {};\",\n            // to avoid hoisting related bugs in old versions of IE.\n            // http://wiki.ecmascript.org/doku.php?id=resources:jscriptdeviationsfromes3\n            // http://code.google.com/p/closure-compiler/issues/detail?id=208\n            //\n            // var // the variable holding the function expression\n            //     NAME = NAME || function() {...};\n            // Add $jscomp.scope.name = NAME;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node fnNameNode = Node.newString(Token.NAME, name).useSourceInfoFrom(n);\n                Node fnDecl = Node.newFunction(fnNameNode, Node.newParamList(null), Node.newBlock(null)).useSourceInfoIfMissingFromForTree(n);\n                Node exprNode = Node.newVar(fnNameNode, NodeUtil.newQName(compiler, globalName).useSourceInfoFrom(n), fnDecl).useSourceInfoFrom(n);\n                Node assignNode = NodeUtil.newQName(compiler, globalName);\n                assignNode.addChildToBack(exprNode);\n                Node newDecl = NodeUtil.newExpr(assignNode).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild(), n, name);\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -23,21 +23,23 @@\n             compiler.ensureLibraryInjected(\"base\");\n             // First, we need to free up the function expression (EXPR)\n             // to be used in another expression.\n-            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n-            // We can't keep the local name on the function expression,\n-            // because IE is buggy and will leak the name into the global\n-            // scope. This is covered in more detail here:\n-            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n+            // Replace \"function NAME() { ... }\" with \"var NAME = NAME || function() {};\",\n+            // to avoid hoisting related bugs in old versions of IE.\n+            // http://wiki.ecmascript.org/doku.php?id=resources:jscriptdeviationsfromes3\n+            // http://code.google.com/p/closure-compiler/issues/detail?id=208\n             //\n-            // This will only cause problems if this is a hoisted, recursive\n-            // function, and the programmer is using the hoisting.\n-            // If this is a VAR, we can just detach the expression and\n-            // the tree will still be valid.\n-            // Add $jscomp.scope.name = EXPR;\n+            // var // the variable holding the function expression\n+            //     NAME = NAME || function() {...};\n+            // Add $jscomp.scope.name = NAME;\n             // Make sure we copy over all the jsdoc and debug info.\n             if (value != null || v.getJSDocInfo() != null) {\n-                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+                Node fnNameNode = Node.newString(Token.NAME, name).useSourceInfoFrom(n);\n+                Node fnDecl = Node.newFunction(fnNameNode, Node.newParamList(null), Node.newBlock(null)).useSourceInfoIfMissingFromForTree(n);\n+                Node exprNode = Node.newVar(fnNameNode, NodeUtil.newQName(compiler, globalName).useSourceInfoFrom(n), fnDecl).useSourceInfoFrom(n);\n+                Node assignNode = NodeUtil.newQName(compiler, globalName);\n+                assignNode.addChildToBack(exprNode);\n+                Node newDecl = NodeUtil.newExpr(assignNode).useSourceInfoIfMissingFromForTree(n);\n+                NodeUtil.setDebugInformation(newDecl.getFirstChild(), n, name);\n                 grandparent.addChildBefore(newDecl, varNode);\n             }\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n            Node varNode = parent;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            // If this is a VAR, we can just detach the expression and\n            // the tree will still be valid.\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild(), n, name);\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -37,7 +37,7 @@\n             // Make sure we copy over all the jsdoc and debug info.\n             if (value != null || v.getJSDocInfo() != null) {\n                 Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+                NodeUtil.setDebugInformation(newDecl.getFirstChild(), n, name);\n                 grandparent.addChildBefore(newDecl, varNode);\n             }\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n            Node varNode = parent;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME = function(){};\"\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            // If this is a VAR, we can just detach the expression and\n            // the tree will still be valid.\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newExpr = IR.function().useSourceInfoFrom(n).setJSDocInfo(v.getJSDocInfo()).setIsArrowFunction(false);\n                Node newDecl = IR.var(NodeUtil.newQName(compiler, globalName)).useSourceInfoIfMissingFromForTree(n);\n                newDecl.getFirstChild().addChildToBack(newExpr);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                grandparent.addChildBefore(newDecl, varNode);\n                newExpr.getLastChild().addChildToFront(value);\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -23,7 +23,7 @@\n             compiler.ensureLibraryInjected(\"base\");\n             // First, we need to free up the function expression (EXPR)\n             // to be used in another expression.\n-            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n+            // Replace \"function NAME() { ... }\" with \"var NAME = function(){};\"\n             // We can't keep the local name on the function expression,\n             // because IE is buggy and will leak the name into the global\n             // scope. This is covered in more detail here:\n@@ -36,9 +36,12 @@\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n             if (value != null || v.getJSDocInfo() != null) {\n-                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n+                Node newExpr = IR.function().useSourceInfoFrom(n).setJSDocInfo(v.getJSDocInfo()).setIsArrowFunction(false);\n+                Node newDecl = IR.var(NodeUtil.newQName(compiler, globalName)).useSourceInfoIfMissingFromForTree(n);\n+                newDecl.getFirstChild().addChildToBack(newExpr);\n                 NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                 grandparent.addChildBefore(newDecl, varNode);\n+                newExpr.getLastChild().addChildToFront(value);\n             }\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n             v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? n.getFirstFirstChild().detach() : null;\n            Node varNode = parent;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            // If this is a VAR, we can just detach the expression and\n            // the tree will still be valid.\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -14,7 +14,7 @@\n             // error.\n         } else if (isVar) {\n             Node grandparent = parent.getParent();\n-            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n+            Node value = n.hasChildren() ? n.getFirstFirstChild().detach() : null;\n             Node varNode = parent;\n             String name = n.getString();\n             int nameCount = scopedAliasNames.count(name);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? n.getFirstChild() : null; // Fixed this line to get the first child instead of v.getInitialValue().\n            Node varNode = parent;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            // If this is a VAR, we can just detach the expression and\n            // the tree will still be valid.\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -14,7 +14,7 @@\n             // error.\n         } else if (isVar) {\n             Node grandparent = parent.getParent();\n-            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n+            Node value = n.hasChildren() ? n.getFirstChild() : null; // Fixed this line to get the first child instead of v.getInitialValue().\n             Node varNode = parent;\n             String name = n.getString();\n             int nameCount = scopedAliasNames.count(name);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n            Node varNode = parent;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME = function() {};\".\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            // If this is a VAR, we can just detach the expression and\n            // the tree will still be valid.\n            Node newVarNode = new Node(Token.VAR);\n            Node newAssignNode = NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, value, name);\n            newAssignNode.putBooleanProp(Node.METHOD_REFERENCE, true);\n            newVarNode.addChildToBack(newAssignNode);\n            grandparent.addChildBefore(newVarNode, varNode);\n            compiler.reportChangeToEnclosingScope(newVarNode);\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -23,7 +23,7 @@\n             compiler.ensureLibraryInjected(\"base\");\n             // First, we need to free up the function expression (EXPR)\n             // to be used in another expression.\n-            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n+            // Replace \"function NAME() { ... }\" with \"var NAME = function() {};\".\n             // We can't keep the local name on the function expression,\n             // because IE is buggy and will leak the name into the global\n             // scope. This is covered in more detail here:\n@@ -33,15 +33,12 @@\n             // function, and the programmer is using the hoisting.\n             // If this is a VAR, we can just detach the expression and\n             // the tree will still be valid.\n-            // Add $jscomp.scope.name = EXPR;\n-            // Make sure we copy over all the jsdoc and debug info.\n-            if (value != null || v.getJSDocInfo() != null) {\n-                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n-                grandparent.addChildBefore(newDecl, varNode);\n-            }\n-            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            Node newVarNode = new Node(Token.VAR);\n+            Node newAssignNode = NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, value, name);\n+            newAssignNode.putBooleanProp(Node.METHOD_REFERENCE, true);\n+            newVarNode.addChildToBack(newAssignNode);\n+            grandparent.addChildBefore(newVarNode, varNode);\n+            compiler.reportChangeToEnclosingScope(newVarNode);\n             recordAlias(v);\n         } else {\n             // Do not other kinds of local symbols, like catch params.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? n.removeFirstChild() : null;\n            Node varNode = parent;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            // If this is a VAR, we can just detach the expression and\n            // the tree will still be valid.\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = IR.var(IR.name(globalName)).useSourceInfoIfMissingFromForTree(n);\n                newDecl.getFirstChild().addChildToFront(value);\n                newDecl.getFirstChild().setJSDocInfo(v.getJSDocInfo());\n                NodeUtil.setDebugInformation(newDecl.getFirstChild(), n, name);\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            n.addChildToFront(IR.name(globalName).useSourceInfoIfMissingFrom(n)).setJSDocInfo(v.getJSDocInfo());\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -14,7 +14,7 @@\n             // error.\n         } else if (isVar) {\n             Node grandparent = parent.getParent();\n-            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n+            Node value = n.hasChildren() ? n.removeFirstChild() : null;\n             Node varNode = parent;\n             String name = n.getString();\n             int nameCount = scopedAliasNames.count(name);\n@@ -36,12 +36,14 @@\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n             if (value != null || v.getJSDocInfo() != null) {\n-                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+                Node newDecl = IR.var(IR.name(globalName)).useSourceInfoIfMissingFromForTree(n);\n+                newDecl.getFirstChild().addChildToFront(value);\n+                newDecl.getFirstChild().setJSDocInfo(v.getJSDocInfo());\n+                NodeUtil.setDebugInformation(newDecl.getFirstChild(), n, name);\n                 grandparent.addChildBefore(newDecl, varNode);\n             }\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            n.addChildToFront(IR.name(globalName).useSourceInfoIfMissingFrom(n)).setJSDocInfo(v.getJSDocInfo());\n             recordAlias(v);\n         } else {\n             // Do not other kinds of local symbols, like catch params.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            \n            // New Code to fix bug:\n            if (grandparent == null || grandparent.isScript()) {\n                // Don't process if grandparent is null or a script node\n                continue;\n            }\n            \n            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n            Node varNode = parent;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            // If this is a VAR, we can just detach the expression and\n            // the tree will still be valid.\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -14,6 +14,13 @@\n             // error.\n         } else if (isVar) {\n             Node grandparent = parent.getParent();\n+            \n+            // New Code to fix bug:\n+            if (grandparent == null || grandparent.isScript()) {\n+                // Don't process if grandparent is null or a script node\n+                continue;\n+            }\n+            \n             Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n             Node varNode = parent;\n             String name = n.getString();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? v.getInitialValue().detach() : null;\n            Node varNode = parent;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            // If this is a VAR, we can just detach the expression and\n            // the tree will still be valid.\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -4,7 +4,7 @@\n         Node n = v.getNode();\n         Node parent = n.getParent();\n         boolean isVar = parent.isVar();\n-        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n+        if (isVar && n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n             recordAlias(v);\n         } else if (v.isBleedingFunction()) {\n             // Bleeding functions already get a BAD_PARAMETERS error, so just\n@@ -14,7 +14,7 @@\n             // error.\n         } else if (isVar) {\n             Node grandparent = parent.getParent();\n-            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n+            Node value = n.hasChildren() ? v.getInitialValue().detach() : null;\n             Node varNode = parent;\n             String name = n.getString();\n             int nameCount = scopedAliasNames.count(name);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n            Node varNode = parent;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            // If this is a VAR, we can just detach the expression and\n            // the tree will still be valid.\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstFirstChild(), n, name);\n                grandparent.addChildBefore(newDecl, varNode);\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -37,7 +37,7 @@\n             // Make sure we copy over all the jsdoc and debug info.\n             if (value != null || v.getJSDocInfo() != null) {\n                 Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+                NodeUtil.setDebugInformation(newDecl.getFirstFirstChild(), n, name);\n                 grandparent.addChildBefore(newDecl, varNode);\n             }\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n            Node varNode = parent;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME = function() {};\"\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            // If this is a VAR, we can just detach the expression and\n            // the tree will still be valid.\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                    compiler.getCodingConvention(), globalName, null, v.getJSDocInfo())\n                    .useSourceInfoIfMissingFromForTree(n);\n                Node assign = new Node(Token.ASSIGN, newDecl,\n                    NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, null, name));\n                if (value != null) {\n                    assign.getLastChild().addChildToFront(value);\n                }\n                NodeUtil.setDebugInformation(assign.getFirstFirstChild(), n, name);\n                grandparent.addChildBefore(assign, varNode);\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(\n                NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, null, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -23,7 +23,7 @@\n             compiler.ensureLibraryInjected(\"base\");\n             // First, we need to free up the function expression (EXPR)\n             // to be used in another expression.\n-            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n+            // Replace \"function NAME() { ... }\" with \"var NAME = function() {};\"\n             // We can't keep the local name on the function expression,\n             // because IE is buggy and will leak the name into the global\n             // scope. This is covered in more detail here:\n@@ -36,12 +36,20 @@\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n             if (value != null || v.getJSDocInfo() != null) {\n-                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n-                grandparent.addChildBefore(newDecl, varNode);\n+                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n+                    compiler.getCodingConvention(), globalName, null, v.getJSDocInfo())\n+                    .useSourceInfoIfMissingFromForTree(n);\n+                Node assign = new Node(Token.ASSIGN, newDecl,\n+                    NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, null, name));\n+                if (value != null) {\n+                    assign.getLastChild().addChildToFront(value);\n+                }\n+                NodeUtil.setDebugInformation(assign.getFirstFirstChild(), n, name);\n+                grandparent.addChildBefore(assign, varNode);\n             }\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            v.getNameNode().addChildToFront(\n+                NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, null, name));\n             recordAlias(v);\n         } else {\n             // Do not other kinds of local symbols, like catch params.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar) {\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? v.getInitialValue().detachFromParent() : null;\n            Node varNode = parent;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            // Replace \"function NAME() { ... }\" with \"var NAME = function NAME() {};\".\n            // We can't keep the local name on the function expression,\n            // because IE is buggy and will leak the name into the global\n            // scope. This is covered in more detail here:\n            // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n            //\n            // This will only cause problems if this is a hoisted, recursive\n            // function, and the programmer is using the hoisting.\n            // If this is a VAR, we can just detach the expression and\n            // the tree will still be valid.\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (parent == grandparent.getFirstChild() && grandparent.isBlock() && grandparent.getParent().isFunction()) {\n                // We are rewriting the function declaration.\n                Node newBlock = new Node(Token.BLOCK);\n                Node newFunction = NodeUtil.newQNameDeclaration(compiler.getCodingConvention(), globalName, newBlock, v.getJSDocInfo()).useSourceInfoFromForTree(n);\n                NodeUtil.setDebugInformation(newFunction.getFirstChild(), n, name);\n                grandparent.getParent().addChildBefore(newFunction, grandparent);\n                Node fnNameNode = NodeUtil.newName(globalName);\n                Scope hoistedScope = SyntacticScopeCreator.makeTyped(compiler).createScope(newFunction, scope);\n                hoistedScope.declare(fnNameNode.getString(), fnNameNode, null, null);\n                newBlock.addChildToFront(NodeUtil.newFunctionDeclaration(fnNameNode, parent.getSecondChild().detachFromParent(), v.getJSDocInfo(), hoistedScope).useSourceInfoIfMissingFromForTree(n));\n                varNode.removeChild(n);\n            } else {\n                // We are rewriting a variable declaration.\n                Node newDecl = NodeUtil.newQNameDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild(), n, name);\n                grandparent.addChildBefore(newDecl, varNode);\n                n.setString(globalName);\n            }\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -23,7 +23,7 @@\n             compiler.ensureLibraryInjected(\"base\");\n             // First, we need to free up the function expression (EXPR)\n             // to be used in another expression.\n-            // Replace \"function NAME() { ... }\" with \"var NAME;\".\n+            // Replace \"function NAME() { ... }\" with \"var NAME = function NAME() {};\".\n             // We can't keep the local name on the function expression,\n             // because IE is buggy and will leak the name into the global\n             // scope. This is covered in more detail here:\n@@ -35,13 +35,24 @@\n             // the tree will still be valid.\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n-            if (value != null || v.getJSDocInfo() != null) {\n-                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+            if (parent == grandparent.getFirstChild() && grandparent.isBlock() && grandparent.getParent().isFunction()) {\n+                // We are rewriting the function declaration.\n+                Node newBlock = new Node(Token.BLOCK);\n+                Node newFunction = NodeUtil.newQNameDeclaration(compiler.getCodingConvention(), globalName, newBlock, v.getJSDocInfo()).useSourceInfoFromForTree(n);\n+                NodeUtil.setDebugInformation(newFunction.getFirstChild(), n, name);\n+                grandparent.getParent().addChildBefore(newFunction, grandparent);\n+                Node fnNameNode = NodeUtil.newName(globalName);\n+                Scope hoistedScope = SyntacticScopeCreator.makeTyped(compiler).createScope(newFunction, scope);\n+                hoistedScope.declare(fnNameNode.getString(), fnNameNode, null, null);\n+                newBlock.addChildToFront(NodeUtil.newFunctionDeclaration(fnNameNode, parent.getSecondChild().detachFromParent(), v.getJSDocInfo(), hoistedScope).useSourceInfoIfMissingFromForTree(n));\n+                varNode.removeChild(n);\n+            } else {\n+                // We are rewriting a variable declaration.\n+                Node newDecl = NodeUtil.newQNameDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n+                NodeUtil.setDebugInformation(newDecl.getFirstChild(), n, name);\n                 grandparent.addChildBefore(newDecl, varNode);\n+                n.setString(globalName);\n             }\n-            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n             recordAlias(v);\n         } else {\n             // Do not other kinds of local symbols, like catch params.\n", "finish_reason": "stop", "valid": false, "num": 1}]