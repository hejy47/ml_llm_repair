[{"output": "public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n    // simple optimization to avoid costly introspection if type-erased type does NOT differ\n    final Class<?> rawBase = baseType.getRawClass();\n    if (rawBase == subclass) {\n        return baseType;\n    }\n    JavaType newType;\n    // also: if we start from untyped, not much to save\n    do {\n        // bogus loop to be able to break\n        if (rawBase == Object.class) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        if (!baseType.isTypeOrSubTypeOf(subclass)) { // FIX: Check if baseType is subtype of subclass\n            throw new IllegalArgumentException(String.format(\"Class %s not subtype of %s\", subclass.getName(), baseType));\n        }\n        // A few special cases where we can simplify handling:\n        // (1) Original target type has no generics -- just resolve subtype\n        if (baseType.getBindings().isEmpty()) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (2) A small set of \"well-known\" List/Map subtypes where can take a short-cut\n        if (baseType.isContainerType()) {\n            if (baseType.isMapLikeType()) {\n                if ((subclass == HashMap.class) || (subclass == LinkedHashMap.class) || (subclass == EnumMap.class) || (subclass == TreeMap.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getKeyType(), baseType.getContentType()));\n                    break;\n                }\n            } else if (baseType.isCollectionLikeType()) {\n                if ((subclass == ArrayList.class) || (subclass == LinkedList.class) || (subclass == HashSet.class) || (subclass == TreeSet.class)) {\n                    newType = _fromClass(null, subclass, TypeBindings.create(subclass, baseType.getContentType()));\n                    break;\n                }\n                // 29-Oct-2015, tatu: One further shortcut: there are variants of `EnumSet`,\n                //    but they are impl details and we basically do not care...\n                if (rawBase == EnumSet.class) {\n                    return baseType;\n                }\n            }\n        }\n        // (3) Sub-class does not take type parameters -- just resolve subtype\n        int typeParamCount = subclass.getTypeParameters().length;\n        if (typeParamCount == 0) {\n            newType = _fromClass(null, subclass, TypeBindings.emptyBindings());\n            break;\n        }\n        // (4) If all else fails, do the full traversal using placeholders\n        TypeBindings tb = _bindingsForSubtype(baseType, typeParamCount, subclass);\n        newType = _fromClass(null, subclass, tb);\n    } while (false);\n    // 25-Sep-2016, tatu: As per [databind#1384] also need to ensure handlers get\n    //   copied as well\n    newType = newType.withHandlersFrom(baseType);\n    return newType;\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 20}]