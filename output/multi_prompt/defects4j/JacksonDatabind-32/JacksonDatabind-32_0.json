[{"output": "There are no apparent bugs in the provided code snippet.", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.hasSomeOfFeatures(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS.getMask())) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                JsonToken t = p.getCurrentToken();\n                if (t == JsonToken.VALUE_STRING && p.getText().trim().length() == 0) {\n                    return null;\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            break;\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case JsonTokenId.ID_NULL:\n            return null;\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -28,16 +28,24 @@\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n-                return _coerceIntegral(p, ctxt);\n+            if (ctxt.hasSomeOfFeatures(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS.getMask())) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n             }\n-            // should be optimal, whatever it is\n-            return p.getNumberValue();\n+            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                JsonToken t = p.getCurrentToken();\n+                if (t == JsonToken.VALUE_STRING && p.getText().trim().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+            break;\n         case JsonTokenId.ID_NUMBER_FLOAT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n@@ -45,10 +53,8 @@\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case JsonTokenId.ID_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n     }\n     throw ctxt.mappingException(Object.class);\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -2,55 +2,60 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+        case JsonTokenId.ID_FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n+            }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n-                return _coerceIntegral(p, ctxt);\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n             }\n-            // should be optimal, whatever it is\n-            return p.getNumberValue();\n+            if (ctxt.hasSomeOfFeatures(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS.getMask())) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                JsonToken t = p.getCurrentToken();\n+                if (t == JsonToken.VALUE_STRING && p.getText().trim().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+            break;\n         case JsonTokenId.ID_NUMBER_FLOAT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n+            return p.getDoubleValue();\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case JsonTokenId.ID_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentTokenId()) { // changed getCurrentTokenId to currentTokenId\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case JsonTokenId.ID_NULL: // removed commented out line\n            return null;\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,6 +1,6 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n+    switch(p.currentTokenId()) { // changed getCurrentTokenId to currentTokenId\n         case JsonTokenId.ID_START_OBJECT:\n         case JsonTokenId.ID_FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n@@ -45,10 +45,8 @@\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case JsonTokenId.ID_NULL: // removed commented out line\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n     }\n     throw ctxt.mappingException(Object.class);\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,53 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n+    switch(p.currentTokenId()) { // changed getCurrentTokenId to currentTokenId\n         case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+        case JsonTokenId.ID_FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n+            }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n+            return p.getDoubleValue();\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case JsonTokenId.ID_NULL: // removed commented out line\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) {\n        case START_OBJECT:\n        case FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case VALUE_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_NULL:\n            return null;\n        //        case ID_END_ARRAY: // invalid\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,15 +1,15 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n+    switch(p.currentToken()) {\n+        case START_OBJECT:\n+        case FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n             //    if caller has advanced to the first token of Object, but for empty Object\n             if (_mapDeserializer != null) {\n                 return _mapDeserializer.deserialize(p, ctxt);\n             }\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n@@ -17,38 +17,37 @@\n                 return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n             if (_stringDeserializer != null) {\n                 return _stringDeserializer.deserialize(p, ctxt);\n             }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n+        case VALUE_TRUE:\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case ID_END_ARRAY: // invalid\n         default:\n     }\n     throw ctxt.mappingException(Object.class);\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,54 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+    switch(p.currentToken()) {\n+        case START_OBJECT:\n+        case FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n+            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n+            return p.getDoubleValue();\n+        case VALUE_TRUE:\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) {\n        case START_OBJECT:\n        case FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case VALUE_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_NULL:\n            return null;\n        //        case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,15 +1,15 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n+    switch(p.currentToken()) {\n+        case START_OBJECT:\n+        case FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n             //    if caller has advanced to the first token of Object, but for empty Object\n             if (_mapDeserializer != null) {\n                 return _mapDeserializer.deserialize(p, ctxt);\n             }\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n@@ -17,14 +17,14 @@\n                 return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n             if (_stringDeserializer != null) {\n                 return _stringDeserializer.deserialize(p, ctxt);\n             }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n@@ -33,7 +33,7 @@\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n@@ -41,12 +41,11 @@\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n+        case VALUE_TRUE:\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL:\n             return null;\n         //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,54 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+    switch(p.currentToken()) {\n+        case START_OBJECT:\n+        case FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n+            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n-            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+        case VALUE_NUMBER_INT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+        case VALUE_NUMBER_FLOAT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n+            return p.getDoubleValue();\n+        case VALUE_TRUE:\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) {\n        case START_OBJECT:\n        case FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case VALUE_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_NULL:\n            return null;\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,15 +1,15 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n+    switch(p.currentToken()) {\n+        case START_OBJECT:\n+        case FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n             //    if caller has advanced to the first token of Object, but for empty Object\n             if (_mapDeserializer != null) {\n                 return _mapDeserializer.deserialize(p, ctxt);\n             }\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n@@ -17,38 +17,36 @@\n                 return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n             if (_stringDeserializer != null) {\n                 return _stringDeserializer.deserialize(p, ctxt);\n             }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n+        case VALUE_TRUE:\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n     }\n     throw ctxt.mappingException(Object.class);\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,53 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+    switch(p.currentToken()) {\n+        case START_OBJECT:\n+        case FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n+            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n+            return p.getDoubleValue();\n+        case VALUE_TRUE:\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) {\n        case START_OBJECT:\n        case FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case VALUE_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_NULL:\n            return null;\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,15 +1,15 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n+    switch(p.currentToken()) {\n+        case START_OBJECT:\n+        case FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n             //    if caller has advanced to the first token of Object, but for empty Object\n             if (_mapDeserializer != null) {\n                 return _mapDeserializer.deserialize(p, ctxt);\n             }\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n@@ -17,14 +17,14 @@\n                 return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n             if (_stringDeserializer != null) {\n                 return _stringDeserializer.deserialize(p, ctxt);\n             }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n@@ -33,7 +33,7 @@\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n@@ -41,14 +41,12 @@\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n+        case VALUE_TRUE:\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n     }\n     throw ctxt.mappingException(Object.class);\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,53 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+    switch(p.currentToken()) {\n+        case START_OBJECT:\n+        case FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n+            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n-            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+        case VALUE_NUMBER_INT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+        case VALUE_NUMBER_FLOAT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n+            return p.getDoubleValue();\n+        case VALUE_TRUE:\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) { //correction is made here, instead of p.getCurrentTokenId() we have p.currentToken()\n        case START_OBJECT:\n        case FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case VALUE_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_NULL:\n            return null;\n        //        case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,15 +1,15 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n+    switch(p.currentToken()) { //correction is made here, instead of p.getCurrentTokenId() we have p.currentToken()\n+        case START_OBJECT:\n+        case FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n             //    if caller has advanced to the first token of Object, but for empty Object\n             if (_mapDeserializer != null) {\n                 return _mapDeserializer.deserialize(p, ctxt);\n             }\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n@@ -17,36 +17,35 @@\n                 return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n             if (_stringDeserializer != null) {\n                 return _stringDeserializer.deserialize(p, ctxt);\n             }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n+        case VALUE_TRUE:\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL:\n             return null;\n         //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,54 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+    switch(p.currentToken()) { //correction is made here, instead of p.getCurrentTokenId() we have p.currentToken()\n+        case START_OBJECT:\n+        case FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n+            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n+            return p.getDoubleValue();\n+        case VALUE_TRUE:\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            } else {\n                return p.getNumberValue();  // Fix added to return NumberValue if null\n            }\n            // removed coercion check\n            // return _coerceIntegral(p, ctxt); \n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        //        case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -27,17 +27,16 @@\n         case JsonTokenId.ID_NUMBER_INT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n+            } else {\n+                return p.getNumberValue();  // Fix added to return NumberValue if null\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n-                return _coerceIntegral(p, ctxt);\n-            }\n-            // should be optimal, whatever it is\n-            return p.getNumberValue();\n+            // removed coercion check\n+            // return _coerceIntegral(p, ctxt); \n         case JsonTokenId.ID_NUMBER_FLOAT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -2,44 +2,44 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+        case JsonTokenId.ID_FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n+            }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n-                return _coerceIntegral(p, ctxt);\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            } else {\n+                return p.getNumberValue();  // Fix added to return NumberValue if null\n             }\n-            // should be optimal, whatever it is\n-            return p.getNumberValue();\n+            // removed coercion check\n+            // return _coerceIntegral(p, ctxt); \n         case JsonTokenId.ID_NUMBER_FLOAT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n+            return p.getDoubleValue();\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n@@ -47,10 +47,8 @@\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) { // use currentToken instead of getCurrentTokenId\n        case START_OBJECT:\n        case FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT: // use VALUE_EMBEDDED_OBJECT instead of ID_EMBEDDED_OBJECT\n            return p.getEmbeddedObject();\n        case VALUE_STRING: // use VALUE_STRING instead of ID_STRING\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case VALUE_NUMBER_INT: // use VALUE_NUMBER_INT instead of ID_NUMBER_INT\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT: // use VALUE_NUMBER_FLOAT instead of ID_NUMBER_FLOAT\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case VALUE_TRUE: // use VALUE_TRUE instead of ID_TRUE\n            return Boolean.TRUE;\n        case VALUE_FALSE: // use VALUE_FALSE instead of ID_FALSE\n            return Boolean.FALSE;\n        case VALUE_NULL: // use VALUE_NULL instead of ID_NULL\n            return null;\n        //        case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,15 +1,15 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n+    switch(p.currentToken()) { // use currentToken instead of getCurrentTokenId\n+        case START_OBJECT:\n+        case FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n             //    if caller has advanced to the first token of Object, but for empty Object\n             if (_mapDeserializer != null) {\n                 return _mapDeserializer.deserialize(p, ctxt);\n             }\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n@@ -17,36 +17,35 @@\n                 return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT: // use VALUE_EMBEDDED_OBJECT instead of ID_EMBEDDED_OBJECT\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING: // use VALUE_STRING instead of ID_STRING\n             if (_stringDeserializer != null) {\n                 return _stringDeserializer.deserialize(p, ctxt);\n             }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT: // use VALUE_NUMBER_INT instead of ID_NUMBER_INT\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT: // use VALUE_NUMBER_FLOAT instead of ID_NUMBER_FLOAT\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n+        case VALUE_TRUE: // use VALUE_TRUE instead of ID_TRUE\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE: // use VALUE_FALSE instead of ID_FALSE\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL: // use VALUE_NULL instead of ID_NULL\n             return null;\n         //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,54 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+    switch(p.currentToken()) { // use currentToken instead of getCurrentTokenId\n+        case START_OBJECT:\n+        case FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n+            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT: // use VALUE_EMBEDDED_OBJECT instead of ID_EMBEDDED_OBJECT\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING: // use VALUE_STRING instead of ID_STRING\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT: // use VALUE_NUMBER_INT instead of ID_NUMBER_INT\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT: // use VALUE_NUMBER_FLOAT instead of ID_NUMBER_FLOAT\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n+            return p.getDoubleValue();\n+        case VALUE_TRUE: // use VALUE_TRUE instead of ID_TRUE\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE: // use VALUE_FALSE instead of ID_FALSE\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL: // use VALUE_NULL instead of ID_NULL\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) {\n        case START_OBJECT:\n        case FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case VALUE_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_NULL:\n            return null;\n        // case END_ARRAY: // not reached but added to eliminate warning\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,15 +1,15 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n+    switch(p.currentToken()) {\n+        case START_OBJECT:\n+        case FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n             //    if caller has advanced to the first token of Object, but for empty Object\n             if (_mapDeserializer != null) {\n                 return _mapDeserializer.deserialize(p, ctxt);\n             }\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n@@ -17,14 +17,14 @@\n                 return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n             if (_stringDeserializer != null) {\n                 return _stringDeserializer.deserialize(p, ctxt);\n             }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n@@ -33,7 +33,7 @@\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT:\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n@@ -41,14 +41,13 @@\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n+        case VALUE_TRUE:\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        // case END_ARRAY: // not reached but added to eliminate warning\n         default:\n     }\n     throw ctxt.mappingException(Object.class);\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,54 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+    switch(p.currentToken()) {\n+        case START_OBJECT:\n+        case FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n+            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n-            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+        case VALUE_NUMBER_INT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+        case VALUE_NUMBER_FLOAT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n+            return p.getDoubleValue();\n+        case VALUE_TRUE:\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        // case END_ARRAY: // not reached but added to eliminate warning\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentTokenId()) { // changed getCurrentTokenId() to currentTokenId()\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case JsonTokenId.ID_NULL: // added missing case for ID_NULL\n            return null;\n        //        case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,6 +1,6 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n+    switch(p.currentTokenId()) { // changed getCurrentTokenId() to currentTokenId()\n         case JsonTokenId.ID_START_OBJECT:\n         case JsonTokenId.ID_FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n@@ -45,8 +45,7 @@\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case JsonTokenId.ID_NULL: // added missing case for ID_NULL\n             return null;\n         //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,54 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n+    switch(p.currentTokenId()) { // changed getCurrentTokenId() to currentTokenId()\n         case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+        case JsonTokenId.ID_FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n+            }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n+            return p.getDoubleValue();\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case JsonTokenId.ID_NULL: // added missing case for ID_NULL\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentTokenId()) { // changed method name from getCurrentTokenId()\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.hasSomeOfFeatures(DeserializationFeature.ACCEPT_INT_AS_FLOAT)) { // changed from F_MASK_INT_COERCIONS\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        //        case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,6 +1,6 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n+    switch(p.currentTokenId()) { // changed method name from getCurrentTokenId()\n         case JsonTokenId.ID_START_OBJECT:\n         case JsonTokenId.ID_FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n@@ -28,7 +28,7 @@\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+                        if (ctxt.hasSomeOfFeatures(DeserializationFeature.ACCEPT_INT_AS_FLOAT)) { // changed from F_MASK_INT_COERCIONS\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,45 +1,46 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n+    switch(p.currentTokenId()) { // changed method name from getCurrentTokenId()\n         case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+        case JsonTokenId.ID_FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n+            }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.hasSomeOfFeatures(DeserializationFeature.ACCEPT_INT_AS_FLOAT)) { // changed from F_MASK_INT_COERCIONS\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n+            return p.getDoubleValue();\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n@@ -47,10 +48,8 @@\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) { // Use currentToken instead of deprecated getCurrentTokenId\n        case START_OBJECT:\n        case FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT: // Use VALUE_EMBEDDED_OBJECT instead of deprecated ID_EMBEDDED_OBJECT\n            return p.getEmbeddedObject();\n        case VALUE_STRING: // Use VALUE_STRING instead of deprecated ID_STRING\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case VALUE_NUMBER_INT: // Use VALUE_NUMBER_INT instead of deprecated ID_NUMBER_INT\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT: // Use VALUE_NUMBER_FLOAT instead of deprecated ID_NUMBER_FLOAT\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case VALUE_TRUE: // Use VALUE_TRUE instead of deprecated ID_TRUE\n            return Boolean.TRUE;\n        case VALUE_FALSE: // Use VALUE_FALSE instead of deprecated ID_FALSE\n            return Boolean.FALSE;\n        case VALUE_NULL: // Use VALUE_NULL instead of deprecated ID_NULL\n            return null;\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,15 +1,15 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n+    switch(p.currentToken()) { // Use currentToken instead of deprecated getCurrentTokenId\n+        case START_OBJECT:\n+        case FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n             //    if caller has advanced to the first token of Object, but for empty Object\n             if (_mapDeserializer != null) {\n                 return _mapDeserializer.deserialize(p, ctxt);\n             }\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n@@ -17,38 +17,36 @@\n                 return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT: // Use VALUE_EMBEDDED_OBJECT instead of deprecated ID_EMBEDDED_OBJECT\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING: // Use VALUE_STRING instead of deprecated ID_STRING\n             if (_stringDeserializer != null) {\n                 return _stringDeserializer.deserialize(p, ctxt);\n             }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT: // Use VALUE_NUMBER_INT instead of deprecated ID_NUMBER_INT\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT: // Use VALUE_NUMBER_FLOAT instead of deprecated ID_NUMBER_FLOAT\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n+        case VALUE_TRUE: // Use VALUE_TRUE instead of deprecated ID_TRUE\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE: // Use VALUE_FALSE instead of deprecated ID_FALSE\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL: // Use VALUE_NULL instead of deprecated ID_NULL\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n     }\n     throw ctxt.mappingException(Object.class);\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,53 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+    switch(p.currentToken()) { // Use currentToken instead of deprecated getCurrentTokenId\n+        case START_OBJECT:\n+        case FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n+            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT: // Use VALUE_EMBEDDED_OBJECT instead of deprecated ID_EMBEDDED_OBJECT\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING: // Use VALUE_STRING instead of deprecated ID_STRING\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT: // Use VALUE_NUMBER_INT instead of deprecated ID_NUMBER_INT\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT: // Use VALUE_NUMBER_FLOAT instead of deprecated ID_NUMBER_FLOAT\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n+            return p.getDoubleValue();\n+        case VALUE_TRUE: // Use VALUE_TRUE instead of deprecated ID_TRUE\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE: // Use VALUE_FALSE instead of deprecated ID_FALSE\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL: // Use VALUE_NULL instead of deprecated ID_NULL\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n        case JsonTokenId.ID_FIELD_NAME:\n            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.hasSomeOfFeatures(DeserializationFeature.ACCEPT_INT_AS_FLOAT)) {  // Fixed feature check name\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case JsonTokenId.ID_NULL:\n            return null; // No change\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,6 +1,6 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n+    switch(p.currentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n         case JsonTokenId.ID_FIELD_NAME:\n             // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n@@ -28,7 +28,7 @@\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(DeserializationFeature.ACCEPT_INT_AS_FLOAT)) {  // Fixed feature check name\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n@@ -37,7 +37,7 @@\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n@@ -45,10 +45,8 @@\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n-            return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        case JsonTokenId.ID_NULL:\n+            return null; // No change\n         default:\n     }\n     throw ctxt.mappingException(Object.class);\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,53 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n+    switch(p.currentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+        case JsonTokenId.ID_FIELD_NAME:\n+            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+            //    if caller has advanced to the first token of Object, but for empty Object\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n+            }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n+            if (ctxt.hasSomeOfFeatures(DeserializationFeature.ACCEPT_INT_AS_FLOAT)) {  // Fixed feature check name\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n+            return p.getDoubleValue();\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n-            return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        case JsonTokenId.ID_NULL:\n+            return null; // No change\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    JsonToken currentToken = p.getCurrentToken();\n    if(currentToken == JsonToken.START_OBJECT || currentToken == JsonToken.FIELD_NAME){\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        if (_mapDeserializer != null) {\n            return _mapDeserializer.deserialize(p, ctxt);\n        }\n        return mapObject(p, ctxt);\n    } else if(currentToken == JsonToken.START_ARRAY) {\n        if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n            return mapArrayToArray(p, ctxt);\n        }\n        if (_listDeserializer != null) {\n            return _listDeserializer.deserialize(p, ctxt);\n        }\n        return mapArray(p, ctxt);\n    } else if(currentToken == JsonToken.VALUE_EMBEDDED_OBJECT){\n        return p.getEmbeddedObject();\n    } else if(currentToken == JsonToken.VALUE_STRING){\n        if (_stringDeserializer != null) {\n            return _stringDeserializer.deserialize(p, ctxt);\n        }\n        return p.getText();\n    } else if(currentToken == JsonToken.VALUE_NUMBER_INT){\n        if (_numberDeserializer != null) {\n            return _numberDeserializer.deserialize(p, ctxt);\n        }\n        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n            return _coerceIntegral(p, ctxt);\n        }\n        // should be optimal, whatever it is\n        return p.getNumberValue();\n    } else if(currentToken == JsonToken.VALUE_NUMBER_FLOAT){\n        if (_numberDeserializer != null) {\n            return _numberDeserializer.deserialize(p, ctxt);\n        }\n        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n            return p.getDecimalValue();\n        }\n        return p.getDoubleValue();\n    } else if(currentToken == JsonToken.VALUE_TRUE){\n        return Boolean.TRUE;\n    } else if(currentToken == JsonToken.VALUE_FALSE){\n        return Boolean.FALSE;\n    } else if(currentToken == JsonToken.VALUE_NULL){\n        return null;\n    }\n\n    throw ctxt.mappingException(Object.class);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,55 +1,52 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (_mapDeserializer != null) {\n-                return _mapDeserializer.deserialize(p, ctxt);\n-            }\n-            return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                return mapArrayToArray(p, ctxt);\n-            }\n-            if (_listDeserializer != null) {\n-                return _listDeserializer.deserialize(p, ctxt);\n-            }\n-            return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n-            return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n-            if (_stringDeserializer != null) {\n-                return _stringDeserializer.deserialize(p, ctxt);\n-            }\n-            return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n-                return _coerceIntegral(p, ctxt);\n-            }\n-            // should be optimal, whatever it is\n-            return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n-                return p.getDecimalValue();\n-            }\n-            return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n-            return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n-            return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n-            return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n-        default:\n+    JsonToken currentToken = p.getCurrentToken();\n+    if(currentToken == JsonToken.START_OBJECT || currentToken == JsonToken.FIELD_NAME){\n+        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+        //    if caller has advanced to the first token of Object, but for empty Object\n+        if (_mapDeserializer != null) {\n+            return _mapDeserializer.deserialize(p, ctxt);\n+        }\n+        return mapObject(p, ctxt);\n+    } else if(currentToken == JsonToken.START_ARRAY) {\n+        if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+            return mapArrayToArray(p, ctxt);\n+        }\n+        if (_listDeserializer != null) {\n+            return _listDeserializer.deserialize(p, ctxt);\n+        }\n+        return mapArray(p, ctxt);\n+    } else if(currentToken == JsonToken.VALUE_EMBEDDED_OBJECT){\n+        return p.getEmbeddedObject();\n+    } else if(currentToken == JsonToken.VALUE_STRING){\n+        if (_stringDeserializer != null) {\n+            return _stringDeserializer.deserialize(p, ctxt);\n+        }\n+        return p.getText();\n+    } else if(currentToken == JsonToken.VALUE_NUMBER_INT){\n+        if (_numberDeserializer != null) {\n+            return _numberDeserializer.deserialize(p, ctxt);\n+        }\n+        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            return _coerceIntegral(p, ctxt);\n+        }\n+        // should be optimal, whatever it is\n+        return p.getNumberValue();\n+    } else if(currentToken == JsonToken.VALUE_NUMBER_FLOAT){\n+        if (_numberDeserializer != null) {\n+            return _numberDeserializer.deserialize(p, ctxt);\n+        }\n+        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            return p.getDecimalValue();\n+        }\n+        return p.getDoubleValue();\n+    } else if(currentToken == JsonToken.VALUE_TRUE){\n+        return Boolean.TRUE;\n+    } else if(currentToken == JsonToken.VALUE_FALSE){\n+        return Boolean.FALSE;\n+    } else if(currentToken == JsonToken.VALUE_NULL){\n+        return null;\n     }\n+\n     throw ctxt.mappingException(Object.class);\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,52 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n-            }\n-        case JsonTokenId.ID_FIELD_NAME:\n-            return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n-            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                return mapArrayToArray(p, ctxt);\n-            }\n-            return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n-            return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n-            return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n-            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n-                return _coerceIntegral(p, ctxt);\n-            }\n-            // should be optimal, whatever it is\n-            return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n-                return p.getDecimalValue();\n-            }\n-            return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n-            return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n-            return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n-            return null;\n+    JsonToken currentToken = p.getCurrentToken();\n+    if(currentToken == JsonToken.START_OBJECT || currentToken == JsonToken.FIELD_NAME){\n         // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n         //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n-        default:\n-            throw ctxt.mappingException(Object.class);\n+        if (_mapDeserializer != null) {\n+            return _mapDeserializer.deserialize(p, ctxt);\n+        }\n+        return mapObject(p, ctxt);\n+    } else if(currentToken == JsonToken.START_ARRAY) {\n+        if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+            return mapArrayToArray(p, ctxt);\n+        }\n+        if (_listDeserializer != null) {\n+            return _listDeserializer.deserialize(p, ctxt);\n+        }\n+        return mapArray(p, ctxt);\n+    } else if(currentToken == JsonToken.VALUE_EMBEDDED_OBJECT){\n+        return p.getEmbeddedObject();\n+    } else if(currentToken == JsonToken.VALUE_STRING){\n+        if (_stringDeserializer != null) {\n+            return _stringDeserializer.deserialize(p, ctxt);\n+        }\n+        return p.getText();\n+    } else if(currentToken == JsonToken.VALUE_NUMBER_INT){\n+        if (_numberDeserializer != null) {\n+            return _numberDeserializer.deserialize(p, ctxt);\n+        }\n+        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            return _coerceIntegral(p, ctxt);\n+        }\n+        // should be optimal, whatever it is\n+        return p.getNumberValue();\n+    } else if(currentToken == JsonToken.VALUE_NUMBER_FLOAT){\n+        if (_numberDeserializer != null) {\n+            return _numberDeserializer.deserialize(p, ctxt);\n+        }\n+        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            return p.getDecimalValue();\n+        }\n+        return p.getDoubleValue();\n+    } else if(currentToken == JsonToken.VALUE_TRUE){\n+        return Boolean.TRUE;\n+    } else if(currentToken == JsonToken.VALUE_FALSE){\n+        return Boolean.FALSE;\n+    } else if(currentToken == JsonToken.VALUE_NULL){\n+        return null;\n     }\n+\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) { // change getCurrentTokenId() to currentToken()\n        case START_OBJECT:\n        case FIELD_NAME:\n            if (_mapDeserializer != null) {\n                return _mapDeserializer.deserialize(p, ctxt);\n            }\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            if (_listDeserializer != null) {\n                return _listDeserializer.deserialize(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT: // change ID_EMBEDDED_OBJECT to VALUE_EMBEDDED_OBJECT\n            return p.getEmbeddedObject();\n        case VALUE_STRING: // change ID_STRING to VALUE_STRING\n            if (_stringDeserializer != null) {\n                return _stringDeserializer.deserialize(p, ctxt);\n            }\n            return p.getText();\n        case VALUE_NUMBER_INT: // change ID_NUMBER_INT to VALUE_NUMBER_INT\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT: // change ID_NUMBER_FLOAT to VALUE_NUMBER_FLOAT\n            if (_numberDeserializer != null) {\n                return _numberDeserializer.deserialize(p, ctxt);\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return p.getDoubleValue();\n        case VALUE_TRUE: // change ID_TRUE to VALUE_TRUE\n            return Boolean.TRUE;\n        case VALUE_FALSE: // change ID_FALSE to VALUE_FALSE\n            return Boolean.FALSE;\n        case VALUE_NULL: // change ID_NULL to VALUE_NULL\n            return null;\n        default:\n    }\n    throw ctxt.mappingException(Object.class);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,15 +1,13 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n+    switch(p.currentToken()) { // change getCurrentTokenId() to currentToken()\n+        case START_OBJECT:\n+        case FIELD_NAME:\n             if (_mapDeserializer != null) {\n                 return _mapDeserializer.deserialize(p, ctxt);\n             }\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n@@ -17,38 +15,35 @@\n                 return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT: // change ID_EMBEDDED_OBJECT to VALUE_EMBEDDED_OBJECT\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING: // change ID_STRING to VALUE_STRING\n             if (_stringDeserializer != null) {\n                 return _stringDeserializer.deserialize(p, ctxt);\n             }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT: // change ID_NUMBER_INT to VALUE_NUMBER_INT\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n-            // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT: // change ID_NUMBER_FLOAT to VALUE_NUMBER_FLOAT\n             if (_numberDeserializer != null) {\n                 return _numberDeserializer.deserialize(p, ctxt);\n             }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n             return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n+        case VALUE_TRUE: // change ID_TRUE to VALUE_TRUE\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE: // change ID_FALSE to VALUE_FALSE\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL: // change ID_NULL to VALUE_NULL\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n     }\n     throw ctxt.mappingException(Object.class);\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,56 +1,50 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n-                    return new LinkedHashMap<String, Object>(2);\n-                }\n+    switch(p.currentToken()) { // change getCurrentTokenId() to currentToken()\n+        case START_OBJECT:\n+        case FIELD_NAME:\n+            if (_mapDeserializer != null) {\n+                return _mapDeserializer.deserialize(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n-            {\n-                JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n-                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                        return NO_OBJECTS;\n-                    }\n-                    return new ArrayList<Object>(2);\n-                }\n-            }\n+        case START_ARRAY:\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n+            if (_listDeserializer != null) {\n+                return _listDeserializer.deserialize(p, ctxt);\n+            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT: // change ID_EMBEDDED_OBJECT to VALUE_EMBEDDED_OBJECT\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING: // change ID_STRING to VALUE_STRING\n+            if (_stringDeserializer != null) {\n+                return _stringDeserializer.deserialize(p, ctxt);\n+            }\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT: // change ID_NUMBER_INT to VALUE_NUMBER_INT\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n-            // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT: // change ID_NUMBER_FLOAT to VALUE_NUMBER_FLOAT\n+            if (_numberDeserializer != null) {\n+                return _numberDeserializer.deserialize(p, ctxt);\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n+            return p.getDoubleValue();\n+        case VALUE_TRUE: // change ID_TRUE to VALUE_TRUE\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE: // change ID_FALSE to VALUE_FALSE\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL: // change ID_NULL to VALUE_NULL\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n-            throw ctxt.mappingException(Object.class);\n     }\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]