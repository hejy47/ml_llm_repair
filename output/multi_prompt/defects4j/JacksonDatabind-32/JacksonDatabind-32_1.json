[{"output": "It is difficult to provide a fix for this function without more context and information about the bug. Please provide more information or specify which version of the JacksonDatabind project you are referring to.", "diff": "", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n                // add missing break statement here\n                break;\n            }\n        case JsonTokenId.ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n                // add missing break statement here\n                break;\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case JsonTokenId.ID_NULL:\n            return null;\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -2,54 +2,55 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_OBJECT) {\n+                    return new LinkedHashMap<String, Object>(2);\n+                }\n+                // add missing break statement here\n+                break;\n+            }\n         case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (_mapDeserializer != null) {\n-                return _mapDeserializer.deserialize(p, ctxt);\n-            }\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    // and empty one too\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                        return NO_OBJECTS;\n+                    }\n+                    return new ArrayList<Object>(2);\n+                }\n+                // add missing break statement here\n+                break;\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n-            }\n-            if (_listDeserializer != null) {\n-                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n-            if (_stringDeserializer != null) {\n-                return _stringDeserializer.deserialize(p, ctxt);\n-            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return p.getDoubleValue();\n+            return Double.valueOf(p.getDoubleValue());\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case JsonTokenId.ID_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -7,6 +7,8 @@\n                 if (t == JsonToken.END_OBJECT) {\n                     return new LinkedHashMap<String, Object>(2);\n                 }\n+                // add missing break statement here\n+                break;\n             }\n         case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n@@ -20,6 +22,8 @@\n                     }\n                     return new ArrayList<Object>(2);\n                 }\n+                // add missing break statement here\n+                break;\n             }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n@@ -44,12 +48,8 @@\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case JsonTokenId.ID_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n             throw ctxt.mappingException(Object.class);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n                // This \"else\" statement was added to fix the issue\n                else {\n                    return mapObject(p, ctxt);\n                }\n            }\n        case JsonTokenId.ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -2,45 +2,48 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_OBJECT) {\n+                    return new LinkedHashMap<String, Object>(2);\n+                }\n+                // This \"else\" statement was added to fix the issue\n+                else {\n+                    return mapObject(p, ctxt);\n+                }\n+            }\n         case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (_mapDeserializer != null) {\n-                return _mapDeserializer.deserialize(p, ctxt);\n-            }\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    // and empty one too\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                        return NO_OBJECTS;\n+                    }\n+                    return new ArrayList<Object>(2);\n+                }\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n-            }\n-            if (_listDeserializer != null) {\n-                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n-            if (_stringDeserializer != null) {\n-                return _stringDeserializer.deserialize(p, ctxt);\n-            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return p.getDoubleValue();\n+            return Double.valueOf(p.getDoubleValue());\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n@@ -48,8 +51,10 @@\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+        //    if caller has advanced to the first token of Object, but for empty Object\n+        //case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -6,6 +6,10 @@\n                 JsonToken t = p.nextToken();\n                 if (t == JsonToken.END_OBJECT) {\n                     return new LinkedHashMap<String, Object>(2);\n+                }\n+                // This \"else\" statement was added to fix the issue\n+                else {\n+                    return mapObject(p, ctxt);\n                 }\n             }\n         case JsonTokenId.ID_FIELD_NAME:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonTokenId.ID_END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n                return mapObject(p, ctxt);\n            }\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonTokenId.ID_END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n                if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                    return mapArrayToArray(p, ctxt);\n                }\n                return mapArray(p, ctxt);\n            }\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n                JsonTokenId.ID_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,55 +1,55 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n+    switch(p.currentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (_mapDeserializer != null) {\n-                return _mapDeserializer.deserialize(p, ctxt);\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonTokenId.ID_END_OBJECT) {\n+                    return new LinkedHashMap<String, Object>(2);\n+                }\n+                return mapObject(p, ctxt);\n             }\n-            return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n-            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                return mapArrayToArray(p, ctxt);\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonTokenId.ID_END_ARRAY) {\n+                    // and empty one too\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                        return NO_OBJECTS;\n+                    }\n+                    return new ArrayList<Object>(2);\n+                }\n+                if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                    return mapArrayToArray(p, ctxt);\n+                }\n+                return mapArray(p, ctxt);\n             }\n-            if (_listDeserializer != null) {\n-                return _listDeserializer.deserialize(p, ctxt);\n-            }\n-            return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n-            if (_stringDeserializer != null) {\n-                return _stringDeserializer.deserialize(p, ctxt);\n-            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return p.getDoubleValue();\n+            return Double.valueOf(p.getDoubleValue());\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n         case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+                JsonTokenId.ID_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+        //    if caller has advanced to the first token of Object, but for empty Object\n+        //case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,30 +1,29 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n+    switch(p.currentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n             {\n                 JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_OBJECT) {\n+                if (t == JsonTokenId.ID_END_OBJECT) {\n                     return new LinkedHashMap<String, Object>(2);\n                 }\n+                return mapObject(p, ctxt);\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n-            return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n             {\n                 JsonToken t = p.nextToken();\n-                if (t == JsonToken.END_ARRAY) {\n+                if (t == JsonTokenId.ID_END_ARRAY) {\n                     // and empty one too\n                     if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                         return NO_OBJECTS;\n                     }\n                     return new ArrayList<Object>(2);\n                 }\n+                if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                    return mapArrayToArray(p, ctxt);\n+                }\n+                return mapArray(p, ctxt);\n             }\n-            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                return mapArrayToArray(p, ctxt);\n-            }\n-            return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n@@ -45,7 +44,7 @@\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n         case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+                JsonTokenId.ID_NULL:\n             return null;\n         // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n         //    if caller has advanced to the first token of Object, but for empty Object\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n            //Intentional fallthrough\n        case JsonTokenId.ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case JsonTokenId.ID_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        case JsonTokenId.ID_END_OBJECT: //Added case for END_OBJECT\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -2,54 +2,55 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_OBJECT) {\n+                    return new LinkedHashMap<String, Object>(2);\n+                }\n+            }\n+            //Intentional fallthrough\n         case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (_mapDeserializer != null) {\n-                return _mapDeserializer.deserialize(p, ctxt);\n-            }\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    // and empty one too\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                        return NO_OBJECTS;\n+                    }\n+                    return new ArrayList<Object>(2);\n+                }\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n-            }\n-            if (_listDeserializer != null) {\n-                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n-            if (_stringDeserializer != null) {\n-                return _stringDeserializer.deserialize(p, ctxt);\n-            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return p.getDoubleValue();\n+            return Double.valueOf(p.getDoubleValue());\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case JsonTokenId.ID_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+        //    if caller has advanced to the first token of Object, but for empty Object\n+        case JsonTokenId.ID_END_OBJECT: //Added case for END_OBJECT\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -8,6 +8,7 @@\n                     return new LinkedHashMap<String, Object>(2);\n                 }\n             }\n+            //Intentional fallthrough\n         case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n@@ -44,12 +45,11 @@\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case JsonTokenId.ID_NULL:\n             return null;\n         // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n         //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        case JsonTokenId.ID_END_OBJECT: //Added case for END_OBJECT\n         default:\n             throw ctxt.mappingException(Object.class);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n                break; // missing break statement added\n            }\n        case JsonTokenId.ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n                break; // missing break statement added\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -2,45 +2,46 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_OBJECT) {\n+                    return new LinkedHashMap<String, Object>(2);\n+                }\n+                break; // missing break statement added\n+            }\n         case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (_mapDeserializer != null) {\n-                return _mapDeserializer.deserialize(p, ctxt);\n-            }\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    // and empty one too\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                        return NO_OBJECTS;\n+                    }\n+                    return new ArrayList<Object>(2);\n+                }\n+                break; // missing break statement added\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n-            }\n-            if (_listDeserializer != null) {\n-                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n-            if (_stringDeserializer != null) {\n-                return _stringDeserializer.deserialize(p, ctxt);\n-            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return p.getDoubleValue();\n+            return Double.valueOf(p.getDoubleValue());\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n@@ -48,8 +49,10 @@\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+        //    if caller has advanced to the first token of Object, but for empty Object\n+        //case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -7,6 +7,7 @@\n                 if (t == JsonToken.END_OBJECT) {\n                     return new LinkedHashMap<String, Object>(2);\n                 }\n+                break; // missing break statement added\n             }\n         case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n@@ -20,6 +21,7 @@\n                     }\n                     return new ArrayList<Object>(2);\n                 }\n+                break; // missing break statement added\n             }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken().id()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_FIELD_NAME:\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                return p.getBigIntegerValue();\n            } else if (ctxt.isEnabled(DeserializationFeature.USE_LONG_FOR_INTS)) {\n                return p.getLongValue();\n            }\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case JsonTokenId.ID_NULL:\n            return null;\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,55 +1,53 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n+    switch(p.currentToken().id()) {\n         case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (_mapDeserializer != null) {\n-                return _mapDeserializer.deserialize(p, ctxt);\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_OBJECT) {\n+                    return new LinkedHashMap<String, Object>(2);\n+                }\n             }\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    // and empty one too\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                        return NO_OBJECTS;\n+                    }\n+                    return new ArrayList<Object>(2);\n+                }\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n-            if (_listDeserializer != null) {\n-                return _listDeserializer.deserialize(p, ctxt);\n-            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n-            return p.getEmbeddedObject();\n+        case JsonTokenId.ID_FIELD_NAME:\n         case JsonTokenId.ID_STRING:\n-            if (_stringDeserializer != null) {\n-                return _stringDeserializer.deserialize(p, ctxt);\n-            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n+                return p.getBigIntegerValue();\n+            } else if (ctxt.isEnabled(DeserializationFeature.USE_LONG_FOR_INTS)) {\n+                return p.getLongValue();\n             }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n-                return _coerceIntegral(p, ctxt);\n-            }\n-            // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return p.getDoubleValue();\n+            return Double.valueOf(p.getDoubleValue());\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case JsonTokenId.ID_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+            return p.getEmbeddedObject();\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,6 +1,6 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n+    switch(p.currentToken().id()) {\n         case JsonTokenId.ID_START_OBJECT:\n             {\n                 JsonToken t = p.nextToken();\n@@ -8,7 +8,6 @@\n                     return new LinkedHashMap<String, Object>(2);\n                 }\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n             {\n@@ -25,15 +24,15 @@\n                 return mapArrayToArray(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n-            return p.getEmbeddedObject();\n+        case JsonTokenId.ID_FIELD_NAME:\n         case JsonTokenId.ID_STRING:\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n-                return _coerceIntegral(p, ctxt);\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n+                return p.getBigIntegerValue();\n+            } else if (ctxt.isEnabled(DeserializationFeature.USE_LONG_FOR_INTS)) {\n+                return p.getLongValue();\n             }\n-            // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n@@ -44,12 +43,10 @@\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case JsonTokenId.ID_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+            return p.getEmbeddedObject();\n         default:\n             throw ctxt.mappingException(Object.class);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken().id()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n\n            return mapObject(p, ctxt);\n\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,55 +1,62 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n+    switch(p.currentToken().id()) {\n         case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (_mapDeserializer != null) {\n-                return _mapDeserializer.deserialize(p, ctxt);\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_OBJECT) {\n+                    return new LinkedHashMap<String, Object>(2);\n+                }\n             }\n+\n             return mapObject(p, ctxt);\n+\n         case JsonTokenId.ID_START_ARRAY:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    // and empty one too\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                        return NO_OBJECTS;\n+                    }\n+                    return new ArrayList<Object>(2);\n+                }\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n-            if (_listDeserializer != null) {\n-                return _listDeserializer.deserialize(p, ctxt);\n-            }\n             return mapArray(p, ctxt);\n+\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n+\n         case JsonTokenId.ID_STRING:\n-            if (_stringDeserializer != null) {\n-                return _stringDeserializer.deserialize(p, ctxt);\n-            }\n             return p.getText();\n+\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n+\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return p.getDoubleValue();\n+            return Double.valueOf(p.getDoubleValue());\n+\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n+\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n+\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,6 +1,6 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n+    switch(p.currentToken().id()) {\n         case JsonTokenId.ID_START_OBJECT:\n             {\n                 JsonToken t = p.nextToken();\n@@ -8,8 +8,9 @@\n                     return new LinkedHashMap<String, Object>(2);\n                 }\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n+\n             return mapObject(p, ctxt);\n+\n         case JsonTokenId.ID_START_ARRAY:\n             {\n                 JsonToken t = p.nextToken();\n@@ -25,31 +26,36 @@\n                 return mapArrayToArray(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n+\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n+\n         case JsonTokenId.ID_STRING:\n             return p.getText();\n+\n         case JsonTokenId.ID_NUMBER_INT:\n             if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n+\n         case JsonTokenId.ID_NUMBER_FLOAT:\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n             return Double.valueOf(p.getDoubleValue());\n+\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n+\n         case JsonTokenId.ID_FALSE:\n             return Boolean.FALSE;\n+\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+\n         default:\n             throw ctxt.mappingException(Object.class);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n            // add a break statement to prevent fall-through to the next case\n            break;\n        case JsonTokenId.ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n    // add a return statement to handle the case where the function returns before the end of the switch statement\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -2,45 +2,46 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_OBJECT) {\n+                    return new LinkedHashMap<String, Object>(2);\n+                }\n+            }\n+            // add a break statement to prevent fall-through to the next case\n+            break;\n         case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (_mapDeserializer != null) {\n-                return _mapDeserializer.deserialize(p, ctxt);\n-            }\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    // and empty one too\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                        return NO_OBJECTS;\n+                    }\n+                    return new ArrayList<Object>(2);\n+                }\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n-            }\n-            if (_listDeserializer != null) {\n-                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n-            if (_stringDeserializer != null) {\n-                return _stringDeserializer.deserialize(p, ctxt);\n-            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return p.getDoubleValue();\n+            return Double.valueOf(p.getDoubleValue());\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n@@ -48,8 +49,12 @@\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+        //    if caller has advanced to the first token of Object, but for empty Object\n+        //case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n+    // add a return statement to handle the case where the function returns before the end of the switch statement\n+    return null;\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -8,6 +8,8 @@\n                     return new LinkedHashMap<String, Object>(2);\n                 }\n             }\n+            // add a break statement to prevent fall-through to the next case\n+            break;\n         case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n@@ -53,4 +55,6 @@\n         default:\n             throw ctxt.mappingException(Object.class);\n     }\n+    // add a return statement to handle the case where the function returns before the end of the switch statement\n+    return null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n            // added break statement here\n            break;\n        case JsonTokenId.ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n    // added return statement here\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -2,45 +2,46 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_OBJECT) {\n+                    return new LinkedHashMap<String, Object>(2);\n+                }\n+            }\n+            // added break statement here\n+            break;\n         case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (_mapDeserializer != null) {\n-                return _mapDeserializer.deserialize(p, ctxt);\n-            }\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    // and empty one too\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                        return NO_OBJECTS;\n+                    }\n+                    return new ArrayList<Object>(2);\n+                }\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n-            }\n-            if (_listDeserializer != null) {\n-                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n-            if (_stringDeserializer != null) {\n-                return _stringDeserializer.deserialize(p, ctxt);\n-            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return p.getDoubleValue();\n+            return Double.valueOf(p.getDoubleValue());\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n@@ -48,8 +49,12 @@\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+        //    if caller has advanced to the first token of Object, but for empty Object\n+        //case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n+    // added return statement here\n+    return null;\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -8,6 +8,8 @@\n                     return new LinkedHashMap<String, Object>(2);\n                 }\n             }\n+            // added break statement here\n+            break;\n         case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n@@ -53,4 +55,6 @@\n         default:\n             throw ctxt.mappingException(Object.class);\n     }\n+    // added return statement here\n+    return null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n                // Add break statement to exit switch case\n                break;\n            }\n        case JsonTokenId.ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n                // Add break statement to exit switch case\n                break;\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n    // Add default return statement to handle cases where switch doesn't return a value\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -2,45 +2,48 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_OBJECT) {\n+                    return new LinkedHashMap<String, Object>(2);\n+                }\n+                // Add break statement to exit switch case\n+                break;\n+            }\n         case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (_mapDeserializer != null) {\n-                return _mapDeserializer.deserialize(p, ctxt);\n-            }\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    // and empty one too\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                        return NO_OBJECTS;\n+                    }\n+                    return new ArrayList<Object>(2);\n+                }\n+                // Add break statement to exit switch case\n+                break;\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n-            }\n-            if (_listDeserializer != null) {\n-                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n-            if (_stringDeserializer != null) {\n-                return _stringDeserializer.deserialize(p, ctxt);\n-            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return p.getDoubleValue();\n+            return Double.valueOf(p.getDoubleValue());\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n@@ -48,8 +51,12 @@\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+        //    if caller has advanced to the first token of Object, but for empty Object\n+        //case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n+    // Add default return statement to handle cases where switch doesn't return a value\n+    return null;\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -7,6 +7,8 @@\n                 if (t == JsonToken.END_OBJECT) {\n                     return new LinkedHashMap<String, Object>(2);\n                 }\n+                // Add break statement to exit switch case\n+                break;\n             }\n         case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n@@ -20,6 +22,8 @@\n                     }\n                     return new ArrayList<Object>(2);\n                 }\n+                // Add break statement to exit switch case\n+                break;\n             }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n@@ -53,4 +57,6 @@\n         default:\n             throw ctxt.mappingException(Object.class);\n     }\n+    // Add default return statement to handle cases where switch doesn't return a value\n+    return null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentToken()) { //changed getCurrentTokenId() to currentToken()\n        case START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n        case FIELD_NAME: // removed JsonTokenId.ID_FIELD_NAME\n            return mapObject(p, ctxt);\n        case START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case VALUE_EMBEDDED_OBJECT: // changed JsonTokenId.ID_EMBEDDED_OBJECT to VALUE_EMBEDDED_OBJECT\n            return p.getEmbeddedObject();\n        case VALUE_STRING: // changed JsonTokenId.ID_STRING to VALUE_STRING\n            return p.getText();\n        case VALUE_NUMBER_INT: // changed JsonTokenId.ID_NUMBER_INT to VALUE_NUMBER_INT\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT: // changed JsonTokenId.ID_NUMBER_FLOAT to VALUE_NUMBER_FLOAT\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case VALUE_TRUE: // changed JsonTokenId.ID_TRUE to VALUE_TRUE\n            return Boolean.TRUE;\n        case VALUE_FALSE: // changed JsonTokenId.ID_FALSE to VALUE_FALSE\n            return Boolean.FALSE;\n        case VALUE_NULL: // changed JsonTokenId.ID_NULL to VALUE_NULL\n            return null;\n        case END_OBJECT: // added case for END_OBJECT\n            return new LinkedHashMap<String, Object>(2);\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,55 +1,52 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n-        case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (_mapDeserializer != null) {\n-                return _mapDeserializer.deserialize(p, ctxt);\n+    switch(p.currentToken()) { //changed getCurrentTokenId() to currentToken()\n+        case START_OBJECT:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_OBJECT) {\n+                    return new LinkedHashMap<String, Object>(2);\n+                }\n             }\n+        case FIELD_NAME: // removed JsonTokenId.ID_FIELD_NAME\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                        return NO_OBJECTS;\n+                    }\n+                    return new ArrayList<Object>(2);\n+                }\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n             }\n-            if (_listDeserializer != null) {\n-                return _listDeserializer.deserialize(p, ctxt);\n-            }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT: // changed JsonTokenId.ID_EMBEDDED_OBJECT to VALUE_EMBEDDED_OBJECT\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n-            if (_stringDeserializer != null) {\n-                return _stringDeserializer.deserialize(p, ctxt);\n-            }\n+        case VALUE_STRING: // changed JsonTokenId.ID_STRING to VALUE_STRING\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+        case VALUE_NUMBER_INT: // changed JsonTokenId.ID_NUMBER_INT to VALUE_NUMBER_INT\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n-            // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+        case VALUE_NUMBER_FLOAT: // changed JsonTokenId.ID_NUMBER_FLOAT to VALUE_NUMBER_FLOAT\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return p.getDoubleValue();\n-        case JsonTokenId.ID_TRUE:\n+            return Double.valueOf(p.getDoubleValue());\n+        case VALUE_TRUE: // changed JsonTokenId.ID_TRUE to VALUE_TRUE\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE: // changed JsonTokenId.ID_FALSE to VALUE_FALSE\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL: // changed JsonTokenId.ID_NULL to VALUE_NULL\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        case END_OBJECT: // added case for END_OBJECT\n+            return new LinkedHashMap<String, Object>(2);\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,20 +1,19 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n-        case JsonTokenId.ID_START_OBJECT:\n+    switch(p.currentToken()) { //changed getCurrentTokenId() to currentToken()\n+        case START_OBJECT:\n             {\n                 JsonToken t = p.nextToken();\n                 if (t == JsonToken.END_OBJECT) {\n                     return new LinkedHashMap<String, Object>(2);\n                 }\n             }\n-        case JsonTokenId.ID_FIELD_NAME:\n+        case FIELD_NAME: // removed JsonTokenId.ID_FIELD_NAME\n             return mapObject(p, ctxt);\n-        case JsonTokenId.ID_START_ARRAY:\n+        case START_ARRAY:\n             {\n                 JsonToken t = p.nextToken();\n                 if (t == JsonToken.END_ARRAY) {\n-                    // and empty one too\n                     if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                         return NO_OBJECTS;\n                     }\n@@ -25,31 +24,28 @@\n                 return mapArrayToArray(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n-        case JsonTokenId.ID_EMBEDDED_OBJECT:\n+        case VALUE_EMBEDDED_OBJECT: // changed JsonTokenId.ID_EMBEDDED_OBJECT to VALUE_EMBEDDED_OBJECT\n             return p.getEmbeddedObject();\n-        case JsonTokenId.ID_STRING:\n+        case VALUE_STRING: // changed JsonTokenId.ID_STRING to VALUE_STRING\n             return p.getText();\n-        case JsonTokenId.ID_NUMBER_INT:\n+        case VALUE_NUMBER_INT: // changed JsonTokenId.ID_NUMBER_INT to VALUE_NUMBER_INT\n             if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n-            // should be optimal, whatever it is\n             return p.getNumberValue();\n-        case JsonTokenId.ID_NUMBER_FLOAT:\n+        case VALUE_NUMBER_FLOAT: // changed JsonTokenId.ID_NUMBER_FLOAT to VALUE_NUMBER_FLOAT\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n             return Double.valueOf(p.getDoubleValue());\n-        case JsonTokenId.ID_TRUE:\n+        case VALUE_TRUE: // changed JsonTokenId.ID_TRUE to VALUE_TRUE\n             return Boolean.TRUE;\n-        case JsonTokenId.ID_FALSE:\n+        case VALUE_FALSE: // changed JsonTokenId.ID_FALSE to VALUE_FALSE\n             return Boolean.FALSE;\n-        case // should not get this but...\n-        JsonTokenId.ID_NULL:\n+        case VALUE_NULL: // changed JsonTokenId.ID_NULL to VALUE_NULL\n             return null;\n-        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-        //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        case END_OBJECT: // added case for END_OBJECT\n+            return new LinkedHashMap<String, Object>(2);\n         default:\n             throw ctxt.mappingException(Object.class);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n            // need to add a break statement here\n            break;\n        case JsonTokenId.ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        case JsonTokenId.ID_END_OBJECT:\n            return new LinkedHashMap<String, Object>(2);\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -2,45 +2,46 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_OBJECT) {\n+                    return new LinkedHashMap<String, Object>(2);\n+                }\n+            }\n+            // need to add a break statement here\n+            break;\n         case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (_mapDeserializer != null) {\n-                return _mapDeserializer.deserialize(p, ctxt);\n-            }\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    // and empty one too\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                        return NO_OBJECTS;\n+                    }\n+                    return new ArrayList<Object>(2);\n+                }\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n-            }\n-            if (_listDeserializer != null) {\n-                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n-            if (_stringDeserializer != null) {\n-                return _stringDeserializer.deserialize(p, ctxt);\n-            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return p.getDoubleValue();\n+            return Double.valueOf(p.getDoubleValue());\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n@@ -48,8 +49,11 @@\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+        //    if caller has advanced to the first token of Object, but for empty Object\n+        case JsonTokenId.ID_END_OBJECT:\n+            return new LinkedHashMap<String, Object>(2);\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -8,6 +8,8 @@\n                     return new LinkedHashMap<String, Object>(2);\n                 }\n             }\n+            // need to add a break statement here\n+            break;\n         case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n@@ -49,7 +51,8 @@\n             return null;\n         // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n         //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        case JsonTokenId.ID_END_OBJECT:\n+            return new LinkedHashMap<String, Object>(2);\n         default:\n             throw ctxt.mappingException(Object.class);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n                // Added break statement to exit switch statement\n                break;\n            }\n        case JsonTokenId.ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n                // Added break statement to exit switch statement\n                break;\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        case JsonTokenId.ID_END_OBJECT: \n            // Added return statement to handle empty object\n            return new LinkedHashMap<String, Object>(2);\n        case JsonTokenId.ID_END_ARRAY:\n            // Added return statement to handle empty array\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return NO_OBJECTS;\n            }\n            return new ArrayList<Object>(2);\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -2,45 +2,48 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_OBJECT) {\n+                    return new LinkedHashMap<String, Object>(2);\n+                }\n+                // Added break statement to exit switch statement\n+                break;\n+            }\n         case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (_mapDeserializer != null) {\n-                return _mapDeserializer.deserialize(p, ctxt);\n-            }\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    // and empty one too\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                        return NO_OBJECTS;\n+                    }\n+                    return new ArrayList<Object>(2);\n+                }\n+                // Added break statement to exit switch statement\n+                break;\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n-            }\n-            if (_listDeserializer != null) {\n-                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n-            if (_stringDeserializer != null) {\n-                return _stringDeserializer.deserialize(p, ctxt);\n-            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return p.getDoubleValue();\n+            return Double.valueOf(p.getDoubleValue());\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n@@ -48,8 +51,18 @@\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+        //    if caller has advanced to the first token of Object, but for empty Object\n+        case JsonTokenId.ID_END_OBJECT: \n+            // Added return statement to handle empty object\n+            return new LinkedHashMap<String, Object>(2);\n+        case JsonTokenId.ID_END_ARRAY:\n+            // Added return statement to handle empty array\n+            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                return NO_OBJECTS;\n+            }\n+            return new ArrayList<Object>(2);\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -7,6 +7,8 @@\n                 if (t == JsonToken.END_OBJECT) {\n                     return new LinkedHashMap<String, Object>(2);\n                 }\n+                // Added break statement to exit switch statement\n+                break;\n             }\n         case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n@@ -20,6 +22,8 @@\n                     }\n                     return new ArrayList<Object>(2);\n                 }\n+                // Added break statement to exit switch statement\n+                break;\n             }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n@@ -49,7 +53,15 @@\n             return null;\n         // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n         //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        case JsonTokenId.ID_END_OBJECT: \n+            // Added return statement to handle empty object\n+            return new LinkedHashMap<String, Object>(2);\n+        case JsonTokenId.ID_END_ARRAY:\n+            // Added return statement to handle empty array\n+            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                return NO_OBJECTS;\n+            }\n+            return new ArrayList<Object>(2);\n         default:\n             throw ctxt.mappingException(Object.class);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n            // add a break statement to prevent fall-through to the next case\n            break;\n        case JsonTokenId.ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n    // add a return statement to avoid unreachable code warning\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -2,45 +2,46 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_OBJECT) {\n+                    return new LinkedHashMap<String, Object>(2);\n+                }\n+            }\n+            // add a break statement to prevent fall-through to the next case\n+            break;\n         case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (_mapDeserializer != null) {\n-                return _mapDeserializer.deserialize(p, ctxt);\n-            }\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    // and empty one too\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                        return NO_OBJECTS;\n+                    }\n+                    return new ArrayList<Object>(2);\n+                }\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n-            }\n-            if (_listDeserializer != null) {\n-                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n-            if (_stringDeserializer != null) {\n-                return _stringDeserializer.deserialize(p, ctxt);\n-            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return p.getDoubleValue();\n+            return Double.valueOf(p.getDoubleValue());\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n@@ -48,8 +49,12 @@\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+        //    if caller has advanced to the first token of Object, but for empty Object\n+        //case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n+    // add a return statement to avoid unreachable code warning\n+    return null;\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -8,6 +8,8 @@\n                     return new LinkedHashMap<String, Object>(2);\n                 }\n             }\n+            // add a break statement to prevent fall-through to the next case\n+            break;\n         case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n@@ -53,4 +55,6 @@\n         default:\n             throw ctxt.mappingException(Object.class);\n     }\n+    // add a return statement to avoid unreachable code warning\n+    return null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n                return mapObject(p, ctxt);\n            }\n        case JsonTokenId.ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n                if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                    return mapArrayToArray(p, ctxt);\n                }\n                return mapArray(p, ctxt);\n            }\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -2,45 +2,45 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_OBJECT) {\n+                    return new LinkedHashMap<String, Object>(2);\n+                }\n+                return mapObject(p, ctxt);\n+            }\n         case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (_mapDeserializer != null) {\n-                return _mapDeserializer.deserialize(p, ctxt);\n-            }\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n-            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                return mapArrayToArray(p, ctxt);\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    // and empty one too\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                        return NO_OBJECTS;\n+                    }\n+                    return new ArrayList<Object>(2);\n+                }\n+                if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                    return mapArrayToArray(p, ctxt);\n+                }\n+                return mapArray(p, ctxt);\n             }\n-            if (_listDeserializer != null) {\n-                return _listDeserializer.deserialize(p, ctxt);\n-            }\n-            return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n-            if (_stringDeserializer != null) {\n-                return _stringDeserializer.deserialize(p, ctxt);\n-            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return p.getDoubleValue();\n+            return Double.valueOf(p.getDoubleValue());\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n@@ -48,8 +48,10 @@\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+        //    if caller has advanced to the first token of Object, but for empty Object\n+        //case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -7,6 +7,7 @@\n                 if (t == JsonToken.END_OBJECT) {\n                     return new LinkedHashMap<String, Object>(2);\n                 }\n+                return mapObject(p, ctxt);\n             }\n         case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n@@ -20,11 +21,11 @@\n                     }\n                     return new ArrayList<Object>(2);\n                 }\n+                if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                    return mapArrayToArray(p, ctxt);\n+                }\n+                return mapArray(p, ctxt);\n             }\n-            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n-                return mapArrayToArray(p, ctxt);\n-            }\n-            return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.getCurrentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n            // add break statement to exit switch case\n            break;\n        case JsonTokenId.ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        //case JsonTokenId.ID_END_ARRAY: // invalid\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n    // if input JSON is empty object, return empty LinkedHashMap\n    if (p.getCurrentTokenId() == JsonTokenId.ID_END_OBJECT) {\n        return new LinkedHashMap<String, Object>(2);\n    }\n    // throw exception if none of the cases match\n    throw ctxt.mappingException(Object.class);\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -2,45 +2,46 @@\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n     switch(p.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_OBJECT) {\n+                    return new LinkedHashMap<String, Object>(2);\n+                }\n+            }\n+            // add break statement to exit switch case\n+            break;\n         case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (_mapDeserializer != null) {\n-                return _mapDeserializer.deserialize(p, ctxt);\n-            }\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    // and empty one too\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                        return NO_OBJECTS;\n+                    }\n+                    return new ArrayList<Object>(2);\n+                }\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n-            }\n-            if (_listDeserializer != null) {\n-                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n-            if (_stringDeserializer != null) {\n-                return _stringDeserializer.deserialize(p, ctxt);\n-            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return p.getDoubleValue();\n+            return Double.valueOf(p.getDoubleValue());\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n@@ -48,8 +49,16 @@\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+        //    if caller has advanced to the first token of Object, but for empty Object\n+        //case JsonTokenId.ID_END_ARRAY: // invalid\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n+    // if input JSON is empty object, return empty LinkedHashMap\n+    if (p.getCurrentTokenId() == JsonTokenId.ID_END_OBJECT) {\n+        return new LinkedHashMap<String, Object>(2);\n+    }\n+    // throw exception if none of the cases match\n     throw ctxt.mappingException(Object.class);\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -8,6 +8,8 @@\n                     return new LinkedHashMap<String, Object>(2);\n                 }\n             }\n+            // add break statement to exit switch case\n+            break;\n         case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n@@ -53,4 +55,10 @@\n         default:\n             throw ctxt.mappingException(Object.class);\n     }\n+    // if input JSON is empty object, return empty LinkedHashMap\n+    if (p.getCurrentTokenId() == JsonTokenId.ID_END_OBJECT) {\n+        return new LinkedHashMap<String, Object>(2);\n+    }\n+    // throw exception if none of the cases match\n+    throw ctxt.mappingException(Object.class);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n    switch(p.currentTokenId()) {\n        case JsonTokenId.ID_START_OBJECT:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_OBJECT) {\n                    return new LinkedHashMap<String, Object>(2);\n                }\n            }\n            // Add a break statement to exit the switch case\n            break;\n        case JsonTokenId.ID_FIELD_NAME:\n            return mapObject(p, ctxt);\n        case JsonTokenId.ID_START_ARRAY:\n            {\n                JsonToken t = p.nextToken();\n                if (t == JsonToken.END_ARRAY) {\n                    // and empty one too\n                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                        return NO_OBJECTS;\n                    }\n                    return new ArrayList<Object>(2);\n                }\n            }\n            if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                return mapArrayToArray(p, ctxt);\n            }\n            return mapArray(p, ctxt);\n        case JsonTokenId.ID_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case JsonTokenId.ID_STRING:\n            return p.getText();\n        case JsonTokenId.ID_NUMBER_INT:\n            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                return _coerceIntegral(p, ctxt);\n            }\n            // should be optimal, whatever it is\n            return p.getNumberValue();\n        case JsonTokenId.ID_NUMBER_FLOAT:\n            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                return p.getDecimalValue();\n            }\n            return Double.valueOf(p.getDoubleValue());\n        case JsonTokenId.ID_TRUE:\n            return Boolean.TRUE;\n        case JsonTokenId.ID_FALSE:\n            return Boolean.FALSE;\n        case // should not get this but...\n        JsonTokenId.ID_NULL:\n            return null;\n        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n        //    if caller has advanced to the first token of Object, but for empty Object\n        case JsonTokenId.ID_END_OBJECT:\n            if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n                throw ctxt.mappingException(Object.class);\n            }\n            return null;\n        default:\n            throw ctxt.mappingException(Object.class);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize\n@@ -1,46 +1,47 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n+    switch(p.currentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_OBJECT) {\n+                    return new LinkedHashMap<String, Object>(2);\n+                }\n+            }\n+            // Add a break statement to exit the switch case\n+            break;\n         case JsonTokenId.ID_FIELD_NAME:\n-            // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (_mapDeserializer != null) {\n-                return _mapDeserializer.deserialize(p, ctxt);\n-            }\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n+            {\n+                JsonToken t = p.nextToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    // and empty one too\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+                        return NO_OBJECTS;\n+                    }\n+                    return new ArrayList<Object>(2);\n+                }\n+            }\n             if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n                 return mapArrayToArray(p, ctxt);\n-            }\n-            if (_listDeserializer != null) {\n-                return _listDeserializer.deserialize(p, ctxt);\n             }\n             return mapArray(p, ctxt);\n         case JsonTokenId.ID_EMBEDDED_OBJECT:\n             return p.getEmbeddedObject();\n         case JsonTokenId.ID_STRING:\n-            if (_stringDeserializer != null) {\n-                return _stringDeserializer.deserialize(p, ctxt);\n-            }\n             return p.getText();\n         case JsonTokenId.ID_NUMBER_INT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n+            if (ctxt.hasSomeOfFeatures(F_MASK_INT_COERCIONS)) {\n                 return _coerceIntegral(p, ctxt);\n             }\n             // should be optimal, whatever it is\n             return p.getNumberValue();\n         case JsonTokenId.ID_NUMBER_FLOAT:\n-            if (_numberDeserializer != null) {\n-                return _numberDeserializer.deserialize(p, ctxt);\n-            }\n-                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return p.getDecimalValue();\n             }\n-            return p.getDoubleValue();\n+            return Double.valueOf(p.getDoubleValue());\n         case JsonTokenId.ID_TRUE:\n             return Boolean.TRUE;\n         case JsonTokenId.ID_FALSE:\n@@ -48,8 +49,14 @@\n         case // should not get this but...\n         JsonTokenId.ID_NULL:\n             return null;\n-        //        case JsonTokenId.ID_END_ARRAY: // invalid\n+        // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n+        //    if caller has advanced to the first token of Object, but for empty Object\n+        case JsonTokenId.ID_END_OBJECT:\n+            if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n+                throw ctxt.mappingException(Object.class);\n+            }\n+            return null;\n         default:\n+            throw ctxt.mappingException(Object.class);\n     }\n-    throw ctxt.mappingException(Object.class);\n }\n--- com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n+++ com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java@deserialize1\n@@ -1,6 +1,6 @@\n @Override\n public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n-    switch(p.getCurrentTokenId()) {\n+    switch(p.currentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n             {\n                 JsonToken t = p.nextToken();\n@@ -8,6 +8,8 @@\n                     return new LinkedHashMap<String, Object>(2);\n                 }\n             }\n+            // Add a break statement to exit the switch case\n+            break;\n         case JsonTokenId.ID_FIELD_NAME:\n             return mapObject(p, ctxt);\n         case JsonTokenId.ID_START_ARRAY:\n@@ -49,7 +51,11 @@\n             return null;\n         // 28-Oct-2015, tatu: [databind#989] We may also be given END_OBJECT (similar to FIELD_NAME),\n         //    if caller has advanced to the first token of Object, but for empty Object\n-        //case JsonTokenId.ID_END_ARRAY: // invalid\n+        case JsonTokenId.ID_END_OBJECT:\n+            if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n+                throw ctxt.mappingException(Object.class);\n+            }\n+            return null;\n         default:\n             throw ctxt.mappingException(Object.class);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}]