[{"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local && !var.isExtern()) { // modified to check if it's not an extern variable\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern variable\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -28,7 +28,7 @@\n     }\n     if (isExternsPass_) {\n         // Keep track of extern globals.\n-        if (!local) {\n+        if (!local && !var.isExtern()) { // modified to check if it's not an extern variable\n             externNames.add(name);\n         }\n         return;\n@@ -40,7 +40,7 @@\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n     } else if (var != null) {\n-        // Not an extern\n+        // Not an extern variable\n         // If it's global, increment global count\n         incCount(name, var.input);\n         globalNameNodes.add(n);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        var.setName(tempName);   // update the scope variable name\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -36,6 +36,7 @@\n     if (local) {\n         // Local var: assign a new name\n         String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n+        var.setName(tempName);   // update the scope variable name\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass()) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var == null ? null : var.getInput());\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -26,7 +26,7 @@\n         // Blindly de-uniquify for the Prototype library for issue 103.\n         return;\n     }\n-    if (isExternsPass_) {\n+    if (isExternsPass()) {\n         // Keep track of extern globals.\n         if (!local) {\n             externNames.add(name);\n@@ -39,10 +39,10 @@\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n-    } else if (var != null) {\n+    } else {\n         // Not an extern\n         // If it's global, increment global count\n-        incCount(name, var.input);\n+        incCount(name, var == null ? null : var.getInput());\n         globalNameNodes.add(n);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isName()) {\n        String name = n.getString();\n        // Ignore anonymous functions\n        if (!name.isEmpty()) {\n            // Is this local or Global?\n            Scope.Var var = t.getScope().getVar(name);\n            boolean local = (var != null) && var.isLocal();\n            // Are we renaming global variables?\n            if (!local && localRenamingOnly) {\n                reservedNames.add(name);\n                return;\n            }\n            // Are we renaming anonymous function names?\n            if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n                reservedNames.add(name);\n                return;\n            }\n            // Check if we can rename this.\n            if (okToRenameVar(name, local)) {\n                if (isExternsPass_) {\n                    // Keep track of extern globals.\n                    if (!local) {\n                        externNames.add(name);\n                    }\n                } else {\n                    if (local) {\n                        // Local var: assign a new name\n                        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n                        incCount(tempName, null);\n                        localNameNodes.add(n);\n                        localTempNames.add(tempName);\n                    } else if (!var.isExtern()) {\n                        // Not an extern\n                        // If it's global, increment global count\n                        incCount(name, var.input);\n                        globalNameNodes.add(n);\n                    }\n                }\n            } else if (name.equals(\"goog\")) {\n                // Rename goog to something unlikely to appear in code.\n                n.setString(RESERVED_PREFIX + \"goog\");\n            } \n            // Blindly de-uniquify for the Prototype library for issue 103.\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,48 +1,48 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n-        return;\n-    }\n-    String name = n.getString();\n-    // Ignore anonymous functions\n-    if (name.length() == 0) {\n-        return;\n-    }\n-    // Is this local or Global?\n-    Scope.Var var = t.getScope().getVar(name);\n-    boolean local = (var != null) && var.isLocal();\n-    // Are we renaming global variables?\n-    if (!local && localRenamingOnly) {\n-        reservedNames.add(name);\n-        return;\n-    }\n-    // Are we renaming anonymous function names?\n-    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n-        reservedNames.add(name);\n-        return;\n-    }\n-    // Check if we can rename this.\n-    if (!okToRenameVar(name, local)) {\n-        // Blindly de-uniquify for the Prototype library for issue 103.\n-        return;\n-    }\n-    if (isExternsPass_) {\n-        // Keep track of extern globals.\n-        if (!local) {\n-            externNames.add(name);\n+    if (n.isName()) {\n+        String name = n.getString();\n+        // Ignore anonymous functions\n+        if (!name.isEmpty()) {\n+            // Is this local or Global?\n+            Scope.Var var = t.getScope().getVar(name);\n+            boolean local = (var != null) && var.isLocal();\n+            // Are we renaming global variables?\n+            if (!local && localRenamingOnly) {\n+                reservedNames.add(name);\n+                return;\n+            }\n+            // Are we renaming anonymous function names?\n+            if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n+                reservedNames.add(name);\n+                return;\n+            }\n+            // Check if we can rename this.\n+            if (okToRenameVar(name, local)) {\n+                if (isExternsPass_) {\n+                    // Keep track of extern globals.\n+                    if (!local) {\n+                        externNames.add(name);\n+                    }\n+                } else {\n+                    if (local) {\n+                        // Local var: assign a new name\n+                        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n+                        incCount(tempName, null);\n+                        localNameNodes.add(n);\n+                        localTempNames.add(tempName);\n+                    } else if (!var.isExtern()) {\n+                        // Not an extern\n+                        // If it's global, increment global count\n+                        incCount(name, var.input);\n+                        globalNameNodes.add(n);\n+                    }\n+                }\n+            } else if (name.equals(\"goog\")) {\n+                // Rename goog to something unlikely to appear in code.\n+                n.setString(RESERVED_PREFIX + \"goog\");\n+            } \n+            // Blindly de-uniquify for the Prototype library for issue 103.\n         }\n-        return;\n-    }\n-    if (local) {\n-        // Local var: assign a new name\n-        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n-        incCount(tempName, null);\n-        localNameNodes.add(n);\n-        localTempNames.add(tempName);\n-    } else if (var != null) {\n-        // Not an extern\n-        // If it's global, increment global count\n-        incCount(name, var.input);\n-        globalNameNodes.add(n);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n        n.setString(tempName); // update the node string with the new name\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n        n.setString(getNewName(name)); // update the node string with the new name\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -39,10 +39,12 @@\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n+        n.setString(tempName); // update the node string with the new name\n     } else if (var != null) {\n         // Not an extern\n         // If it's global, increment global count\n         incCount(name, var.input);\n         globalNameNodes.add(n);\n+        n.setString(getNewName(name)); // update the node string with the new name\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (!n.isName()) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.isEmpty()) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null && !var.isExtern()) {\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,11 +1,11 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n+    if (!n.isName()) {\n         return;\n     }\n     String name = n.getString();\n     // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    if (name.isEmpty()) {\n         return;\n     }\n     // Is this local or Global?\n@@ -39,8 +39,7 @@\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n-    } else if (var != null) {\n-        // Not an extern\n+    } else if (var != null && !var.isExtern()) {\n         // If it's global, increment global count\n         incCount(name, var.input);\n         globalNameNodes.add(n);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (!n.isName()) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.isEmpty()) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass()) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getBaseName();\n        var.setBaseName(tempName);\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,11 +1,11 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n+    if (!n.isName()) {\n         return;\n     }\n     String name = n.getString();\n     // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    if (name.isEmpty()) {\n         return;\n     }\n     // Is this local or Global?\n@@ -26,7 +26,7 @@\n         // Blindly de-uniquify for the Prototype library for issue 103.\n         return;\n     }\n-    if (isExternsPass_) {\n+    if (isExternsPass()) {\n         // Keep track of extern globals.\n         if (!local) {\n             externNames.add(name);\n@@ -35,7 +35,8 @@\n     }\n     if (local) {\n         // Local var: assign a new name\n-        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n+        String tempName = LOCAL_VAR_PREFIX + var.getBaseName();\n+        var.setBaseName(tempName);\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (!n.isName()) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.isEmpty()) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_ && !local) {\n        // Keep track of extern globals.\n        externNames.add(name);\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getScope().getVarCount();\n        var.setOriginalName(name); // Set the original name for use in sourcemaps.\n        var.setName(tempName);\n        localVarNodes.add(n);\n        localTempNames.add(tempName);\n    } else {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var == null ? null : var.input);\n        globalVarNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,11 +1,11 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n+    if (!n.isName()) {\n         return;\n     }\n     String name = n.getString();\n     // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    if (name.isEmpty()) {\n         return;\n     }\n     // Is this local or Global?\n@@ -26,23 +26,22 @@\n         // Blindly de-uniquify for the Prototype library for issue 103.\n         return;\n     }\n-    if (isExternsPass_) {\n+    if (isExternsPass_ && !local) {\n         // Keep track of extern globals.\n-        if (!local) {\n-            externNames.add(name);\n-        }\n+        externNames.add(name);\n         return;\n     }\n     if (local) {\n         // Local var: assign a new name\n-        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n-        incCount(tempName, null);\n-        localNameNodes.add(n);\n+        String tempName = LOCAL_VAR_PREFIX + var.getScope().getVarCount();\n+        var.setOriginalName(name); // Set the original name for use in sourcemaps.\n+        var.setName(tempName);\n+        localVarNodes.add(n);\n         localTempNames.add(tempName);\n-    } else if (var != null) {\n+    } else {\n         // Not an extern\n         // If it's global, increment global count\n-        incCount(name, var.input);\n-        globalNameNodes.add(n);\n+        incCount(name, var == null ? null : var.input);\n+        globalVarNodes.add(n);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        if (name.equals(\"$$\")) {\n            name = \"$\";\n            n.setString(name);\n        }\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -24,6 +24,10 @@\n     // Check if we can rename this.\n     if (!okToRenameVar(name, local)) {\n         // Blindly de-uniquify for the Prototype library for issue 103.\n+        if (name.equals(\"$$\")) {\n+            name = \"$\";\n+            n.setString(name);\n+        }\n         return;\n     }\n     if (isExternsPass_) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getToken() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0 || NodeUtil.isNameAnonymousFunctionDeclaration(n)) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getScope().getVarCount();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n        var.setName(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n        var.setName(getNewName(name, currentId));\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,11 +1,11 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n+    if (n.getToken() != Token.NAME) {\n         return;\n     }\n     String name = n.getString();\n     // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    if (name.length() == 0 || NodeUtil.isNameAnonymousFunctionDeclaration(n)) {\n         return;\n     }\n     // Is this local or Global?\n@@ -13,11 +13,6 @@\n     boolean local = (var != null) && var.isLocal();\n     // Are we renaming global variables?\n     if (!local && localRenamingOnly) {\n-        reservedNames.add(name);\n-        return;\n-    }\n-    // Are we renaming anonymous function names?\n-    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n         reservedNames.add(name);\n         return;\n     }\n@@ -35,14 +30,16 @@\n     }\n     if (local) {\n         // Local var: assign a new name\n-        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n+        String tempName = LOCAL_VAR_PREFIX + var.getScope().getVarCount();\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n+        var.setName(tempName);\n     } else if (var != null) {\n         // Not an extern\n         // If it's global, increment global count\n         incCount(name, var.input);\n         globalNameNodes.add(n);\n+        var.setName(getNewName(name, currentId));\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isName()) {\n        String name = n.getString();\n        // Ignore anonymous functions\n        if (name.length() == 0) {\n            return;\n        }\n        // Is this local or global?\n        Scope.Var var = t.getScope().getVar(name);\n        boolean local = (var != null) && var.isLocal();\n        // Are we renaming global variables?\n        if (!local && localRenamingOnly) {\n            reservedNames.add(name);\n            return;\n        }\n        // Are we renaming anonymous function names?\n        if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n            reservedNames.add(name);\n            return;\n        }\n        // Check if we can rename this.\n        if (!okToRenameVar(name, local)) {\n            // Blindly de-uniquify for the Prototype library for issue 103.\n            return;\n        }\n        if (isExternsPass_) {\n            // Keep track of extern globals.\n            if (!local) {\n                externNames.add(name);\n            }\n            return;\n        }\n        if (local) {\n            // Local var: assign a new name\n            String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n            incCount(tempName, null);\n            localNameNodes.add(n);\n            localTempNames.add(tempName);\n        } else if (var == null || !var.isGlobal()) {\n            // Not a var, or a local var, or an extern\n            return;\n        } else {\n            // Global var: assign a new name\n            String newName = getGlobalName(name);\n            incCount(newName, var.input);\n            globalNameNodes.add(n);\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,48 +1,50 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n-        return;\n-    }\n-    String name = n.getString();\n-    // Ignore anonymous functions\n-    if (name.length() == 0) {\n-        return;\n-    }\n-    // Is this local or Global?\n-    Scope.Var var = t.getScope().getVar(name);\n-    boolean local = (var != null) && var.isLocal();\n-    // Are we renaming global variables?\n-    if (!local && localRenamingOnly) {\n-        reservedNames.add(name);\n-        return;\n-    }\n-    // Are we renaming anonymous function names?\n-    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n-        reservedNames.add(name);\n-        return;\n-    }\n-    // Check if we can rename this.\n-    if (!okToRenameVar(name, local)) {\n-        // Blindly de-uniquify for the Prototype library for issue 103.\n-        return;\n-    }\n-    if (isExternsPass_) {\n-        // Keep track of extern globals.\n-        if (!local) {\n-            externNames.add(name);\n+    if (n.isName()) {\n+        String name = n.getString();\n+        // Ignore anonymous functions\n+        if (name.length() == 0) {\n+            return;\n         }\n-        return;\n-    }\n-    if (local) {\n-        // Local var: assign a new name\n-        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n-        incCount(tempName, null);\n-        localNameNodes.add(n);\n-        localTempNames.add(tempName);\n-    } else if (var != null) {\n-        // Not an extern\n-        // If it's global, increment global count\n-        incCount(name, var.input);\n-        globalNameNodes.add(n);\n+        // Is this local or global?\n+        Scope.Var var = t.getScope().getVar(name);\n+        boolean local = (var != null) && var.isLocal();\n+        // Are we renaming global variables?\n+        if (!local && localRenamingOnly) {\n+            reservedNames.add(name);\n+            return;\n+        }\n+        // Are we renaming anonymous function names?\n+        if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n+            reservedNames.add(name);\n+            return;\n+        }\n+        // Check if we can rename this.\n+        if (!okToRenameVar(name, local)) {\n+            // Blindly de-uniquify for the Prototype library for issue 103.\n+            return;\n+        }\n+        if (isExternsPass_) {\n+            // Keep track of extern globals.\n+            if (!local) {\n+                externNames.add(name);\n+            }\n+            return;\n+        }\n+        if (local) {\n+            // Local var: assign a new name\n+            String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n+            incCount(tempName, null);\n+            localNameNodes.add(n);\n+            localTempNames.add(tempName);\n+        } else if (var == null || !var.isGlobal()) {\n+            // Not a var, or a local var, or an extern\n+            return;\n+        } else {\n+            // Global var: assign a new name\n+            String newName = getGlobalName(name);\n+            incCount(newName, var.input);\n+            globalNameNodes.add(n);\n+        }\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isName()) {\n        String name = n.getString();\n        // Ignore anonymous functions\n        if (name.isEmpty()) {\n            return;\n        }\n        // Check if this is a local or global variable\n        Scope.Var var = t.getScope().getVar(name);\n        boolean local = (var != null) && var.isLocal();\n        // Check if we're only renaming local variables\n        if (!local && localRenamingOnly) {\n            reservedNames.add(name);\n            return;\n        }\n        // Check if we're preserving anonymous function names\n        if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunctionDeclaration(var.getParentNode())) {\n            reservedNames.add(name);\n            return;\n        }\n        // Check whether or not we're allowed to rename this variable\n        if (!okToRenameVar(name, local)) {\n            // Blindly de-uniquify for the Prototype library for issue 103.\n            return;\n        }\n        if (isExternsPass_) {\n            // Keep track of extern globals\n            if (!local) {\n                externNames.add(name);\n            }\n            return;\n        }\n        if (local) {\n            // Rename local variables with a new name\n            String tempName = LOCAL_VAR_PREFIX + var.getLocalIndex();\n            incCount(tempName, null);\n            localNameNodes.add(n);\n            localTempNames.add(tempName);\n        } else if (var != null && !var.isExtern()) {\n            // If it's a global variable, increment global count\n            incCount(name, var.getNode().getSourceFileName());\n            globalNameNodes.add(n);\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,48 +1,46 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n-        return;\n-    }\n-    String name = n.getString();\n-    // Ignore anonymous functions\n-    if (name.length() == 0) {\n-        return;\n-    }\n-    // Is this local or Global?\n-    Scope.Var var = t.getScope().getVar(name);\n-    boolean local = (var != null) && var.isLocal();\n-    // Are we renaming global variables?\n-    if (!local && localRenamingOnly) {\n-        reservedNames.add(name);\n-        return;\n-    }\n-    // Are we renaming anonymous function names?\n-    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n-        reservedNames.add(name);\n-        return;\n-    }\n-    // Check if we can rename this.\n-    if (!okToRenameVar(name, local)) {\n-        // Blindly de-uniquify for the Prototype library for issue 103.\n-        return;\n-    }\n-    if (isExternsPass_) {\n-        // Keep track of extern globals.\n-        if (!local) {\n-            externNames.add(name);\n+    if (n.isName()) {\n+        String name = n.getString();\n+        // Ignore anonymous functions\n+        if (name.isEmpty()) {\n+            return;\n         }\n-        return;\n-    }\n-    if (local) {\n-        // Local var: assign a new name\n-        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n-        incCount(tempName, null);\n-        localNameNodes.add(n);\n-        localTempNames.add(tempName);\n-    } else if (var != null) {\n-        // Not an extern\n-        // If it's global, increment global count\n-        incCount(name, var.input);\n-        globalNameNodes.add(n);\n+        // Check if this is a local or global variable\n+        Scope.Var var = t.getScope().getVar(name);\n+        boolean local = (var != null) && var.isLocal();\n+        // Check if we're only renaming local variables\n+        if (!local && localRenamingOnly) {\n+            reservedNames.add(name);\n+            return;\n+        }\n+        // Check if we're preserving anonymous function names\n+        if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunctionDeclaration(var.getParentNode())) {\n+            reservedNames.add(name);\n+            return;\n+        }\n+        // Check whether or not we're allowed to rename this variable\n+        if (!okToRenameVar(name, local)) {\n+            // Blindly de-uniquify for the Prototype library for issue 103.\n+            return;\n+        }\n+        if (isExternsPass_) {\n+            // Keep track of extern globals\n+            if (!local) {\n+                externNames.add(name);\n+            }\n+            return;\n+        }\n+        if (local) {\n+            // Rename local variables with a new name\n+            String tempName = LOCAL_VAR_PREFIX + var.getLocalIndex();\n+            incCount(tempName, null);\n+            localNameNodes.add(n);\n+            localTempNames.add(tempName);\n+        } else if (var != null && !var.isExtern()) {\n+            // If it's a global variable, increment global count\n+            incCount(name, var.getNode().getSourceFileName());\n+            globalNameNodes.add(n);\n+        }\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        var.setName(tempName);   // Rename variable\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -36,6 +36,7 @@\n     if (local) {\n         // Local var: assign a new name\n         String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n+        var.setName(tempName);   // Rename variable\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0 || NodeUtil.isFunctionExpression(n)) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -5,7 +5,7 @@\n     }\n     String name = n.getString();\n     // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    if (name.length() == 0 || NodeUtil.isFunctionExpression(n)) {\n         return;\n     }\n     // Is this local or Global?\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getToken() != Token.NAME || !NodeUtil.isValidSimpleName(n)) {\n        return;\n    }\n\n    String name = n.getString();\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = var != null && var.isLocal();\n    // check if var can be renamed\n    if (!okToRenameVar(name, local)) {\n        return;\n    }\n\n    // Ignore anonymous functions\n    if (NodeUtil.isFunctionExpression(n) && !NodeUtil.isNamedFunctionExpression(n)) {\n        return;\n    }\n\n    if (local) {\n        // local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else {\n        // global var\n        // increment global count\n        incCount(name, var == null ? null : var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,48 +1,32 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n+    if (n.getToken() != Token.NAME || !NodeUtil.isValidSimpleName(n)) {\n         return;\n     }\n+\n     String name = n.getString();\n-    // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    Scope.Var var = t.getScope().getVar(name);\n+    boolean local = var != null && var.isLocal();\n+    // check if var can be renamed\n+    if (!okToRenameVar(name, local)) {\n         return;\n     }\n-    // Is this local or Global?\n-    Scope.Var var = t.getScope().getVar(name);\n-    boolean local = (var != null) && var.isLocal();\n-    // Are we renaming global variables?\n-    if (!local && localRenamingOnly) {\n-        reservedNames.add(name);\n+\n+    // Ignore anonymous functions\n+    if (NodeUtil.isFunctionExpression(n) && !NodeUtil.isNamedFunctionExpression(n)) {\n         return;\n     }\n-    // Are we renaming anonymous function names?\n-    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n-        reservedNames.add(name);\n-        return;\n-    }\n-    // Check if we can rename this.\n-    if (!okToRenameVar(name, local)) {\n-        // Blindly de-uniquify for the Prototype library for issue 103.\n-        return;\n-    }\n-    if (isExternsPass_) {\n-        // Keep track of extern globals.\n-        if (!local) {\n-            externNames.add(name);\n-        }\n-        return;\n-    }\n+\n     if (local) {\n-        // Local var: assign a new name\n+        // local var: assign a new name\n         String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n-    } else if (var != null) {\n-        // Not an extern\n-        // If it's global, increment global count\n-        incCount(name, var.input);\n+    } else {\n+        // global var\n+        // increment global count\n+        incCount(name, var == null ? null : var.input);\n         globalNameNodes.add(n);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null && !var.isExtern()) { // Check if variable is not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -39,8 +39,7 @@\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n-    } else if (var != null) {\n-        // Not an extern\n+    } else if (var != null && !var.isExtern()) { // Check if variable is not an extern\n         // If it's global, increment global count\n         incCount(name, var.input);\n         globalNameNodes.add(n);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n        // rename the variable with tempName\n        n.setString(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -39,6 +39,8 @@\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n+        // rename the variable with tempName\n+        n.setString(tempName);\n     } else if (var != null) {\n         // Not an extern\n         // If it's global, increment global count\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME || NodeUtil.isLabelName(n)) { // Check if node is a label\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.isEmpty() || NodeUtil.isNameAnonymousFunction(parent)) { // Check if parent is an anonymous function\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -1,11 +1,11 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (n.getType() != Token.NAME) {\n+    if (n.getType() != Token.NAME || NodeUtil.isLabelName(n)) { // Check if node is a label\n         return;\n     }\n     String name = n.getString();\n     // Ignore anonymous functions\n-    if (name.length() == 0) {\n+    if (name.isEmpty() || NodeUtil.isNameAnonymousFunction(parent)) { // Check if parent is an anonymous function\n         return;\n     }\n     // Is this local or Global?\n@@ -23,7 +23,6 @@\n     }\n     // Check if we can rename this.\n     if (!okToRenameVar(name, local)) {\n-        // Blindly de-uniquify for the Prototype library for issue 103.\n         return;\n     }\n     if (isExternsPass_) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        n.setString(tempName);  // set the new name on the node\n        localTempNames.add(tempName);\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n        n.setString(getNewName(name));  // set the new name on the node\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -38,11 +38,13 @@\n         String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n         incCount(tempName, null);\n         localNameNodes.add(n);\n+        n.setString(tempName);  // set the new name on the node\n         localTempNames.add(tempName);\n     } else if (var != null) {\n         // Not an extern\n         // If it's global, increment global count\n         incCount(name, var.input);\n         globalNameNodes.add(n);\n+        n.setString(getNewName(name));  // set the new name on the node\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n        return;\n    }\n    String name = n.getString();\n    // Ignore anonymous functions\n    if (name.length() == 0) {\n        return;\n    }\n    // Is this local or Global?\n    Scope.Var var = t.getScope().getVar(name);\n    boolean local = (var != null) && var.isLocal();\n    // Are we renaming global variables?\n    if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n    }\n    // Are we renaming anonymous function names?\n    if (preserveAnonymousFunctionNames && var != null && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n    }\n    // Check if we can rename this.\n    if (!okToRenameVar(name, local)) {\n        // Blindly de-uniquify for the Prototype library for issue 103.\n        return;\n    }\n    if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n            externNames.add(name);\n        }\n        return;\n    }\n    if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n        n.setString(tempName); // set the new name in the AST\n    } else if (var != null) {\n        // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n    }\n}", "diff": "--- com/google/javascript/jscomp/RenameVars.java@visit\n+++ com/google/javascript/jscomp/RenameVars.java@visit\n@@ -39,6 +39,7 @@\n         incCount(tempName, null);\n         localNameNodes.add(n);\n         localTempNames.add(tempName);\n+        n.setString(tempName); // set the new name in the AST\n     } else if (var != null) {\n         // Not an extern\n         // If it's global, increment global count\n", "finish_reason": "stop", "valid": false, "num": 1}]