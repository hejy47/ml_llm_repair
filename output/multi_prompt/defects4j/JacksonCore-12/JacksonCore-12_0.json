[{"output": "@Override\npublic final JsonToken nextToken() throws IOException {\n        if (_currToken == JsonToken.FIELD_NAME) {\n        return _nextAfterName();\n    }\n    // But if we didn't already have a name, and (partially?) decode number,\n    // need to ensure no numeric information is leaked\n    _numTypesValid = NR_UNKNOWN;\n    if (_tokenIncomplete) {\n        // only strings can be partial\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        // end-of-input\n        close();\n        return (_currToken = null);\n    }\n    // clear any data retained so far\n    _binaryValue = null;\n    // Closing scope?\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_ARRAY);\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_OBJECT);\n    }\n    // Nope: do we then expect a comma?\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n        if (i < 0) {\n            close();\n            return (_currToken = null);\n        }\n    }\n    _updateLocation();\n    boolean inObject = _parsingContext.inObject();\n    if (inObject) {\n        // First, field name itself:\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        if (i < 0) {\n            close();\n            return (_currToken = null);\n        }\n        _updateLocation();\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n                        t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    if (inObject) {\n        _nextToken = t;\n        return _currToken;\n    }\n    _currToken = t;\n    return t;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -13,7 +13,7 @@\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n         // end-of-input\n-                close();\n+        close();\n         return (_currToken = null);\n     }\n     // clear any data retained so far\n@@ -38,15 +38,24 @@\n     // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n+        if (i < 0) {\n+            close();\n+            return (_currToken = null);\n+        }\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n+    boolean inObject = _parsingContext.inObject();\n     if (inObject) {\n         // First, field name itself:\n         String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n         _parsingContext.setCurrentName(name);\n         _currToken = JsonToken.FIELD_NAME;\n         i = _skipColon();\n+        if (i < 0) {\n+            close();\n+            return (_currToken = null);\n+        }\n+        _updateLocation();\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,29 +1,31 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public final JsonToken nextToken() throws IOException {\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return false;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -31,44 +33,89 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n+        if (i < 0) {\n+            close();\n+            return (_currToken = null);\n+        }\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+        if (i < 0) {\n+            close();\n+            return (_currToken = null);\n+        }\n+        _updateLocation();\n     }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n             }\n-        }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+                        t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,29 +1,31 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public final JsonToken nextToken() throws IOException {\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return null;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -31,31 +33,68 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n+        if (i < 0) {\n+            close();\n+            return (_currToken = null);\n+        }\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+        if (i < 0) {\n+            close();\n+            return (_currToken = null);\n+        }\n+        _updateLocation();\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n         case '-':\n-            t = _parseNegNumber();\n+                        t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n@@ -69,28 +108,14 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    _nextToken = t;\n-    return name;\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,121 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public final JsonToken nextToken() throws IOException {\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+        if (i < 0) {\n+            close();\n+            return (_currToken = null);\n+        }\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+        if (i < 0) {\n+            close();\n+            return (_currToken = null);\n+        }\n+        _updateLocation();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+                        t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,121 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+public final JsonToken nextToken() throws IOException {\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+        if (i < 0) {\n+            close();\n+            return (_currToken = null);\n+        }\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+        if (i < 0) {\n+            close();\n+            return (_currToken = null);\n+        }\n+        _updateLocation();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+                        t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic final JsonToken nextToken() throws IOException {\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return _nextAfterName();\n    }\n    _numTypesValid = NR_UNKNOWN;\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        return (_currToken = null);\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_ARRAY);\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_OBJECT);\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    boolean inObject = _parsingContext.inObject();\n    if (inObject) {\n        String name;\n        if (i == INT_QUOTE) {\n            name = _parseName();\n        } else if (i == INT_EMBEDDED_OBJECT) {\n            name = _handleOddName(_skipWS());\n        } else {\n            _reportUnexpectedChar(i, \"expected JSON String\");\n            name = null; // never gets here\n        }\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n    }\n    JsonToken t;\n    switch(i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n            t = _parseNumber2(false);\n            break;\n        case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    if (inObject) {\n        _nextToken = t;\n        return _currToken;\n    }\n    _currToken = t;\n    return t;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,24 +1,18 @@\n @Override\n public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n         return _nextAfterName();\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n+        close();\n         return (_currToken = null);\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n@@ -35,20 +29,25 @@\n         _parsingContext = _parsingContext.getParent();\n         return (_currToken = JsonToken.END_OBJECT);\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n+    boolean inObject = _parsingContext.inObject();\n     if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        String name;\n+        if (i == INT_QUOTE) {\n+            name = _parseName();\n+        } else if (i == INT_EMBEDDED_OBJECT) {\n+            name = _handleOddName(_skipWS());\n+        } else {\n+            _reportUnexpectedChar(i, \"expected JSON String\");\n+            name = null; // never gets here\n+        }\n         _parsingContext.setCurrentName(name);\n         _currToken = JsonToken.FIELD_NAME;\n         i = _skipColon();\n     }\n-    // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n         case '\"':\n@@ -69,8 +68,6 @@\n             break;\n         case ']':\n         case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n             _reportUnexpectedChar(i, \"expected a value\");\n         case 't':\n             _matchTrue();\n@@ -85,18 +82,13 @@\n             t = JsonToken.VALUE_NULL;\n             break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n+            t = _parseNumber2(false);\n+            break;\n+        case '1': case '2': case '3': case '4': case '5':\n+        case '6': case '7': case '8': case '9':\n             t = _parsePosNumber(i);\n             break;\n         default:\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,19 +1,16 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n-    }\n     if (_tokenIncomplete) {\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n         close();\n-        _currToken = null;\n-        return false;\n+        return (_currToken = null);\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -22,8 +19,7 @@\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -31,44 +27,78 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        String name;\n+        if (i == INT_QUOTE) {\n+            name = _parseName();\n+        } else if (i == INT_EMBEDDED_OBJECT) {\n+            name = _handleOddName(_skipWS());\n+        } else {\n+            _reportUnexpectedChar(i, \"expected JSON String\");\n+            name = null; // never gets here\n+        }\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n             }\n-        }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            _reportUnexpectedChar(i, \"expected a value\");\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+            t = _parseNumber2(false);\n+            break;\n+        case '1': case '2': case '3': case '4': case '5':\n+        case '6': case '7': case '8': case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,19 +1,16 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n-    }\n     if (_tokenIncomplete) {\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n         close();\n-        _currToken = null;\n-        return null;\n+        return (_currToken = null);\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -22,8 +19,7 @@\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -31,43 +27,51 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        String name;\n+        if (i == INT_QUOTE) {\n+            name = _parseName();\n+        } else if (i == INT_EMBEDDED_OBJECT) {\n+            name = _handleOddName(_skipWS());\n+        } else {\n+            _reportUnexpectedChar(i, \"expected JSON String\");\n+            name = null; // never gets here\n+        }\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n             break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            _reportUnexpectedChar(i, \"expected a value\");\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n             break;\n         case 'f':\n             _matchFalse();\n@@ -77,20 +81,24 @@\n             _matchNull();\n             t = JsonToken.VALUE_NULL;\n             break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n+        case '-':\n+            t = _parseNegNumber();\n             break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n+        case '0':\n+            t = _parseNumber2(false);\n             break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n+        case '1': case '2': case '3': case '4': case '5':\n+        case '6': case '7': case '8': case '9':\n+            t = _parsePosNumber(i);\n             break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    _nextToken = t;\n-    return name;\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,104 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        return (_currToken = null);\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        String name;\n+        if (i == INT_QUOTE) {\n+            name = _parseName();\n+        } else if (i == INT_EMBEDDED_OBJECT) {\n+            name = _handleOddName(_skipWS());\n+        } else {\n+            _reportUnexpectedChar(i, \"expected JSON String\");\n+            name = null; // never gets here\n+        }\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            _reportUnexpectedChar(i, \"expected a value\");\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+            t = _parseNumber2(false);\n+            break;\n+        case '1': case '2': case '3': case '4': case '5':\n+        case '6': case '7': case '8': case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,104 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public final JsonToken nextToken() throws IOException {\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return _nextAfterName();\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        return (_currToken = null);\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        String name;\n+        if (i == INT_QUOTE) {\n+            name = _parseName();\n+        } else if (i == INT_EMBEDDED_OBJECT) {\n+            name = _handleOddName(_skipWS());\n+        } else {\n+            _reportUnexpectedChar(i, \"expected JSON String\");\n+            name = null; // never gets here\n+        }\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            _reportUnexpectedChar(i, \"expected a value\");\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+            t = _parseNumber2(false);\n+            break;\n+        case '1': case '2': case '3': case '4': case '5':\n+        case '6': case '7': case '8': case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "Unfortunately, as an AI language model, I cannot access the JacksonCore project to provide a fixed function for the buggy one. Can you please provide more details about the specific bug and what the function is supposed to do?", "diff": "", "finish_reason": "stop", "valid": false, "num": 7}, {"output": "@Override\npublic final JsonToken nextToken() throws IOException {\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return _nextAfterName();\n    }\n    // But if we didn't already have a name, and (partially?) decode number,\n    // need to ensure no numeric information is leaked\n    _numTypesValid = NR_UNKNOWN;\n    if (_tokenIncomplete) {\n        // only strings can be partial\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        // end-of-input\n        close();\n        return (_currToken = null);\n    }\n    // clear any data retained so far\n    _binaryValue = null;\n    // Closing scope?\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker('}', ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_ARRAY);\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(']', '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_OBJECT);\n    }\n    // Nope: do we then expect a comma?\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    boolean inObject = _parsingContext.inObject();\n    if (inObject) {\n        // First, field name itself:\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n            return null;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    if (inObject) {\n        _nextToken = t;\n        return _currToken;\n    }\n    _currToken = t;\n    return t;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,6 +1,6 @@\n @Override\n public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n         return _nextAfterName();\n     }\n     // But if we didn't already have a name, and (partially?) decode number,\n@@ -13,7 +13,7 @@\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n         // end-of-input\n-                close();\n+        close();\n         return (_currToken = null);\n     }\n     // clear any data retained so far\n@@ -22,7 +22,7 @@\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker('}', ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n         return (_currToken = JsonToken.END_ARRAY);\n@@ -30,7 +30,7 @@\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(']', '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n         return (_currToken = JsonToken.END_OBJECT);\n@@ -40,7 +40,7 @@\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n+    boolean inObject = _parsingContext.inObject();\n     if (inObject) {\n         // First, field name itself:\n         String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n@@ -72,6 +72,7 @@\n             // Error: neither is valid at this point; valid closers have\n             // been handled earlier\n             _reportUnexpectedChar(i, \"expected a value\");\n+            return null;\n         case 't':\n             _matchTrue();\n             t = JsonToken.VALUE_TRUE;\n@@ -85,7 +86,7 @@\n             t = JsonToken.VALUE_NULL;\n             break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,113 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return false;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker('}', ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(']', '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n             }\n-        }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            return null;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,59 +1,90 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return null;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker('}', ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(']', '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            return null;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n         case '-':\n             t = _parseNegNumber();\n             break;\n@@ -69,28 +100,14 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    _nextToken = t;\n-    return name;\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,113 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker('}', ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(']', '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            return null;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,113 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public final JsonToken nextToken() throws IOException {\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return _nextAfterName();\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker('}', ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(']', '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            return null;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic final JsonToken nextToken() throws IOException {\n        if (_currToken == JsonToken.FIELD_NAME) {\n        return _nextAfterName();\n    }\n    _numTypesValid = NR_UNKNOWN;\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        return (_currToken = null);\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_ARRAY);\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_OBJECT);\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    boolean inObject = _parsingContext.inObject();\n    if (inObject) {\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n    }\n    JsonToken t;\n    switch(i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n            // Error: cannot have closing bracket outside of array\n            _reportUnexpectedChar(i, \"expected a value\");\n            break;\n        case '}':\n            // Error: cannot have closing bracket outside of object\n            _reportUnexpectedChar(i, \"expected a value\");\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    if (inObject) {\n        _nextToken = t;\n        return _currToken;\n    }\n    _currToken = t;\n    return t;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -3,22 +3,16 @@\n         if (_currToken == JsonToken.FIELD_NAME) {\n         return _nextAfterName();\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n+        close();\n         return (_currToken = null);\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n@@ -35,20 +29,17 @@\n         _parsingContext = _parsingContext.getParent();\n         return (_currToken = JsonToken.END_OBJECT);\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n+    boolean inObject = _parsingContext.inObject();\n     if (inObject) {\n-        // First, field name itself:\n         String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n         _parsingContext.setCurrentName(name);\n         _currToken = JsonToken.FIELD_NAME;\n         i = _skipColon();\n     }\n-    // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n         case '\"':\n@@ -68,10 +59,13 @@\n             t = JsonToken.START_OBJECT;\n             break;\n         case ']':\n+            // Error: cannot have closing bracket outside of array\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            break;\n         case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n+            // Error: cannot have closing bracket outside of object\n             _reportUnexpectedChar(i, \"expected a value\");\n+            break;\n         case 't':\n             _matchTrue();\n             t = JsonToken.VALUE_TRUE;\n@@ -85,7 +79,7 @@\n             t = JsonToken.VALUE_NULL;\n             break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,19 +1,16 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public final JsonToken nextToken() throws IOException {\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n-    }\n     if (_tokenIncomplete) {\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n         close();\n-        _currToken = null;\n-        return false;\n+        return (_currToken = null);\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -22,8 +19,7 @@\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -31,44 +27,80 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n             }\n-        }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+            // Error: cannot have closing bracket outside of array\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            break;\n+        case '}':\n+            // Error: cannot have closing bracket outside of object\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,19 +1,16 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public final JsonToken nextToken() throws IOException {\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n-    }\n     if (_tokenIncomplete) {\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n         close();\n-        _currToken = null;\n-        return null;\n+        return (_currToken = null);\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -22,8 +19,7 @@\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -31,29 +27,57 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+            // Error: cannot have closing bracket outside of array\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            break;\n+        case '}':\n+            // Error: cannot have closing bracket outside of object\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n         case '-':\n             t = _parseNegNumber();\n             break;\n@@ -69,28 +93,14 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    _nextToken = t;\n-    return name;\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,106 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public final JsonToken nextToken() throws IOException {\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        return (_currToken = null);\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+            // Error: cannot have closing bracket outside of array\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            break;\n+        case '}':\n+            // Error: cannot have closing bracket outside of object\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,106 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+public final JsonToken nextToken() throws IOException {\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        return (_currToken = null);\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+            // Error: cannot have closing bracket outside of array\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            break;\n+        case '}':\n+            // Error: cannot have closing bracket outside of object\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic final JsonToken nextToken() throws IOException {\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return _nextAfterName();\n    }\n    // But if we didn't already have a name, and (partially?) decode number,\n    // need to ensure no numeric information is leaked\n    _numTypesValid = NR_UNKNOWN;\n    if (_tokenIncomplete) {\n        // only strings can be partial\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        // end-of-input\n        close();\n        return (_currToken = null);\n    }\n    // clear any data retained so far\n    _binaryValue = null;\n    // Closing scope?\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, ']'); // Fix: changed '}' to ']'\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_ARRAY);\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, '}'); // Fix: changed ']' to '}'\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_OBJECT);\n    }\n    // Nope: do we then expect a comma?\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    boolean inObject = _parsingContext.inObject();\n    if (inObject) {\n        // First, field name itself:\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n            t = null; // Add default case to avoid null pointer exception\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    if (inObject) {\n        _nextToken = t;\n        return _currToken;\n    }\n    _currToken = t;\n    return t;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,6 +1,6 @@\n @Override\n public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n         return _nextAfterName();\n     }\n     // But if we didn't already have a name, and (partially?) decode number,\n@@ -13,7 +13,7 @@\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n         // end-of-input\n-                close();\n+        close();\n         return (_currToken = null);\n     }\n     // clear any data retained so far\n@@ -22,7 +22,7 @@\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']'); // Fix: changed '}' to ']'\n         }\n         _parsingContext = _parsingContext.getParent();\n         return (_currToken = JsonToken.END_ARRAY);\n@@ -30,7 +30,7 @@\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}'); // Fix: changed ']' to '}'\n         }\n         _parsingContext = _parsingContext.getParent();\n         return (_currToken = JsonToken.END_OBJECT);\n@@ -40,7 +40,7 @@\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n+    boolean inObject = _parsingContext.inObject();\n     if (inObject) {\n         // First, field name itself:\n         String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n@@ -72,6 +72,8 @@\n             // Error: neither is valid at this point; valid closers have\n             // been handled earlier\n             _reportUnexpectedChar(i, \"expected a value\");\n+            t = null; // Add default case to avoid null pointer exception\n+            break;\n         case 't':\n             _matchTrue();\n             t = JsonToken.VALUE_TRUE;\n@@ -85,7 +87,7 @@\n             t = JsonToken.VALUE_NULL;\n             break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,114 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return false;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']'); // Fix: changed '}' to ']'\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}'); // Fix: changed ']' to '}'\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n             }\n-        }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            t = null; // Add default case to avoid null pointer exception\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,59 +1,91 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return null;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']'); // Fix: changed '}' to ']'\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}'); // Fix: changed ']' to '}'\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            t = null; // Add default case to avoid null pointer exception\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n         case '-':\n             t = _parseNegNumber();\n             break;\n@@ -69,28 +101,14 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    _nextToken = t;\n-    return name;\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,114 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, ']'); // Fix: changed '}' to ']'\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, '}'); // Fix: changed ']' to '}'\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            t = null; // Add default case to avoid null pointer exception\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,114 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public final JsonToken nextToken() throws IOException {\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return _nextAfterName();\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, ']'); // Fix: changed '}' to ']'\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, '}'); // Fix: changed ']' to '}'\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            t = null; // Add default case to avoid null pointer exception\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic final JsonToken nextToken() throws IOException {\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return _nextAfterName();\n    }\n    // But if we didn't already have a name, and (partially?) decode number,\n    // need to ensure no numeric information is leaked\n    _numTypesValid = NR_UNKNOWN;\n    if (_tokenIncomplete) {\n        // only strings can be partial\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        // end-of-input\n        close();\n        return (_currToken = null);\n    }\n    // clear any data retained so far\n    _binaryValue = null;\n    // Closing scope?\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_ARRAY);\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_OBJECT);\n    }\n    // Nope: do we then expect a comma?\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    boolean inObject = _parsingContext.inObject();\n    if (inObject) {\n        // First, field name itself:\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n            if (!_parsingContext.inArray()) {\n                _reportUnexpectedChar(i, \"expected a value\");\n            }\n            // there is an edge case where multiple ] characters can be encountered\n            // https://github.com/FasterXML/jackson-core/issues/369\n            if (!inObject) {\n                _parsingContext = _parsingContext.getParent();\n            }\n            t = JsonToken.END_ARRAY;\n            break;\n        case '}':\n            if (!_parsingContext.inObject()) {\n                _reportUnexpectedChar(i, \"expected a value\");\n            }\n            if (!inObject) {\n                _parsingContext = _parsingContext.getParent();\n            }\n            t = JsonToken.END_OBJECT;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    if (inObject) {\n        _nextToken = t;\n        return _currToken;\n    }\n    _currToken = t;\n    return t;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,6 +1,6 @@\n @Override\n public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n         return _nextAfterName();\n     }\n     // But if we didn't already have a name, and (partially?) decode number,\n@@ -13,7 +13,7 @@\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n         // end-of-input\n-                close();\n+        close();\n         return (_currToken = null);\n     }\n     // clear any data retained so far\n@@ -22,7 +22,7 @@\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n         return (_currToken = JsonToken.END_ARRAY);\n@@ -30,7 +30,7 @@\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n         return (_currToken = JsonToken.END_OBJECT);\n@@ -40,7 +40,7 @@\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n+    boolean inObject = _parsingContext.inObject();\n     if (inObject) {\n         // First, field name itself:\n         String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n@@ -68,10 +68,25 @@\n             t = JsonToken.START_OBJECT;\n             break;\n         case ']':\n+            if (!_parsingContext.inArray()) {\n+                _reportUnexpectedChar(i, \"expected a value\");\n+            }\n+            // there is an edge case where multiple ] characters can be encountered\n+            // https://github.com/FasterXML/jackson-core/issues/369\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.getParent();\n+            }\n+            t = JsonToken.END_ARRAY;\n+            break;\n         case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n+            if (!_parsingContext.inObject()) {\n+                _reportUnexpectedChar(i, \"expected a value\");\n+            }\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.getParent();\n+            }\n+            t = JsonToken.END_OBJECT;\n+            break;\n         case 't':\n             _matchTrue();\n             t = JsonToken.VALUE_TRUE;\n@@ -85,7 +100,7 @@\n             t = JsonToken.VALUE_NULL;\n             break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,127 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return false;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n             }\n-        }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+            if (!_parsingContext.inArray()) {\n+                _reportUnexpectedChar(i, \"expected a value\");\n+            }\n+            // there is an edge case where multiple ] characters can be encountered\n+            // https://github.com/FasterXML/jackson-core/issues/369\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.getParent();\n+            }\n+            t = JsonToken.END_ARRAY;\n+            break;\n+        case '}':\n+            if (!_parsingContext.inObject()) {\n+                _reportUnexpectedChar(i, \"expected a value\");\n+            }\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.getParent();\n+            }\n+            t = JsonToken.END_OBJECT;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,59 +1,104 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return null;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+            if (!_parsingContext.inArray()) {\n+                _reportUnexpectedChar(i, \"expected a value\");\n+            }\n+            // there is an edge case where multiple ] characters can be encountered\n+            // https://github.com/FasterXML/jackson-core/issues/369\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.getParent();\n+            }\n+            t = JsonToken.END_ARRAY;\n+            break;\n+        case '}':\n+            if (!_parsingContext.inObject()) {\n+                _reportUnexpectedChar(i, \"expected a value\");\n+            }\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.getParent();\n+            }\n+            t = JsonToken.END_OBJECT;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n         case '-':\n             t = _parseNegNumber();\n             break;\n@@ -69,28 +114,14 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    _nextToken = t;\n-    return name;\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,127 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+            if (!_parsingContext.inArray()) {\n+                _reportUnexpectedChar(i, \"expected a value\");\n+            }\n+            // there is an edge case where multiple ] characters can be encountered\n+            // https://github.com/FasterXML/jackson-core/issues/369\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.getParent();\n+            }\n+            t = JsonToken.END_ARRAY;\n+            break;\n+        case '}':\n+            if (!_parsingContext.inObject()) {\n+                _reportUnexpectedChar(i, \"expected a value\");\n+            }\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.getParent();\n+            }\n+            t = JsonToken.END_OBJECT;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,127 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public final JsonToken nextToken() throws IOException {\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return _nextAfterName();\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+            if (!_parsingContext.inArray()) {\n+                _reportUnexpectedChar(i, \"expected a value\");\n+            }\n+            // there is an edge case where multiple ] characters can be encountered\n+            // https://github.com/FasterXML/jackson-core/issues/369\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.getParent();\n+            }\n+            t = JsonToken.END_ARRAY;\n+            break;\n+        case '}':\n+            if (!_parsingContext.inObject()) {\n+                _reportUnexpectedChar(i, \"expected a value\");\n+            }\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.getParent();\n+            }\n+            t = JsonToken.END_OBJECT;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic final JsonToken nextToken() throws IOException {\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return _nextAfterName();\n    }\n    // But if we didn't already have a name, and (partially?) decode number,\n    // need to ensure no numeric information is leaked\n    _numTypesValid = NR_UNKNOWN;\n    if (_tokenIncomplete) {\n        // only strings can be partial\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        // end-of-input\n        close();\n        return (_currToken = null);\n    }\n    // clear any data retained so far\n    _binaryValue = null;\n    // Closing scope?\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_ARRAY);\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_OBJECT);\n    }\n    // Nope: do we then expect a comma?\n    if (_parsingContext.expectComma() && i != INT_COMMA) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    boolean inObject = _parsingContext.inObject();\n\n    if (inObject && (i == INT_RBRACKET || i == INT_RCURLY)) {\n        // End of an object or an array, return END_OBJECT or END_ARRAY prematurely\n        // based on what we see\n        if (!_parsingContext.hasExpectedPartiallyFinishedEndObject()) {\n            _reportUnexpectedChar(i, \"expected closing END_OBJECT or END_ARRAY\");\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = (i == INT_RBRACKET) ? JsonToken.END_ARRAY : JsonToken.END_OBJECT);\n    }\n    // Start handling value tokens\n    if (inObject) {\n        // First: field name\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n        _updateLocation();\n    }\n    switch (i) {\n    case INT_QUOTE:\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return _currToken;\n    case INT_LBRACKET:\n        if (!inObject) {\n            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n        }\n        _currToken = JsonToken.START_ARRAY;\n        return _currToken;\n    case INT_LCURLY:\n        if (!inObject) {\n            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n        }\n        _currToken = JsonToken.START_OBJECT;\n        return _currToken;\n    case INT_RBRACKET:\n    case INT_RCURLY:\n        _reportUnexpectedChar(i, \"expected a value\");\n        break;\n    case INT_t:\n        _matchTrue();\n        _nextToken = JsonToken.VALUE_TRUE;\n        return _currToken;\n    case INT_f:\n        _matchFalse();\n        _nextToken = JsonToken.VALUE_FALSE;\n        return _currToken;\n    case INT_n:\n        _matchNull();\n        _nextToken = JsonToken.VALUE_NULL;\n        return _currToken;\n    case INT_MINUS:\n        _nextToken = _parseNegNumber();\n        return _currToken;\n    case INT_0:\n    case INT_1:\n    case INT_2:\n    case INT_3:\n    case INT_4:\n    case INT_5:\n    case INT_6:\n    case INT_7:\n    case INT_8:\n    case INT_9:\n        _nextToken = _parsePosNumber(i);\n        return _currToken;\n    default:\n        _nextToken = _handleOddValue(i);\n        return _currToken;\n    }\n    // shouldn't get here\n    return null;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,6 +1,6 @@\n @Override\n public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n         return _nextAfterName();\n     }\n     // But if we didn't already have a name, and (partially?) decode number,\n@@ -13,7 +13,7 @@\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n         // end-of-input\n-                close();\n+        close();\n         return (_currToken = null);\n     }\n     // clear any data retained so far\n@@ -22,7 +22,7 @@\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n         return (_currToken = JsonToken.END_ARRAY);\n@@ -30,83 +30,88 @@\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n         return (_currToken = JsonToken.END_OBJECT);\n     }\n     // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n+    if (_parsingContext.expectComma() && i != INT_COMMA) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n+    boolean inObject = _parsingContext.inObject();\n+\n+    if (inObject && (i == INT_RBRACKET || i == INT_RCURLY)) {\n+        // End of an object or an array, return END_OBJECT or END_ARRAY prematurely\n+        // based on what we see\n+        if (!_parsingContext.hasExpectedPartiallyFinishedEndObject()) {\n+            _reportUnexpectedChar(i, \"expected closing END_OBJECT or END_ARRAY\");\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = (i == INT_RBRACKET) ? JsonToken.END_ARRAY : JsonToken.END_OBJECT);\n+    }\n+    // Start handling value tokens\n     if (inObject) {\n-        // First, field name itself:\n+        // First: field name\n         String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n         _parsingContext.setCurrentName(name);\n         _currToken = JsonToken.FIELD_NAME;\n         i = _skipColon();\n+        _updateLocation();\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n+    switch (i) {\n+    case INT_QUOTE:\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return _currToken;\n+    case INT_LBRACKET:\n+        if (!inObject) {\n+            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+        }\n+        _currToken = JsonToken.START_ARRAY;\n+        return _currToken;\n+    case INT_LCURLY:\n+        if (!inObject) {\n+            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+        }\n+        _currToken = JsonToken.START_OBJECT;\n+        return _currToken;\n+    case INT_RBRACKET:\n+    case INT_RCURLY:\n+        _reportUnexpectedChar(i, \"expected a value\");\n+        break;\n+    case INT_t:\n+        _matchTrue();\n+        _nextToken = JsonToken.VALUE_TRUE;\n+        return _currToken;\n+    case INT_f:\n+        _matchFalse();\n+        _nextToken = JsonToken.VALUE_FALSE;\n+        return _currToken;\n+    case INT_n:\n+        _matchNull();\n+        _nextToken = JsonToken.VALUE_NULL;\n+        return _currToken;\n+    case INT_MINUS:\n+        _nextToken = _parseNegNumber();\n+        return _currToken;\n+    case INT_0:\n+    case INT_1:\n+    case INT_2:\n+    case INT_3:\n+    case INT_4:\n+    case INT_5:\n+    case INT_6:\n+    case INT_7:\n+    case INT_8:\n+    case INT_9:\n+        _nextToken = _parsePosNumber(i);\n+        return _currToken;\n+    default:\n+        _nextToken = _handleOddValue(i);\n         return _currToken;\n     }\n-    _currToken = t;\n-    return t;\n+    // shouldn't get here\n+    return null;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,117 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return false;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n-    if (_parsingContext.expectComma()) {\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma() && i != INT_COMMA) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n+    boolean inObject = _parsingContext.inObject();\n+\n+    if (inObject && (i == INT_RBRACKET || i == INT_RCURLY)) {\n+        // End of an object or an array, return END_OBJECT or END_ARRAY prematurely\n+        // based on what we see\n+        if (!_parsingContext.hasExpectedPartiallyFinishedEndObject()) {\n+            _reportUnexpectedChar(i, \"expected closing END_OBJECT or END_ARRAY\");\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = (i == INT_RBRACKET) ? JsonToken.END_ARRAY : JsonToken.END_OBJECT);\n     }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n+    // Start handling value tokens\n+    if (inObject) {\n+        // First: field name\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+        _updateLocation();\n+    }\n+    switch (i) {\n+    case INT_QUOTE:\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return _currToken;\n+    case INT_LBRACKET:\n+        if (!inObject) {\n+            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n         }\n+        _currToken = JsonToken.START_ARRAY;\n+        return _currToken;\n+    case INT_LCURLY:\n+        if (!inObject) {\n+            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+        }\n+        _currToken = JsonToken.START_OBJECT;\n+        return _currToken;\n+    case INT_RBRACKET:\n+    case INT_RCURLY:\n+        _reportUnexpectedChar(i, \"expected a value\");\n+        break;\n+    case INT_t:\n+        _matchTrue();\n+        _nextToken = JsonToken.VALUE_TRUE;\n+        return _currToken;\n+    case INT_f:\n+        _matchFalse();\n+        _nextToken = JsonToken.VALUE_FALSE;\n+        return _currToken;\n+    case INT_n:\n+        _matchNull();\n+        _nextToken = JsonToken.VALUE_NULL;\n+        return _currToken;\n+    case INT_MINUS:\n+        _nextToken = _parseNegNumber();\n+        return _currToken;\n+    case INT_0:\n+    case INT_1:\n+    case INT_2:\n+    case INT_3:\n+    case INT_4:\n+    case INT_5:\n+    case INT_6:\n+    case INT_7:\n+    case INT_8:\n+    case INT_9:\n+        _nextToken = _parsePosNumber(i);\n+        return _currToken;\n+    default:\n+        _nextToken = _handleOddValue(i);\n+        return _currToken;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    // shouldn't get here\n+    return null;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,117 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return null;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n-    if (_parsingContext.expectComma()) {\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma() && i != INT_COMMA) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n+    boolean inObject = _parsingContext.inObject();\n+\n+    if (inObject && (i == INT_RBRACKET || i == INT_RCURLY)) {\n+        // End of an object or an array, return END_OBJECT or END_ARRAY prematurely\n+        // based on what we see\n+        if (!_parsingContext.hasExpectedPartiallyFinishedEndObject()) {\n+            _reportUnexpectedChar(i, \"expected closing END_OBJECT or END_ARRAY\");\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = (i == INT_RBRACKET) ? JsonToken.END_ARRAY : JsonToken.END_OBJECT);\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n+    // Start handling value tokens\n+    if (inObject) {\n+        // First: field name\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+        _updateLocation();\n+    }\n+    switch (i) {\n+    case INT_QUOTE:\n         _tokenIncomplete = true;\n         _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        return _currToken;\n+    case INT_LBRACKET:\n+        if (!inObject) {\n+            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+        }\n+        _currToken = JsonToken.START_ARRAY;\n+        return _currToken;\n+    case INT_LCURLY:\n+        if (!inObject) {\n+            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+        }\n+        _currToken = JsonToken.START_OBJECT;\n+        return _currToken;\n+    case INT_RBRACKET:\n+    case INT_RCURLY:\n+        _reportUnexpectedChar(i, \"expected a value\");\n+        break;\n+    case INT_t:\n+        _matchTrue();\n+        _nextToken = JsonToken.VALUE_TRUE;\n+        return _currToken;\n+    case INT_f:\n+        _matchFalse();\n+        _nextToken = JsonToken.VALUE_FALSE;\n+        return _currToken;\n+    case INT_n:\n+        _matchNull();\n+        _nextToken = JsonToken.VALUE_NULL;\n+        return _currToken;\n+    case INT_MINUS:\n+        _nextToken = _parseNegNumber();\n+        return _currToken;\n+    case INT_0:\n+    case INT_1:\n+    case INT_2:\n+    case INT_3:\n+    case INT_4:\n+    case INT_5:\n+    case INT_6:\n+    case INT_7:\n+    case INT_8:\n+    case INT_9:\n+        _nextToken = _parsePosNumber(i);\n+        return _currToken;\n+    default:\n+        _nextToken = _handleOddValue(i);\n+        return _currToken;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    // shouldn't get here\n+    return null;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,117 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma() && i != INT_COMMA) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+\n+    if (inObject && (i == INT_RBRACKET || i == INT_RCURLY)) {\n+        // End of an object or an array, return END_OBJECT or END_ARRAY prematurely\n+        // based on what we see\n+        if (!_parsingContext.hasExpectedPartiallyFinishedEndObject()) {\n+            _reportUnexpectedChar(i, \"expected closing END_OBJECT or END_ARRAY\");\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = (i == INT_RBRACKET) ? JsonToken.END_ARRAY : JsonToken.END_OBJECT);\n+    }\n+    // Start handling value tokens\n+    if (inObject) {\n+        // First: field name\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+        _updateLocation();\n+    }\n+    switch (i) {\n+    case INT_QUOTE:\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return _currToken;\n+    case INT_LBRACKET:\n+        if (!inObject) {\n+            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+        }\n+        _currToken = JsonToken.START_ARRAY;\n+        return _currToken;\n+    case INT_LCURLY:\n+        if (!inObject) {\n+            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+        }\n+        _currToken = JsonToken.START_OBJECT;\n+        return _currToken;\n+    case INT_RBRACKET:\n+    case INT_RCURLY:\n+        _reportUnexpectedChar(i, \"expected a value\");\n+        break;\n+    case INT_t:\n+        _matchTrue();\n+        _nextToken = JsonToken.VALUE_TRUE;\n+        return _currToken;\n+    case INT_f:\n+        _matchFalse();\n+        _nextToken = JsonToken.VALUE_FALSE;\n+        return _currToken;\n+    case INT_n:\n+        _matchNull();\n+        _nextToken = JsonToken.VALUE_NULL;\n+        return _currToken;\n+    case INT_MINUS:\n+        _nextToken = _parseNegNumber();\n+        return _currToken;\n+    case INT_0:\n+    case INT_1:\n+    case INT_2:\n+    case INT_3:\n+    case INT_4:\n+    case INT_5:\n+    case INT_6:\n+    case INT_7:\n+    case INT_8:\n+    case INT_9:\n+        _nextToken = _parsePosNumber(i);\n+        return _currToken;\n+    default:\n+        _nextToken = _handleOddValue(i);\n+        return _currToken;\n+    }\n+    // shouldn't get here\n+    return null;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,117 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public final JsonToken nextToken() throws IOException {\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return _nextAfterName();\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma() && i != INT_COMMA) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+\n+    if (inObject && (i == INT_RBRACKET || i == INT_RCURLY)) {\n+        // End of an object or an array, return END_OBJECT or END_ARRAY prematurely\n+        // based on what we see\n+        if (!_parsingContext.hasExpectedPartiallyFinishedEndObject()) {\n+            _reportUnexpectedChar(i, \"expected closing END_OBJECT or END_ARRAY\");\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = (i == INT_RBRACKET) ? JsonToken.END_ARRAY : JsonToken.END_OBJECT);\n+    }\n+    // Start handling value tokens\n+    if (inObject) {\n+        // First: field name\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+        _updateLocation();\n+    }\n+    switch (i) {\n+    case INT_QUOTE:\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return _currToken;\n+    case INT_LBRACKET:\n+        if (!inObject) {\n+            _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+        }\n+        _currToken = JsonToken.START_ARRAY;\n+        return _currToken;\n+    case INT_LCURLY:\n+        if (!inObject) {\n+            _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+        }\n+        _currToken = JsonToken.START_OBJECT;\n+        return _currToken;\n+    case INT_RBRACKET:\n+    case INT_RCURLY:\n+        _reportUnexpectedChar(i, \"expected a value\");\n+        break;\n+    case INT_t:\n+        _matchTrue();\n+        _nextToken = JsonToken.VALUE_TRUE;\n+        return _currToken;\n+    case INT_f:\n+        _matchFalse();\n+        _nextToken = JsonToken.VALUE_FALSE;\n+        return _currToken;\n+    case INT_n:\n+        _matchNull();\n+        _nextToken = JsonToken.VALUE_NULL;\n+        return _currToken;\n+    case INT_MINUS:\n+        _nextToken = _parseNegNumber();\n+        return _currToken;\n+    case INT_0:\n+    case INT_1:\n+    case INT_2:\n+    case INT_3:\n+    case INT_4:\n+    case INT_5:\n+    case INT_6:\n+    case INT_7:\n+    case INT_8:\n+    case INT_9:\n+        _nextToken = _parsePosNumber(i);\n+        return _currToken;\n+    default:\n+        _nextToken = _handleOddValue(i);\n+        return _currToken;\n+    }\n+    // shouldn't get here\n+    return null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic final JsonToken nextToken() throws IOException {\n        if (_currToken == JsonToken.FIELD_NAME) {\n        return _nextAfterName();\n    }\n    // But if we didn't already have a name, and (partially?) decode number,\n    // need to ensure no numeric information is leaked\n    _numTypesValid = NR_UNKNOWN;\n    if (_tokenIncomplete) {\n        // only strings can be partial\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        // end-of-input\n                close();\n        return (_currToken = null);\n    }\n    // clear any data retained so far\n    _binaryValue = null;\n    // Closing scope?\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_ARRAY);\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_OBJECT);\n    }\n    // Nope: do we then expect a comma?\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    boolean inObject = _parsingContext.inObject();\n    if (inObject) {\n        // First, field name itself:\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n            _reportUnexpectedChar(i, \"expected a value\");\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            if (!_parsingContext.inObject()) {\n                _reportUnexpectedChar(i, \"expected a value\");\n            }\n            _parsingContext = _parsingContext.getParent();\n            t = JsonToken.END_OBJECT;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    if (inObject) {\n        _nextToken = t;\n        return _currToken;\n    }\n    _currToken = t;\n    return t;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -22,7 +22,7 @@\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n         return (_currToken = JsonToken.END_ARRAY);\n@@ -30,7 +30,7 @@\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n         return (_currToken = JsonToken.END_OBJECT);\n@@ -40,7 +40,7 @@\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n+    boolean inObject = _parsingContext.inObject();\n     if (inObject) {\n         // First, field name itself:\n         String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n@@ -68,10 +68,16 @@\n             t = JsonToken.START_OBJECT;\n             break;\n         case ']':\n+            _reportUnexpectedChar(i, \"expected a value\");\n         case '}':\n             // Error: neither is valid at this point; valid closers have\n             // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n+            if (!_parsingContext.inObject()) {\n+                _reportUnexpectedChar(i, \"expected a value\");\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            t = JsonToken.END_OBJECT;\n+            break;\n         case 't':\n             _matchTrue();\n             t = JsonToken.VALUE_TRUE;\n@@ -85,7 +91,7 @@\n             t = JsonToken.VALUE_NULL;\n             break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,118 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public final JsonToken nextToken() throws IOException {\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n+        // end-of-input\n+                close();\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n             }\n-        }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+            _reportUnexpectedChar(i, \"expected a value\");\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            if (!_parsingContext.inObject()) {\n+                _reportUnexpectedChar(i, \"expected a value\");\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            t = JsonToken.END_OBJECT;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,59 +1,95 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public final JsonToken nextToken() throws IOException {\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n+        // end-of-input\n+                close();\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+            _reportUnexpectedChar(i, \"expected a value\");\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            if (!_parsingContext.inObject()) {\n+                _reportUnexpectedChar(i, \"expected a value\");\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            t = JsonToken.END_OBJECT;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n         case '-':\n             t = _parseNegNumber();\n             break;\n@@ -69,28 +105,14 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    _nextToken = t;\n-    return name;\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,118 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public final JsonToken nextToken() throws IOException {\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+                close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+            _reportUnexpectedChar(i, \"expected a value\");\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            if (!_parsingContext.inObject()) {\n+                _reportUnexpectedChar(i, \"expected a value\");\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            t = JsonToken.END_OBJECT;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,118 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+public final JsonToken nextToken() throws IOException {\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+                close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+            _reportUnexpectedChar(i, \"expected a value\");\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            if (!_parsingContext.inObject()) {\n+                _reportUnexpectedChar(i, \"expected a value\");\n+            }\n+            _parsingContext = _parsingContext.getParent();\n+            t = JsonToken.END_OBJECT;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic final JsonToken nextToken() throws IOException {\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return _nextAfterName();\n    }\n    // But if we didn't already have a name, and (partially?) decode number,\n    // need to ensure no numeric information is leaked\n    _numTypesValid = NR_UNKNOWN;\n    if (_tokenIncomplete) { // Fix: Check if there are more tokens to consume\n        // only strings can be partial\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        // end-of-input\n        close();\n        return (_currToken = null);\n    }\n    // clear any data retained so far\n    _binaryValue = null;\n    // Closing scope?\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_ARRAY);\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_OBJECT);\n    }\n    // Nope: do we then expect a comma?\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    boolean inObject = _parsingContext.inObject();\n    if (inObject) {\n        // First, field name itself:\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n            return null; // Fix: Return null to avoid NullPointerException\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    if (inObject) {\n        _nextToken = t;\n        return _currToken;\n    }\n    _currToken = t;\n    return t;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,19 +1,19 @@\n @Override\n public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n         return _nextAfterName();\n     }\n     // But if we didn't already have a name, and (partially?) decode number,\n     // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n+    if (_tokenIncomplete) { // Fix: Check if there are more tokens to consume\n         // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n         // end-of-input\n-                close();\n+        close();\n         return (_currToken = null);\n     }\n     // clear any data retained so far\n@@ -40,7 +40,7 @@\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n+    boolean inObject = _parsingContext.inObject();\n     if (inObject) {\n         // First, field name itself:\n         String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n@@ -72,6 +72,7 @@\n             // Error: neither is valid at this point; valid closers have\n             // been handled earlier\n             _reportUnexpectedChar(i, \"expected a value\");\n+            return null; // Fix: Return null to avoid NullPointerException\n         case 't':\n             _matchTrue();\n             t = JsonToken.VALUE_TRUE;\n@@ -85,7 +86,7 @@\n             t = JsonToken.VALUE_NULL;\n             break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,29 +1,31 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n-    }\n-    if (_tokenIncomplete) {\n+    if (_tokenIncomplete) { // Fix: Check if there are more tokens to consume\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return false;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -31,44 +33,81 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n             }\n-        }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            return null; // Fix: Return null to avoid NullPointerException\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,29 +1,31 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n-    }\n-    if (_tokenIncomplete) {\n+    if (_tokenIncomplete) { // Fix: Check if there are more tokens to consume\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return null;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -31,29 +33,58 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            return null; // Fix: Return null to avoid NullPointerException\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n         case '-':\n             t = _parseNegNumber();\n             break;\n@@ -69,28 +100,14 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    _nextToken = t;\n-    return name;\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,113 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) { // Fix: Check if there are more tokens to consume\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            return null; // Fix: Return null to avoid NullPointerException\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,113 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public final JsonToken nextToken() throws IOException {\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return _nextAfterName();\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) { // Fix: Check if there are more tokens to consume\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            return null; // Fix: Return null to avoid NullPointerException\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic final JsonToken nextToken() throws IOException {\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return _nextAfterName();\n    }\n    // But if we didn't already have a name, and (partially?) decode number,\n    // need to ensure no numeric information is leaked\n    _numTypesValid = NR_UNKNOWN;\n    if (_tokenIncomplete) {\n        // only strings can be partial\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        // end-of-input\n        close();\n        return (_currToken = null);\n    }\n    // clear any data retained so far\n    _binaryValue = null;\n    // Closing scope?\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_ARRAY);\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_OBJECT);\n    }\n    // Nope: do we then expect a comma?\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    boolean inObject = _parsingContext.inObject();\n    if (inObject) {\n        // First, field name itself:\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        default:\n            if (i >= '0' && i <= '9') {\n                t = _parsePosNumber(i);\n            } else {\n                t = _handleOddValue(i);\n            }\n            break;\n    }\n    if (inObject) {\n        _nextToken = t;\n        return _currToken;\n    }\n    _currToken = t;\n    return t;\n} ", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,6 +1,6 @@\n @Override\n public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n         return _nextAfterName();\n     }\n     // But if we didn't already have a name, and (partially?) decode number,\n@@ -13,7 +13,7 @@\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n         // end-of-input\n-                close();\n+        close();\n         return (_currToken = null);\n     }\n     // clear any data retained so far\n@@ -22,7 +22,7 @@\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n         return (_currToken = JsonToken.END_ARRAY);\n@@ -30,7 +30,7 @@\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n         return (_currToken = JsonToken.END_OBJECT);\n@@ -40,7 +40,7 @@\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n+    boolean inObject = _parsingContext.inObject();\n     if (inObject) {\n         // First, field name itself:\n         String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n@@ -67,11 +67,6 @@\n             }\n             t = JsonToken.START_OBJECT;\n             break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n         case 't':\n             _matchTrue();\n             t = JsonToken.VALUE_TRUE;\n@@ -84,23 +79,12 @@\n             _matchNull();\n             t = JsonToken.VALUE_NULL;\n             break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n         default:\n-            t = _handleOddValue(i);\n+            if (i >= '0' && i <= '9') {\n+                t = _parsePosNumber(i);\n+            } else {\n+                t = _handleOddValue(i);\n+            }\n             break;\n     }\n     if (inObject) {\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,96 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return false;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n             }\n-        }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        default:\n+            if (i >= '0' && i <= '9') {\n+                t = _parsePosNumber(i);\n+            } else {\n+                t = _handleOddValue(i);\n+            }\n+            break;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,73 +1,75 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return null;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n             break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n             break;\n         case 'f':\n             _matchFalse();\n@@ -77,20 +79,18 @@\n             _matchNull();\n             t = JsonToken.VALUE_NULL;\n             break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n         default:\n-            t = _handleOddValue(i);\n+            if (i >= '0' && i <= '9') {\n+                t = _parsePosNumber(i);\n+            } else {\n+                t = _handleOddValue(i);\n+            }\n             break;\n     }\n-    _nextToken = t;\n-    return name;\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,96 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        default:\n+            if (i >= '0' && i <= '9') {\n+                t = _parsePosNumber(i);\n+            } else {\n+                t = _handleOddValue(i);\n+            }\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,96 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public final JsonToken nextToken() throws IOException {\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return _nextAfterName();\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        default:\n+            if (i >= '0' && i <= '9') {\n+                t = _parsePosNumber(i);\n+            } else {\n+                t = _handleOddValue(i);\n+            }\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic final JsonToken nextToken() throws IOException {\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return _nextAfterName();\n    }\n    // But if we didn't already have a name, and (partially?) decode number,\n    // need to ensure no numeric information is leaked\n    _numTypesValid = NR_UNKNOWN;\n    if (_tokenIncomplete) {\n        // only strings can be partial\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        // end-of-input\n        close();\n        return (_currToken = null);\n    }\n    // clear any data retained so far\n    _binaryValue = null;\n    // Closing scope?\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, ']'); // fix: changed '}' to ']'\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_ARRAY);\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_OBJECT);\n    }\n    // Nope: do we then expect a comma?\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    boolean inObject = _parsingContext.inObject();\n    if (inObject) {\n        // First, field name itself:\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n            // fix: add break statement after error reporting\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    if (inObject) {\n        _nextToken = t;\n        return _currToken;\n    }\n    _currToken = t;\n    return t;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,6 +1,6 @@\n @Override\n public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n         return _nextAfterName();\n     }\n     // But if we didn't already have a name, and (partially?) decode number,\n@@ -13,7 +13,7 @@\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n         // end-of-input\n-                close();\n+        close();\n         return (_currToken = null);\n     }\n     // clear any data retained so far\n@@ -22,7 +22,7 @@\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']'); // fix: changed '}' to ']'\n         }\n         _parsingContext = _parsingContext.getParent();\n         return (_currToken = JsonToken.END_ARRAY);\n@@ -30,7 +30,7 @@\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n         return (_currToken = JsonToken.END_OBJECT);\n@@ -40,7 +40,7 @@\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n+    boolean inObject = _parsingContext.inObject();\n     if (inObject) {\n         // First, field name itself:\n         String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n@@ -72,6 +72,8 @@\n             // Error: neither is valid at this point; valid closers have\n             // been handled earlier\n             _reportUnexpectedChar(i, \"expected a value\");\n+            // fix: add break statement after error reporting\n+            break;\n         case 't':\n             _matchTrue();\n             t = JsonToken.VALUE_TRUE;\n@@ -85,7 +87,7 @@\n             t = JsonToken.VALUE_NULL;\n             break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,114 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return false;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']'); // fix: changed '}' to ']'\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n             }\n-        }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            // fix: add break statement after error reporting\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,59 +1,91 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return null;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']'); // fix: changed '}' to ']'\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            // fix: add break statement after error reporting\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n         case '-':\n             t = _parseNegNumber();\n             break;\n@@ -69,28 +101,14 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    _nextToken = t;\n-    return name;\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,114 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, ']'); // fix: changed '}' to ']'\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            // fix: add break statement after error reporting\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,114 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public final JsonToken nextToken() throws IOException {\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return _nextAfterName();\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, ']'); // fix: changed '}' to ']'\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            // fix: add break statement after error reporting\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic final JsonToken nextToken() throws IOException {\n        if (_currToken == JsonToken.FIELD_NAME) {\n        return _nextAfterName();\n    }\n    // But if we didn't already have a name, and (partially?) decode number,\n    // need to ensure no numeric information is leaked\n    _numTypesValid = NR_UNKNOWN;\n    if (_tokenIncomplete) {\n        // only strings can be partial\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        // end-of-input\n        close();\n        return (_currToken = null);\n    }\n    // clear any data retained so far\n    _binaryValue = null;\n    // Closing scope?\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_ARRAY);\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_OBJECT);\n    }\n    // Nope: do we then expect a comma?\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    boolean inObject = _parsingContext.inObject();\n    if (inObject) {\n        // First, field name itself:\n        String name;\n        if (i == INT_QUOTE) {\n            name = _parseName();\n        } else {\n            name = _handleOddName(i);\n        }\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            throw _constructError(\"Unexpected close marker '\"+((char) i)+\"': expected ']' or '}'\");\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    if (inObject) {\n        _nextToken = t;\n        return _currToken;\n    }\n    _currToken = t;\n    return t;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -13,7 +13,7 @@\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n         // end-of-input\n-                close();\n+        close();\n         return (_currToken = null);\n     }\n     // clear any data retained so far\n@@ -40,10 +40,15 @@\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n+    boolean inObject = _parsingContext.inObject();\n     if (inObject) {\n         // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        String name;\n+        if (i == INT_QUOTE) {\n+            name = _parseName();\n+        } else {\n+            name = _handleOddName(i);\n+        }\n         _parsingContext.setCurrentName(name);\n         _currToken = JsonToken.FIELD_NAME;\n         i = _skipColon();\n@@ -71,7 +76,7 @@\n         case '}':\n             // Error: neither is valid at this point; valid closers have\n             // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n+            throw _constructError(\"Unexpected close marker '\"+((char) i)+\"': expected ']' or '}'\");\n         case 't':\n             _matchTrue();\n             t = JsonToken.VALUE_TRUE;\n@@ -85,7 +90,7 @@\n             t = JsonToken.VALUE_NULL;\n             break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,29 +1,31 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public final JsonToken nextToken() throws IOException {\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return false;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -31,44 +33,85 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name;\n+        if (i == INT_QUOTE) {\n+            name = _parseName();\n+        } else {\n+            name = _handleOddName(i);\n+        }\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n             }\n-        }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            throw _constructError(\"Unexpected close marker '\"+((char) i)+\"': expected ']' or '}'\");\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,29 +1,31 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public final JsonToken nextToken() throws IOException {\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return null;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -31,29 +33,62 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name;\n+        if (i == INT_QUOTE) {\n+            name = _parseName();\n+        } else {\n+            name = _handleOddName(i);\n+        }\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            throw _constructError(\"Unexpected close marker '\"+((char) i)+\"': expected ']' or '}'\");\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n         case '-':\n             t = _parseNegNumber();\n             break;\n@@ -69,28 +104,14 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    _nextToken = t;\n-    return name;\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,117 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public final JsonToken nextToken() throws IOException {\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name;\n+        if (i == INT_QUOTE) {\n+            name = _parseName();\n+        } else {\n+            name = _handleOddName(i);\n+        }\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            throw _constructError(\"Unexpected close marker '\"+((char) i)+\"': expected ']' or '}'\");\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,117 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+public final JsonToken nextToken() throws IOException {\n+        if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name;\n+        if (i == INT_QUOTE) {\n+            name = _parseName();\n+        } else {\n+            name = _handleOddName(i);\n+        }\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            throw _constructError(\"Unexpected close marker '\"+((char) i)+\"': expected ']' or '}'\");\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic final JsonToken nextToken() throws IOException {\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return _nextAfterName();\n    }\n    // But if we didn't already have a name, and (partially?) decode number,\n    // need to ensure no numeric information is leaked\n    _numTypesValid = NR_UNKNOWN;\n    if (_tokenIncomplete) {\n        // only strings can be partial\n        _skipString();\n    }\n    int i;\n    try {\n        i = _skipWSOrEnd();\n    } catch (JsonParseException e) {\n        _wrapError(\"Failed to parse into a JSON format\", e);\n        throw e;\n    }\n    if (i < 0) {\n        // end-of-input\n        close();\n        return (_currToken = null);\n    }\n    // clear any data retained so far\n    _binaryValue = null;\n    // Closing scope?\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_ARRAY);\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        return (_currToken = JsonToken.END_OBJECT);\n    }\n    // Nope: do we then expect a comma?\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    boolean inObject = _parsingContext.inObject();\n    if (inObject) {\n        // First, field name itself:\n        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '\"':\n            _tokenIncomplete = true;\n            t = JsonToken.VALUE_STRING;\n            break;\n        case '[':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            if (!inObject) {\n                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n            }\n            t = JsonToken.START_OBJECT;\n            break;\n        case ']':\n        case '}':\n            // Error: neither is valid at this point; valid closers have\n            // been handled earlier\n            _reportUnexpectedChar(i, \"expected a value\");\n            // break; needed by coverage...\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    if (inObject) {\n        _nextToken = t;\n        return _currToken;\n    }\n    _currToken = t;\n    return t;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,6 +1,6 @@\n @Override\n public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n         return _nextAfterName();\n     }\n     // But if we didn't already have a name, and (partially?) decode number,\n@@ -10,10 +10,16 @@\n         // only strings can be partial\n         _skipString();\n     }\n-    int i = _skipWSOrEnd();\n+    int i;\n+    try {\n+        i = _skipWSOrEnd();\n+    } catch (JsonParseException e) {\n+        _wrapError(\"Failed to parse into a JSON format\", e);\n+        throw e;\n+    }\n     if (i < 0) {\n         // end-of-input\n-                close();\n+        close();\n         return (_currToken = null);\n     }\n     // clear any data retained so far\n@@ -40,7 +46,7 @@\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n+    boolean inObject = _parsingContext.inObject();\n     if (inObject) {\n         // First, field name itself:\n         String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n@@ -72,6 +78,7 @@\n             // Error: neither is valid at this point; valid closers have\n             // been handled earlier\n             _reportUnexpectedChar(i, \"expected a value\");\n+            // break; needed by coverage...\n         case 't':\n             _matchTrue();\n             t = JsonToken.VALUE_TRUE;\n@@ -85,7 +92,7 @@\n             t = JsonToken.VALUE_NULL;\n             break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,29 +1,37 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n-    int i = _skipWSOrEnd();\n+    int i;\n+    try {\n+        i = _skipWSOrEnd();\n+    } catch (JsonParseException e) {\n+        _wrapError(\"Failed to parse into a JSON format\", e);\n+        throw e;\n+    }\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return false;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -31,44 +39,81 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n             }\n-        }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            // break; needed by coverage...\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,29 +1,37 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n-    }\n     if (_tokenIncomplete) {\n+        // only strings can be partial\n         _skipString();\n     }\n-    int i = _skipWSOrEnd();\n+    int i;\n+    try {\n+        i = _skipWSOrEnd();\n+    } catch (JsonParseException e) {\n+        _wrapError(\"Failed to parse into a JSON format\", e);\n+        throw e;\n+    }\n     if (i < 0) {\n+        // end-of-input\n         close();\n-        _currToken = null;\n-        return null;\n+        return (_currToken = null);\n     }\n+    // clear any data retained so far\n     _binaryValue = null;\n+    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return (_currToken = JsonToken.END_ARRAY);\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -31,29 +39,58 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return (_currToken = JsonToken.END_OBJECT);\n     }\n+    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            // break; needed by coverage...\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n         case '-':\n             t = _parseNegNumber();\n             break;\n@@ -69,28 +106,14 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    _nextToken = t;\n-    return name;\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,119 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public final JsonToken nextToken() throws IOException {\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return _nextAfterName();\n+    }\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i;\n+    try {\n+        i = _skipWSOrEnd();\n+    } catch (JsonParseException e) {\n+        _wrapError(\"Failed to parse into a JSON format\", e);\n+        throw e;\n+    }\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            // break; needed by coverage...\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,119 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public final JsonToken nextToken() throws IOException {\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return _nextAfterName();\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    // But if we didn't already have a name, and (partially?) decode number,\n+    // need to ensure no numeric information is leaked\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_tokenIncomplete) {\n+        // only strings can be partial\n+        _skipString();\n+    }\n+    int i;\n+    try {\n+        i = _skipWSOrEnd();\n+    } catch (JsonParseException e) {\n+        _wrapError(\"Failed to parse into a JSON format\", e);\n+        throw e;\n+    }\n+    if (i < 0) {\n+        // end-of-input\n+        close();\n+        return (_currToken = null);\n+    }\n+    // clear any data retained so far\n+    _binaryValue = null;\n+    // Closing scope?\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_ARRAY);\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        return (_currToken = JsonToken.END_OBJECT);\n+    }\n+    // Nope: do we then expect a comma?\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    boolean inObject = _parsingContext.inObject();\n+    if (inObject) {\n+        // First, field name itself:\n+        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '\"':\n+            _tokenIncomplete = true;\n+            t = JsonToken.VALUE_STRING;\n+            break;\n+        case '[':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            if (!inObject) {\n+                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            }\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case ']':\n+        case '}':\n+            // Error: neither is valid at this point; valid closers have\n+            // been handled earlier\n+            _reportUnexpectedChar(i, \"expected a value\");\n+            // break; needed by coverage...\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    if (inObject) {\n+        _nextToken = t;\n+        return _currToken;\n+    }\n+    _currToken = t;\n+    return t;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]