[{"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    // Note: most of the code below is copied from nextToken()\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i == INT_QUOTE) {\n        // when doing literal match, must consider escaping:\n        char[] nameChars = sstr.asQuotedChars();\n        final int len = nameChars.length;\n        // Require 4 more bytes for faster skipping of colon that follows name\n        if ((_inputPtr + len + 4) < _inputEnd) {\n            // maybe...\n            // first check length match by\n            final int end = _inputPtr + len;\n            if (_inputBuffer[end] == '\"') {\n                // If we have a match, advance the pointer to the colon\n                int ptr = _skipStringPart(_inputPtr + 1, end, INT_QUOTE);\n                if (_skipColonFast(ptr) == INT_COLON) {\n                    // Match found\n                    _inputPtr = ptr + 1;\n                    _parsingContext.setCurrentName(sstr.getValue());\n                    _currToken = JsonToken.FIELD_NAME;\n                    _isNextTokenNameYes();\n                    return true;\n                }\n            }\n        }           \n    }\n    return _isNextTokenNameMaybe(i, sstr.getValue());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,29 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // Note: most of the code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +31,39 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                // If we have a match, advance the pointer to the colon\n+                int ptr = _skipStringPart(_inputPtr + 1, end, INT_QUOTE);\n+                if (_skipColonFast(ptr) == INT_COLON) {\n+                    // Match found\n+                    _inputPtr = ptr + 1;\n+                    _parsingContext.setCurrentName(sstr.getValue());\n+                    _currToken = JsonToken.FIELD_NAME;\n+                    _isNextTokenNameYes();\n+                    return true;\n+                }\n             }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+        }           \n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,6 +1,6 @@\n @Override\n public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+    // Note: most of the code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -52,23 +52,18 @@\n             // first check length match by\n             final int end = _inputPtr + len;\n             if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n+                // If we have a match, advance the pointer to the colon\n+                int ptr = _skipStringPart(_inputPtr + 1, end, INT_QUOTE);\n+                if (_skipColonFast(ptr) == INT_COLON) {\n+                    // Match found\n+                    _inputPtr = ptr + 1;\n+                    _parsingContext.setCurrentName(sstr.getValue());\n+                    _currToken = JsonToken.FIELD_NAME;\n+                    _isNextTokenNameYes();\n+                    return true;\n                 }\n             }\n-        }\n+        }           \n     }\n     return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,10 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // Note: most of the code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +13,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +23,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +32,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,57 +40,30 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                // If we have a match, advance the pointer to the colon\n+                int ptr = _skipStringPart(_inputPtr + 1, end, INT_QUOTE);\n+                if (_skipColonFast(ptr) == INT_COLON) {\n+                    // Match found\n+                    _inputPtr = ptr + 1;\n+                    _parsingContext.setCurrentName(sstr.getValue());\n+                    _currToken = JsonToken.FIELD_NAME;\n+                    _isNextTokenNameYes();\n+                    return true;\n+                }\n+            }\n+        }           \n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,69 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // Note: most of the code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                // If we have a match, advance the pointer to the colon\n+                int ptr = _skipStringPart(_inputPtr + 1, end, INT_QUOTE);\n+                if (_skipColonFast(ptr) == INT_COLON) {\n+                    // Match found\n+                    _inputPtr = ptr + 1;\n+                    _parsingContext.setCurrentName(sstr.getValue());\n+                    _currToken = JsonToken.FIELD_NAME;\n+                    _isNextTokenNameYes();\n+                    return true;\n+                }\n+            }\n+        }           \n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,69 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // Note: most of the code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                // If we have a match, advance the pointer to the colon\n+                int ptr = _skipStringPart(_inputPtr + 1, end, INT_QUOTE);\n+                if (_skipColonFast(ptr) == INT_COLON) {\n+                    // Match found\n+                    _inputPtr = ptr + 1;\n+                    _parsingContext.setCurrentName(sstr.getValue());\n+                    _currToken = JsonToken.FIELD_NAME;\n+                    _isNextTokenNameYes();\n+                    return true;\n+                }\n+            }\n+        }           \n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    // // // Note: most of code below is copied from nextToken()\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i == INT_QUOTE) {\n        // when doing literal match, must consider escaping:\n        char[] nameChars = sstr.asQuotedChars();\n        final int len = nameChars.length;\n        // Require 4 more bytes for faster skipping of colon that follows name\n        if ((_inputPtr + len + 4) < _inputEnd) {\n            // maybe...\n            // first check length match by\n            final int end = _inputPtr + len;\n            if (_inputBuffer[end - 1] == '\"') {\n                int offset = 0;\n                int ptr = _inputPtr;\n                while (true) {\n                    if (ptr == end) {\n                        // yes, match!\n                        _parsingContext.setCurrentName(sstr.getValue());\n                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n                        return true;\n                    }\n                    if (nameChars[offset] != _inputBuffer[ptr]) {\n                        break;\n                    }\n                    ++offset;\n                    ++ptr;\n                }\n            }\n        }\n    }\n    return _isNextTokenNameMaybe(i, sstr.getValue());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,29 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +31,44 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end - 1] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n             }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+        }\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -51,7 +51,7 @@\n             // maybe...\n             // first check length match by\n             final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n+            if (_inputBuffer[end - 1] == '\"') {\n                 int offset = 0;\n                 int ptr = _inputPtr;\n                 while (true) {\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,10 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +13,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +23,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +32,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,57 +40,35 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end - 1] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,74 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end - 1] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,74 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end - 1] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    // // // Note: most of code below is copied from nextToken()\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i == INT_QUOTE) {\n        // when doing literal match, must consider escaping:\n        char[] nameChars = sstr.asQuotedChars();\n        final int len = nameChars.length;\n        // Require 4 more bytes for faster skipping of colon that follows name\n        if ((_inputPtr + len + 4) < _inputEnd) {\n            // maybe...\n            // first check length match by\n            final int end = _inputPtr + len;\n            if (_inputBuffer[end - 1] == '\"') { // Fixed line - Check the correct index of the inputBuffer array\n                int offset = 0;\n                int ptr = _inputPtr;\n                while (true) {\n                    if (ptr == end) {\n                        // yes, match!\n                        _parsingContext.setCurrentName(sstr.getValue());\n                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n                        return true;\n                    }\n                    if (nameChars[offset] != _inputBuffer[ptr]) {\n                        break;\n                    }\n                    ++offset;\n                    ++ptr;\n                }\n            }\n        }\n    }\n    return _isNextTokenNameMaybe(i, sstr.getValue());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,29 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +31,44 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end - 1] == '\"') { // Fixed line - Check the correct index of the inputBuffer array\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n             }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+        }\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -51,7 +51,7 @@\n             // maybe...\n             // first check length match by\n             final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n+            if (_inputBuffer[end - 1] == '\"') { // Fixed line - Check the correct index of the inputBuffer array\n                 int offset = 0;\n                 int ptr = _inputPtr;\n                 while (true) {\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,10 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +13,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +23,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +32,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,57 +40,35 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end - 1] == '\"') { // Fixed line - Check the correct index of the inputBuffer array\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,74 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end - 1] == '\"') { // Fixed line - Check the correct index of the inputBuffer array\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,74 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end - 1] == '\"') { // Fixed line - Check the correct index of the inputBuffer array\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i == INT_QUOTE) {\n        char[] nameChars = sstr.asQuotedChars();\n        final int len = nameChars.length;\n        if ((_inputPtr + len + 4) < _inputEnd) {\n            final int end = _inputPtr + len;\n            if (_inputBuffer[end] == '\"' && _verifyQuotedFieldName(nameChars)) {\n                _parsingContext.setCurrentName(sstr.getValue());\n                _isNextTokenNameYes(_skipColonFast(end + 1));\n                return true;\n            }\n        }\n    }\n    return _isNextTokenNameMaybe(i, sstr.getValue());\n}\n\nprivate boolean _verifyQuotedFieldName(char[] nameChars) throws IOException {\n    int offset = 0;\n    int ptr = _inputPtr;\n    while (true) {\n        if (nameChars[offset] != _inputBuffer[ptr]) {\n            return false;\n        }\n        ++offset;\n        ++ptr;\n        if (offset >= nameChars.length) {\n            // If we matched the whole name, make sure the next \n            // character is a colon character\n            int i = _skipColon();\n            if (i == INT_QUOTE) {\n                // Empty String as name\n                return false;\n            }\n            _inputPtr = i;\n            return true;\n        }\n        if (_inputBuffer[ptr] != '\"') {\n            return false;\n        }\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,28 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +30,28 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+    if (i == INT_QUOTE) {\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"' && _verifyQuotedFieldName(nameChars)) {\n+                _parsingContext.setCurrentName(sstr.getValue());\n+                _isNextTokenNameYes(_skipColonFast(end + 1));\n+                return true;\n             }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+        }\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,6 +1,5 @@\n @Override\n public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -43,30 +42,14 @@\n         return false;\n     }\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n         char[] nameChars = sstr.asQuotedChars();\n         final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n         if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n             final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n+            if (_inputBuffer[end] == '\"' && _verifyQuotedFieldName(nameChars)) {\n+                _parsingContext.setCurrentName(sstr.getValue());\n+                _isNextTokenNameYes(_skipColonFast(end + 1));\n+                return true;\n             }\n         }\n     }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,9 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +12,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +22,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +31,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,57 +39,19 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"' && _verifyQuotedFieldName(nameChars)) {\n+                _parsingContext.setCurrentName(sstr.getValue());\n+                _isNextTokenNameYes(_skipColonFast(end + 1));\n+                return true;\n+            }\n+        }\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,57 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"' && _verifyQuotedFieldName(nameChars)) {\n+                _parsingContext.setCurrentName(sstr.getValue());\n+                _isNextTokenNameYes(_skipColonFast(end + 1));\n+                return true;\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,57 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"' && _verifyQuotedFieldName(nameChars)) {\n+                _parsingContext.setCurrentName(sstr.getValue());\n+                _isNextTokenNameYes(_skipColonFast(end + 1));\n+                return true;\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i == INT_QUOTE) {\n        // Replace the existing custom comparison code with a call to BytesUtils's 'equals' method\n        if (sstr.getValue().length() == (_inputEnd - _inputPtr - 1) && _inputBuffer[_inputPtr + sstr.getValue().length()] == '\"') {\n            if (BytesUtils.equalsUTF8(sstr.asQuotedUTF8(), _inputBuffer, _inputPtr + 1)) {\n                _inputPtr += sstr.asQuotedUTF8().length + 1;\n                _parsingContext.setCurrentName(sstr.getValue());\n                _isNextTokenNameYes(_skipColonFast(_inputPtr));\n                return true;\n            }\n        }\n    }\n    return _isNextTokenNameMaybe(i, sstr.getValue());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,28 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +30,27 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+    if (i == INT_QUOTE) {\n+        // Replace the existing custom comparison code with a call to BytesUtils's 'equals' method\n+        if (sstr.getValue().length() == (_inputEnd - _inputPtr - 1) && _inputBuffer[_inputPtr + sstr.getValue().length()] == '\"') {\n+            if (BytesUtils.equalsUTF8(sstr.asQuotedUTF8(), _inputBuffer, _inputPtr + 1)) {\n+                _inputPtr += sstr.asQuotedUTF8().length + 1;\n+                _parsingContext.setCurrentName(sstr.getValue());\n+                _isNextTokenNameYes(_skipColonFast(_inputPtr));\n+                return true;\n             }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+        }\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,6 +1,5 @@\n @Override\n public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -43,30 +42,13 @@\n         return false;\n     }\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n+        // Replace the existing custom comparison code with a call to BytesUtils's 'equals' method\n+        if (sstr.getValue().length() == (_inputEnd - _inputPtr - 1) && _inputBuffer[_inputPtr + sstr.getValue().length()] == '\"') {\n+            if (BytesUtils.equalsUTF8(sstr.asQuotedUTF8(), _inputBuffer, _inputPtr + 1)) {\n+                _inputPtr += sstr.asQuotedUTF8().length + 1;\n+                _parsingContext.setCurrentName(sstr.getValue());\n+                _isNextTokenNameYes(_skipColonFast(_inputPtr));\n+                return true;\n             }\n         }\n     }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,9 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +12,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +22,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +31,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,57 +39,18 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        // Replace the existing custom comparison code with a call to BytesUtils's 'equals' method\n+        if (sstr.getValue().length() == (_inputEnd - _inputPtr - 1) && _inputBuffer[_inputPtr + sstr.getValue().length()] == '\"') {\n+            if (BytesUtils.equalsUTF8(sstr.asQuotedUTF8(), _inputBuffer, _inputPtr + 1)) {\n+                _inputPtr += sstr.asQuotedUTF8().length + 1;\n+                _parsingContext.setCurrentName(sstr.getValue());\n+                _isNextTokenNameYes(_skipColonFast(_inputPtr));\n+                return true;\n+            }\n+        }\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,56 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // Replace the existing custom comparison code with a call to BytesUtils's 'equals' method\n+        if (sstr.getValue().length() == (_inputEnd - _inputPtr - 1) && _inputBuffer[_inputPtr + sstr.getValue().length()] == '\"') {\n+            if (BytesUtils.equalsUTF8(sstr.asQuotedUTF8(), _inputBuffer, _inputPtr + 1)) {\n+                _inputPtr += sstr.asQuotedUTF8().length + 1;\n+                _parsingContext.setCurrentName(sstr.getValue());\n+                _isNextTokenNameYes(_skipColonFast(_inputPtr));\n+                return true;\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,56 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // Replace the existing custom comparison code with a call to BytesUtils's 'equals' method\n+        if (sstr.getValue().length() == (_inputEnd - _inputPtr - 1) && _inputBuffer[_inputPtr + sstr.getValue().length()] == '\"') {\n+            if (BytesUtils.equalsUTF8(sstr.asQuotedUTF8(), _inputBuffer, _inputPtr + 1)) {\n+                _inputPtr += sstr.asQuotedUTF8().length + 1;\n+                _parsingContext.setCurrentName(sstr.getValue());\n+                _isNextTokenNameYes(_skipColonFast(_inputPtr));\n+                return true;\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    // // // Note: most of code below is copied from nextToken()\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i == INT_QUOTE) {\n        // when doing literal match, must consider escaping:\n        char[] nameChars = sstr.asQuotedChars();\n        final int len = nameChars.length;\n        // Require 4 more bytes for faster skipping of colon that follows name\n        if ((_inputPtr + len + 4) < _inputEnd) {\n            // maybe...\n            // first check length match by\n            final int end = _inputPtr + len;\n            if (_inputBuffer[end - 1] == '\"') { // fixed line - compare the last character to the quote char\n                int offset = 0;\n                int ptr = _inputPtr;\n                while (true) {\n                    if (ptr == end) {\n                        // yes, match!\n                        _parsingContext.setCurrentName(sstr.getValue());\n                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n                        return true;\n                    }\n                    if (nameChars[offset] != _inputBuffer[ptr]) {\n                        break;\n                    }\n                    ++offset;\n                    ++ptr;\n                }\n            }\n        }\n    }\n    return _isNextTokenNameMaybe(i, sstr.getValue());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,29 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +31,44 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end - 1] == '\"') { // fixed line - compare the last character to the quote char\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n             }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+        }\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -51,7 +51,7 @@\n             // maybe...\n             // first check length match by\n             final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n+            if (_inputBuffer[end - 1] == '\"') { // fixed line - compare the last character to the quote char\n                 int offset = 0;\n                 int ptr = _inputPtr;\n                 while (true) {\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,10 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +13,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +23,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +32,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,57 +40,35 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end - 1] == '\"') { // fixed line - compare the last character to the quote char\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,74 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end - 1] == '\"') { // fixed line - compare the last character to the quote char\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,74 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end - 1] == '\"') { // fixed line - compare the last character to the quote char\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i == INT_QUOTE) {\n        if (_matchQuotedName(sstr)) {\n            _isNextTokenNameYes(_skipColonFast(_inputPtr + sstr.getQuotedLength()));\n            return true;\n        }\n    }\n    return _isNextTokenNameMaybe(i, sstr.getValue());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,28 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +30,22 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+    if (i == INT_QUOTE) {\n+        if (_matchQuotedName(sstr)) {\n+            _isNextTokenNameYes(_skipColonFast(_inputPtr + sstr.getQuotedLength()));\n+            return true;\n+        }\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,6 +1,5 @@\n @Override\n public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -43,31 +42,9 @@\n         return false;\n     }\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n+        if (_matchQuotedName(sstr)) {\n+            _isNextTokenNameYes(_skipColonFast(_inputPtr + sstr.getQuotedLength()));\n+            return true;\n         }\n     }\n     return _isNextTokenNameMaybe(i, sstr.getValue());\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,9 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +12,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +22,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +31,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,57 +39,13 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        if (_matchQuotedName(sstr)) {\n+            _isNextTokenNameYes(_skipColonFast(_inputPtr + sstr.getQuotedLength()));\n+            return true;\n+        }\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,51 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        if (_matchQuotedName(sstr)) {\n+            _isNextTokenNameYes(_skipColonFast(_inputPtr + sstr.getQuotedLength()));\n+            return true;\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,51 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        if (_matchQuotedName(sstr)) {\n+            _isNextTokenNameYes(_skipColonFast(_inputPtr + sstr.getQuotedLength()));\n+            return true;\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    // // // Note: most of code below is copied from nextToken()\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i == INT_QUOTE) {\n        // when doing literal match, must consider escaping:\n        char[] nameChars = sstr.asQuotedChars();\n        final int len = nameChars.length;\n        // Require 4 more bytes for faster skipping of colon that follows name\n        if ((_inputPtr + len + 4) < _inputEnd) {\n            // maybe...\n            // first check length match by\n            final int end = _inputPtr + len;\n            if (_inputBuffer[end-1] == '\"') {\n                int offset = 0;\n                int ptr = _inputPtr;\n                while (true) {\n                    if (ptr == end) {\n                        // yes, match!\n                        _parsingContext.setCurrentName(sstr.getValue());\n                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n                        return true;\n                    }\n                    if (nameChars[offset] != _inputBuffer[ptr]) {\n                        break;\n                    }\n                    ++offset;\n                    ++ptr;\n                }\n            }\n        }\n    }\n    return _isNextTokenNameMaybe(i, sstr.getValue());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,29 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +31,44 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end-1] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n             }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+        }\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -51,7 +51,7 @@\n             // maybe...\n             // first check length match by\n             final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n+            if (_inputBuffer[end-1] == '\"') {\n                 int offset = 0;\n                 int ptr = _inputPtr;\n                 while (true) {\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,10 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +13,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +23,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +32,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,57 +40,35 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end-1] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,74 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end-1] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,74 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end-1] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    // // // Note: most of code below is copied from nextToken()\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i == INT_QUOTE) {\n        // when doing literal match, must consider escaping:\n        char[] nameChars = sstr.asQuotedChars();\n        final int len = nameChars.length;\n        // Require 4 more bytes for faster skipping of colon that follows name\n        if ((_inputPtr + len + 4) < _inputEnd) {\n            // maybe...\n            // first check length match\n            final int end = _inputPtr + len;\n            if (_inputBuffer[end] == '\"') {\n                int offset = 0;\n                int ptr = _inputPtr;\n                while (true) {\n                    if (ptr == end) {\n                        // yes, match!\n                        _parsingContext.setCurrentName(sstr.getValue());\n                        _isNextTokenNameYes(_skipColonFast(end + 1));\n                        return true;\n                    }\n                    if (nameChars[offset] != _inputBuffer[ptr]) {\n                        break;\n                    }\n                    ++offset;\n                    ++ptr;\n                }\n            }\n        }\n    }\n    return _isNextTokenNameMaybe(i, sstr.getValue());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,29 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +31,44 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(end + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n             }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+        }\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -49,7 +49,7 @@\n         // Require 4 more bytes for faster skipping of colon that follows name\n         if ((_inputPtr + len + 4) < _inputEnd) {\n             // maybe...\n-            // first check length match by\n+            // first check length match\n             final int end = _inputPtr + len;\n             if (_inputBuffer[end] == '\"') {\n                 int offset = 0;\n@@ -58,7 +58,7 @@\n                     if (ptr == end) {\n                         // yes, match!\n                         _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        _isNextTokenNameYes(_skipColonFast(end + 1));\n                         return true;\n                     }\n                     if (nameChars[offset] != _inputBuffer[ptr]) {\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,10 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +13,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +23,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +32,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,57 +40,35 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(end + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,74 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(end + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,74 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(end + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    // // // Note: most of code below is copied from nextToken()\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i == INT_QUOTE) {\n        // when doing literal match, must consider escaping:\n        char[] nameChars = sstr.asQuotedChars();\n        final int len = nameChars.length;\n        // Require 3 more bytes for faster skipping of colon that follows name\n        if ((_inputPtr + len + 3) < _inputEnd) {\n            // maybe...\n            // first check length match by\n            final int end = _inputPtr + len;\n            if (_inputBuffer[end] == '\"') {\n                int offset = 0;\n                int ptr = _inputPtr;\n                while (true) {\n                    if (ptr == end) {\n                        // yes, match!\n                        // add 2 bytes to keep pointer after colon(space or quote)\n                        _parsingContext.setCurrentName(sstr.getValue());\n                        _isNextTokenNameYes(_skipColonFast(ptr + 2));\n                        return true;\n                    }\n                    if (nameChars[offset] != _inputBuffer[ptr]) {\n                        break;\n                    }\n                    ++offset;\n                    ++ptr;\n                }\n            }\n        }\n    }\n    return _isNextTokenNameMaybe(i, sstr.getValue());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,29 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +31,45 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 3 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 3) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        // add 2 bytes to keep pointer after colon(space or quote)\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 2));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n             }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+        }\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -46,8 +46,8 @@\n         // when doing literal match, must consider escaping:\n         char[] nameChars = sstr.asQuotedChars();\n         final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n+        // Require 3 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 3) < _inputEnd) {\n             // maybe...\n             // first check length match by\n             final int end = _inputPtr + len;\n@@ -57,8 +57,9 @@\n                 while (true) {\n                     if (ptr == end) {\n                         // yes, match!\n+                        // add 2 bytes to keep pointer after colon(space or quote)\n                         _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 2));\n                         return true;\n                     }\n                     if (nameChars[offset] != _inputBuffer[ptr]) {\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,10 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +13,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +23,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +32,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,57 +40,36 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 3 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 3) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        // add 2 bytes to keep pointer after colon(space or quote)\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 2));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,75 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 3 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 3) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        // add 2 bytes to keep pointer after colon(space or quote)\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 2));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,75 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 3 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 3) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        // add 2 bytes to keep pointer after colon(space or quote)\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 2));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i != INT_QUOTE) {\n        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n    }\n    // when doing literal match, must consider escaping:\n    char[] nameChars = sstr.asQuotedChars();\n    final int len = nameChars.length;\n    if (_inputPtr + len + 4 >= _inputEnd) {\n        return _slowNextFieldName(sstr, i);\n    }\n    int end = _inputPtr + len;\n    if (_inputBuffer[end] != '\"') {\n        return _slowNextFieldName2(sstr, i, nameChars, end);\n    }\n    int offset = 0;\n    int ptr = _inputPtr;\n    while (ptr != end) {\n        if (nameChars[offset] != _inputBuffer[ptr]) {\n            return _slowNextFieldName2(sstr, i, nameChars, end);\n        }\n        ++offset;\n        ++ptr;\n    }\n    _inputPtr = ptr + 1;\n    _updateLocation();\n    _parsingContext.setCurrentName(sstr.getValue());\n    _currToken = JsonToken.FIELD_NAME;\n    _isNextTokenNameYes(_skipColonFast(_inputPtr));\n    return true;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,28 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +30,43 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+    if (i != INT_QUOTE) {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n+    // when doing literal match, must consider escaping:\n+    char[] nameChars = sstr.asQuotedChars();\n+    final int len = nameChars.length;\n+    if (_inputPtr + len + 4 >= _inputEnd) {\n+        return _slowNextFieldName(sstr, i);\n     }\n-    _currToken = t;\n-    return t;\n+    int end = _inputPtr + len;\n+    if (_inputBuffer[end] != '\"') {\n+        return _slowNextFieldName2(sstr, i, nameChars, end);\n+    }\n+    int offset = 0;\n+    int ptr = _inputPtr;\n+    while (ptr != end) {\n+        if (nameChars[offset] != _inputBuffer[ptr]) {\n+            return _slowNextFieldName2(sstr, i, nameChars, end);\n+        }\n+        ++offset;\n+        ++ptr;\n+    }\n+    _inputPtr = ptr + 1;\n+    _updateLocation();\n+    _parsingContext.setCurrentName(sstr.getValue());\n+    _currToken = JsonToken.FIELD_NAME;\n+    _isNextTokenNameYes(_skipColonFast(_inputPtr));\n+    return true;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,6 +1,5 @@\n @Override\n public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -42,33 +41,32 @@\n         _nextTokenNotInObject(i);\n         return false;\n     }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n+    if (i != INT_QUOTE) {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+    }\n+    // when doing literal match, must consider escaping:\n+    char[] nameChars = sstr.asQuotedChars();\n+    final int len = nameChars.length;\n+    if (_inputPtr + len + 4 >= _inputEnd) {\n+        return _slowNextFieldName(sstr, i);\n+    }\n+    int end = _inputPtr + len;\n+    if (_inputBuffer[end] != '\"') {\n+        return _slowNextFieldName2(sstr, i, nameChars, end);\n+    }\n+    int offset = 0;\n+    int ptr = _inputPtr;\n+    while (ptr != end) {\n+        if (nameChars[offset] != _inputBuffer[ptr]) {\n+            return _slowNextFieldName2(sstr, i, nameChars, end);\n         }\n+        ++offset;\n+        ++ptr;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    _inputPtr = ptr + 1;\n+    _updateLocation();\n+    _parsingContext.setCurrentName(sstr.getValue());\n+    _currToken = JsonToken.FIELD_NAME;\n+    _isNextTokenNameYes(_skipColonFast(_inputPtr));\n+    return true;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,9 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +12,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +22,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +31,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,57 +39,34 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n+    if (i != INT_QUOTE) {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+    }\n+    // when doing literal match, must consider escaping:\n+    char[] nameChars = sstr.asQuotedChars();\n+    final int len = nameChars.length;\n+    if (_inputPtr + len + 4 >= _inputEnd) {\n+        return _slowNextFieldName(sstr, i);\n+    }\n+    int end = _inputPtr + len;\n+    if (_inputBuffer[end] != '\"') {\n+        return _slowNextFieldName2(sstr, i, nameChars, end);\n+    }\n+    int offset = 0;\n+    int ptr = _inputPtr;\n+    while (ptr != end) {\n+        if (nameChars[offset] != _inputBuffer[ptr]) {\n+            return _slowNextFieldName2(sstr, i, nameChars, end);\n+        }\n+        ++offset;\n+        ++ptr;\n+    }\n+    _inputPtr = ptr + 1;\n+    _updateLocation();\n+    _parsingContext.setCurrentName(sstr.getValue());\n     _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    _isNextTokenNameYes(_skipColonFast(_inputPtr));\n+    return true;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,72 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i != INT_QUOTE) {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+    }\n+    // when doing literal match, must consider escaping:\n+    char[] nameChars = sstr.asQuotedChars();\n+    final int len = nameChars.length;\n+    if (_inputPtr + len + 4 >= _inputEnd) {\n+        return _slowNextFieldName(sstr, i);\n+    }\n+    int end = _inputPtr + len;\n+    if (_inputBuffer[end] != '\"') {\n+        return _slowNextFieldName2(sstr, i, nameChars, end);\n+    }\n+    int offset = 0;\n+    int ptr = _inputPtr;\n+    while (ptr != end) {\n+        if (nameChars[offset] != _inputBuffer[ptr]) {\n+            return _slowNextFieldName2(sstr, i, nameChars, end);\n+        }\n+        ++offset;\n+        ++ptr;\n+    }\n+    _inputPtr = ptr + 1;\n+    _updateLocation();\n+    _parsingContext.setCurrentName(sstr.getValue());\n+    _currToken = JsonToken.FIELD_NAME;\n+    _isNextTokenNameYes(_skipColonFast(_inputPtr));\n+    return true;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,72 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i != INT_QUOTE) {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+    }\n+    // when doing literal match, must consider escaping:\n+    char[] nameChars = sstr.asQuotedChars();\n+    final int len = nameChars.length;\n+    if (_inputPtr + len + 4 >= _inputEnd) {\n+        return _slowNextFieldName(sstr, i);\n+    }\n+    int end = _inputPtr + len;\n+    if (_inputBuffer[end] != '\"') {\n+        return _slowNextFieldName2(sstr, i, nameChars, end);\n+    }\n+    int offset = 0;\n+    int ptr = _inputPtr;\n+    while (ptr != end) {\n+        if (nameChars[offset] != _inputBuffer[ptr]) {\n+            return _slowNextFieldName2(sstr, i, nameChars, end);\n+        }\n+        ++offset;\n+        ++ptr;\n+    }\n+    _inputPtr = ptr + 1;\n+    _updateLocation();\n+    _parsingContext.setCurrentName(sstr.getValue());\n+    _currToken = JsonToken.FIELD_NAME;\n+    _isNextTokenNameYes(_skipColonFast(_inputPtr));\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    // Note: most of code below is copied from nextToken()\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i); // skip comma before next field name\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i); // parsing context is not an object, return false\n        return false;\n    }\n    if (i == INT_QUOTE) {\n        // when doing literal match, must consider escaping:\n        char[] nameChars = sstr.asQuotedChars();\n        final int len = nameChars.length;\n        // Require 4 more bytes for faster skipping of colon that follows name\n        if ((_inputPtr + len + 4) < _inputEnd) {\n            // maybe...\n            // first check length match by\n            final int end = _inputPtr + len;\n            if (_inputBuffer[end] == '\"') {\n                int offset = 0;\n                int ptr = _inputPtr;\n                while (true) {\n                    if (ptr == end) {\n                        // yes, match!\n                        _parsingContext.setCurrentName(sstr.getValue());\n                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n                        return true;\n                    }\n                    if (nameChars[offset] != _inputBuffer[ptr]) {\n                        break;\n                    }\n                    ++offset;\n                    ++ptr;\n                }\n            }\n        }\n    }\n    _parsingContext.setCurrentName(sstr.getValue()); // set current context with the field name\n    _currToken = JsonToken.FIELD_NAME; \n    return true; // return true as the field name has been found\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,29 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +31,46 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n+        i = _skipComma(i); // skip comma before next field name\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i); // parsing context is not an object, return false\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n             }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+        }\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _parsingContext.setCurrentName(sstr.getValue()); // set current context with the field name\n+    _currToken = JsonToken.FIELD_NAME; \n+    return true; // return true as the field name has been found\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,6 +1,6 @@\n @Override\n public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+    // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -35,11 +35,11 @@\n         return false;\n     }\n     if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n+        i = _skipComma(i); // skip comma before next field name\n     }\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n+        _nextTokenNotInObject(i); // parsing context is not an object, return false\n         return false;\n     }\n     if (i == INT_QUOTE) {\n@@ -70,5 +70,7 @@\n             }\n         }\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    _parsingContext.setCurrentName(sstr.getValue()); // set current context with the field name\n+    _currToken = JsonToken.FIELD_NAME; \n+    return true; // return true as the field name has been found\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,10 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +13,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +23,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,65 +32,45 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n+        i = _skipComma(i); // skip comma before next field name\n     }\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n+        _nextTokenNotInObject(i); // parsing context is not an object, return false\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    _parsingContext.setCurrentName(sstr.getValue()); // set current context with the field name\n+    _currToken = JsonToken.FIELD_NAME; \n+    return true; // return true as the field name has been found\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,76 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i); // skip comma before next field name\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i); // parsing context is not an object, return false\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    _parsingContext.setCurrentName(sstr.getValue()); // set current context with the field name\n+    _currToken = JsonToken.FIELD_NAME; \n+    return true; // return true as the field name has been found\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,76 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i); // skip comma before next field name\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i); // parsing context is not an object, return false\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    _parsingContext.setCurrentName(sstr.getValue()); // set current context with the field name\n+    _currToken = JsonToken.FIELD_NAME; \n+    return true; // return true as the field name has been found\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    // // // Note: most of code below is copied from nextToken()\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i == INT_QUOTE) {\n        // when doing literal match, must consider escaping:\n        char[] nameChars = sstr.asQuotedChars();\n        final int len = nameChars.length;\n        // Require 2 more bytes for checking colon that follows name\n        if ((_inputPtr + len + 2) < _inputEnd) {\n            // maybe...\n            // first check length match by\n            final int end = _inputPtr + len;\n            if (_inputBuffer[end] == '\"') {\n                int offset = 0;\n                int ptr = _inputPtr;\n                while (true) {\n                    if (ptr == end) {\n                        // yes, match!\n                        _parsingContext.setCurrentName(sstr.getValue());\n                        // Fixed Function - check if colon follows the name\n                        if (_skipColonFast(ptr + 1) == INT_COLON) {\n                            _isNextTokenNameYes(ptr + 2);\n                            return true;\n                        } else {\n                            return false;\n                        }\n                    }\n                    if (nameChars[offset] != _inputBuffer[ptr]) {\n                        break;\n                    }\n                    ++offset;\n                    ++ptr;\n                }\n            }\n        }\n    }\n    return _isNextTokenNameMaybe(i, sstr.getValue());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,29 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +31,49 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 2 more bytes for checking colon that follows name\n+        if ((_inputPtr + len + 2) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        // Fixed Function - check if colon follows the name\n+                        if (_skipColonFast(ptr + 1) == INT_COLON) {\n+                            _isNextTokenNameYes(ptr + 2);\n+                            return true;\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n             }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+        }\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -46,8 +46,8 @@\n         // when doing literal match, must consider escaping:\n         char[] nameChars = sstr.asQuotedChars();\n         final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n+        // Require 2 more bytes for checking colon that follows name\n+        if ((_inputPtr + len + 2) < _inputEnd) {\n             // maybe...\n             // first check length match by\n             final int end = _inputPtr + len;\n@@ -58,8 +58,13 @@\n                     if (ptr == end) {\n                         // yes, match!\n                         _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n+                        // Fixed Function - check if colon follows the name\n+                        if (_skipColonFast(ptr + 1) == INT_COLON) {\n+                            _isNextTokenNameYes(ptr + 2);\n+                            return true;\n+                        } else {\n+                            return false;\n+                        }\n                     }\n                     if (nameChars[offset] != _inputBuffer[ptr]) {\n                         break;\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,10 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +13,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +23,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +32,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,57 +40,40 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 2 more bytes for checking colon that follows name\n+        if ((_inputPtr + len + 2) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        // Fixed Function - check if colon follows the name\n+                        if (_skipColonFast(ptr + 1) == INT_COLON) {\n+                            _isNextTokenNameYes(ptr + 2);\n+                            return true;\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,79 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 2 more bytes for checking colon that follows name\n+        if ((_inputPtr + len + 2) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        // Fixed Function - check if colon follows the name\n+                        if (_skipColonFast(ptr + 1) == INT_COLON) {\n+                            _isNextTokenNameYes(ptr + 2);\n+                            return true;\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,79 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 2 more bytes for checking colon that follows name\n+        if ((_inputPtr + len + 2) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        // Fixed Function - check if colon follows the name\n+                        if (_skipColonFast(ptr + 1) == INT_COLON) {\n+                            _isNextTokenNameYes(ptr + 2);\n+                            return true;\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i != INT_QUOTE) {\n        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n    }\n    // text buffer handling...\n    final byte[] nameBytes = sstr.asQuotedUTF8();\n    final int len = nameBytes.length;\n    if ((_inputPtr + len + 4) >= _inputEnd) {\n        return _isNameMatchComplex(sstr.getValue());\n    }\n    int end = _inputPtr + len;\n    if (_inputBuffer[end] == '\"') {\n        int offset = 0;\n        int ptr = _inputPtr;\n        while (true) {\n            if (ptr == end) {\n                // yes, match!\n                _inputPtr = ptr + 1; // to skip the colon, move Ptr ahead\n                _parsingContext.setCurrentName(sstr.getValue());\n                _currToken = JsonToken.FIELD_NAME;\n                _isNextTokenNameYes(_skipWS());\n                return true;\n            }\n            if (nameBytes[offset] != _inputBuffer[ptr]) {\n                break;\n            }\n            ++offset;\n            ++ptr;\n        }\n    }\n    return _isNameMatchComplex(sstr.getValue());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,28 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +30,45 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+    if (i != INT_QUOTE) {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+    }\n+    // text buffer handling...\n+    final byte[] nameBytes = sstr.asQuotedUTF8();\n+    final int len = nameBytes.length;\n+    if ((_inputPtr + len + 4) >= _inputEnd) {\n+        return _isNameMatchComplex(sstr.getValue());\n+    }\n+    int end = _inputPtr + len;\n+    if (_inputBuffer[end] == '\"') {\n+        int offset = 0;\n+        int ptr = _inputPtr;\n+        while (true) {\n+            if (ptr == end) {\n+                // yes, match!\n+                _inputPtr = ptr + 1; // to skip the colon, move Ptr ahead\n+                _parsingContext.setCurrentName(sstr.getValue());\n+                _currToken = JsonToken.FIELD_NAME;\n+                _isNextTokenNameYes(_skipWS());\n+                return true;\n             }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n+            if (nameBytes[offset] != _inputBuffer[ptr]) {\n+                break;\n             }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+            ++offset;\n+            ++ptr;\n+        }\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return _isNameMatchComplex(sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,6 +1,5 @@\n @Override\n public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -42,33 +41,34 @@\n         _nextTokenNotInObject(i);\n         return false;\n     }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n+    if (i != INT_QUOTE) {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+    }\n+    // text buffer handling...\n+    final byte[] nameBytes = sstr.asQuotedUTF8();\n+    final int len = nameBytes.length;\n+    if ((_inputPtr + len + 4) >= _inputEnd) {\n+        return _isNameMatchComplex(sstr.getValue());\n+    }\n+    int end = _inputPtr + len;\n+    if (_inputBuffer[end] == '\"') {\n+        int offset = 0;\n+        int ptr = _inputPtr;\n+        while (true) {\n+            if (ptr == end) {\n+                // yes, match!\n+                _inputPtr = ptr + 1; // to skip the colon, move Ptr ahead\n+                _parsingContext.setCurrentName(sstr.getValue());\n+                _currToken = JsonToken.FIELD_NAME;\n+                _isNextTokenNameYes(_skipWS());\n+                return true;\n             }\n+            if (nameBytes[offset] != _inputBuffer[ptr]) {\n+                break;\n+            }\n+            ++offset;\n+            ++ptr;\n         }\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    return _isNameMatchComplex(sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,9 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +12,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +22,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +31,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,57 +39,36 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+    if (i != INT_QUOTE) {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+    // text buffer handling...\n+    final byte[] nameBytes = sstr.asQuotedUTF8();\n+    final int len = nameBytes.length;\n+    if ((_inputPtr + len + 4) >= _inputEnd) {\n+        return _isNameMatchComplex(sstr.getValue());\n     }\n-    _nextToken = t;\n-    return name;\n+    int end = _inputPtr + len;\n+    if (_inputBuffer[end] == '\"') {\n+        int offset = 0;\n+        int ptr = _inputPtr;\n+        while (true) {\n+            if (ptr == end) {\n+                // yes, match!\n+                _inputPtr = ptr + 1; // to skip the colon, move Ptr ahead\n+                _parsingContext.setCurrentName(sstr.getValue());\n+                _currToken = JsonToken.FIELD_NAME;\n+                _isNextTokenNameYes(_skipWS());\n+                return true;\n+            }\n+            if (nameBytes[offset] != _inputBuffer[ptr]) {\n+                break;\n+            }\n+            ++offset;\n+            ++ptr;\n+        }\n+    }\n+    return _isNameMatchComplex(sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,74 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i != INT_QUOTE) {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+    }\n+    // text buffer handling...\n+    final byte[] nameBytes = sstr.asQuotedUTF8();\n+    final int len = nameBytes.length;\n+    if ((_inputPtr + len + 4) >= _inputEnd) {\n+        return _isNameMatchComplex(sstr.getValue());\n+    }\n+    int end = _inputPtr + len;\n+    if (_inputBuffer[end] == '\"') {\n+        int offset = 0;\n+        int ptr = _inputPtr;\n+        while (true) {\n+            if (ptr == end) {\n+                // yes, match!\n+                _inputPtr = ptr + 1; // to skip the colon, move Ptr ahead\n+                _parsingContext.setCurrentName(sstr.getValue());\n+                _currToken = JsonToken.FIELD_NAME;\n+                _isNextTokenNameYes(_skipWS());\n+                return true;\n+            }\n+            if (nameBytes[offset] != _inputBuffer[ptr]) {\n+                break;\n+            }\n+            ++offset;\n+            ++ptr;\n+        }\n+    }\n+    return _isNameMatchComplex(sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,74 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i != INT_QUOTE) {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+    }\n+    // text buffer handling...\n+    final byte[] nameBytes = sstr.asQuotedUTF8();\n+    final int len = nameBytes.length;\n+    if ((_inputPtr + len + 4) >= _inputEnd) {\n+        return _isNameMatchComplex(sstr.getValue());\n+    }\n+    int end = _inputPtr + len;\n+    if (_inputBuffer[end] == '\"') {\n+        int offset = 0;\n+        int ptr = _inputPtr;\n+        while (true) {\n+            if (ptr == end) {\n+                // yes, match!\n+                _inputPtr = ptr + 1; // to skip the colon, move Ptr ahead\n+                _parsingContext.setCurrentName(sstr.getValue());\n+                _currToken = JsonToken.FIELD_NAME;\n+                _isNextTokenNameYes(_skipWS());\n+                return true;\n+            }\n+            if (nameBytes[offset] != _inputBuffer[ptr]) {\n+                break;\n+            }\n+            ++offset;\n+            ++ptr;\n+        }\n+    }\n+    return _isNameMatchComplex(sstr.getValue());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    // // // Note: most of code below is copied from nextToken()\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i == INT_QUOTE) {\n        // when doing literal match, must consider escaping:\n        char[] nameChars = sstr.asQuotedChars();\n        final int len = nameChars.length;\n        // Require 4 more bytes for faster skipping of colon that follows name\n        if ((_inputPtr + len + 4) < _inputEnd) {\n            // maybe...\n            // first check length match by\n            final int end = _inputPtr + len;\n            if (_inputBuffer[end - 1] == '\"') { // Fixed line: use `end-1` to check the last character\n                int offset = 0;\n                int ptr = _inputPtr;\n                while (true) {\n                    if (ptr == end) {\n                        // yes, match!\n                        _parsingContext.setCurrentName(sstr.getValue());\n                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n                        return true;\n                    }\n                    if (nameChars[offset] != _inputBuffer[ptr]) {\n                        break;\n                    }\n                    ++offset;\n                    ++ptr;\n                }\n            }\n        }\n    }\n    return _isNextTokenNameMaybe(i, sstr.getValue());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,29 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +31,44 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end - 1] == '\"') { // Fixed line: use `end-1` to check the last character\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n             }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+        }\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -51,7 +51,7 @@\n             // maybe...\n             // first check length match by\n             final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n+            if (_inputBuffer[end - 1] == '\"') { // Fixed line: use `end-1` to check the last character\n                 int offset = 0;\n                 int ptr = _inputPtr;\n                 while (true) {\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,10 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +13,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +23,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +32,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,57 +40,35 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end - 1] == '\"') { // Fixed line: use `end-1` to check the last character\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,74 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end - 1] == '\"') { // Fixed line: use `end-1` to check the last character\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,74 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end - 1] == '\"') { // Fixed line: use `end-1` to check the last character\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i == INT_QUOTE) {\n        char[] nameChars = sstr.asQuotedChars();\n        final int len = nameChars.length;\n        // Remove unnecessary bounds check on input buffer\n        if ((_inputPtr + len) < _inputEnd) {\n            // Only check ending double quote\n            int end = _inputPtr + len;\n            if (_inputBuffer[end] == '\"') {\n                int offset = 0;\n                int ptr = _inputPtr;\n                while (true) {\n                    if (ptr == end) {\n                        _parsingContext.setCurrentName(sstr.getValue());\n                        // Only skip colon if the current token is not END_OBJECT\n                        if (!_isNextTokenEndObject(_skipColonFast(ptr + 1))) {\n                            // Set the next token to FIELD_NAME and return true\n                            _currToken = JsonToken.FIELD_NAME;\n                            return true;\n                        }\n                        _currToken = JsonToken.END_OBJECT;\n                        return false;\n                    }\n                    if (nameChars[offset] != _inputBuffer[ptr]) {\n                        break;\n                    }\n                    ++offset;\n                    ++ptr;\n                }\n            }\n        }\n    }\n    return _isNextTokenNameMaybe(i, sstr.getValue());\n}\n\n// Helper function to check if the next token is END_OBJECT\nprivate boolean _isNextTokenEndObject(int i) throws IOException {\n    switch (i) {\n        case INT_RCURLY:\n            _updateLocation();\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_OBJECT;\n            return true;\n        case INT_RBRACKET:\n            _updateLocation();\n            _parsingContext = _parsingContext.getParent();\n            _currToken = JsonToken.END_ARRAY;\n            return true;\n        default:\n            return false;\n    }\n}\n\n// Helper function to set the next token to FIELD_NAME and skip the colon\nprivate void _isNextTokenNameYes(int i) throws IOException {\n    _updateLocation();\n    _currToken = JsonToken.FIELD_NAME;\n    if (i == INT_COLON) {\n        i = _skipWS();\n        if (i == INT_QUOTE) {\n            _tokenIncomplete = true;\n            _nextToken = JsonToken.VALUE_STRING;\n            return;\n        }\n        switch (i) {\n            case INT_LBRACKET:\n                _nextToken = JsonToken.START_ARRAY;\n                return;\n            case INT_LCURLY:\n                _nextToken = JsonToken.START_OBJECT;\n                return;\n            case INT_TRUE:\n                _nextToken = JsonToken.VALUE_TRUE;\n                return;\n            case INT_FALSE:\n                _nextToken = JsonToken.VALUE_FALSE;\n                return;\n            case INT_NULL:\n                _nextToken = JsonToken.VALUE_NULL;\n                return;\n            case INT_MINUS:\n                _nextToken = parseNumberText(i);\n                return;\n            default:\n                _nextToken = parseNumberText(i);\n                return;\n        }\n    }\n    // Colon should always follow the current token name.\n    _reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,28 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +30,47 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+    if (i == INT_QUOTE) {\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Remove unnecessary bounds check on input buffer\n+        if ((_inputPtr + len) < _inputEnd) {\n+            // Only check ending double quote\n+            int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        // Only skip colon if the current token is not END_OBJECT\n+                        if (!_isNextTokenEndObject(_skipColonFast(ptr + 1))) {\n+                            // Set the next token to FIELD_NAME and return true\n+                            _currToken = JsonToken.FIELD_NAME;\n+                            return true;\n+                        }\n+                        _currToken = JsonToken.END_OBJECT;\n+                        return false;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n             }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+        }\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,6 +1,5 @@\n @Override\n public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -43,23 +42,26 @@\n         return false;\n     }\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n         char[] nameChars = sstr.asQuotedChars();\n         final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n+        // Remove unnecessary bounds check on input buffer\n+        if ((_inputPtr + len) < _inputEnd) {\n+            // Only check ending double quote\n+            int end = _inputPtr + len;\n             if (_inputBuffer[end] == '\"') {\n                 int offset = 0;\n                 int ptr = _inputPtr;\n                 while (true) {\n                     if (ptr == end) {\n-                        // yes, match!\n                         _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n+                        // Only skip colon if the current token is not END_OBJECT\n+                        if (!_isNextTokenEndObject(_skipColonFast(ptr + 1))) {\n+                            // Set the next token to FIELD_NAME and return true\n+                            _currToken = JsonToken.FIELD_NAME;\n+                            return true;\n+                        }\n+                        _currToken = JsonToken.END_OBJECT;\n+                        return false;\n                     }\n                     if (nameChars[offset] != _inputBuffer[ptr]) {\n                         break;\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,9 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +12,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +22,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +31,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,57 +39,38 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Remove unnecessary bounds check on input buffer\n+        if ((_inputPtr + len) < _inputEnd) {\n+            // Only check ending double quote\n+            int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        // Only skip colon if the current token is not END_OBJECT\n+                        if (!_isNextTokenEndObject(_skipColonFast(ptr + 1))) {\n+                            // Set the next token to FIELD_NAME and return true\n+                            _currToken = JsonToken.FIELD_NAME;\n+                            return true;\n+                        }\n+                        _currToken = JsonToken.END_OBJECT;\n+                        return false;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,76 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Remove unnecessary bounds check on input buffer\n+        if ((_inputPtr + len) < _inputEnd) {\n+            // Only check ending double quote\n+            int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        // Only skip colon if the current token is not END_OBJECT\n+                        if (!_isNextTokenEndObject(_skipColonFast(ptr + 1))) {\n+                            // Set the next token to FIELD_NAME and return true\n+                            _currToken = JsonToken.FIELD_NAME;\n+                            return true;\n+                        }\n+                        _currToken = JsonToken.END_OBJECT;\n+                        return false;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,76 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Remove unnecessary bounds check on input buffer\n+        if ((_inputPtr + len) < _inputEnd) {\n+            // Only check ending double quote\n+            int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        // Only skip colon if the current token is not END_OBJECT\n+                        if (!_isNextTokenEndObject(_skipColonFast(ptr + 1))) {\n+                            // Set the next token to FIELD_NAME and return true\n+                            _currToken = JsonToken.FIELD_NAME;\n+                            return true;\n+                        }\n+                        _currToken = JsonToken.END_OBJECT;\n+                        return false;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    // // // Note: most of code below is copied from nextToken()\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i == INT_QUOTE) {\n        // when doing literal match, must consider escaping:\n        char[] nameChars = sstr.asQuotedChars();\n        final int len = nameChars.length;\n        // Require 4 more bytes for faster skipping of colon that follows name\n        if ((_inputPtr + len + 4) < _inputEnd) {\n            // maybe...\n            // first check length match by\n            final int end = _inputPtr + len;\n            if (_inputBuffer[end] == '\"') {\n                int offset = 0;\n                int ptr = _inputPtr;\n                while (true) {\n                    if (ptr == end) {\n                        // yes, match!\n                        _parsingContext.setCurrentName(sstr.getValue());\n                        _isNextTokenNameYes(_skipColonFast(end + 1));\n                        break;\n                    }\n                    if (nameChars[offset] != _inputBuffer[ptr]) {\n                        break;\n                    }\n                    ++offset;\n                    ++ptr;\n                }\n                if (ptr == end) {\n                    return true;\n                }\n            }\n        }\n    }\n    return _isNextTokenNameMaybe(i, sstr.getValue());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,29 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +31,47 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(end + 1));\n+                        break;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+                if (ptr == end) {\n+                    return true;\n+                }\n             }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+        }\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -58,8 +58,8 @@\n                     if (ptr == end) {\n                         // yes, match!\n                         _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n+                        _isNextTokenNameYes(_skipColonFast(end + 1));\n+                        break;\n                     }\n                     if (nameChars[offset] != _inputBuffer[ptr]) {\n                         break;\n@@ -67,6 +67,9 @@\n                     ++offset;\n                     ++ptr;\n                 }\n+                if (ptr == end) {\n+                    return true;\n+                }\n             }\n         }\n     }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,10 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +13,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +23,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +32,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,57 +40,38 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(end + 1));\n+                        break;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+                if (ptr == end) {\n+                    return true;\n+                }\n+            }\n+        }\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,77 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(end + 1));\n+                        break;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+                if (ptr == end) {\n+                    return true;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,77 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(end + 1));\n+                        break;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+                if (ptr == end) {\n+                    return true;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i == INT_QUOTE) {\n        // Use new method to match field name\n        return _isNextTokenNameYes(_skipColonFast(_fastMatchName(sstr)));\n    }\n    return _isNextTokenNameMaybe(i, sstr.getValue());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,28 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +30,20 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+    if (i == INT_QUOTE) {\n+        // Use new method to match field name\n+        return _isNextTokenNameYes(_skipColonFast(_fastMatchName(sstr)));\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,6 +1,5 @@\n @Override\n public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -43,32 +42,8 @@\n         return false;\n     }\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n+        // Use new method to match field name\n+        return _isNextTokenNameYes(_skipColonFast(_fastMatchName(sstr)));\n     }\n     return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,9 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +12,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +22,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +31,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,57 +39,11 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        // Use new method to match field name\n+        return _isNextTokenNameYes(_skipColonFast(_fastMatchName(sstr)));\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,49 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // Use new method to match field name\n+        return _isNextTokenNameYes(_skipColonFast(_fastMatchName(sstr)));\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,49 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // Use new method to match field name\n+        return _isNextTokenNameYes(_skipColonFast(_fastMatchName(sstr)));\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    // // // Note: most of code below is copied from nextToken()\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.clearAndGetParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.clearAndGetParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i == INT_QUOTE) {\n        // when doing literal match, must consider escaping:\n        char[] nameChars = sstr.asQuotedChars();\n        final int len = nameChars.length;\n        // Require 4 more bytes for faster skipping of colon that follows name\n        if ((_inputPtr + len + 4) < _inputEnd) {\n            // maybe...\n            // first check length match by\n            final int end = _inputPtr + len;\n            if (_inputBuffer[end] == '\"') {\n                int offset = 0;\n                int ptr = _inputPtr;\n                while (true) {\n                    if (ptr == end) {\n                        // yes, match!\n                        _parsingContext.setCurrentName(sstr.getValue());\n                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n                        return true;\n                    }\n                    if (nameChars[offset] != _inputBuffer[ptr]) {\n                        break;\n                    }\n                    ++offset;\n                    ++ptr;\n                }\n            }\n        }\n    }\n    _parsingContext.setCurrentName(sstr.getValue());\n    _currToken = JsonToken.FIELD_NAME;\n    _isNextTokenNameYes(i);\n    return true;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,77 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _parsingContext = _parsingContext.clearAndGetParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n             _reportMismatchedEndMarker(i, ']');\n         }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _parsingContext = _parsingContext.clearAndGetParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n             }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+        }\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _parsingContext.setCurrentName(sstr.getValue());\n+    _currToken = JsonToken.FIELD_NAME;\n+    _isNextTokenNameYes(i);\n+    return true;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -21,7 +21,7 @@\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n-        _parsingContext = _parsingContext.getParent();\n+        _parsingContext = _parsingContext.clearAndGetParent();\n         _currToken = JsonToken.END_ARRAY;\n         return false;\n     }\n@@ -30,7 +30,7 @@\n         if (!_parsingContext.inObject()) {\n             _reportMismatchedEndMarker(i, ']');\n         }\n-        _parsingContext = _parsingContext.getParent();\n+        _parsingContext = _parsingContext.clearAndGetParent();\n         _currToken = JsonToken.END_OBJECT;\n         return false;\n     }\n@@ -70,5 +70,8 @@\n             }\n         }\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    _parsingContext.setCurrentName(sstr.getValue());\n+    _currToken = JsonToken.FIELD_NAME;\n+    _isNextTokenNameYes(i);\n+    return true;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,10 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +13,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -21,18 +21,18 @@\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n-        _parsingContext = _parsingContext.getParent();\n+        _parsingContext = _parsingContext.clearAndGetParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n             _reportMismatchedEndMarker(i, ']');\n         }\n-        _parsingContext = _parsingContext.getParent();\n+        _parsingContext = _parsingContext.clearAndGetParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,57 +40,38 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    _parsingContext.setCurrentName(sstr.getValue());\n     _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    _isNextTokenNameYes(i);\n+    return true;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,77 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.clearAndGetParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.clearAndGetParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    _parsingContext.setCurrentName(sstr.getValue());\n+    _currToken = JsonToken.FIELD_NAME;\n+    _isNextTokenNameYes(i);\n+    return true;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,77 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    // // // Note: most of code below is copied from nextToken()\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.clearAndGetParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.clearAndGetParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // when doing literal match, must consider escaping:\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        // Require 4 more bytes for faster skipping of colon that follows name\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            // maybe...\n+            // first check length match by\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // yes, match!\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    _parsingContext.setCurrentName(sstr.getValue());\n+    _currToken = JsonToken.FIELD_NAME;\n+    _isNextTokenNameYes(i);\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic boolean nextFieldName(SerializableString sstr) throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return false;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return false;\n    }\n\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return false;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return false;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        if (i == INT_QUOTE) {\n            sstr.getValue();\n        }\n        _nextTokenNotInObject(i);\n        return false;\n    }\n    if (i == INT_QUOTE) {\n        // If the string is already quoted, there is no need to convert it to\n        // quoted chars\n        char[] nameChars = sstr.asQuotedChars();\n        final int len = nameChars.length;\n        if ((_inputPtr + len + 4) < _inputEnd) {\n            final int end = _inputPtr + len;\n            if (_inputBuffer[end] == '\"') {\n                int offset = 0;\n                int ptr = _inputPtr;\n                while (true) {\n                    if (ptr == end) {\n                        // Match found\n                        _parsingContext.setCurrentName(sstr.getValue());\n                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n                        return true;\n                    }\n                    if (nameChars[offset] != _inputBuffer[ptr]) {\n                        break;\n                    }\n                    ++offset;\n                    ++ptr;\n                }\n            }\n        }\n    }\n    return _isNextTokenNameMaybe(i, sstr.getValue());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,28 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return false;\n     }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n+\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +30,46 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n+\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        if (i == INT_QUOTE) {\n+            sstr.getValue();\n+        }\n+        _nextTokenNotInObject(i);\n+        return false;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n+    if (i == INT_QUOTE) {\n+        // If the string is already quoted, there is no need to convert it to\n+        // quoted chars\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // Match found\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n             }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+        }\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,6 +1,5 @@\n @Override\n public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -15,7 +14,7 @@\n         _currToken = null;\n         return false;\n     }\n-    _binaryValue = null;\n+\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n@@ -37,26 +36,28 @@\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n+\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n+        if (i == INT_QUOTE) {\n+            sstr.getValue();\n+        }\n         _nextTokenNotInObject(i);\n         return false;\n     }\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n+        // If the string is already quoted, there is no need to convert it to\n+        // quoted chars\n         char[] nameChars = sstr.asQuotedChars();\n         final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n         if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n             final int end = _inputPtr + len;\n             if (_inputBuffer[end] == '\"') {\n                 int offset = 0;\n                 int ptr = _inputPtr;\n                 while (true) {\n                     if (ptr == end) {\n-                        // yes, match!\n+                        // Match found\n                         _parsingContext.setCurrentName(sstr.getValue());\n                         _isNextTokenNameYes(_skipColonFast(ptr + 1));\n                         return true;\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,9 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return null;\n+        return false;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,9 +12,9 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return null;\n+        return false;\n     }\n-    _binaryValue = null;\n+\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n@@ -23,7 +22,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return null;\n+        return false;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,65 +31,45 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return null;\n+        return false;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n+\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n+        if (i == INT_QUOTE) {\n+            sstr.getValue();\n+        }\n         _nextTokenNotInObject(i);\n-        return null;\n+        return false;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        // If the string is already quoted, there is no need to convert it to\n+        // quoted chars\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // Match found\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,75 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return false;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        if (i == INT_QUOTE) {\n+            sstr.getValue();\n+        }\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // If the string is already quoted, there is no need to convert it to\n+        // quoted chars\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // Match found\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,75 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public boolean nextFieldName(SerializableString sstr) throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return false;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return false;\n+    }\n+\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return false;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return false;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        if (i == INT_QUOTE) {\n+            sstr.getValue();\n+        }\n+        _nextTokenNotInObject(i);\n+        return false;\n+    }\n+    if (i == INT_QUOTE) {\n+        // If the string is already quoted, there is no need to convert it to\n+        // quoted chars\n+        char[] nameChars = sstr.asQuotedChars();\n+        final int len = nameChars.length;\n+        if ((_inputPtr + len + 4) < _inputEnd) {\n+            final int end = _inputPtr + len;\n+            if (_inputBuffer[end] == '\"') {\n+                int offset = 0;\n+                int ptr = _inputPtr;\n+                while (true) {\n+                    if (ptr == end) {\n+                        // Match found\n+                        _parsingContext.setCurrentName(sstr.getValue());\n+                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n+                        return true;\n+                    }\n+                    if (nameChars[offset] != _inputBuffer[ptr]) {\n+                        break;\n+                    }\n+                    ++offset;\n+                    ++ptr;\n+                }\n+            }\n+        }\n+    }\n+    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]