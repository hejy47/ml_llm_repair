[{"output": "@Override\npublic String nextFieldName() throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return name;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,28 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,59 +30,41 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n+        if (i < 0) {\n+            close();\n+            _currToken = null;\n+            return null;\n+        }\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n@@ -99,14 +78,28 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,9 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +12,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +22,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,43 +31,75 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n+        if (i < 0) {\n+            close();\n+            _currToken = null;\n+            return null;\n+        }\n     }\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,6 +1,5 @@\n @Override\n public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -36,6 +35,11 @@\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n+        if (i < 0) {\n+            close();\n+            _currToken = null;\n+            return null;\n+        }\n     }\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n@@ -46,6 +50,11 @@\n     _parsingContext.setCurrentName(name);\n     _currToken = JsonToken.FIELD_NAME;\n     i = _skipColon();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n     if (i == INT_QUOTE) {\n         _tokenIncomplete = true;\n         _nextToken = JsonToken.VALUE_STRING;\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,105 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+        if (i < 0) {\n+            close();\n+            _currToken = null;\n+            return null;\n+        }\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,105 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+        if (i < 0) {\n+            close();\n+            _currToken = null;\n+            return null;\n+        }\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name;\n    if (i == INT_QUOTE) {\n        name = _parseName();\n    } else {\n        if (!_parsingContext.getFactory().isEnabled(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        }\n        name = _handleUnusualFieldName(i);\n    }\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    JsonToken t;\n    switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return name;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,28 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,59 +30,38 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n     }\n-    // Ok: we must have a value... what is it?\n+    String name;\n+    if (i == INT_QUOTE) {\n+        name = _parseName();\n+    } else {\n+        if (!_parsingContext.getFactory().isEnabled(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n+            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+        }\n+        name = _handleUnusualFieldName(i);\n+    }\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n     JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n+    switch (i) {\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n@@ -99,14 +75,28 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,9 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +12,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +22,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +31,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,35 +39,64 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n     }\n+    String name;\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n+        name = _parseName();\n+    } else {\n+        if (!_parsingContext.getFactory().isEnabled(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n+            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n         }\n+        name = _handleUnusualFieldName(i);\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch (i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,6 +1,5 @@\n @Override\n public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -42,7 +41,15 @@\n         _nextTokenNotInObject(i);\n         return null;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    String name;\n+    if (i == INT_QUOTE) {\n+        name = _parseName();\n+    } else {\n+        if (!_parsingContext.getFactory().isEnabled(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n+            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+        }\n+        name = _handleUnusualFieldName(i);\n+    }\n     _parsingContext.setCurrentName(name);\n     _currToken = JsonToken.FIELD_NAME;\n     i = _skipColon();\n@@ -51,9 +58,8 @@\n         _nextToken = JsonToken.VALUE_STRING;\n         return name;\n     }\n-    // Ok: we must have a value... what is it?\n     JsonToken t;\n-    switch(i) {\n+    switch (i) {\n         case '-':\n             t = _parseNegNumber();\n             break;\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,102 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name;\n+    if (i == INT_QUOTE) {\n+        name = _parseName();\n+    } else {\n+        if (!_parsingContext.getFactory().isEnabled(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n+            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+        }\n+        name = _handleUnusualFieldName(i);\n+    }\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch (i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,102 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name;\n+    if (i == INT_QUOTE) {\n+        name = _parseName();\n+    } else {\n+        if (!_parsingContext.getFactory().isEnabled(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n+            _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+        }\n+        name = _handleUnusualFieldName(i);\n+    }\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch (i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n        if (i < 0) {\n            _handleEOF();\n        }\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return name;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,28 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,59 +30,34 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n+        if (i < 0) {\n+            _handleEOF();\n+        }\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n@@ -99,14 +71,28 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,9 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +12,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +22,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,43 +31,68 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n+        if (i < 0) {\n+            _handleEOF();\n+        }\n     }\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n     }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,6 +1,5 @@\n @Override\n public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -36,6 +35,9 @@\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n+        if (i < 0) {\n+            _handleEOF();\n+        }\n     }\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,98 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+        if (i < 0) {\n+            _handleEOF();\n+        }\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,98 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+        if (i < 0) {\n+            _handleEOF();\n+        }\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        // _nextAfterName();\n        _currToken = _nextToken;\n        _nextToken = null;\n        _tokenInputRow = _currInputRow;\n        _tokenInputCol = _currInputRow;\n        _tokenOffset = _currInputProcessed;\n        return _parsingContext.getCurrentName();\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n    if (i == INT_QUOTE) {\n        // _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return name;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,33 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        // _nextAfterName();\n+        _currToken = _nextToken;\n+        _nextToken = null;\n+        _tokenInputRow = _currInputRow;\n+        _tokenInputCol = _currInputRow;\n+        _tokenOffset = _currInputProcessed;\n+        return _parsingContext.getCurrentName();\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,59 +35,31 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        // _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n@@ -99,14 +73,28 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,14 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+        // _nextAfterName();\n+        _currToken = _nextToken;\n+        _nextToken = null;\n+        _tokenInputRow = _currInputRow;\n+        _tokenInputCol = _currInputRow;\n+        _tokenOffset = _currInputProcessed;\n+        return _parsingContext.getCurrentName();\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +17,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +27,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +36,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,35 +44,57 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n     }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n+        // _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,10 +1,14 @@\n @Override\n public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n+        // _nextAfterName();\n+        _currToken = _nextToken;\n+        _nextToken = null;\n+        _tokenInputRow = _currInputRow;\n+        _tokenInputCol = _currInputRow;\n+        _tokenOffset = _currInputProcessed;\n+        return _parsingContext.getCurrentName();\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -47,7 +51,7 @@\n     _currToken = JsonToken.FIELD_NAME;\n     i = _skipColon();\n     if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n+        // _tokenIncomplete = true;\n         _nextToken = JsonToken.VALUE_STRING;\n         return name;\n     }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,100 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        // _nextAfterName();\n+        _currToken = _nextToken;\n+        _nextToken = null;\n+        _tokenInputRow = _currInputRow;\n+        _tokenInputCol = _currInputRow;\n+        _tokenOffset = _currInputProcessed;\n+        return _parsingContext.getCurrentName();\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        // _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,100 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        // _nextAfterName();\n+        _currToken = _nextToken;\n+        _nextToken = null;\n+        _tokenInputRow = _currInputRow;\n+        _tokenInputCol = _currInputRow;\n+        _tokenOffset = _currInputProcessed;\n+        return _parsingContext.getCurrentName();\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        // _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColonFast(i + 1);\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return name;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,29 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,59 +31,31 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColonFast(i + 1);\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n@@ -99,14 +69,28 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,10 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n+    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +13,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +23,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +32,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,35 +40,57 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n     }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColonFast(i + 1);\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -45,7 +45,7 @@\n     String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n     _parsingContext.setCurrentName(name);\n     _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n+    i = _skipColonFast(i + 1);\n     if (i == INT_QUOTE) {\n         _tokenIncomplete = true;\n         _nextToken = JsonToken.VALUE_STRING;\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,96 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColonFast(i + 1);\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,96 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColonFast(i + 1);\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name;\n    if (i == INT_QUOTE) {\n        name = _parseName();\n    } else if (i == INT_APOSTROPHE) {\n        name = _parseName2();\n    } else {\n        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        name = _parseName(); // doesn't really matter\n    }\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    JsonToken t;\n    switch (i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return name;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,28 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,59 +30,38 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n     }\n-    // Ok: we must have a value... what is it?\n+    String name;\n+    if (i == INT_QUOTE) {\n+        name = _parseName();\n+    } else if (i == INT_APOSTROPHE) {\n+        name = _parseName2();\n+    } else {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+        name = _parseName(); // doesn't really matter\n+    }\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n     JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n+    switch (i) {\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n@@ -99,14 +75,28 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,9 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +12,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +22,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +31,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,35 +39,64 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n     }\n+    String name;\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n+        name = _parseName();\n+    } else if (i == INT_APOSTROPHE) {\n+        name = _parseName2();\n+    } else {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+        name = _parseName(); // doesn't really matter\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch (i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,6 +1,5 @@\n @Override\n public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -42,7 +41,15 @@\n         _nextTokenNotInObject(i);\n         return null;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    String name;\n+    if (i == INT_QUOTE) {\n+        name = _parseName();\n+    } else if (i == INT_APOSTROPHE) {\n+        name = _parseName2();\n+    } else {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+        name = _parseName(); // doesn't really matter\n+    }\n     _parsingContext.setCurrentName(name);\n     _currToken = JsonToken.FIELD_NAME;\n     i = _skipColon();\n@@ -51,9 +58,8 @@\n         _nextToken = JsonToken.VALUE_STRING;\n         return name;\n     }\n-    // Ok: we must have a value... what is it?\n     JsonToken t;\n-    switch(i) {\n+    switch (i) {\n         case '-':\n             t = _parseNegNumber();\n             break;\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,102 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name;\n+    if (i == INT_QUOTE) {\n+        name = _parseName();\n+    } else if (i == INT_APOSTROPHE) {\n+        name = _parseName2();\n+    } else {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+        name = _parseName(); // doesn't really matter\n+    }\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch (i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,102 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name;\n+    if (i == INT_QUOTE) {\n+        name = _parseName();\n+    } else if (i == INT_APOSTROPHE) {\n+        name = _parseName2();\n+    } else {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+        name = _parseName(); // doesn't really matter\n+    }\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch (i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, ']'); // fix: changed '}' to ']'\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    JsonToken t;\n    switch(i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return name;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,91 +1,59 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']'); // fix: changed '}' to ']'\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n     }\n-    // Ok: we must have a value... what is it?\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n     JsonToken t;\n     switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n@@ -99,14 +67,28 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,9 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,26 +12,26 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']'); // fix: changed '}' to ']'\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,35 +39,56 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n     }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,6 +1,5 @@\n @Override\n public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -19,7 +18,7 @@\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']'); // fix: changed '}' to ']'\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n@@ -28,7 +27,7 @@\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n@@ -51,7 +50,6 @@\n         _nextToken = JsonToken.VALUE_STRING;\n         return name;\n     }\n-    // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n         case '-':\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,94 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, ']'); // fix: changed '}' to ']'\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,94 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, ']'); // fix: changed '}' to ']'\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n        if (i < 0) {\n            close();\n            _currToken = null;\n            return null;\n        }\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _updateLocation();\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    JsonToken t;\n    switch(i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return name;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,28 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,59 +30,41 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n+        if (i < 0) {\n+            close();\n+            _currToken = null;\n+            return null;\n+        }\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n     }\n-    // Ok: we must have a value... what is it?\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _updateLocation();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n     JsonToken t;\n     switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n@@ -99,14 +78,28 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,9 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +12,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +22,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,43 +31,75 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n+        if (i < 0) {\n+            close();\n+            _currToken = null;\n+            return null;\n+        }\n     }\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n     }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _updateLocation();\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,6 +1,5 @@\n @Override\n public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -36,6 +35,11 @@\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n+        if (i < 0) {\n+            close();\n+            _currToken = null;\n+            return null;\n+        }\n     }\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n@@ -46,12 +50,17 @@\n     _parsingContext.setCurrentName(name);\n     _currToken = JsonToken.FIELD_NAME;\n     i = _skipColon();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _updateLocation();\n     if (i == INT_QUOTE) {\n         _tokenIncomplete = true;\n         _nextToken = JsonToken.VALUE_STRING;\n         return name;\n     }\n-    // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n         case '-':\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,105 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+        if (i < 0) {\n+            close();\n+            _currToken = null;\n+            return null;\n+        }\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _updateLocation();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,105 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+        if (i < 0) {\n+            close();\n+            _currToken = null;\n+            return null;\n+        }\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _updateLocation();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker('}', i);\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(']', i);\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name;\n    if (i == INT_QUOTE) {\n        name = _parseName();\n    } else if (i == INT_APOSTROPHE) {\n        name = _parseName2();\n    } else {\n        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n        // the line below should be unreachable code\n        name = \"\"; // to make compiler happy\n    }\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return name;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,91 +1,70 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker('}', i);\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(']', i);\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name;\n+    if (i == INT_QUOTE) {\n+        name = _parseName();\n+    } else if (i == INT_APOSTROPHE) {\n+        name = _parseName2();\n+    } else {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+        // the line below should be unreachable code\n+        name = \"\"; // to make compiler happy\n+    }\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n@@ -99,14 +78,28 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,10 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n+    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,26 +13,26 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker('}', i);\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(']', i);\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,35 +40,66 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n     }\n+    String name;\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n+        name = _parseName();\n+    } else if (i == INT_APOSTROPHE) {\n+        name = _parseName2();\n+    } else {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+        // the line below should be unreachable code\n+        name = \"\"; // to make compiler happy\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -19,7 +19,7 @@\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker('}', i);\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n@@ -28,7 +28,7 @@\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(']', i);\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n@@ -42,7 +42,16 @@\n         _nextTokenNotInObject(i);\n         return null;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    String name;\n+    if (i == INT_QUOTE) {\n+        name = _parseName();\n+    } else if (i == INT_APOSTROPHE) {\n+        name = _parseName2();\n+    } else {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+        // the line below should be unreachable code\n+        name = \"\"; // to make compiler happy\n+    }\n     _parsingContext.setCurrentName(name);\n     _currToken = JsonToken.FIELD_NAME;\n     i = _skipColon();\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,105 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker('}', i);\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(']', i);\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name;\n+    if (i == INT_QUOTE) {\n+        name = _parseName();\n+    } else if (i == INT_APOSTROPHE) {\n+        name = _parseName2();\n+    } else {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+        // the line below should be unreachable code\n+        name = \"\"; // to make compiler happy\n+    }\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,105 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker('}', i);\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(']', i);\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name;\n+    if (i == INT_QUOTE) {\n+        name = _parseName();\n+    } else if (i == INT_APOSTROPHE) {\n+        name = _parseName2();\n+    } else {\n+        _reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n+        // the line below should be unreachable code\n+        name = \"\"; // to make compiler happy\n+    }\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker('}', i);\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(']', i);\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    JsonToken t;\n    switch(i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchToken(\"false\", 1);\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchToken(\"null\", 1);\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchToken(\"true\", 1);\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return name;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,86 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker('}', i);\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(']', i);\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n     }\n-    // Ok: we must have a value... what is it?\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n     JsonToken t;\n     switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n+        case '-':\n+            t = _parseNegNumber();\n             break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n+        case '0': case '1': case '2': case '3': case '4':\n+        case '5': case '6': case '7': case '8': case '9':\n+            t = _parsePosNumber(i);\n             break;\n         case 'f':\n-            _matchFalse();\n+            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n             break;\n         case 'n':\n-            _matchNull();\n+            _matchToken(\"null\", 1);\n             t = JsonToken.VALUE_NULL;\n             break;\n-        case '-':\n-                        t = _parseNegNumber();\n+        case 't':\n+            _matchToken(\"true\", 1);\n+            t = JsonToken.VALUE_TRUE;\n             break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n             break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,9 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,26 +12,26 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker('}', i);\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(']', i);\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,35 +39,48 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n     }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0': case '1': case '2': case '3': case '4':\n+        case '5': case '6': case '7': case '8': case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchToken(\"false\", 1);\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchToken(\"null\", 1);\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchToken(\"true\", 1);\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,6 +1,5 @@\n @Override\n public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -19,7 +18,7 @@\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker('}', i);\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n@@ -28,7 +27,7 @@\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(']', i);\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n@@ -51,41 +50,32 @@\n         _nextToken = JsonToken.VALUE_STRING;\n         return name;\n     }\n-    // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n         case '-':\n             t = _parseNegNumber();\n             break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n+        case '0': case '1': case '2': case '3': case '4':\n+        case '5': case '6': case '7': case '8': case '9':\n             t = _parsePosNumber(i);\n             break;\n         case 'f':\n-            _matchFalse();\n+            _matchToken(\"false\", 1);\n             t = JsonToken.VALUE_FALSE;\n             break;\n         case 'n':\n-            _matchNull();\n+            _matchToken(\"null\", 1);\n             t = JsonToken.VALUE_NULL;\n             break;\n         case 't':\n-            _matchTrue();\n+            _matchToken(\"true\", 1);\n             t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n             break;\n         case '[':\n             t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n             break;\n         default:\n             t = _handleOddValue(i);\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,86 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker('}', i);\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(']', i);\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0': case '1': case '2': case '3': case '4':\n+        case '5': case '6': case '7': case '8': case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchToken(\"false\", 1);\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchToken(\"null\", 1);\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchToken(\"true\", 1);\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,86 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker('}', i);\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(']', i);\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0': case '1': case '2': case '3': case '4':\n+        case '5': case '6': case '7': case '8': case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchToken(\"false\", 1);\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchToken(\"null\", 1);\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchToken(\"true\", 1);\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma() && i != INT_COMMA) {\n        _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.getTypeDesc() + \" entries\");\n    }\n    i = _skipWS();\n    if (_parsingContext.inObject()) {\n        String name;\n        if (i == INT_QUOTE) {\n            name = _parseName();\n        } else {\n            name = _handleOddName(i);\n        }\n        _parsingContext.setCurrentName(name);\n        _currToken = JsonToken.FIELD_NAME;\n        i = _skipColon();\n    }\n    _updateLocation();\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return _parsingContext.getCurrentName();\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return _parsingContext.getCurrentName();\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,28 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,59 +30,35 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n+    if (_parsingContext.expectComma() && i != INT_COMMA) {\n+        _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.getTypeDesc() + \" entries\");\n     }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    i = _skipWS();\n+    if (_parsingContext.inObject()) {\n+        String name;\n+        if (i == INT_QUOTE) {\n+            name = _parseName();\n+        } else {\n+            name = _handleOddName(i);\n+        }\n         _parsingContext.setCurrentName(name);\n         _currToken = JsonToken.FIELD_NAME;\n         i = _skipColon();\n     }\n+    _updateLocation();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return _parsingContext.getCurrentName();\n+    }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n@@ -99,14 +72,28 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _nextToken = t;\n+    return _parsingContext.getCurrentName();\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,9 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +12,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +22,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,43 +31,69 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n+    if (_parsingContext.expectComma() && i != INT_COMMA) {\n+        _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.getTypeDesc() + \" entries\");\n+    }\n+    i = _skipWS();\n+    if (_parsingContext.inObject()) {\n+        String name;\n+        if (i == INT_QUOTE) {\n+            name = _parseName();\n+        } else {\n+            name = _handleOddName(i);\n+        }\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return _parsingContext.getCurrentName();\n     }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    _nextToken = t;\n+    return _parsingContext.getCurrentName();\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,6 +1,5 @@\n @Override\n public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -34,22 +33,26 @@\n         _currToken = JsonToken.END_OBJECT;\n         return null;\n     }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n+    if (_parsingContext.expectComma() && i != INT_COMMA) {\n+        _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.getTypeDesc() + \" entries\");\n+    }\n+    i = _skipWS();\n+    if (_parsingContext.inObject()) {\n+        String name;\n+        if (i == INT_QUOTE) {\n+            name = _parseName();\n+        } else {\n+            name = _handleOddName(i);\n+        }\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n     }\n     _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n     if (i == INT_QUOTE) {\n         _tokenIncomplete = true;\n         _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n+        return _parsingContext.getCurrentName();\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n@@ -92,5 +95,5 @@\n             break;\n     }\n     _nextToken = t;\n-    return name;\n+    return _parsingContext.getCurrentName();\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,99 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma() && i != INT_COMMA) {\n+        _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.getTypeDesc() + \" entries\");\n+    }\n+    i = _skipWS();\n+    if (_parsingContext.inObject()) {\n+        String name;\n+        if (i == INT_QUOTE) {\n+            name = _parseName();\n+        } else {\n+            name = _handleOddName(i);\n+        }\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    _updateLocation();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return _parsingContext.getCurrentName();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return _parsingContext.getCurrentName();\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,99 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma() && i != INT_COMMA) {\n+        _reportUnexpectedChar(i, \"was expecting comma to separate \" + _parsingContext.getTypeDesc() + \" entries\");\n+    }\n+    i = _skipWS();\n+    if (_parsingContext.inObject()) {\n+        String name;\n+        if (i == INT_QUOTE) {\n+            name = _parseName();\n+        } else {\n+            name = _handleOddName(i);\n+        }\n+        _parsingContext.setCurrentName(name);\n+        _currToken = JsonToken.FIELD_NAME;\n+        i = _skipColon();\n+    }\n+    _updateLocation();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return _parsingContext.getCurrentName();\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return _parsingContext.getCurrentName();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i;\n    try {\n        i = _skipWSOrEnd();\n    } catch (JsonParseException e) {\n        _reportInvalidEOF(\": was expecting closing quote for a string value\", JsonToken.FIELD_NAME);\n        throw e; // to make compiler happy\n    }\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name;\n    if (i != INT_QUOTE) {\n        name = _handleOddName(i);\n    } else {\n        if ((_inputPtr + 13) <= _inputEnd) { // fast path, common case\n            name = _fastParseName();\n        } else {\n            name = _parseName();\n        }\n    }\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    JsonToken t;\n    switch(i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return name;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,34 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n-    int i = _skipWSOrEnd();\n+    int i;\n+    try {\n+        i = _skipWSOrEnd();\n+    } catch (JsonParseException e) {\n+        _reportInvalidEOF(\": was expecting closing quote for a string value\", JsonToken.FIELD_NAME);\n+        throw e; // to make compiler happy\n+    }\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,59 +36,39 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n     }\n-    // Ok: we must have a value... what is it?\n+    String name;\n+    if (i != INT_QUOTE) {\n+        name = _handleOddName(i);\n+    } else {\n+        if ((_inputPtr + 13) <= _inputEnd) { // fast path, common case\n+            name = _fastParseName();\n+        } else {\n+            name = _parseName();\n+        }\n+    }\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n     JsonToken t;\n     switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n@@ -99,14 +82,28 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,19 +1,24 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n     }\n-    int i = _skipWSOrEnd();\n+    int i;\n+    try {\n+        i = _skipWSOrEnd();\n+    } catch (JsonParseException e) {\n+        _reportInvalidEOF(\": was expecting closing quote for a string value\", JsonToken.FIELD_NAME);\n+        throw e; // to make compiler happy\n+    }\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +28,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +37,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,35 +45,65 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n     }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n+    String name;\n+    if (i != INT_QUOTE) {\n+        name = _handleOddName(i);\n+    } else {\n+        if ((_inputPtr + 13) <= _inputEnd) { // fast path, common case\n+            name = _fastParseName();\n+        } else {\n+            name = _parseName();\n         }\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,6 +1,5 @@\n @Override\n public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -9,7 +8,13 @@\n     if (_tokenIncomplete) {\n         _skipString();\n     }\n-    int i = _skipWSOrEnd();\n+    int i;\n+    try {\n+        i = _skipWSOrEnd();\n+    } catch (JsonParseException e) {\n+        _reportInvalidEOF(\": was expecting closing quote for a string value\", JsonToken.FIELD_NAME);\n+        throw e; // to make compiler happy\n+    }\n     if (i < 0) {\n         close();\n         _currToken = null;\n@@ -42,7 +47,16 @@\n         _nextTokenNotInObject(i);\n         return null;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    String name;\n+    if (i != INT_QUOTE) {\n+        name = _handleOddName(i);\n+    } else {\n+        if ((_inputPtr + 13) <= _inputEnd) { // fast path, common case\n+            name = _fastParseName();\n+        } else {\n+            name = _parseName();\n+        }\n+    }\n     _parsingContext.setCurrentName(name);\n     _currToken = JsonToken.FIELD_NAME;\n     i = _skipColon();\n@@ -51,7 +65,6 @@\n         _nextToken = JsonToken.VALUE_STRING;\n         return name;\n     }\n-    // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n         case '-':\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,109 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i;\n+    try {\n+        i = _skipWSOrEnd();\n+    } catch (JsonParseException e) {\n+        _reportInvalidEOF(\": was expecting closing quote for a string value\", JsonToken.FIELD_NAME);\n+        throw e; // to make compiler happy\n+    }\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name;\n+    if (i != INT_QUOTE) {\n+        name = _handleOddName(i);\n+    } else {\n+        if ((_inputPtr + 13) <= _inputEnd) { // fast path, common case\n+            name = _fastParseName();\n+        } else {\n+            name = _parseName();\n+        }\n+    }\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,109 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i;\n+    try {\n+        i = _skipWSOrEnd();\n+    } catch (JsonParseException e) {\n+        _reportInvalidEOF(\": was expecting closing quote for a string value\", JsonToken.FIELD_NAME);\n+        throw e; // to make compiler happy\n+    }\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name;\n+    if (i != INT_QUOTE) {\n+        name = _handleOddName(i);\n+    } else {\n+        if ((_inputPtr + 13) <= _inputEnd) { // fast path, common case\n+            name = _fastParseName();\n+        } else {\n+            name = _parseName();\n+        }\n+    }\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker('}', i);\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(']', i);\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return name;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,91 +1,61 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker('}', i);\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(']', i);\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n@@ -99,14 +69,28 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,10 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n+    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,26 +13,26 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker('}', i);\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(']', i);\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,35 +40,57 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n     }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -19,7 +19,7 @@\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker('}', i);\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n@@ -28,7 +28,7 @@\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(']', i);\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,96 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker('}', i);\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(']', i);\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,96 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker('}', i);\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(']', i);\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n        if (i < 0) {\n            _handleUnexpectedEndOfInput();\n        }\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return name;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,28 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,59 +30,34 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n+        if (i < 0) {\n+            _handleUnexpectedEndOfInput();\n+        }\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n@@ -99,14 +71,28 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,9 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +12,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +22,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,43 +31,68 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n+        if (i < 0) {\n+            _handleUnexpectedEndOfInput();\n+        }\n     }\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n     }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,6 +1,5 @@\n @Override\n public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -36,6 +35,9 @@\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n+        if (i < 0) {\n+            _handleUnexpectedEndOfInput();\n+        }\n     }\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,98 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+        if (i < 0) {\n+            _handleUnexpectedEndOfInput();\n+        }\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,98 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+        if (i < 0) {\n+            _handleUnexpectedEndOfInput();\n+        }\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0': case '1': case '2': case '3': case '4': \n        case '5': case '6': case '7': case '8': case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return name;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,80 +1,64 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n+        case '-':\n+            t = _parseNegNumber();\n             break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n+        case '0': case '1': case '2': case '3': case '4': \n+        case '5': case '6': case '7': case '8': case '9':\n+            t = _parsePosNumber(i);\n             break;\n         case 'f':\n             _matchFalse();\n@@ -84,29 +68,20 @@\n             _matchNull();\n             t = JsonToken.VALUE_NULL;\n             break;\n-        case '-':\n-                        t = _parseNegNumber();\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n             break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n             break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,9 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,26 +12,26 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,35 +39,49 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n     }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0': case '1': case '2': case '3': case '4': \n+        case '5': case '6': case '7': case '8': case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,6 +1,5 @@\n @Override\n public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -19,7 +18,7 @@\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n@@ -28,7 +27,7 @@\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n@@ -57,16 +56,8 @@\n         case '-':\n             t = _parseNegNumber();\n             break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n+        case '0': case '1': case '2': case '3': case '4': \n+        case '5': case '6': case '7': case '8': case '9':\n             t = _parsePosNumber(i);\n             break;\n         case 'f':\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,87 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0': case '1': case '2': case '3': case '4': \n+        case '5': case '6': case '7': case '8': case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,87 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0': case '1': case '2': case '3': case '4': \n+        case '5': case '6': case '7': case '8': case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    JsonToken savedToken = _currToken;\n    if (savedToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    JsonToken t;\n    switch(i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return name;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,29 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    JsonToken savedToken = _currToken;\n+    if (savedToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,59 +31,30 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n     }\n-    // Ok: we must have a value... what is it?\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n     JsonToken t;\n     switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n@@ -99,14 +68,28 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,10 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n+    JsonToken savedToken = _currToken;\n+    if (savedToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +13,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +23,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +32,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,35 +40,56 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n     }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,8 +1,8 @@\n @Override\n public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n+    JsonToken savedToken = _currToken;\n+    if (savedToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n         return null;\n     }\n@@ -51,7 +51,6 @@\n         _nextToken = JsonToken.VALUE_STRING;\n         return name;\n     }\n-    // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n         case '-':\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,95 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    JsonToken savedToken = _currToken;\n+    if (savedToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,95 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    JsonToken savedToken = _currToken;\n+    if (savedToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name = null;\n    if (i == INT_QUOTE) {\n        name = _parseName();\n    } else {\n        name = _handleOddName(i);\n    }\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    // Ok: we must have a value... what is it?\n    JsonToken t;\n    switch(i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return name;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,28 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,59 +30,36 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = null;\n+    if (i == INT_QUOTE) {\n+        name = _parseName();\n+    } else {\n+        name = _handleOddName(i);\n+    }\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n     // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n         case '-':\n-                        t = _parseNegNumber();\n+            t = _parseNegNumber();\n             break;\n         case '0':\n         case '1':\n@@ -99,14 +73,28 @@\n         case '9':\n             t = _parsePosNumber(i);\n             break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,9 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +12,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +22,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +31,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,35 +39,62 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n     }\n+    String name = null;\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n+        name = _parseName();\n+    } else {\n+        name = _handleOddName(i);\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,6 +1,5 @@\n @Override\n public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -42,7 +41,12 @@\n         _nextTokenNotInObject(i);\n         return null;\n     }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    String name = null;\n+    if (i == INT_QUOTE) {\n+        name = _parseName();\n+    } else {\n+        name = _handleOddName(i);\n+    }\n     _parsingContext.setCurrentName(name);\n     _currToken = JsonToken.FIELD_NAME;\n     i = _skipColon();\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,100 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = null;\n+    if (i == INT_QUOTE) {\n+        name = _parseName();\n+    } else {\n+        name = _handleOddName(i);\n+    }\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,100 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = null;\n+    if (i == INT_QUOTE) {\n+        name = _parseName();\n+    } else {\n+        name = _handleOddName(i);\n+    }\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    // Ok: we must have a value... what is it?\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0':\n+        case '1':\n+        case '2':\n+        case '3':\n+        case '4':\n+        case '5':\n+        case '6':\n+        case '7':\n+        case '8':\n+        case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n        if (i < 0) {\n            _handleEOF();\n        }\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    JsonToken t;\n    switch(i) {\n        case '-':\n            t = _parseNegNumber();\n            break;\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7': case '8': case '9':\n            t = _parsePosNumber(i);\n            break;\n        case 'f':\n            _matchFalse();\n            t = JsonToken.VALUE_FALSE;\n            break;\n        case 'n':\n            _matchNull();\n            t = JsonToken.VALUE_NULL;\n            break;\n        case 't':\n            _matchTrue();\n            t = JsonToken.VALUE_TRUE;\n            break;\n        case '[':\n            t = JsonToken.START_ARRAY;\n            break;\n        case '{':\n            t = JsonToken.START_OBJECT;\n            break;\n        default:\n            t = _handleOddValue(i);\n            break;\n    }\n    _nextToken = t;\n    return name;\n}\n\nThe fix involves adding an additional check for the end of the input (i.e., i < 0) after skipping the comma. This ensures that the function handles the end of the input correctly.", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,28 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,48 +30,37 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n+        if (i < 0) {\n+            _handleEOF();\n+        }\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n     }\n-    // Ok: we must have a value... what is it?\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n     JsonToken t;\n     switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n+        case '-':\n+            t = _parseNegNumber();\n             break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n+        case '0': case '1': case '2': case '3': case '4':\n+        case '5': case '6': case '7': case '8': case '9':\n+            t = _parsePosNumber(i);\n             break;\n         case 'f':\n             _matchFalse();\n@@ -84,29 +70,20 @@\n             _matchNull();\n             t = JsonToken.VALUE_NULL;\n             break;\n-        case '-':\n-                        t = _parseNegNumber();\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n             break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n             break;\n         default:\n             t = _handleOddValue(i);\n             break;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,9 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +12,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +22,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,43 +31,59 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n+        if (i < 0) {\n+            _handleEOF();\n+        }\n     }\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n     }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0': case '1': case '2': case '3': case '4':\n+        case '5': case '6': case '7': case '8': case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,6 +1,5 @@\n @Override\n public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -36,6 +35,9 @@\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n+        if (i < 0) {\n+            _handleEOF();\n+        }\n     }\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n@@ -51,22 +53,13 @@\n         _nextToken = JsonToken.VALUE_STRING;\n         return name;\n     }\n-    // Ok: we must have a value... what is it?\n     JsonToken t;\n     switch(i) {\n         case '-':\n             t = _parseNegNumber();\n             break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n+        case '0': case '1': case '2': case '3': case '4':\n+        case '5': case '6': case '7': case '8': case '9':\n             t = _parsePosNumber(i);\n             break;\n         case 'f':\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,89 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+        if (i < 0) {\n+            _handleEOF();\n+        }\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0': case '1': case '2': case '3': case '4':\n+        case '5': case '6': case '7': case '8': case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,89 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+        if (i < 0) {\n+            _handleEOF();\n+        }\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+    switch(i) {\n+        case '-':\n+            t = _parseNegNumber();\n+            break;\n+        case '0': case '1': case '2': case '3': case '4':\n+        case '5': case '6': case '7': case '8': case '9':\n+            t = _parsePosNumber(i);\n+            break;\n+        case 'f':\n+            _matchFalse();\n+            t = JsonToken.VALUE_FALSE;\n+            break;\n+        case 'n':\n+            _matchNull();\n+            t = JsonToken.VALUE_NULL;\n+            break;\n+        case 't':\n+            _matchTrue();\n+            t = JsonToken.VALUE_TRUE;\n+            break;\n+        case '[':\n+            t = JsonToken.START_ARRAY;\n+            break;\n+        case '{':\n+            t = JsonToken.START_OBJECT;\n+            break;\n+        default:\n+            t = _handleOddValue(i);\n+            break;\n+    }\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, '}');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, ']');\n        }\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    JsonToken t = _handleRegularValue(i);\n    _nextToken = t;\n    return name;\n}\n\n//Helper method\nprivate JsonToken _handleRegularValue(int i) throws IOException {\n    switch (i) {\n        case '-':\n            return _parseNegNumber();\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            return _parsePosNumber(i);\n        case 'f':\n            _matchFalse();\n            return JsonToken.VALUE_FALSE;\n        case 'n':\n            _matchNull();\n            return JsonToken.VALUE_NULL;\n        case 't':\n            _matchTrue();\n            return JsonToken.VALUE_TRUE;\n        case '[':\n            return JsonToken.START_ARRAY;\n        case '{':\n            return JsonToken.START_OBJECT;\n        default:\n            return _handleOddValue(i);\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,31 +1,28 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n             _reportMismatchedEndMarker(i, '}');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -33,80 +30,27 @@\n             _reportMismatchedEndMarker(i, ']');\n         }\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    JsonToken t = _handleRegularValue(i);\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,9 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,7 +12,7 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n@@ -23,7 +22,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n@@ -32,7 +31,7 @@\n         }\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,35 +39,18 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n     }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    JsonToken t = _handleRegularValue(i);\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,6 +1,5 @@\n @Override\n public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -51,46 +50,7 @@\n         _nextToken = JsonToken.VALUE_STRING;\n         return name;\n     }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n+    JsonToken t = _handleRegularValue(i);\n     _nextToken = t;\n     return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,56 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t = _handleRegularValue(i);\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,56 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, '}');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, ']');\n+        }\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t = _handleRegularValue(i);\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic String nextFieldName() throws IOException {\n    _numTypesValid = NR_UNKNOWN;\n    if (_currToken == JsonToken.FIELD_NAME) {\n        _nextAfterName();\n        return null;\n    }\n    if (_tokenIncomplete) {\n        _skipString();\n    }\n    int i = _skipWSOrEnd();\n    if (i < 0) {\n        close();\n        _currToken = null;\n        return null;\n    }\n    _binaryValue = null;\n    if (i == INT_RBRACKET) {\n        _updateLocation();\n        if (!_parsingContext.inArray()) {\n            _reportMismatchedEndMarker(i, ']'); // Changed '}' to ']'\n        }\n\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_ARRAY;\n        return null;\n    }\n    if (i == INT_RCURLY) {\n        _updateLocation();\n        if (!_parsingContext.inObject()) {\n            _reportMismatchedEndMarker(i, '}'); // Changed ']' to '}'\n        }\n\n        _parsingContext = _parsingContext.getParent();\n        _currToken = JsonToken.END_OBJECT;\n        return null;\n    }\n    if (_parsingContext.expectComma()) {\n        i = _skipComma(i);\n    }\n    _updateLocation();\n    if (!_parsingContext.inObject()) {\n        _nextTokenNotInObject(i);\n        return null;\n    }\n    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n    _parsingContext.setCurrentName(name);\n    _currToken = JsonToken.FIELD_NAME;\n    i = _skipColon();\n    if (i == INT_QUOTE) {\n        _tokenIncomplete = true;\n        _nextToken = JsonToken.VALUE_STRING;\n        return name;\n    }\n    JsonToken t;\n\n    if (i == '-') {\n        t = _parseNegNumber();\n    } else if (i >= '0' && i <= '9') {\n        t = _parsePosNumber(i);\n    } else {\n        switch (i) {\n            case 'f':\n                _matchFalse();\n                t = JsonToken.VALUE_FALSE;\n                break;\n            case 'n':\n                _matchNull();\n                t = JsonToken.VALUE_NULL;\n                break;\n            case 't':\n                _matchTrue();\n                t = JsonToken.VALUE_TRUE;\n                break;\n\n            case '\"':\n                t = JsonToken.VALUE_STRING;\n                break;\n            case '[':\n                t = JsonToken.START_ARRAY;\n                break;\n            case '{':\n                t = JsonToken.START_OBJECT;\n                break;\n\n            default:\n                t = _handleOddValue(i);\n                break;\n        }\n    }\n\n    _nextToken = t;\n    return name;\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,94 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n     if (_tokenIncomplete) {\n-        // only strings can be partial\n         _skipString();\n     }\n     int i = _skipWSOrEnd();\n     if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n+        close();\n+        _currToken = null;\n+        return null;\n     }\n-    // clear any data retained so far\n     _binaryValue = null;\n-    // Closing scope?\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']'); // Changed '}' to ']'\n         }\n+\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}'); // Changed ']' to '}'\n         }\n+\n         _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n     }\n-    // Nope: do we then expect a comma?\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n     }\n     _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n     }\n-    // Ok: we must have a value... what is it?\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n     JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+\n+    if (i == '-') {\n+        t = _parseNegNumber();\n+    } else if (i >= '0' && i <= '9') {\n+        t = _parsePosNumber(i);\n+    } else {\n+        switch (i) {\n+            case 'f':\n+                _matchFalse();\n+                t = JsonToken.VALUE_FALSE;\n+                break;\n+            case 'n':\n+                _matchNull();\n+                t = JsonToken.VALUE_NULL;\n+                break;\n+            case 't':\n+                _matchTrue();\n+                t = JsonToken.VALUE_TRUE;\n+                break;\n+\n+            case '\"':\n+                t = JsonToken.VALUE_STRING;\n+                break;\n+            case '[':\n+                t = JsonToken.START_ARRAY;\n+                break;\n+            case '{':\n+                t = JsonToken.START_OBJECT;\n+                break;\n+\n+            default:\n+                t = _handleOddValue(i);\n+                break;\n+        }\n     }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,10 +1,9 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n+public String nextFieldName() throws IOException {\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n-        return false;\n+        return null;\n     }\n     if (_tokenIncomplete) {\n         _skipString();\n@@ -13,26 +12,28 @@\n     if (i < 0) {\n         close();\n         _currToken = null;\n-        return false;\n+        return null;\n     }\n     _binaryValue = null;\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']'); // Changed '}' to ']'\n         }\n+\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n-        return false;\n+        return null;\n     }\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}'); // Changed ']' to '}'\n         }\n+\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n-        return false;\n+        return null;\n     }\n     if (_parsingContext.expectComma()) {\n         i = _skipComma(i);\n@@ -40,35 +41,54 @@\n     _updateLocation();\n     if (!_parsingContext.inObject()) {\n         _nextTokenNotInObject(i);\n-        return false;\n+        return null;\n     }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n     if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+\n+    if (i == '-') {\n+        t = _parseNegNumber();\n+    } else if (i >= '0' && i <= '9') {\n+        t = _parsePosNumber(i);\n+    } else {\n+        switch (i) {\n+            case 'f':\n+                _matchFalse();\n+                t = JsonToken.VALUE_FALSE;\n+                break;\n+            case 'n':\n+                _matchNull();\n+                t = JsonToken.VALUE_NULL;\n+                break;\n+            case 't':\n+                _matchTrue();\n+                t = JsonToken.VALUE_TRUE;\n+                break;\n+\n+            case '\"':\n+                t = JsonToken.VALUE_STRING;\n+                break;\n+            case '[':\n+                t = JsonToken.START_ARRAY;\n+                break;\n+            case '{':\n+                t = JsonToken.START_OBJECT;\n+                break;\n+\n+            default:\n+                t = _handleOddValue(i);\n+                break;\n         }\n     }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,6 +1,5 @@\n @Override\n public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n     _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n         _nextAfterName();\n@@ -19,8 +18,9 @@\n     if (i == INT_RBRACKET) {\n         _updateLocation();\n         if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n+            _reportMismatchedEndMarker(i, ']'); // Changed '}' to ']'\n         }\n+\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_ARRAY;\n         return null;\n@@ -28,8 +28,9 @@\n     if (i == INT_RCURLY) {\n         _updateLocation();\n         if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n+            _reportMismatchedEndMarker(i, '}'); // Changed ']' to '}'\n         }\n+\n         _parsingContext = _parsingContext.getParent();\n         _currToken = JsonToken.END_OBJECT;\n         return null;\n@@ -51,46 +52,43 @@\n         _nextToken = JsonToken.VALUE_STRING;\n         return name;\n     }\n-    // Ok: we must have a value... what is it?\n     JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n+\n+    if (i == '-') {\n+        t = _parseNegNumber();\n+    } else if (i >= '0' && i <= '9') {\n+        t = _parsePosNumber(i);\n+    } else {\n+        switch (i) {\n+            case 'f':\n+                _matchFalse();\n+                t = JsonToken.VALUE_FALSE;\n+                break;\n+            case 'n':\n+                _matchNull();\n+                t = JsonToken.VALUE_NULL;\n+                break;\n+            case 't':\n+                _matchTrue();\n+                t = JsonToken.VALUE_TRUE;\n+                break;\n+\n+            case '\"':\n+                t = JsonToken.VALUE_STRING;\n+                break;\n+            case '[':\n+                t = JsonToken.START_ARRAY;\n+                break;\n+            case '{':\n+                t = JsonToken.START_OBJECT;\n+                break;\n+\n+            default:\n+                t = _handleOddValue(i);\n+                break;\n+        }\n     }\n+\n     _nextToken = t;\n     return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,94 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        _nextAfterName();\n+        return null;\n+    }\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, ']'); // Changed '}' to ']'\n+        }\n+\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, '}'); // Changed ']' to '}'\n+        }\n+\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+\n+    if (i == '-') {\n+        t = _parseNegNumber();\n+    } else if (i >= '0' && i <= '9') {\n+        t = _parsePosNumber(i);\n+    } else {\n+        switch (i) {\n+            case 'f':\n+                _matchFalse();\n+                t = JsonToken.VALUE_FALSE;\n+                break;\n+            case 'n':\n+                _matchNull();\n+                t = JsonToken.VALUE_NULL;\n+                break;\n+            case 't':\n+                _matchTrue();\n+                t = JsonToken.VALUE_TRUE;\n+                break;\n+\n+            case '\"':\n+                t = JsonToken.VALUE_STRING;\n+                break;\n+            case '[':\n+                t = JsonToken.START_ARRAY;\n+                break;\n+            case '{':\n+                t = JsonToken.START_OBJECT;\n+                break;\n+\n+            default:\n+                t = _handleOddValue(i);\n+                break;\n+        }\n+    }\n+\n+    _nextToken = t;\n+    return name;\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,94 @@\n @Override\n-public JsonLocation getTokenLocation() {\n-    final Object src = _ioContext.getSourceReference();\n+public String nextFieldName() throws IOException {\n+    _numTypesValid = NR_UNKNOWN;\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        _nextAfterName();\n+        return null;\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    if (_tokenIncomplete) {\n+        _skipString();\n+    }\n+    int i = _skipWSOrEnd();\n+    if (i < 0) {\n+        close();\n+        _currToken = null;\n+        return null;\n+    }\n+    _binaryValue = null;\n+    if (i == INT_RBRACKET) {\n+        _updateLocation();\n+        if (!_parsingContext.inArray()) {\n+            _reportMismatchedEndMarker(i, ']'); // Changed '}' to ']'\n+        }\n+\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_ARRAY;\n+        return null;\n+    }\n+    if (i == INT_RCURLY) {\n+        _updateLocation();\n+        if (!_parsingContext.inObject()) {\n+            _reportMismatchedEndMarker(i, '}'); // Changed ']' to '}'\n+        }\n+\n+        _parsingContext = _parsingContext.getParent();\n+        _currToken = JsonToken.END_OBJECT;\n+        return null;\n+    }\n+    if (_parsingContext.expectComma()) {\n+        i = _skipComma(i);\n+    }\n+    _updateLocation();\n+    if (!_parsingContext.inObject()) {\n+        _nextTokenNotInObject(i);\n+        return null;\n+    }\n+    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n+    _parsingContext.setCurrentName(name);\n+    _currToken = JsonToken.FIELD_NAME;\n+    i = _skipColon();\n+    if (i == INT_QUOTE) {\n+        _tokenIncomplete = true;\n+        _nextToken = JsonToken.VALUE_STRING;\n+        return name;\n+    }\n+    JsonToken t;\n+\n+    if (i == '-') {\n+        t = _parseNegNumber();\n+    } else if (i >= '0' && i <= '9') {\n+        t = _parsePosNumber(i);\n+    } else {\n+        switch (i) {\n+            case 'f':\n+                _matchFalse();\n+                t = JsonToken.VALUE_FALSE;\n+                break;\n+            case 'n':\n+                _matchNull();\n+                t = JsonToken.VALUE_NULL;\n+                break;\n+            case 't':\n+                _matchTrue();\n+                t = JsonToken.VALUE_TRUE;\n+                break;\n+\n+            case '\"':\n+                t = JsonToken.VALUE_STRING;\n+                break;\n+            case '[':\n+                t = JsonToken.START_ARRAY;\n+                break;\n+            case '{':\n+                t = JsonToken.START_OBJECT;\n+                break;\n+\n+            default:\n+                t = _handleOddValue(i);\n+                break;\n+        }\n+    }\n+\n+    _nextToken = t;\n+    return name;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]