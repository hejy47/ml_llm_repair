[{"output": "@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return new JsonLocation(src, _currInputProcessed + _nameStartOffset - 1, -1L, _nameStartRow, _nameStartCol);\n    }\n    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,8 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset - 1, -1L, _nameStartRow, _nameStartCol);\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n-        // only strings can be partial\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n-    }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n-    }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,8 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset - 1, -1L, _nameStartRow, _nameStartCol);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n-    }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n-    }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,8 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset - 1, -1L, _nameStartRow, _nameStartCol);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,8 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset - 1, -1L, _nameStartRow, _nameStartCol);\n+    }\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -2,7 +2,7 @@\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset - 1, -1L, _nameStartRow, _nameStartCol);\n     }\n     return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return new JsonLocation(src, _tokenInputTotal, -1L, _tokenInputRow, _tokenInputCol - _name.length());\n    }\n    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,8 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _tokenInputTotal, -1L, _tokenInputRow, _tokenInputCol - _name.length());\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n-        // only strings can be partial\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n-    }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n-    }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,8 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+        return new JsonLocation(src, _tokenInputTotal, -1L, _tokenInputRow, _tokenInputCol - _name.length());\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n-    }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n-    }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,8 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n+        return new JsonLocation(src, _tokenInputTotal, -1L, _tokenInputRow, _tokenInputCol - _name.length());\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,8 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _tokenInputTotal, -1L, _tokenInputRow, _tokenInputCol - _name.length());\n+    }\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -2,7 +2,7 @@\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return new JsonLocation(src, _tokenInputTotal, -1L, _tokenInputRow, _tokenInputCol - _name.length());\n     }\n     return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return new JsonLocation(src, _currInputProcessed + (_nameStartOffset - 1), -1L, _nameStartRow, _nameStartCol);\n    }\n    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,8 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _currInputProcessed + (_nameStartOffset - 1), -1L, _nameStartRow, _nameStartCol);\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n-        // only strings can be partial\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n-    }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n-    }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,8 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+        return new JsonLocation(src, _currInputProcessed + (_nameStartOffset - 1), -1L, _nameStartRow, _nameStartCol);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n-    }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n-    }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,8 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n+        return new JsonLocation(src, _currInputProcessed + (_nameStartOffset - 1), -1L, _nameStartRow, _nameStartCol);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,8 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _currInputProcessed + (_nameStartOffset - 1), -1L, _nameStartRow, _nameStartCol);\n+    }\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -2,7 +2,7 @@\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return new JsonLocation(src, _currInputProcessed + (_nameStartOffset - 1), -1L, _nameStartRow, _nameStartCol);\n     }\n     return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return new JsonLocation(src, _inputStream.getCurrentLocation().getTotalOffset(), -1L, _inputStream.getCurrentLocation().getRowNr(), _inputStream.getCurrentLocation().getColumnNr());\n    }\n    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n} \n\nNote: This fix assumes that the JacksonCore project is using the Jackson streaming API with a JsonParser instance named 'inputStream'. If a different approach is being used, the fix may need to be adjusted accordingly.", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,8 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputStream.getCurrentLocation().getTotalOffset(), -1L, _inputStream.getCurrentLocation().getRowNr(), _inputStream.getCurrentLocation().getColumnNr());\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n-        // only strings can be partial\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n-    }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n-    }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,8 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+        return new JsonLocation(src, _inputStream.getCurrentLocation().getTotalOffset(), -1L, _inputStream.getCurrentLocation().getRowNr(), _inputStream.getCurrentLocation().getColumnNr());\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n-    }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n-    }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,8 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n+        return new JsonLocation(src, _inputStream.getCurrentLocation().getTotalOffset(), -1L, _inputStream.getCurrentLocation().getRowNr(), _inputStream.getCurrentLocation().getColumnNr());\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,8 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputStream.getCurrentLocation().getTotalOffset(), -1L, _inputStream.getCurrentLocation().getRowNr(), _inputStream.getCurrentLocation().getColumnNr());\n+    }\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -2,7 +2,7 @@\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return new JsonLocation(src, _inputStream.getCurrentLocation().getTotalOffset(), -1L, _inputStream.getCurrentLocation().getRowNr(), _inputStream.getCurrentLocation().getColumnNr());\n     }\n     return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _nameStartRow, _nameStartOffset - _currInputRowStart);\n    }\n    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,8 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _nameStartRow, _nameStartOffset - _currInputRowStart);\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n-        // only strings can be partial\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n-    }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n-    }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,8 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _nameStartRow, _nameStartOffset - _currInputRowStart);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n-    }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n-    }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,8 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _nameStartRow, _nameStartOffset - _currInputRowStart);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,8 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _nameStartRow, _nameStartOffset - _currInputRowStart);\n+    }\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -2,7 +2,7 @@\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _nameStartRow, _nameStartOffset - _currInputRowStart);\n     }\n     return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@JsonLocation\n@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return new JsonLocation(src, _inputPtr + _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n    }\n    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,8 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputPtr + _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n-        // only strings can be partial\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n-    }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n-    }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,8 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+        return new JsonLocation(src, _inputPtr + _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n-    }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n-    }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,8 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n+        return new JsonLocation(src, _inputPtr + _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,8 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputPtr + _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n+    }\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -2,7 +2,7 @@\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return new JsonLocation(src, _inputPtr + _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n     }\n     return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return new JsonLocation(src, _currInputProcessed + _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n    }\n    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,8 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n-        // only strings can be partial\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n-    }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n-    }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,8 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n-    }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n-    }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,8 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,8 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n+    }\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -2,7 +2,7 @@\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n     }\n     return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return new JsonLocation(src, _currInputProcessed + _nameStartOffset, -1L, _currInputRow, _nameStartOffset);\n    }\n    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,8 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset, -1L, _currInputRow, _nameStartOffset);\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n-        // only strings can be partial\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n-    }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n-    }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,8 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset, -1L, _currInputRow, _nameStartOffset);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n-    }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n-    }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,8 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset, -1L, _currInputRow, _nameStartOffset);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,8 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset, -1L, _currInputRow, _nameStartOffset);\n+    }\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -2,7 +2,7 @@\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset, -1L, _currInputRow, _nameStartOffset);\n     }\n     return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    if (_currToken == null) {\n        return null;\n    } else if (_currToken == JsonToken.FIELD_NAME) {\n        return new JsonLocation(src, _inputPtr - 1, -1L, _currInputRow, _nameStartOffset - 1);\n    } else {\n        return new JsonLocation(src, _inputPtr, -1L, _currInputRow, _currInputRow - _inputRowStart);\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,11 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == null) {\n+        return null;\n+    } else if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputPtr - 1, -1L, _currInputRow, _nameStartOffset - 1);\n+    } else {\n+        return new JsonLocation(src, _inputPtr, -1L, _currInputRow, _currInputRow - _inputRowStart);\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n-        // only strings can be partial\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n-    }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n-    }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,11 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == null) {\n+        return null;\n+    } else if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputPtr - 1, -1L, _currInputRow, _nameStartOffset - 1);\n+    } else {\n+        return new JsonLocation(src, _inputPtr, -1L, _currInputRow, _currInputRow - _inputRowStart);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n-    }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n-    }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,11 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == null) {\n         return null;\n+    } else if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputPtr - 1, -1L, _currInputRow, _nameStartOffset - 1);\n+    } else {\n+        return new JsonLocation(src, _inputPtr, -1L, _currInputRow, _currInputRow - _inputRowStart);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,11 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+    if (_currToken == null) {\n+        return null;\n+    } else if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputPtr - 1, -1L, _currInputRow, _nameStartOffset - 1);\n+    } else {\n+        return new JsonLocation(src, _inputPtr, -1L, _currInputRow, _currInputRow - _inputRowStart);\n+    }\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,11 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+    if (_currToken == null) {\n+        return null;\n+    } else if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputPtr - 1, -1L, _currInputRow, _nameStartOffset - 1);\n+    } else {\n+        return new JsonLocation(src, _inputPtr, -1L, _currInputRow, _currInputRow - _inputRowStart);\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    if (_currToken == null) {\n        return null; // no current token, can't determine location\n    }\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return new JsonLocation(src, _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n    }\n    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,11 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == null) {\n+        return null; // no current token, can't determine location\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n-        // only strings can be partial\n-        _skipString();\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n     }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n-    }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n-    }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,11 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == null) {\n+        return null; // no current token, can't determine location\n+    }\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+        return new JsonLocation(src, _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n-    }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n-    }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,11 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == null) {\n+        return null; // no current token, can't determine location\n+    }\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n+        return new JsonLocation(src, _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,11 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+    if (_currToken == null) {\n+        return null; // no current token, can't determine location\n+    }\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n+    }\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -1,8 +1,11 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n+    if (_currToken == null) {\n+        return null; // no current token, can't determine location\n+    }\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return new JsonLocation(src, _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n     }\n     return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _tokenInputRow, _nameStartRow);\n    }\n    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,8 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _tokenInputRow, _nameStartRow);\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n-        // only strings can be partial\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n-    }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n-    }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,8 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _tokenInputRow, _nameStartRow);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n-    }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n-    }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,8 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _tokenInputRow, _nameStartRow);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,8 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _tokenInputRow, _nameStartRow);\n+    }\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -2,7 +2,7 @@\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _tokenInputRow, _nameStartRow);\n     }\n     return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return new JsonLocation(src, _tokenizer.tokenStartOffset(), -1L, _tokenizer.tokenStartLine(), _tokenizer.tokenStartColumn());\n    }\n    return new JsonLocation(src, _tokenizer.tokenStartOffset(), -1L, _tokenizer.tokenStartLine(), _tokenizer.tokenStartColumn());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,8 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _tokenizer.tokenStartOffset(), -1L, _tokenizer.tokenStartLine(), _tokenizer.tokenStartColumn());\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n-        // only strings can be partial\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n-    }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n-    }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return new JsonLocation(src, _tokenizer.tokenStartOffset(), -1L, _tokenizer.tokenStartLine(), _tokenizer.tokenStartColumn());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,8 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+        return new JsonLocation(src, _tokenizer.tokenStartOffset(), -1L, _tokenizer.tokenStartLine(), _tokenizer.tokenStartColumn());\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n-    }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n-    }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    return new JsonLocation(src, _tokenizer.tokenStartOffset(), -1L, _tokenizer.tokenStartLine(), _tokenizer.tokenStartColumn());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,8 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n+        return new JsonLocation(src, _tokenizer.tokenStartOffset(), -1L, _tokenizer.tokenStartLine(), _tokenizer.tokenStartColumn());\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return new JsonLocation(src, _tokenizer.tokenStartOffset(), -1L, _tokenizer.tokenStartLine(), _tokenizer.tokenStartColumn());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,8 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _tokenizer.tokenStartOffset(), -1L, _tokenizer.tokenStartLine(), _tokenizer.tokenStartColumn());\n+    }\n+    return new JsonLocation(src, _tokenizer.tokenStartOffset(), -1L, _tokenizer.tokenStartLine(), _tokenizer.tokenStartColumn());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -2,7 +2,7 @@\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return new JsonLocation(src, _tokenizer.tokenStartOffset(), -1L, _tokenizer.tokenStartLine(), _tokenizer.tokenStartColumn());\n     }\n-    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n+    return new JsonLocation(src, _tokenizer.tokenStartOffset(), -1L, _tokenizer.tokenStartLine(), _tokenizer.tokenStartColumn());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n    }\n    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,8 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n-        // only strings can be partial\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n-    }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n-    }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,8 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n-    }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n-    }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,8 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,8 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n+    }\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -2,7 +2,7 @@\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _nameStartRow, _nameStartCol);\n     }\n     return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return new JsonLocation(src, _currInputProcessed, -1L, _currInputRow, _nameStartOffset - _currInputRowStart);\n    }\n    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,8 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _currInputProcessed, -1L, _currInputRow, _nameStartOffset - _currInputRowStart);\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n-        // only strings can be partial\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n-    }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n-    }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,8 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+        return new JsonLocation(src, _currInputProcessed, -1L, _currInputRow, _nameStartOffset - _currInputRowStart);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n-    }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n-    }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,8 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n+        return new JsonLocation(src, _currInputProcessed, -1L, _currInputRow, _nameStartOffset - _currInputRowStart);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,8 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _currInputProcessed, -1L, _currInputRow, _nameStartOffset - _currInputRowStart);\n+    }\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -2,7 +2,7 @@\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return new JsonLocation(src, _currInputProcessed, -1L, _currInputRow, _nameStartOffset - _currInputRowStart);\n     }\n     return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _tokenInputRow, _nameStartOffset);\n    }\n    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,8 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _tokenInputRow, _nameStartOffset);\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n-        // only strings can be partial\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n-    }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n-    }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,8 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _tokenInputRow, _nameStartOffset);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n-    }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n-    }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,8 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _tokenInputRow, _nameStartOffset);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,8 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _tokenInputRow, _nameStartOffset);\n+    }\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -2,7 +2,7 @@\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _tokenInputRow, _nameStartOffset);\n     }\n     return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return new JsonLocation(src, _currInputProcessed + _nameStartOffset, -1L, _currInputRow, _nameStartRow);\n    }\n    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,8 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset, -1L, _currInputRow, _nameStartRow);\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n-        // only strings can be partial\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n-    }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n-    }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,8 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset, -1L, _currInputRow, _nameStartRow);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n-    }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n-    }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,8 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset, -1L, _currInputRow, _nameStartRow);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,8 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset, -1L, _currInputRow, _nameStartRow);\n+    }\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -2,7 +2,7 @@\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return new JsonLocation(src, _currInputProcessed + _nameStartOffset, -1L, _currInputRow, _nameStartRow);\n     }\n     return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    if (_currToken == JsonToken.FIELD_NAME) {\n        int colNr = (_tokenInputCol < 0 ? _tokenInputCol : _tokenInputCol + 1);\n        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, colNr);\n    }\n    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,9 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        int colNr = (_tokenInputCol < 0 ? _tokenInputCol : _tokenInputCol + 1);\n+        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, colNr);\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n-        // only strings can be partial\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n-    }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n-    }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,9 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+        int colNr = (_tokenInputCol < 0 ? _tokenInputCol : _tokenInputCol + 1);\n+        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, colNr);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n-    }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n-    }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,9 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n+        int colNr = (_tokenInputCol < 0 ? _tokenInputCol : _tokenInputCol + 1);\n+        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, colNr);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,9 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        int colNr = (_tokenInputCol < 0 ? _tokenInputCol : _tokenInputCol + 1);\n+        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, colNr);\n+    }\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -2,7 +2,8 @@\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        int colNr = (_tokenInputCol < 0 ? _tokenInputCol : _tokenInputCol + 1);\n+        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, colNr);\n     }\n     return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic JsonLocation getTokenLocation() {\n    final Object src = _ioContext.getSourceReference();\n    if (_currToken == JsonToken.FIELD_NAME) {\n        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _nameStartRow, _nameStartOffset - _nameStartCol);\n    }\n    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n}", "diff": "--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextToken\n@@ -1,112 +1,8 @@\n @Override\n-public final JsonToken nextToken() throws IOException {\n-        if (_currToken == JsonToken.FIELD_NAME) {\n-        return _nextAfterName();\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _nameStartRow, _nameStartOffset - _nameStartCol);\n     }\n-    // But if we didn't already have a name, and (partially?) decode number,\n-    // need to ensure no numeric information is leaked\n-    _numTypesValid = NR_UNKNOWN;\n-    if (_tokenIncomplete) {\n-        // only strings can be partial\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        // end-of-input\n-                close();\n-        return (_currToken = null);\n-    }\n-    // clear any data retained so far\n-    _binaryValue = null;\n-    // Closing scope?\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_ARRAY);\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        return (_currToken = JsonToken.END_OBJECT);\n-    }\n-    // Nope: do we then expect a comma?\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-        boolean inObject = _parsingContext.inObject();\n-    if (inObject) {\n-        // First, field name itself:\n-        String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-        _parsingContext.setCurrentName(name);\n-        _currToken = JsonToken.FIELD_NAME;\n-        i = _skipColon();\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '\"':\n-            _tokenIncomplete = true;\n-            t = JsonToken.VALUE_STRING;\n-            break;\n-        case '[':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            if (!inObject) {\n-                _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n-            }\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        case ']':\n-        case '}':\n-            // Error: neither is valid at this point; valid closers have\n-            // been handled earlier\n-            _reportUnexpectedChar(i, \"expected a value\");\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case '-':\n-                        t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    if (inObject) {\n-        _nextToken = t;\n-        return _currToken;\n-    }\n-    _currToken = t;\n-    return t;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName\n@@ -1,74 +1,8 @@\n @Override\n-public boolean nextFieldName(SerializableString sstr) throws IOException {\n-    // // // Note: most of code below is copied from nextToken()\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return false;\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _nameStartRow, _nameStartOffset - _nameStartCol);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return false;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return false;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return false;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return false;\n-    }\n-    if (i == INT_QUOTE) {\n-        // when doing literal match, must consider escaping:\n-        char[] nameChars = sstr.asQuotedChars();\n-        final int len = nameChars.length;\n-        // Require 4 more bytes for faster skipping of colon that follows name\n-        if ((_inputPtr + len + 4) < _inputEnd) {\n-            // maybe...\n-            // first check length match by\n-            final int end = _inputPtr + len;\n-            if (_inputBuffer[end] == '\"') {\n-                int offset = 0;\n-                int ptr = _inputPtr;\n-                while (true) {\n-                    if (ptr == end) {\n-                        // yes, match!\n-                        _parsingContext.setCurrentName(sstr.getValue());\n-                        _isNextTokenNameYes(_skipColonFast(ptr + 1));\n-                        return true;\n-                    }\n-                    if (nameChars[offset] != _inputBuffer[ptr]) {\n-                        break;\n-                    }\n-                    ++offset;\n-                    ++ptr;\n-                }\n-            }\n-        }\n-    }\n-    return _isNextTokenNameMaybe(i, sstr.getValue());\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@nextFieldName2\n@@ -1,96 +1,8 @@\n @Override\n-public String nextFieldName() throws IOException {\n-    // // // Note: this is almost a verbatim copy of nextToken() (minus comments)\n-    _numTypesValid = NR_UNKNOWN;\n+public JsonLocation getTokenLocation() {\n+    final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        _nextAfterName();\n-        return null;\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _nameStartRow, _nameStartOffset - _nameStartCol);\n     }\n-    if (_tokenIncomplete) {\n-        _skipString();\n-    }\n-    int i = _skipWSOrEnd();\n-    if (i < 0) {\n-        close();\n-        _currToken = null;\n-        return null;\n-    }\n-    _binaryValue = null;\n-    if (i == INT_RBRACKET) {\n-        _updateLocation();\n-        if (!_parsingContext.inArray()) {\n-            _reportMismatchedEndMarker(i, '}');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_ARRAY;\n-        return null;\n-    }\n-    if (i == INT_RCURLY) {\n-        _updateLocation();\n-        if (!_parsingContext.inObject()) {\n-            _reportMismatchedEndMarker(i, ']');\n-        }\n-        _parsingContext = _parsingContext.getParent();\n-        _currToken = JsonToken.END_OBJECT;\n-        return null;\n-    }\n-    if (_parsingContext.expectComma()) {\n-        i = _skipComma(i);\n-    }\n-    _updateLocation();\n-    if (!_parsingContext.inObject()) {\n-        _nextTokenNotInObject(i);\n-        return null;\n-    }\n-    String name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n-    _parsingContext.setCurrentName(name);\n-    _currToken = JsonToken.FIELD_NAME;\n-    i = _skipColon();\n-    if (i == INT_QUOTE) {\n-        _tokenIncomplete = true;\n-        _nextToken = JsonToken.VALUE_STRING;\n-        return name;\n-    }\n-    // Ok: we must have a value... what is it?\n-    JsonToken t;\n-    switch(i) {\n-        case '-':\n-            t = _parseNegNumber();\n-            break;\n-        case '0':\n-        case '1':\n-        case '2':\n-        case '3':\n-        case '4':\n-        case '5':\n-        case '6':\n-        case '7':\n-        case '8':\n-        case '9':\n-            t = _parsePosNumber(i);\n-            break;\n-        case 'f':\n-            _matchFalse();\n-            t = JsonToken.VALUE_FALSE;\n-            break;\n-        case 'n':\n-            _matchNull();\n-            t = JsonToken.VALUE_NULL;\n-            break;\n-        case 't':\n-            _matchTrue();\n-            t = JsonToken.VALUE_TRUE;\n-            break;\n-        case '[':\n-            t = JsonToken.START_ARRAY;\n-            break;\n-        case '{':\n-            t = JsonToken.START_OBJECT;\n-            break;\n-        default:\n-            t = _handleOddValue(i);\n-            break;\n-    }\n-    _nextToken = t;\n-    return name;\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java@getTokenLocation\n@@ -1,5 +1,8 @@\n @Override\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n-    return new JsonLocation(src, -1L, getTokenCharacterOffset(), getTokenLineNr(), getTokenColumnNr());\n+    if (_currToken == JsonToken.FIELD_NAME) {\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _nameStartRow, _nameStartOffset - _nameStartCol);\n+    }\n+    return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n--- com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n+++ com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java@getTokenLocation\n@@ -2,7 +2,7 @@\n public JsonLocation getTokenLocation() {\n     final Object src = _ioContext.getSourceReference();\n     if (_currToken == JsonToken.FIELD_NAME) {\n-        return new JsonLocation(src, _nameInputTotal, -1L, _nameInputRow, _tokenInputCol);\n+        return new JsonLocation(src, _inputPtr - _nameStartOffset, -1L, _nameStartRow, _nameStartOffset - _nameStartCol);\n     }\n     return new JsonLocation(src, getTokenCharacterOffset(), -1L, getTokenLineNr(), getTokenColumnNr());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]