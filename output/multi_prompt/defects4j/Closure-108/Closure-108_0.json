[{"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n        // Also clear the current scope, to avoid issues with nested scopes\n        t.getScope().clear();\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -9,5 +9,7 @@\n         forbiddenLocals.clear();\n         transformation = null;\n         hasNamespaceShadows = false;\n+        // Also clear the current scope, to avoid issues with nested scopes\n+        t.getScope().clear();\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,15 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n+        // Also clear the current scope, to avoid issues with nested scopes\n+        t.getScope().clear();\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 1) { // Changed to t.getScopeDepth() > 1 as the outermost scope is 0\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 1) { // Changed to t.getScopeDepth() == 1 as the top level scope is 1\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,9 +1,9 @@\n @Override\n public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n+    if (t.getScopeDepth() > 1) { // Changed to t.getScopeDepth() > 1 as the outermost scope is 0\n         findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() == 2) {\n+    if (t.getScopeDepth() == 1) { // Changed to t.getScopeDepth() == 1 as the top level scope is 1\n         renameNamespaceShadows(t);\n         aliases.clear();\n         forbiddenLocals.clear();\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,13 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 1) { // Changed to t.getScopeDepth() > 1 as the outermost scope is 0\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+    if (t.getScopeDepth() == 1) { // Changed to t.getScopeDepth() == 1 as the top level scope is 1\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2 && hasNamespaceShadows) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -3,7 +3,7 @@\n     if (t.getScopeDepth() > 2) {\n         findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() == 2) {\n+    if (t.getScopeDepth() == 2 && hasNamespaceShadows) {\n         renameNamespaceShadows(t);\n         aliases.clear();\n         forbiddenLocals.clear();\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,13 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+    if (t.getScopeDepth() == 2 && hasNamespaceShadows) {\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        hasNamespaceShadows = false; // move this line before transformation and null check\n        if (transformation != null) {\n            transformation.transformAst(t.getCompiler(), t.getScope());\n            transformation = null;\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -7,7 +7,10 @@\n         renameNamespaceShadows(t);\n         aliases.clear();\n         forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        hasNamespaceShadows = false; // move this line before transformation and null check\n+        if (transformation != null) {\n+            transformation.transformAst(t.getCompiler(), t.getScope());\n+            transformation = null;\n+        }\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,16 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n+    if (t.getScopeDepth() == 2) {\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        hasNamespaceShadows = false; // move this line before transformation and null check\n+        if (transformation != null) {\n+            transformation.transformAst(t.getCompiler(), t.getScope());\n+            transformation = null;\n         }\n     }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n-    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n        currentScope = t.getTypedScope();\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -9,5 +9,6 @@\n         forbiddenLocals.clear();\n         transformation = null;\n         hasNamespaceShadows = false;\n+        currentScope = t.getTypedScope();\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,14 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n+        currentScope = t.getTypedScope();\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 1) { // fixed line\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -3,7 +3,7 @@\n     if (t.getScopeDepth() > 2) {\n         findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() == 2) {\n+    if (t.getScopeDepth() == 1) { // fixed line\n         renameNamespaceShadows(t);\n         aliases.clear();\n         forbiddenLocals.clear();\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,13 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+    if (t.getScopeDepth() == 1) { // fixed line\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n        outerVars.clear(); // fix: clear any outerVars that may have been set\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -9,5 +9,6 @@\n         forbiddenLocals.clear();\n         transformation = null;\n         hasNamespaceShadows = false;\n+        outerVars.clear(); // fix: clear any outerVars that may have been set\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,14 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n+        outerVars.clear(); // fix: clear any outerVars that may have been set\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.pop(); // instead of clear()\n        forbiddenLocals = new HashSet<>(); // instead of clear()\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -5,8 +5,8 @@\n     }\n     if (t.getScopeDepth() == 2) {\n         renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n+        aliases.pop(); // instead of clear()\n+        forbiddenLocals = new HashSet<>(); // instead of clear()\n         transformation = null;\n         hasNamespaceShadows = false;\n     }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,13 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        renameNamespaceShadows(t);\n+        aliases.pop(); // instead of clear()\n+        forbiddenLocals = new HashSet<>(); // instead of clear()\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n        // Added fix: reset the current namespace after exiting its scope\n        currentNamespace = \"\";\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -9,5 +9,7 @@\n         forbiddenLocals.clear();\n         transformation = null;\n         hasNamespaceShadows = false;\n+        // Added fix: reset the current namespace after exiting its scope\n+        currentNamespace = \"\";\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,15 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n+        // Added fix: reset the current namespace after exiting its scope\n+        currentNamespace = \"\";\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n    super.exitScope(t); // Add this line to call the parent class' exitScope method\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -10,4 +10,5 @@\n         transformation = null;\n         hasNamespaceShadows = false;\n     }\n+    super.exitScope(t); // Add this line to call the parent class' exitScope method\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,14 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n+    if (t.getScopeDepth() == 2) {\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n-    }\n+    super.exitScope(t); // Add this line to call the parent class' exitScope method\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n        currentNamespace = null; // initializes currentNamespace to null when exiting scope depth of 2\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -9,5 +9,6 @@\n         forbiddenLocals.clear();\n         transformation = null;\n         hasNamespaceShadows = false;\n+        currentNamespace = null; // initializes currentNamespace to null when exiting scope depth of 2\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,14 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n+        currentNamespace = null; // initializes currentNamespace to null when exiting scope depth of 2\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 1) { // fixed condition\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 1) { // fixed condition\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,9 +1,9 @@\n @Override\n public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n+    if (t.getScopeDepth() > 1) { // fixed condition\n         findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() == 2) {\n+    if (t.getScopeDepth() == 1) { // fixed condition\n         renameNamespaceShadows(t);\n         aliases.clear();\n         forbiddenLocals.clear();\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,13 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 1) { // fixed condition\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+    if (t.getScopeDepth() == 1) { // fixed condition\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n    }\n    aliases.clear();\n    forbiddenLocals.clear();\n    transformation = null;\n    hasNamespaceShadows = false;\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -5,9 +5,9 @@\n     }\n     if (t.getScopeDepth() == 2) {\n         renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n     }\n+    aliases.clear();\n+    forbiddenLocals.clear();\n+    transformation = null;\n+    hasNamespaceShadows = false;\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,13 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n+    if (t.getScopeDepth() == 2) {\n+        renameNamespaceShadows(t);\n     }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n-    }\n+    aliases.clear();\n+    forbiddenLocals.clear();\n+    transformation = null;\n+    hasNamespaceShadows = false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n    super.exitScope(t);\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -10,4 +10,5 @@\n         transformation = null;\n         hasNamespaceShadows = false;\n     }\n+    super.exitScope(t);\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,14 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n+    if (t.getScopeDepth() == 2) {\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n-    }\n+    super.exitScope(t);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 1) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 1) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,9 +1,9 @@\n @Override\n public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n+    if (t.getScopeDepth() > 1) {\n         findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() == 2) {\n+    if (t.getScopeDepth() == 1) {\n         renameNamespaceShadows(t);\n         aliases.clear();\n         forbiddenLocals.clear();\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,13 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 1) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+    if (t.getScopeDepth() == 1) {\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n        namespaceShadows.clear(); // Adding this line to fix bug\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -9,5 +9,6 @@\n         forbiddenLocals.clear();\n         transformation = null;\n         hasNamespaceShadows = false;\n+        namespaceShadows.clear(); // Adding this line to fix bug\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,14 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n+        namespaceShadows.clear(); // Adding this line to fix bug\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    } else if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -2,8 +2,7 @@\n public void exitScope(NodeTraversal t) {\n     if (t.getScopeDepth() > 2) {\n         findNamespaceShadows(t);\n-    }\n-    if (t.getScopeDepth() == 2) {\n+    } else if (t.getScopeDepth() == 2) {\n         renameNamespaceShadows(t);\n         aliases.clear();\n         forbiddenLocals.clear();\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,12 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n+    } else if (t.getScopeDepth() == 2) {\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 1) { // Fix scope depth condition\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 1) { // Fix scope depth condition\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,9 +1,9 @@\n @Override\n public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n+    if (t.getScopeDepth() > 1) { // Fix scope depth condition\n         findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() == 2) {\n+    if (t.getScopeDepth() == 1) { // Fix scope depth condition\n         renameNamespaceShadows(t);\n         aliases.clear();\n         forbiddenLocals.clear();\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,13 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 1) { // Fix scope depth condition\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+    if (t.getScopeDepth() == 1) { // Fix scope depth condition\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n        compiler.clearJSTypeRegistry();\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -9,5 +9,6 @@\n         forbiddenLocals.clear();\n         transformation = null;\n         hasNamespaceShadows = false;\n+        compiler.clearJSTypeRegistry();\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,14 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n+        compiler.clearJSTypeRegistry();\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() >= 2) { // Changed > to >= to handle nested scopes properly.\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 1) { // Changed == 2 to == 1 to exit from the outermost scope.\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,9 +1,9 @@\n @Override\n public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n+    if (t.getScopeDepth() >= 2) { // Changed > to >= to handle nested scopes properly.\n         findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() == 2) {\n+    if (t.getScopeDepth() == 1) { // Changed == 2 to == 1 to exit from the outermost scope.\n         renameNamespaceShadows(t);\n         aliases.clear();\n         forbiddenLocals.clear();\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,13 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() >= 2) { // Changed > to >= to handle nested scopes properly.\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+    if (t.getScopeDepth() == 1) { // Changed == 2 to == 1 to exit from the outermost scope.\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]