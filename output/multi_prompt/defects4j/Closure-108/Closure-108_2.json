[{"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(name); // Use variable instead of string here\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendant scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,60 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n     }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(name); // Use variable instead of string here\n+        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendant scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO(robbyw): Error for goog.scope not at root.\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -10,7 +10,7 @@\n     Var aliasVar = null;\n     if (type == Token.NAME) {\n         String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n+        Var lexicalVar = t.getScope().getVar(name); // Use variable instead of string here\n         if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n             aliasVar = lexicalVar;\n         }\n@@ -35,7 +35,7 @@\n             report(t, n, GOOG_SCOPE_USES_THROW);\n         }\n     }\n-    // Validate all descendent scopes of the goog.scope block.\n+    // Validate all descendant scopes of the goog.scope block.\n     if (t.getScopeDepth() >= 2) {\n         // Check if this name points to an alias.\n         if (aliasVar != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(name);\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendant scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            Node aliasedNode = aliasVar.getNode();\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here. For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\". If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, aliasedNode));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node typeNode : info.getTypeNodes()) {\n                fixTypeNode(typeNode);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,61 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n     }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(name);\n+        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendant scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            Node aliasedNode = aliasVar.getNode();\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here. For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\". If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, aliasedNode));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node typeNode : info.getTypeNodes()) {\n+                fixTypeNode(typeNode);\n+            }\n+        }\n+        // TODO(robbyw): Error for goog.scope not at root.\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -10,7 +10,7 @@\n     Var aliasVar = null;\n     if (type == Token.NAME) {\n         String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n+        Var lexicalVar = t.getScope().getVar(name);\n         if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n             aliasVar = lexicalVar;\n         }\n@@ -35,24 +35,25 @@\n             report(t, n, GOOG_SCOPE_USES_THROW);\n         }\n     }\n-    // Validate all descendent scopes of the goog.scope block.\n+    // Validate all descendant scopes of the goog.scope block.\n     if (t.getScopeDepth() >= 2) {\n         // Check if this name points to an alias.\n         if (aliasVar != null) {\n+            Node aliasedNode = aliasVar.getNode();\n             // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n+            // clone aliasedNode here. For example,\n             // var g = goog; var d = g.dom; d.createElement('DIV');\n             // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // changes pass above with \"goog\". If we cloned here, we'd end up\n             // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n+            aliasUsages.add(new AliasedNode(aliasVar, aliasedNode));\n         }\n         // When we inject declarations, we duplicate jsdoc. Make sure\n         // we only process that jsdoc once.\n         JSDocInfo info = n.getJSDocInfo();\n         if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n+            for (Node typeNode : info.getTypeNodes()) {\n+                fixTypeNode(typeNode);\n             }\n         }\n         // TODO(robbyw): Error for goog.scope not at root.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, parent); // Changed third argument to parent\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(name); // Removed redundant getString() call\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO: Validate that goog.scope is at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,60 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, parent); // Changed third argument to parent\n     }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(name); // Removed redundant getString() call\n+        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendent scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO: Validate that goog.scope is at root.\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,7 +1,7 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+        validateScopeCall(t, n, parent); // Changed third argument to parent\n     }\n     if (t.getScopeDepth() < 2) {\n         return;\n@@ -10,7 +10,7 @@\n     Var aliasVar = null;\n     if (type == Token.NAME) {\n         String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n+        Var lexicalVar = t.getScope().getVar(name); // Removed redundant getString() call\n         if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n             aliasVar = lexicalVar;\n         }\n@@ -55,6 +55,6 @@\n                 fixTypeNode(node);\n             }\n         }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        // TODO: Validate that goog.scope is at root.\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && aliases.containsKey(name)) {\n            // Changed check from \"lexicalVar == aliases.get(name)\" to \"aliases.containsKey(name)\"\n            aliasVar = aliases.get(name);\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,61 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n     }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(n.getString());\n+        if (lexicalVar != null && aliases.containsKey(name)) {\n+            // Changed check from \"lexicalVar == aliases.get(name)\" to \"aliases.containsKey(name)\"\n+            aliasVar = aliases.get(name);\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendent scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO(robbyw): Error for goog.scope not at root.\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -11,8 +11,9 @@\n     if (type == Token.NAME) {\n         String name = n.getString();\n         Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n+        if (lexicalVar != null && aliases.containsKey(name)) {\n+            // Changed check from \"lexicalVar == aliases.get(name)\" to \"aliases.containsKey(name)\"\n+            aliasVar = aliases.get(name);\n         }\n     }\n     // Validate the top-level of the goog.scope block.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendant scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,60 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n     }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(n.getString());\n+        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendant scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO(robbyw): Error for goog.scope not at root.\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -11,7 +11,7 @@\n     if (type == Token.NAME) {\n         String name = n.getString();\n         Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n             aliasVar = lexicalVar;\n         }\n     }\n@@ -35,7 +35,7 @@\n             report(t, n, GOOG_SCOPE_USES_THROW);\n         }\n     }\n-    // Validate all descendent scopes of the goog.scope block.\n+    // Validate all descendant scopes of the goog.scope block.\n     if (t.getScopeDepth() >= 2) {\n         // Check if this name points to an alias.\n         if (aliasVar != null) {\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, parent);\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(name);\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,60 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, parent);\n     }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(name);\n+        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendent scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO(robbyw): Error for goog.scope not at root.\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,7 +1,7 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+        validateScopeCall(t, n, parent);\n     }\n     if (t.getScopeDepth() < 2) {\n         return;\n@@ -10,7 +10,7 @@\n     Var aliasVar = null;\n     if (type == Token.NAME) {\n         String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n+        Var lexicalVar = t.getScope().getVar(name);\n         if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n             aliasVar = lexicalVar;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,60 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n     }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(n.getString());\n+        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendent scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO(robbyw): Error for goog.scope not at root.\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -11,7 +11,7 @@\n     if (type == Token.NAME) {\n         String name = n.getString();\n         Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n             aliasVar = lexicalVar;\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && aliases.get(name) != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendant scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,60 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n     }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(n.getString());\n+        if (lexicalVar != null && aliases.get(name) != null && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendant scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO(robbyw): Error for goog.scope not at root.\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -11,7 +11,7 @@\n     if (type == Token.NAME) {\n         String name = n.getString();\n         Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+        if (lexicalVar != null && aliases.get(name) != null && lexicalVar == aliases.get(name)) {\n             aliasVar = lexicalVar;\n         }\n     }\n@@ -35,7 +35,7 @@\n             report(t, n, GOOG_SCOPE_USES_THROW);\n         }\n     }\n-    // Validate all descendent scopes of the goog.scope block.\n+    // Validate all descendant scopes of the goog.scope block.\n     if (t.getScopeDepth() >= 2) {\n         // Check if this name points to an alias.\n         if (aliasVar != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                if (!aliasDefinitionsInOrder.contains(n)) {\n                    aliasDefinitionsInOrder.add(n);\n                }\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendant scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,62 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n     }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(n.getString());\n+        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                if (!aliasDefinitionsInOrder.contains(n)) {\n+                    aliasDefinitionsInOrder.add(n);\n+                }\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendant scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO(robbyw): Error for goog.scope not at root.\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -11,7 +11,7 @@\n     if (type == Token.NAME) {\n         String name = n.getString();\n         Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n             aliasVar = lexicalVar;\n         }\n     }\n@@ -19,7 +19,9 @@\n     if (t.getScopeDepth() == 2) {\n         if (aliasVar != null && NodeUtil.isLValue(n)) {\n             if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n+                if (!aliasDefinitionsInOrder.contains(n)) {\n+                    aliasDefinitionsInOrder.add(n);\n+                }\n                 // Return early, to ensure that we don't record a definition\n                 // twice.\n                 return;\n@@ -35,7 +37,7 @@\n             report(t, n, GOOG_SCOPE_USES_THROW);\n         }\n     }\n-    // Validate all descendent scopes of the goog.scope block.\n+    // Validate all descendant scopes of the goog.scope block.\n     if (t.getScopeDepth() >= 2) {\n         // Check if this name points to an alias.\n         if (aliasVar != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScope().isGlobal()) { // change from t.getScopeDepth() < 2 to t.getScope().isGlobal()\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(name); // remove redundant call to n.getString()\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScope().isModuleScope()) { // change from t.getScopeDepth() == 2 to t.getScope().isModuleScope()\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (!t.getScope().isGlobal()) { // change from t.getScopeDepth() >= 2 to !t.getScope().isGlobal()\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,60 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n     }\n-    if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+    if (t.getScope().isGlobal()) { // change from t.getScopeDepth() < 2 to t.getScope().isGlobal()\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(name); // remove redundant call to n.getString()\n+        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n+    if (t.getScope().isModuleScope()) { // change from t.getScopeDepth() == 2 to t.getScope().isModuleScope()\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendent scopes of the goog.scope block.\n+    if (!t.getScope().isGlobal()) { // change from t.getScopeDepth() >= 2 to !t.getScope().isGlobal()\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO(robbyw): Error for goog.scope not at root.\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -3,20 +3,20 @@\n     if (isCallToScopeMethod(n)) {\n         validateScopeCall(t, n, n.getParent());\n     }\n-    if (t.getScopeDepth() < 2) {\n+    if (t.getScope().isGlobal()) { // change from t.getScopeDepth() < 2 to t.getScope().isGlobal()\n         return;\n     }\n     int type = n.getType();\n     Var aliasVar = null;\n     if (type == Token.NAME) {\n         String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n+        Var lexicalVar = t.getScope().getVar(name); // remove redundant call to n.getString()\n         if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n             aliasVar = lexicalVar;\n         }\n     }\n     // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n+    if (t.getScope().isModuleScope()) { // change from t.getScopeDepth() == 2 to t.getScope().isModuleScope()\n         if (aliasVar != null && NodeUtil.isLValue(n)) {\n             if (aliasVar.getNode() == n) {\n                 aliasDefinitionsInOrder.add(n);\n@@ -36,7 +36,7 @@\n         }\n     }\n     // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n+    if (!t.getScope().isGlobal()) { // change from t.getScopeDepth() >= 2 to !t.getScope().isGlobal()\n         // Check if this name points to an alias.\n         if (aliasVar != null) {\n             // Note, to support the transitive case, it's important we don't\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(name);\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendant scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,60 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n     }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(name);\n+        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendant scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO(robbyw): Error for goog.scope not at root.\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -10,7 +10,7 @@\n     Var aliasVar = null;\n     if (type == Token.NAME) {\n         String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n+        Var lexicalVar = t.getScope().getVar(name);\n         if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n             aliasVar = lexicalVar;\n         }\n@@ -35,7 +35,7 @@\n             report(t, n, GOOG_SCOPE_USES_THROW);\n         }\n     }\n-    // Validate all descendent scopes of the goog.scope block.\n+    // Validate all descendant scopes of the goog.scope block.\n     if (t.getScopeDepth() >= 2) {\n         // Check if this name points to an alias.\n         if (aliasVar != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(name);\n        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendant scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2 && t.getClosestHoistScope().isGlobal()) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // Error for goog.scope not at root.\n        if (type == Token.SCRIPT && parent.isBlock() && parent.getParent() != null) {\n            report(t, n, GOOG_SCOPE_NOT_AT_ROOT);\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,63 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n     }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(name);\n+        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendant scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2 && t.getClosestHoistScope().isGlobal()) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // Error for goog.scope not at root.\n+        if (type == Token.SCRIPT && parent.isBlock() && parent.getParent() != null) {\n+            report(t, n, GOOG_SCOPE_NOT_AT_ROOT);\n+        }\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -10,8 +10,8 @@\n     Var aliasVar = null;\n     if (type == Token.NAME) {\n         String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+        Var lexicalVar = t.getScope().getVar(name);\n+        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n             aliasVar = lexicalVar;\n         }\n     }\n@@ -35,8 +35,8 @@\n             report(t, n, GOOG_SCOPE_USES_THROW);\n         }\n     }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n+    // Validate all descendant scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2 && t.getClosestHoistScope().isGlobal()) {\n         // Check if this name points to an alias.\n         if (aliasVar != null) {\n             // Note, to support the transitive case, it's important we don't\n@@ -55,6 +55,9 @@\n                 fixTypeNode(node);\n             }\n         }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        // Error for goog.scope not at root.\n+        if (type == Token.SCRIPT && parent.isBlock() && parent.getParent() != null) {\n+            report(t, n, GOOG_SCOPE_NOT_AT_ROOT);\n+        }\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(name);\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendant scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO (robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,60 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n     }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(name);\n+        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendant scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO (robbyw): Error for goog.scope not at root.\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -10,7 +10,7 @@\n     Var aliasVar = null;\n     if (type == Token.NAME) {\n         String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n+        Var lexicalVar = t.getScope().getVar(name);\n         if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n             aliasVar = lexicalVar;\n         }\n@@ -35,7 +35,7 @@\n             report(t, n, GOOG_SCOPE_USES_THROW);\n         }\n     }\n-    // Validate all descendent scopes of the goog.scope block.\n+    // Validate all descendant scopes of the goog.scope block.\n     if (t.getScopeDepth() >= 2) {\n         // Check if this name points to an alias.\n         if (aliasVar != null) {\n@@ -55,6 +55,6 @@\n                 fixTypeNode(node);\n             }\n         }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        // TODO (robbyw): Error for goog.scope not at root.\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(name); // fixed this line\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,60 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n     }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(name); // fixed this line\n+        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendent scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO(robbyw): Error for goog.scope not at root.\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -10,7 +10,7 @@\n     Var aliasVar = null;\n     if (type == Token.NAME) {\n         String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n+        Var lexicalVar = t.getScope().getVar(name); // fixed this line\n         if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n             aliasVar = lexicalVar;\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(name);\n        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,60 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n     }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(name);\n+        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendent scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO(robbyw): Error for goog.scope not at root.\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -10,8 +10,8 @@\n     Var aliasVar = null;\n     if (type == Token.NAME) {\n         String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+        Var lexicalVar = t.getScope().getVar(name);\n+        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n             aliasVar = lexicalVar;\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getGrandparent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(name);\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendant scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO: Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,60 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getGrandparent());\n     }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(name);\n+        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendant scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO: Error for goog.scope not at root.\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,7 +1,7 @@\n @Override\n public void visit(NodeTraversal t, Node n, Node parent) {\n     if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+        validateScopeCall(t, n, n.getGrandparent());\n     }\n     if (t.getScopeDepth() < 2) {\n         return;\n@@ -10,7 +10,7 @@\n     Var aliasVar = null;\n     if (type == Token.NAME) {\n         String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n+        Var lexicalVar = t.getScope().getVar(name);\n         if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n             aliasVar = lexicalVar;\n         }\n@@ -35,7 +35,7 @@\n             report(t, n, GOOG_SCOPE_USES_THROW);\n         }\n     }\n-    // Validate all descendent scopes of the goog.scope block.\n+    // Validate all descendant scopes of the goog.scope block.\n     if (t.getScopeDepth() >= 2) {\n         // Check if this name points to an alias.\n         if (aliasVar != null) {\n@@ -55,6 +55,6 @@\n                 fixTypeNode(node);\n             }\n         }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        // TODO: Error for goog.scope not at root.\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2 && n.isBlockScope()) { // Added isBlockScope() check\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,60 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n     }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(n.getString());\n+        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendent scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2 && n.isBlockScope()) { // Added isBlockScope() check\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO(robbyw): Error for goog.scope not at root.\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -36,7 +36,7 @@\n         }\n     }\n     // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n+    if (t.getScopeDepth() >= 2 && n.isBlockScope()) { // Added isBlockScope() check\n         // Check if this name points to an alias.\n         if (aliasVar != null) {\n             // Note, to support the transitive case, it's important we don't\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(name);\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendant scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate JSDoc. Make sure\n        // we only process that JSDoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO: error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,60 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n     }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(name);\n+        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendant scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate JSDoc. Make sure\n+        // we only process that JSDoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO: error for goog.scope not at root.\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -10,7 +10,7 @@\n     Var aliasVar = null;\n     if (type == Token.NAME) {\n         String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n+        Var lexicalVar = t.getScope().getVar(name);\n         if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n             aliasVar = lexicalVar;\n         }\n@@ -35,7 +35,7 @@\n             report(t, n, GOOG_SCOPE_USES_THROW);\n         }\n     }\n-    // Validate all descendent scopes of the goog.scope block.\n+    // Validate all descendant scopes of the goog.scope block.\n     if (t.getScopeDepth() >= 2) {\n         // Check if this name points to an alias.\n         if (aliasVar != null) {\n@@ -47,14 +47,14 @@\n             // with <code>g.dom.createElement('DIV')</code>.\n             aliasUsages.add(new AliasedNode(aliasVar, n));\n         }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n+        // When we inject declarations, we duplicate JSDoc. Make sure\n+        // we only process that JSDoc once.\n         JSDocInfo info = n.getJSDocInfo();\n         if (info != null) {\n             for (Node node : info.getTypeNodes()) {\n                 fixTypeNode(node);\n             }\n         }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        // TODO: error for goog.scope not at root.\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendant scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -1,13 +1,61 @@\n @Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n     }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(n.getString());\n+        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+\n+    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendant scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO(robbyw): Error for goog.scope not at root.\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -11,10 +11,11 @@\n     if (type == Token.NAME) {\n         String name = n.getString();\n         Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n             aliasVar = lexicalVar;\n         }\n     }\n+\n     // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n         if (aliasVar != null && NodeUtil.isLValue(n)) {\n@@ -35,7 +36,7 @@\n             report(t, n, GOOG_SCOPE_USES_THROW);\n         }\n     }\n-    // Validate all descendent scopes of the goog.scope block.\n+    // Validate all descendant scopes of the goog.scope block.\n     if (t.getScopeDepth() >= 2) {\n         // Check if this name points to an alias.\n         if (aliasVar != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}]