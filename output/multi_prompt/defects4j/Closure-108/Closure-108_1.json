[{"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"_\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.empty().useSourceInfoFrom(existingName);\n                existingName.replaceWith(newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = IR.var(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name)).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setJsDocInfo(newDecl, v.getJSDocInfo());\n                NodeUtil.setDebugInformation(newDecl.getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n                if (value != null) {\n                    Node assignNode = IR.assign(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name), value).useSourceInfoFrom(value);\n                    grandparent.addChildBefore(assignNode, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().replaceChild(n, NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -21,7 +21,7 @@\n             String name = n.getString();\n             int nameCount = scopedAliasNames.count(name);\n             scopedAliasNames.add(name);\n-            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n+            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"_\" + nameCount));\n             compiler.ensureLibraryInjected(\"base\");\n             // First, we need to free up the function expression (EXPR)\n             // to be used in another expression.\n@@ -35,8 +35,8 @@\n                 //\n                 // This will only cause problems if this is a hoisted, recursive\n                 // function, and the programmer is using the hoisting.\n-                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n-                value.replaceChild(existingName, newName);\n+                Node newName = IR.empty().useSourceInfoFrom(existingName);\n+                existingName.replaceWith(newName);\n                 varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                 grandparent.replaceChild(parent, varNode);\n             } else {\n@@ -50,16 +50,21 @@\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n             if (value != null || v.getJSDocInfo() != null) {\n-                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+                Node newDecl = IR.var(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name)).useSourceInfoIfMissingFromForTree(n);\n+                NodeUtil.setJsDocInfo(newDecl, v.getJSDocInfo());\n+                NodeUtil.setDebugInformation(newDecl.getFirstChild(), n, name);\n                 if (isHoisted) {\n                     grandparent.addChildToFront(newDecl);\n                 } else {\n                     grandparent.addChildBefore(newDecl, varNode);\n                 }\n+                if (value != null) {\n+                    Node assignNode = IR.assign(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name), value).useSourceInfoFrom(value);\n+                    grandparent.addChildBefore(assignNode, varNode);\n+                }\n             }\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            v.getNameNode().replaceChild(n, NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n             recordAlias(v);\n         } else {\n             // Do not other kinds of local symbols, like catch params.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "The function given is a part of a bigger context in a Closure project, and fixing it requires understanding the project and its requirements. Therefore, a fixed function cannot be provided without additional information about the project and its context.", "diff": "", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\"\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                existingName.getParent().replaceChild(existingName, newName);\n                varNode = IR.var(n.cloneNode()).useSourceInfoFrom(parent);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            n.replaceWith(\n                NodeUtil.newQualifiedNameNode(\n                    compiler.getCodingConvention(),\n                    globalName,\n                    n.cloneNode(),\n                    name\n                )\n            );\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -26,7 +26,7 @@\n             // First, we need to free up the function expression (EXPR)\n             // to be used in another expression.\n             if (isFunctionDecl) {\n-                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n+                // Replace \"function NAME() { ... }\" with \"var NAME;\"\n                 Node existingName = v.getNameNode();\n                 // We can't keep the local name on the function expression,\n                 // because IE is buggy and will leak the name into the global\n@@ -36,8 +36,8 @@\n                 // This will only cause problems if this is a hoisted, recursive\n                 // function, and the programmer is using the hoisting.\n                 Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n-                value.replaceChild(existingName, newName);\n-                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n+                existingName.getParent().replaceChild(existingName, newName);\n+                varNode = IR.var(n.cloneNode()).useSourceInfoFrom(parent);\n                 grandparent.replaceChild(parent, varNode);\n             } else {\n                 if (value != null) {\n@@ -59,7 +59,14 @@\n                 }\n             }\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            n.replaceWith(\n+                NodeUtil.newQualifiedNameNode(\n+                    compiler.getCodingConvention(),\n+                    globalName,\n+                    n.cloneNode(),\n+                    name\n+                )\n+            );\n             recordAlias(v);\n         } else {\n             // Do not other kinds of local symbols, like catch params.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue().detach() : null; // detach initial value instead of just getting it\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -16,7 +16,7 @@\n         } else if (isVar || isFunctionDecl) {\n             boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n             Node grandparent = parent.getParent();\n-            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n+            Node value = v.getInitialValue() != null ? v.getInitialValue().detach() : null; // detach initial value instead of just getting it\n             Node varNode = null;\n             String name = n.getString();\n             int nameCount = scopedAliasNames.count(name);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null && parent.hasOneChild()) { // Check if parent only has one child (n), which means it's a VAR initialization.\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                    varNode = parent;\n                } else { // If the parent has other children (i.e. it's a VAR declaration), replace it with a new VAR declaration with the new value as its child.\n                    varNode = IR.var(n.cloneNode(), value).useSourceInfoFrom(parent);\n                    grandparent.replaceChild(parent, varNode);\n                }\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -40,12 +40,15 @@\n                 varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                 grandparent.replaceChild(parent, varNode);\n             } else {\n-                if (value != null) {\n+                if (value != null && parent.hasOneChild()) { // Check if parent only has one child (n), which means it's a VAR initialization.\n                     // If this is a VAR, we can just detach the expression and\n                     // the tree will still be valid.\n                     value.detachFromParent();\n+                    varNode = parent;\n+                } else { // If the parent has other children (i.e. it's a VAR declaration), replace it with a new VAR declaration with the new value as its child.\n+                    varNode = IR.var(n.cloneNode(), value).useSourceInfoFrom(parent);\n+                    grandparent.replaceChild(parent, varNode);\n                 }\n-                varNode = parent;\n             }\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                existingName.replaceWith(newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -36,7 +36,7 @@\n                 // This will only cause problems if this is a hoisted, recursive\n                 // function, and the programmer is using the hoisting.\n                 Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n-                value.replaceChild(existingName, newName);\n+                existingName.replaceWith(newName);\n                 varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                 grandparent.replaceChild(parent, varNode);\n             } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceWith(newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -36,7 +36,7 @@\n                 // This will only cause problems if this is a hoisted, recursive\n                 // function, and the programmer is using the hoisting.\n                 Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n-                value.replaceChild(existingName, newName);\n+                value.replaceWith(newName);\n                 varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                 grandparent.replaceChild(parent, varNode);\n             } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                existingName.replaceWith(newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNode().replaceChild(n, NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n.detach(), name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -36,7 +36,7 @@\n                 // This will only cause problems if this is a hoisted, recursive\n                 // function, and the programmer is using the hoisting.\n                 Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n-                value.replaceChild(existingName, newName);\n+                existingName.replaceWith(newName);\n                 varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                 grandparent.replaceChild(parent, varNode);\n             } else {\n@@ -59,7 +59,7 @@\n                 }\n             }\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            v.getNode().replaceChild(n, NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n.detach(), name));\n             recordAlias(v);\n         } else {\n             // Do not other kinds of local symbols, like catch params.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction() || parent.getType() == Token.LP) {\n            // Bleeding functions and parameters of the scope function already\n            // get a BAD_PARAMETERS error, so just do nothing.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -7,12 +7,9 @@\n         boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n             recordAlias(v);\n-        } else if (v.isBleedingFunction()) {\n-            // Bleeding functions already get a BAD_PARAMETERS error, so just\n-            // do nothing.\n-        } else if (parent.getType() == Token.LP) {\n-            // Parameters of the scope function also get a BAD_PARAMETERS\n-            // error.\n+        } else if (v.isBleedingFunction() || parent.getType() == Token.LP) {\n+            // Bleeding functions and parameters of the scope function already\n+            // get a BAD_PARAMETERS error, so just do nothing.\n         } else if (isVar || isFunctionDecl) {\n             boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n             Node grandparent = parent.getParent();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent.cloneTree();\n                varNode.removeChildAfter(n);\n                varNode.srcrefRange(parent.getStart(), n.getStart());\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            n.replaceWith(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -45,7 +45,9 @@\n                     // the tree will still be valid.\n                     value.detachFromParent();\n                 }\n-                varNode = parent;\n+                varNode = parent.cloneTree();\n+                varNode.removeChildAfter(n);\n+                varNode.srcrefRange(parent.getStart(), n.getStart());\n             }\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n@@ -59,7 +61,7 @@\n                 }\n             }\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            n.replaceWith(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n             recordAlias(v);\n         } else {\n             // Do not other kinds of local symbols, like catch params.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            Node qualifiedNameNode = NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, null, name);\n            v.getNameNode().replaceChild(n, qualifiedNameNode);\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -59,7 +59,8 @@\n                 }\n             }\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            Node qualifiedNameNode = NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, null, name);\n+            v.getNameNode().replaceChild(n, qualifiedNameNode);\n             recordAlias(v);\n         } else {\n             // Do not other kinds of local symbols, like catch params.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue();\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value = null;\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -16,7 +16,7 @@\n         } else if (isVar || isFunctionDecl) {\n             boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n             Node grandparent = parent.getParent();\n-            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n+            Node value = v.getInitialValue();\n             Node varNode = null;\n             String name = n.getString();\n             int nameCount = scopedAliasNames.count(name);\n@@ -36,6 +36,7 @@\n                 // This will only cause problems if this is a hoisted, recursive\n                 // function, and the programmer is using the hoisting.\n                 Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n+                value = null;\n                 value.replaceChild(existingName, newName);\n                 varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                 grandparent.replaceChild(parent, varNode);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression, so check if it's a function declaration.\n            if (isFunctionDecl) {\n                Node existingName = v.getNameNode();\n                // Check for uninitialized named functions.\n                if (value == null) {\n                    Var scopesVar = checkNotNull(scope.getVar(existingName.getString()), existingName);\n                    int declaringScopeDepth = scopesVar.getScope().getDepth();\n                    int fnScopeDepth = v.getScope().getDepth();\n                    // Only attempt to convert named functions to expressions when the function body\n                    // doesn't reference the function name from an outer scope. We can still\n                    // substitute the name when we access it in the new scope.\n                    if (fnScopeDepth == declaringScopeDepth) {\n                        NodeUtil.getEnclosingStatement(parent).replaceWith(IR.expr(existingName.detach()).srcref(existingName));\n                        value = existingName;\n                    }\n                }\n                // Function declarations are replaced with \"var NAME = FUNCTION_NAME;\"\n                if (value != null) {\n                    varNode = IR.var(IR.name(name).useSourceInfoIfMissingFrom(n), IR.name(\"\").useSourceInfoIfMissingFrom(n)).useSourceInfoFrom(parent);\n                    grandparent.replaceChild(parent, varNode);\n                    Var newName = scope.getVar(name);\n                    // Function declarations shouldn't have an initializer.\n                    newName.setInitialValue(null);\n                    newName.getNode().removeFirstChild();\n                    newName.getNameNode().addChildToFront(newName.getNameNode().cloneTree());\n                    varNode.getLastChild().addChildToBack(\n                            NodeUtil.newQName(compiler, globalName).srcrefTreeIfMissing(n));\n                    copyJSDoc(v.getNameNode(), varNode.getFirstFirstChild());\n                    recordAlias(v);\n                } else {\n                    Node newName = IR.name(name).useSourceInfoFrom(existingName);\n                    value.replaceChild(existingName, newName);\n                    varNode = IR.var(newName).useSourceInfoFrom(parent);\n                    grandparent.replaceChild(parent, varNode);\n                    newName.addChildToFront(\n                            NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n                    copyJSDoc(v.getNode(), newName);\n                    recordAlias(v);\n                }\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add \"$jscomp.scope.name = EXPR;\".\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = IR.expr(IR.assign(NodeUtil.newQName(compiler, globalName), value)).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (!isHoisted) {\n                    grandparent.addChildBefore(newDecl, varNode);\n                } else {\n                    grandparent.addChildToFront(newDecl);\n                }\n            }\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -24,21 +24,45 @@\n             String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n             compiler.ensureLibraryInjected(\"base\");\n             // First, we need to free up the function expression (EXPR)\n-            // to be used in another expression.\n+            // to be used in another expression, so check if it's a function declaration.\n             if (isFunctionDecl) {\n-                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                 Node existingName = v.getNameNode();\n-                // We can't keep the local name on the function expression,\n-                // because IE is buggy and will leak the name into the global\n-                // scope. This is covered in more detail here:\n-                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n-                //\n-                // This will only cause problems if this is a hoisted, recursive\n-                // function, and the programmer is using the hoisting.\n-                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n-                value.replaceChild(existingName, newName);\n-                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n-                grandparent.replaceChild(parent, varNode);\n+                // Check for uninitialized named functions.\n+                if (value == null) {\n+                    Var scopesVar = checkNotNull(scope.getVar(existingName.getString()), existingName);\n+                    int declaringScopeDepth = scopesVar.getScope().getDepth();\n+                    int fnScopeDepth = v.getScope().getDepth();\n+                    // Only attempt to convert named functions to expressions when the function body\n+                    // doesn't reference the function name from an outer scope. We can still\n+                    // substitute the name when we access it in the new scope.\n+                    if (fnScopeDepth == declaringScopeDepth) {\n+                        NodeUtil.getEnclosingStatement(parent).replaceWith(IR.expr(existingName.detach()).srcref(existingName));\n+                        value = existingName;\n+                    }\n+                }\n+                // Function declarations are replaced with \"var NAME = FUNCTION_NAME;\"\n+                if (value != null) {\n+                    varNode = IR.var(IR.name(name).useSourceInfoIfMissingFrom(n), IR.name(\"\").useSourceInfoIfMissingFrom(n)).useSourceInfoFrom(parent);\n+                    grandparent.replaceChild(parent, varNode);\n+                    Var newName = scope.getVar(name);\n+                    // Function declarations shouldn't have an initializer.\n+                    newName.setInitialValue(null);\n+                    newName.getNode().removeFirstChild();\n+                    newName.getNameNode().addChildToFront(newName.getNameNode().cloneTree());\n+                    varNode.getLastChild().addChildToBack(\n+                            NodeUtil.newQName(compiler, globalName).srcrefTreeIfMissing(n));\n+                    copyJSDoc(v.getNameNode(), varNode.getFirstFirstChild());\n+                    recordAlias(v);\n+                } else {\n+                    Node newName = IR.name(name).useSourceInfoFrom(existingName);\n+                    value.replaceChild(existingName, newName);\n+                    varNode = IR.var(newName).useSourceInfoFrom(parent);\n+                    grandparent.replaceChild(parent, varNode);\n+                    newName.addChildToFront(\n+                            NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+                    copyJSDoc(v.getNode(), newName);\n+                    recordAlias(v);\n+                }\n             } else {\n                 if (value != null) {\n                     // If this is a VAR, we can just detach the expression and\n@@ -47,20 +71,17 @@\n                 }\n                 varNode = parent;\n             }\n-            // Add $jscomp.scope.name = EXPR;\n+            // Add \"$jscomp.scope.name = EXPR;\".\n             // Make sure we copy over all the jsdoc and debug info.\n             if (value != null || v.getJSDocInfo() != null) {\n-                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n+                Node newDecl = IR.expr(IR.assign(NodeUtil.newQName(compiler, globalName), value)).useSourceInfoIfMissingFromForTree(n);\n                 NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n-                if (isHoisted) {\n+                if (!isHoisted) {\n+                    grandparent.addChildBefore(newDecl, varNode);\n+                } else {\n                     grandparent.addChildToFront(newDecl);\n-                } else {\n-                    grandparent.addChildBefore(newDecl, varNode);\n                 }\n             }\n-            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n-            recordAlias(v);\n         } else {\n             // Do not other kinds of local symbols, like catch params.\n             report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME = function() {};\". Note\n                // that we had to add a function for IE compatibility reasons, as explained\n                // here: http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting. In that specific case, we\n                // surface a warning.\n                Node existingName = v.getNameNode();\n                Node newFunction = IR.function(IR.name(\"\").useSourceInfoFrom(existingName), IR.paramList().useSourceInfoFrom(existingName), IR.block().useSourceInfoFrom(existingName)).useSourceInfoFrom(existingName);\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.addChildToFront(newName);\n                value.replaceChild(existingName, newFunction);\n                varNode = IR.var(existingName, value).useSourceInfoFrom(existingName);\n                if (isHoisted) {\n                    report(t, existingName, GOOG_SCOPE_FUNCTION_DECL_CANNOT_USE_HOISTED_NAME);\n                }\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                    varNode = parent;\n                } else {\n                    // function declarations without a RHS are already a (undefined) function\n                    // as we transform them as function expression that get evaluated immediately\n                    // i.e. \"function() {}()\", so just do a var = undefined.\n                    varNode = IR.var(n.cloneNode(), IR.number(0));\n                    grandparent.replaceChild(parent, varNode);\n                    v.setInitialValue(varNode);\n                }\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n.cloneNode(), name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -26,26 +26,36 @@\n             // First, we need to free up the function expression (EXPR)\n             // to be used in another expression.\n             if (isFunctionDecl) {\n-                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n+                // Replace \"function NAME() { ... }\" with \"var NAME = function() {};\". Note\n+                // that we had to add a function for IE compatibility reasons, as explained\n+                // here: http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n+                // This will only cause problems if this is a hoisted, recursive\n+                // function, and the programmer is using the hoisting. In that specific case, we\n+                // surface a warning.\n                 Node existingName = v.getNameNode();\n-                // We can't keep the local name on the function expression,\n-                // because IE is buggy and will leak the name into the global\n-                // scope. This is covered in more detail here:\n-                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n-                //\n-                // This will only cause problems if this is a hoisted, recursive\n-                // function, and the programmer is using the hoisting.\n+                Node newFunction = IR.function(IR.name(\"\").useSourceInfoFrom(existingName), IR.paramList().useSourceInfoFrom(existingName), IR.block().useSourceInfoFrom(existingName)).useSourceInfoFrom(existingName);\n                 Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n-                value.replaceChild(existingName, newName);\n-                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n+                value.addChildToFront(newName);\n+                value.replaceChild(existingName, newFunction);\n+                varNode = IR.var(existingName, value).useSourceInfoFrom(existingName);\n+                if (isHoisted) {\n+                    report(t, existingName, GOOG_SCOPE_FUNCTION_DECL_CANNOT_USE_HOISTED_NAME);\n+                }\n                 grandparent.replaceChild(parent, varNode);\n             } else {\n                 if (value != null) {\n                     // If this is a VAR, we can just detach the expression and\n                     // the tree will still be valid.\n                     value.detachFromParent();\n+                    varNode = parent;\n+                } else {\n+                    // function declarations without a RHS are already a (undefined) function\n+                    // as we transform them as function expression that get evaluated immediately\n+                    // i.e. \"function() {}()\", so just do a var = undefined.\n+                    varNode = IR.var(n.cloneNode(), IR.number(0));\n+                    grandparent.replaceChild(parent, varNode);\n+                    v.setInitialValue(varNode);\n                 }\n-                varNode = parent;\n             }\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n@@ -59,7 +69,7 @@\n                 }\n             }\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n.cloneNode(), name));\n             recordAlias(v);\n         } else {\n             // Do not other kinds of local symbols, like catch params.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = n.hasChildren() ? n.getFirstChild() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    Node newNode = IR.name(\"\").useSourceInfoFrom(n);\n                    value.replaceWith(newNode);\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -16,7 +16,7 @@\n         } else if (isVar || isFunctionDecl) {\n             boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n             Node grandparent = parent.getParent();\n-            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n+            Node value = n.hasChildren() ? n.getFirstChild() : null;\n             Node varNode = null;\n             String name = n.getString();\n             int nameCount = scopedAliasNames.count(name);\n@@ -43,7 +43,8 @@\n                 if (value != null) {\n                     // If this is a VAR, we can just detach the expression and\n                     // the tree will still be valid.\n-                    value.detachFromParent();\n+                    Node newNode = IR.name(\"\").useSourceInfoFrom(n);\n+                    value.replaceWith(newNode);\n                 }\n                 varNode = parent;\n             }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -20,7 +20,6 @@\n             Node varNode = null;\n             String name = n.getString();\n             int nameCount = scopedAliasNames.count(name);\n-            scopedAliasNames.add(name);\n             String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n             compiler.ensureLibraryInjected(\"base\");\n             // First, we need to free up the function expression (EXPR)\n@@ -51,7 +50,7 @@\n             // Make sure we copy over all the jsdoc and debug info.\n             if (value != null || v.getJSDocInfo() != null) {\n                 Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+                NodeUtil.setDebugInformation(newDecl.getFirstFirstChild(), n, name);\n                 if (isHoisted) {\n                     grandparent.addChildToFront(newDecl);\n                 } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n                if (existingName.getFirstChild() != null) {\n                    existingName.getFirstChild().detachFromParent();\n                }\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -28,17 +28,12 @@\n             if (isFunctionDecl) {\n                 // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                 Node existingName = v.getNameNode();\n-                // We can't keep the local name on the function expression,\n-                // because IE is buggy and will leak the name into the global\n-                // scope. This is covered in more detail here:\n-                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n-                //\n-                // This will only cause problems if this is a hoisted, recursive\n-                // function, and the programmer is using the hoisting.\n                 Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n-                value.replaceChild(existingName, newName);\n                 varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                 grandparent.replaceChild(parent, varNode);\n+                if (existingName.getFirstChild() != null) {\n+                    existingName.getFirstChild().detachFromParent();\n+                }\n             } else {\n                 if (value != null) {\n                     // If this is a VAR, we can just detach the expression and\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP || parent.getType() == Token.PARAM_LIST) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -10,7 +10,7 @@\n         } else if (v.isBleedingFunction()) {\n             // Bleeding functions already get a BAD_PARAMETERS error, so just\n             // do nothing.\n-        } else if (parent.getType() == Token.LP) {\n+        } else if (parent.getType() == Token.LP || parent.getType() == Token.PARAM_LIST) {\n             // Parameters of the scope function also get a BAD_PARAMETERS\n             // error.\n         } else if (isVar || isFunctionDecl) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME = function(){};\"\n                Node existingName = v.getNameNode();\n                Node newName = NodeUtil.newName(compiler, \"\");\n                value.replaceWith(newName);\n                varNode = IR.var(IR.name(existingName.getString()), newName).useSourceInfoFrom(parent);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -26,18 +26,11 @@\n             // First, we need to free up the function expression (EXPR)\n             // to be used in another expression.\n             if (isFunctionDecl) {\n-                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n+                // Replace \"function NAME() { ... }\" with \"var NAME = function(){};\"\n                 Node existingName = v.getNameNode();\n-                // We can't keep the local name on the function expression,\n-                // because IE is buggy and will leak the name into the global\n-                // scope. This is covered in more detail here:\n-                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n-                //\n-                // This will only cause problems if this is a hoisted, recursive\n-                // function, and the programmer is using the hoisting.\n-                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n-                value.replaceChild(existingName, newName);\n-                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n+                Node newName = NodeUtil.newName(compiler, \"\");\n+                value.replaceWith(newName);\n+                varNode = IR.var(IR.name(existingName.getString()), newName).useSourceInfoFrom(parent);\n                 grandparent.replaceChild(parent, varNode);\n             } else {\n                 if (value != null) {\n", "finish_reason": "stop", "valid": false, "num": 1}]