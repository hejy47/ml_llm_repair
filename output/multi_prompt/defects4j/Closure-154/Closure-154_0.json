[{"output": "private void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n        return;\n    }\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasOwnProperty(propertyName);\n    boolean declaredOverride = info != null && info.isOverride();\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n        for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n            if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {\n                continue;\n            }\n            FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();\n            Preconditions.checkNotNull(interfaceType);\n            boolean interfaceHasProperty = interfaceType.getPrototype().hasOwnProperty(propertyName);\n            foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n            if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {\n                // @override not present, but the property does override an interface\n                // property\n                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));\n            }\n            if (interfaceHasProperty) {\n                JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n                if (!propertyType.canAssignTo(interfacePropType)) {\n                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n                }\n            }\n        }\n    }\n    if (!declaredOverride && !superClassHasProperty) {\n        // nothing to do here, it's just a plain new property\n        return;\n    }\n    JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;\n    if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) {\n        // @override not present, but the property does override a superclass\n        // property\n        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));\n    }\n    if (!declaredOverride) {\n        // there's no @override to check\n        return;\n    }\n    // @override is present and we have to check that it is ok\n    if (superClassHasProperty) {\n        // there is a superclass implementation\n        JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n        if (!propertyType.canAssignTo(superClassPropType)) {\n            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n        }\n    } else if (!foundInterfaceProperty) {\n        // there is no superclass nor interface implementation\n        compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString()));\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n+++ com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n@@ -5,7 +5,7 @@\n         return;\n     }\n     FunctionType superClass = ctorType.getSuperClassConstructor();\n-    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName);\n+    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasOwnProperty(propertyName);\n     boolean declaredOverride = info != null && info.isOverride();\n     boolean foundInterfaceProperty = false;\n     if (ctorType.isConstructor()) {\n@@ -15,7 +15,7 @@\n             }\n             FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();\n             Preconditions.checkNotNull(interfaceType);\n-            boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);\n+            boolean interfaceHasProperty = interfaceType.getPrototype().hasOwnProperty(propertyName);\n             foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n             if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {\n                 // @override not present, but the property does override an interface\n", "finish_reason": "stop", "valid": false, "num": 8}, {"output": "private void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n        return;\n    }\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName);\n    boolean declaredOverride = info != null && info.isOverride();\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n        for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n            if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {\n                continue;\n            }\n            FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();\n            Preconditions.checkNotNull(interfaceType);\n            boolean interfaceHasProperty = interfaceType.hasProperty(propertyName); // changed to check property directly on interfaceType without checking prototype\n            foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n            if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {\n                // @override not present, but the property does override an interface\n                // property\n                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));\n            }\n            if (interfaceHasProperty) {\n                JSType interfacePropType = interfaceType.getPropertyType(propertyName); // changed to get property type directly on interfaceType without checking prototype\n                if (!propertyType.canAssignTo(interfacePropType)) {\n                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n                }\n            }\n        }\n    }\n    if (!declaredOverride && !superClassHasProperty) {\n        // nothing to do here, it's just a plain new property\n        return;\n    }\n    JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;\n    if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) {\n        // @override not present, but the property does override a superclass\n        // property\n        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));\n    }\n    if (!declaredOverride) {\n        // there's no @override to check\n        return;\n    }\n    // @override is present and we have to check that it is ok\n    if (superClassHasProperty) {\n        // there is a superclass implementation\n        JSType superClassPropType = superClass.getPropertyType(propertyName); // changed to get property type directly on superClass without checking prototype\n        if (!propertyType.canAssignTo(superClassPropType)) {\n            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n        }\n    } else if (!foundInterfaceProperty) {\n        // there is no superclass nor interface implementation\n        compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString()));\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n+++ com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n@@ -15,7 +15,7 @@\n             }\n             FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();\n             Preconditions.checkNotNull(interfaceType);\n-            boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);\n+            boolean interfaceHasProperty = interfaceType.hasProperty(propertyName); // changed to check property directly on interfaceType without checking prototype\n             foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n             if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {\n                 // @override not present, but the property does override an interface\n@@ -23,7 +23,7 @@\n                 compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));\n             }\n             if (interfaceHasProperty) {\n-                JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n+                JSType interfacePropType = interfaceType.getPropertyType(propertyName); // changed to get property type directly on interfaceType without checking prototype\n                 if (!propertyType.canAssignTo(interfacePropType)) {\n                     compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n                 }\n@@ -47,7 +47,7 @@\n     // @override is present and we have to check that it is ok\n     if (superClassHasProperty) {\n         // there is a superclass implementation\n-        JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n+        JSType superClassPropType = superClass.getPropertyType(propertyName); // changed to get property type directly on superClass without checking prototype\n         if (!propertyType.canAssignTo(superClassPropType)) {\n             compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n        return;\n    }\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName);\n    boolean declaredOverride = info != null && info.isOverride();\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n        for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n            if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {\n                continue;\n            }\n            FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();\n            Preconditions.checkNotNull(interfaceType);\n            boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);\n            foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n            if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {\n                // @override not present, but the property does override an interface\n                // property\n                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));\n            }\n            if (interfaceHasProperty) {\n                JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n                if (!propertyType.isSubtype(interfacePropType)) {\n                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n                }\n            }\n        }\n    }\n    if (!declaredOverride && !superClassHasProperty) {\n        // nothing to do here, it's just a plain new property\n        return;\n    }\n    JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;\n    if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) {\n        // @override not present, but the property does override a superclass\n        // property\n        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));\n    }\n    if (!declaredOverride) {\n        // there's no @override to check\n        return;\n    }\n    // @override is present and we have to check that it is ok\n    if (superClassHasProperty) {\n        // there is a superclass implementation\n        JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n        if (!propertyType.isSubtype(superClassPropType)) {\n            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n        }\n    } else if (!foundInterfaceProperty) {\n        // there is no superclass nor interface implementation\n        compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString()));\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n+++ com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n@@ -24,7 +24,7 @@\n             }\n             if (interfaceHasProperty) {\n                 JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n-                if (!propertyType.canAssignTo(interfacePropType)) {\n+                if (!propertyType.isSubtype(interfacePropType)) {\n                     compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n                 }\n             }\n@@ -48,7 +48,7 @@\n     if (superClassHasProperty) {\n         // there is a superclass implementation\n         JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n-        if (!propertyType.canAssignTo(superClassPropType)) {\n+        if (!propertyType.isSubtype(superClassPropType)) {\n             compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n         }\n     } else if (!foundInterfaceProperty) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n        return;\n    }\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName);\n    boolean declaredOverride = info != null && info.isOverride();\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n        for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n            if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {\n                continue;\n            }\n            FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();\n            Preconditions.checkNotNull(interfaceType);\n            boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);\n            foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n            if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {\n                // @override not present, but the property does override an interface\n                // property\n                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));\n            }\n            if (interfaceHasProperty) {\n                JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n                if (!propertyType.isSubtypeOf(interfacePropType)) {  // isEqualitySubtype -> isSubtypeOf\n                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n                }\n            }\n        }\n    }\n    if (!declaredOverride && !superClassHasProperty) {\n        // nothing to do here, it's just a plain new property\n        return;\n    }\n    JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;\n    if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) {\n        // @override not present, but the property does override a superclass\n        // property\n        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));\n    }\n    if (!declaredOverride) {\n        // there's no @override to check\n        return;\n    }\n    // @override is present and we have to check that it is ok\n    if (superClassHasProperty) {\n        // there is a superclass implementation\n        JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n        if (!propertyType.isSubtypeOf(superClassPropType)) {  // isEqualitySubtype -> isSubtypeOf\n            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n        }\n    } else if (!foundInterfaceProperty) {\n        // there is no superclass nor interface implementation\n        compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString()));\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n+++ com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n@@ -24,7 +24,7 @@\n             }\n             if (interfaceHasProperty) {\n                 JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n-                if (!propertyType.canAssignTo(interfacePropType)) {\n+                if (!propertyType.isSubtypeOf(interfacePropType)) {  // isEqualitySubtype -> isSubtypeOf\n                     compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n                 }\n             }\n@@ -48,7 +48,7 @@\n     if (superClassHasProperty) {\n         // there is a superclass implementation\n         JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n-        if (!propertyType.canAssignTo(superClassPropType)) {\n+        if (!propertyType.isSubtypeOf(superClassPropType)) {  // isEqualitySubtype -> isSubtypeOf\n             compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n         }\n     } else if (!foundInterfaceProperty) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n        return;\n    }\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName);\n    boolean declaredOverride = info != null && info.isOverride();\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n        for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n            if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {\n                continue;\n            }\n            FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();\n            Preconditions.checkNotNull(interfaceType);\n            boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);\n            foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n            if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {\n                // @override not present, but the property does override an interface\n                // property\n                String topLevelDefiningType = interfaceType.getTopMostDefiningType(propertyName).toString();  // FIXED: Get string representation of top level defining type\n                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, topLevelDefiningType));\n            }\n            if (interfaceHasProperty) {\n                JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n                if (!propertyType.canAssignTo(interfacePropType)) {\n                    String topLevelDefiningType = interfaceType.getTopMostDefiningType(propertyName).toString();  // FIXED: Get string representation of top level defining type\n                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, topLevelDefiningType, interfacePropType.toString(), propertyType.toString()));\n                }\n            }\n        }\n    }\n    if (!declaredOverride && !superClassHasProperty) {\n        // nothing to do here, it's just a plain new property\n        return;\n    }\n    String topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName).toString() : null;  // FIXED: Get string representation of top level defining type\n    if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) {\n        // @override not present, but the property does override a superclass\n        // property\n        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType));\n    }\n    if (!declaredOverride) {\n        // there's no @override to check\n        return;\n    }\n    // @override is present and we have to check that it is ok\n    if (superClassHasProperty) {\n        // there is a superclass implementation\n        JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n        if (!propertyType.canAssignTo(superClassPropType)) {\n            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType, superClassPropType.toString(), propertyType.toString()));\n        }\n    } else if (!foundInterfaceProperty) {\n        // there is no superclass nor interface implementation\n        compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString()));\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n+++ com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n@@ -20,12 +20,14 @@\n             if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {\n                 // @override not present, but the property does override an interface\n                 // property\n-                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));\n+                String topLevelDefiningType = interfaceType.getTopMostDefiningType(propertyName).toString();  // FIXED: Get string representation of top level defining type\n+                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, topLevelDefiningType));\n             }\n             if (interfaceHasProperty) {\n                 JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n                 if (!propertyType.canAssignTo(interfacePropType)) {\n-                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n+                    String topLevelDefiningType = interfaceType.getTopMostDefiningType(propertyName).toString();  // FIXED: Get string representation of top level defining type\n+                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, topLevelDefiningType, interfacePropType.toString(), propertyType.toString()));\n                 }\n             }\n         }\n@@ -34,11 +36,11 @@\n         // nothing to do here, it's just a plain new property\n         return;\n     }\n-    JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;\n+    String topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName).toString() : null;  // FIXED: Get string representation of top level defining type\n     if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) {\n         // @override not present, but the property does override a superclass\n         // property\n-        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));\n+        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType));\n     }\n     if (!declaredOverride) {\n         // there's no @override to check\n@@ -49,7 +51,7 @@\n         // there is a superclass implementation\n         JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n         if (!propertyType.canAssignTo(superClassPropType)) {\n-            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n+            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType, superClassPropType.toString(), propertyType.toString()));\n         }\n     } else if (!foundInterfaceProperty) {\n         // there is no superclass nor interface implementation\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n        return;\n    }\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName);\n    boolean declaredOverride = info != null && info.isOverride();\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n        for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n            if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {\n                continue;\n            }\n            FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();\n            Preconditions.checkNotNull(interfaceType);\n            boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);\n            foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n            if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {\n                // @override not present, but the property does override an interface\n                // property\n                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));\n            }\n            if (interfaceHasProperty) {\n                JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n                if (!propertyType.isSubtypeOf(interfacePropType)) {\n                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n                }\n            }\n        }\n    }\n    if (!declaredOverride && !superClassHasProperty) {\n        // nothing to do here, it's just a plain new property\n        return;\n    }\n    JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;\n    if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) {\n        // @override not present, but the property does override a superclass\n        // property\n        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));\n    }\n    if (!declaredOverride) {\n        // there's no @override to check\n        return;\n    }\n    // @override is present and we have to check that it is ok\n    if (superClassHasProperty) {\n        // there is a superclass implementation\n        JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n        if (!propertyType.isSubtypeOf(superClassPropType)) {\n            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n        }\n    } else if (!foundInterfaceProperty) {\n        // there is no superclass nor interface implementation\n        compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString()));\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n+++ com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n@@ -24,7 +24,7 @@\n             }\n             if (interfaceHasProperty) {\n                 JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n-                if (!propertyType.canAssignTo(interfacePropType)) {\n+                if (!propertyType.isSubtypeOf(interfacePropType)) {\n                     compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n                 }\n             }\n@@ -48,7 +48,7 @@\n     if (superClassHasProperty) {\n         // there is a superclass implementation\n         JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n-        if (!propertyType.canAssignTo(superClassPropType)) {\n+        if (!propertyType.isSubtypeOf(superClassPropType)) {\n             compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n         }\n     } else if (!foundInterfaceProperty) {\n", "finish_reason": "stop", "valid": false, "num": 3}, {"output": "private void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n        return;\n    }\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName);\n    boolean declaredOverride = info != null && info.isOverride();\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n        for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n            if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {\n                continue;\n            }\n            FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();\n            Preconditions.checkNotNull(interfaceType);\n            boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);\n            foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n            if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {\n                // @override not present, but the property does override an interface\n                // property\n                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));\n            }\n            if (interfaceHasProperty) {\n                JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n                if (!propertyType.isAssignableTo(interfacePropType)) { // fixed: changed canAssignTo -> isAssignableTo\n                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n                }\n            }\n        }\n    }\n    if (!declaredOverride && !superClassHasProperty) {\n        // nothing to do here, it's just a plain new property\n        return;\n    }\n    JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;\n    if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) {\n        // @override not present, but the property does override a superclass\n        // property\n        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));\n    }\n    if (!declaredOverride) {\n        // there's no @override to check\n        return;\n    }\n    // @override is present and we have to check that it is ok\n    if (superClassHasProperty) {\n        // there is a superclass implementation\n        JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n        if (!propertyType.isAssignableTo(superClassPropType)) { // fixed: changed canAssignTo -> isAssignableTo\n            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n        }\n    } else if (!foundInterfaceProperty) {\n        // there is no superclass nor interface implementation\n        compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString()));\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n+++ com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n@@ -24,7 +24,7 @@\n             }\n             if (interfaceHasProperty) {\n                 JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n-                if (!propertyType.canAssignTo(interfacePropType)) {\n+                if (!propertyType.isAssignableTo(interfacePropType)) { // fixed: changed canAssignTo -> isAssignableTo\n                     compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n                 }\n             }\n@@ -48,7 +48,7 @@\n     if (superClassHasProperty) {\n         // there is a superclass implementation\n         JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n-        if (!propertyType.canAssignTo(superClassPropType)) {\n+        if (!propertyType.isAssignableTo(superClassPropType)) { // fixed: changed canAssignTo -> isAssignableTo\n             compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n         }\n     } else if (!foundInterfaceProperty) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n        return;\n    }\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName);\n    boolean declaredOverride = info != null && info.isOverride();\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n        for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n            if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {\n                continue;\n            }\n            FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();\n            Preconditions.checkNotNull(interfaceType);\n            boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);\n            foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n            if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {\n                // @override not present, but the property does override an interface\n                // property\n                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));\n            }\n            if (interfaceHasProperty) {\n                JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n                if (!propertyType.canAssignTo(interfacePropType)) {\n                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n                }\n            }\n        }\n    }\n    if (!declaredOverride && !superClassHasProperty) {\n        // nothing to do here, it's just a plain new property\n        return;\n    }\n    JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;\n    if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) {\n        // @override not present, but the property does override a superclass\n        // property\n        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));\n    }\n    if (!declaredOverride) {\n        // there's no @override to check\n        return;\n    }\n    // @override is present and we have to check that it is ok\n    if (superClassHasProperty) {\n        // there is a superclass implementation\n        JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n        if (!propertyType.isAssignableTo(superClassPropType)) {\n            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n        }\n    } else if (!foundInterfaceProperty) {\n        // there is no superclass nor interface implementation\n        compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString()));\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n+++ com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n@@ -48,7 +48,7 @@\n     if (superClassHasProperty) {\n         // there is a superclass implementation\n         JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n-        if (!propertyType.canAssignTo(superClassPropType)) {\n+        if (!propertyType.isAssignableTo(superClassPropType)) {\n             compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n         }\n     } else if (!foundInterfaceProperty) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n        return;\n    }\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName);\n    boolean declaredOverride = info != null && info.isOverride();\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n        for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n            if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {\n                continue;\n            }\n            FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();\n            Preconditions.checkNotNull(interfaceType);\n            boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);\n            foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n            if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {\n                // @override not present, but the property does override an interface\n                // property\n                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));\n            }\n            if (interfaceHasProperty) {\n                JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n                if (!propertyType.canAssignTo(interfacePropType)) {\n                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), propertyType.toString(), interfacePropType.toString()));\n                }\n            }\n        }\n    }\n    if (!declaredOverride && !superClassHasProperty) {\n        // nothing to do here, it's just a plain new property\n        return;\n    }\n    JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;\n    if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) {\n        // @override not present, but the property does override a superclass\n        // property\n        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));\n    }\n    if (!declaredOverride) {\n        // there's no @override to check\n        return;\n    }\n    // @override is present and we have to check that it is ok\n    if (superClassHasProperty) {\n        // there is a superclass implementation\n        JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n        if (!superClassPropType.canAssignTo(propertyType)) {\n            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n        }\n    } else if (!foundInterfaceProperty) {\n        // there is no superclass nor interface implementation\n        compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString()));\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n+++ com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n@@ -25,7 +25,7 @@\n             if (interfaceHasProperty) {\n                 JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n                 if (!propertyType.canAssignTo(interfacePropType)) {\n-                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n+                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), propertyType.toString(), interfacePropType.toString()));\n                 }\n             }\n         }\n@@ -48,7 +48,7 @@\n     if (superClassHasProperty) {\n         // there is a superclass implementation\n         JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n-        if (!propertyType.canAssignTo(superClassPropType)) {\n+        if (!superClassPropType.canAssignTo(propertyType)) {\n             compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n         }\n     } else if (!foundInterfaceProperty) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n        return;\n    }\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName);\n    boolean declaredOverride = info != null && info.isOverride();\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n        for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n            if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {\n                continue;\n            }\n            FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();\n            Preconditions.checkNotNull(interfaceType);\n            boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);\n            foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n            if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {\n                // @override not present, but the property does override an interface\n                // property\n                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.toString()));\n            }\n            if (interfaceHasProperty) {\n                JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n                if (!propertyType.isSubtype(interfacePropType)) {\n                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.toString(), interfacePropType.toString(), propertyType.toString()));\n                }\n            }\n        }\n    }\n    if (!declaredOverride && !superClassHasProperty) {\n        // nothing to do here, it's just a plain new property\n        return;\n    }\n    JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;\n    if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) {\n        // @override not present, but the property does override a superclass\n        // property\n        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));\n    }\n    if (!declaredOverride) {\n        // there's no @override to check\n        return;\n    }\n    // @override is present and we have to check that it is ok\n    if (superClassHasProperty) {\n        // there is a superclass implementation\n        JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n        if (!propertyType.isSubtype(superClassPropType)) {\n            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n        }\n    } else if (!foundInterfaceProperty) {\n        // there is no superclass nor interface implementation\n        compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString()));\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n+++ com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n@@ -20,12 +20,12 @@\n             if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {\n                 // @override not present, but the property does override an interface\n                 // property\n-                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));\n+                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.toString()));\n             }\n             if (interfaceHasProperty) {\n                 JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n-                if (!propertyType.canAssignTo(interfacePropType)) {\n-                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n+                if (!propertyType.isSubtype(interfacePropType)) {\n+                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.toString(), interfacePropType.toString(), propertyType.toString()));\n                 }\n             }\n         }\n@@ -48,7 +48,7 @@\n     if (superClassHasProperty) {\n         // there is a superclass implementation\n         JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n-        if (!propertyType.canAssignTo(superClassPropType)) {\n+        if (!propertyType.isSubtype(superClassPropType)) {\n             compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n         }\n     } else if (!foundInterfaceProperty) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private void checkDeclaredPropertyInheritance(NodeTraversal t, Node n, FunctionType ctorType, String propertyName, JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n        return;\n    }\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null && superClass.getPrototype().hasProperty(propertyName);\n    boolean declaredOverride = info != null && info.isOverride();\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n        for (JSType implementedInterface : ctorType.getImplementedInterfaces()) {\n            if (implementedInterface.isUnknownType() || implementedInterface.isEmptyType()) {\n                continue;\n            }\n            FunctionType interfaceType = implementedInterface.toObjectType().getConstructor();\n            Preconditions.checkNotNull(interfaceType);\n            boolean interfaceHasProperty = interfaceType.getPrototype().hasProperty(propertyName);\n            foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n            if (reportMissingOverride.isOn() && !declaredOverride && interfaceHasProperty) {\n                // @override not present, but the property does override an interface\n                // property\n                compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_INTERFACE_PROPERTY, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString()));\n            }\n            if (interfaceHasProperty) {\n                JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n                if (!propertyType.getDisplayName().equals(interfacePropType.getDisplayName()) && !propertyType.canAssignTo(interfacePropType)) {\n                    compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n                }\n            }\n        }\n    }\n    if (!declaredOverride && !superClassHasProperty) {\n        // nothing to do here, it's just a plain new property\n        return;\n    }\n    JSType topInstanceType = superClassHasProperty ? superClass.getTopMostDefiningType(propertyName) : null;\n    if (reportMissingOverride.isOn() && ctorType.isConstructor() && !declaredOverride && superClassHasProperty) {\n        // @override not present, but the property does override a superclass\n        // property\n        compiler.report(t.makeError(n, reportMissingOverride, HIDDEN_SUPERCLASS_PROPERTY, propertyName, topInstanceType.toString()));\n    }\n    if (!declaredOverride) {\n        // there's no @override to check\n        return;\n    }\n    // @override is present and we have to check that it is ok\n    if (superClassHasProperty) {\n        // there is a superclass implementation\n        JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n        if (!propertyType.getDisplayName().equals(superClassPropType.getDisplayName()) && !propertyType.canAssignTo(superClassPropType)) {\n            compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n        }\n    } else if (!foundInterfaceProperty) {\n        // there is no superclass nor interface implementation\n        compiler.report(t.makeError(n, UNKNOWN_OVERRIDE, propertyName, ctorType.getInstanceType().toString()));\n    }\n}", "diff": "--- com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n+++ com/google/javascript/jscomp/TypeCheck.java@checkDeclaredPropertyInheritance\n@@ -24,7 +24,7 @@\n             }\n             if (interfaceHasProperty) {\n                 JSType interfacePropType = interfaceType.getPrototype().getPropertyType(propertyName);\n-                if (!propertyType.canAssignTo(interfacePropType)) {\n+                if (!propertyType.getDisplayName().equals(interfacePropType.getDisplayName()) && !propertyType.canAssignTo(interfacePropType)) {\n                     compiler.report(t.makeError(n, HIDDEN_INTERFACE_PROPERTY_MISMATCH, propertyName, interfaceType.getTopMostDefiningType(propertyName).toString(), interfacePropType.toString(), propertyType.toString()));\n                 }\n             }\n@@ -48,7 +48,7 @@\n     if (superClassHasProperty) {\n         // there is a superclass implementation\n         JSType superClassPropType = superClass.getPrototype().getPropertyType(propertyName);\n-        if (!propertyType.canAssignTo(superClassPropType)) {\n+        if (!propertyType.getDisplayName().equals(superClassPropType.getDisplayName()) && !propertyType.canAssignTo(superClassPropType)) {\n             compiler.report(t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH, propertyName, topInstanceType.toString(), superClassPropType.toString(), propertyType.toString()));\n         }\n     } else if (!foundInterfaceProperty) {\n", "finish_reason": "stop", "valid": false, "num": 1}]