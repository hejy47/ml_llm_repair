[{"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (IllegalArgumentException iae) {\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n    }\n    if (deser == null) {\n        return null;\n    }\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n                if (deser instanceof ResolvableDeserializer) {\n        ((ResolvableDeserializer) deser).resolve(ctxt);\n    }\n    if (addToCache) {\n        _cachedDeserializers.put(type, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -13,9 +13,7 @@\n         // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n     boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n                 if (deser instanceof ResolvableDeserializer) {\n-        _incompleteDeserializers.put(type, deser);\n         ((ResolvableDeserializer) deser).resolve(ctxt);\n-        _incompleteDeserializers.remove(type);\n     }\n     if (addToCache) {\n         _cachedDeserializers.put(type, deser);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (IllegalArgumentException iae) {\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n    }\n    if (deser == null) {\n        return null;\n    }\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n    if (addToCache) {\n        synchronized (this) {\n            if (_cachedDeserializers == null) {\n                _cachedDeserializers = new ConcurrentHashMap<>();\n            } else {\n                JsonDeserializer<Object> old = _cachedDeserializers.get(type);\n                if (old != null) {\n                    deser = old;\n                }\n            }\n            if (deser instanceof ResolvableDeserializer) {\n                _incompleteDeserializers.put(type, deser);\n                ((ResolvableDeserializer) deser).resolve(ctxt);\n                _incompleteDeserializers.remove(type);\n            }\n            _cachedDeserializers.put(type, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -12,13 +12,23 @@\n     }\n         // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n     boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n-                if (deser instanceof ResolvableDeserializer) {\n-        _incompleteDeserializers.put(type, deser);\n-        ((ResolvableDeserializer) deser).resolve(ctxt);\n-        _incompleteDeserializers.remove(type);\n-    }\n     if (addToCache) {\n-        _cachedDeserializers.put(type, deser);\n+        synchronized (this) {\n+            if (_cachedDeserializers == null) {\n+                _cachedDeserializers = new ConcurrentHashMap<>();\n+            } else {\n+                JsonDeserializer<Object> old = _cachedDeserializers.get(type);\n+                if (old != null) {\n+                    deser = old;\n+                }\n+            }\n+            if (deser instanceof ResolvableDeserializer) {\n+                _incompleteDeserializers.put(type, deser);\n+                ((ResolvableDeserializer) deser).resolve(ctxt);\n+                _incompleteDeserializers.remove(type);\n+            }\n+            _cachedDeserializers.put(type, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n        JsonDeserializer<Object> deser;\n        try {\n            deser = _createDeserializer(ctxt, factory, type);\n        } catch (IllegalArgumentException iae) {\n            // We better only expose checked exceptions, since those\n            // are what caller is expected to handle\n            throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n        }\n        if (deser == null) {\n            return null;\n        }\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n        boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n                if (deser instanceof ResolvableDeserializer) {\n            _incompleteDeserializers.put(type, deser);\n            ((ResolvableDeserializer) deser).resolve(ctxt);\n            _incompleteDeserializers.remove(type);\n        }\n        if (addToCache && type.getRawClass() != Object.class) {\n            synchronized (_cachedDeserializers) {\n                _cachedDeserializers.put(type, deser);\n            }\n        }\n        return deser;\n    }", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (JsonMappingException jme) {   // Caught exception type changed to JsonMappingException\n        throw jme;  // Rethrow the caught JsonMappingException\n    } catch (RuntimeException re) {   // Added catch block for RuntimeException\n        throw JsonMappingException.from(ctxt, re.getMessage(), re);\n    }\n    if (deser == null) {\n        return null;\n    }\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n    if (deser instanceof ResolvableDeserializer) {\n        _incompleteDeserializers.put(type, deser);\n        ((ResolvableDeserializer) deser).resolve(ctxt);\n        _incompleteDeserializers.remove(type);\n    }\n    if (addToCache) {\n        _cachedDeserializers.put(type, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -2,17 +2,16 @@\n     JsonDeserializer<Object> deser;\n     try {\n         deser = _createDeserializer(ctxt, factory, type);\n-    } catch (IllegalArgumentException iae) {\n-        // We better only expose checked exceptions, since those\n-        // are what caller is expected to handle\n-        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n+    } catch (JsonMappingException jme) {   // Caught exception type changed to JsonMappingException\n+        throw jme;  // Rethrow the caught JsonMappingException\n+    } catch (RuntimeException re) {   // Added catch block for RuntimeException\n+        throw JsonMappingException.from(ctxt, re.getMessage(), re);\n     }\n     if (deser == null) {\n         return null;\n     }\n-        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n     boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n-                if (deser instanceof ResolvableDeserializer) {\n+    if (deser instanceof ResolvableDeserializer) {\n         _incompleteDeserializers.put(type, deser);\n         ((ResolvableDeserializer) deser).resolve(ctxt);\n         _incompleteDeserializers.remove(type);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (JsonMappingException jme) { // changed to catch JsonMappingException instead\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        throw jme; // propagate the JsonMappingException\n    }\n    if (deser == null) {\n        return null;\n    }\n    // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n    if (deser instanceof ResolvableDeserializer) {\n        _incompleteDeserializers.put(type, deser);\n        ((ResolvableDeserializer) deser).resolve(ctxt);\n        _incompleteDeserializers.remove(type);\n    }\n    if (addToCache) {\n        _cachedDeserializers.put(type, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -2,17 +2,17 @@\n     JsonDeserializer<Object> deser;\n     try {\n         deser = _createDeserializer(ctxt, factory, type);\n-    } catch (IllegalArgumentException iae) {\n+    } catch (JsonMappingException jme) { // changed to catch JsonMappingException instead\n         // We better only expose checked exceptions, since those\n         // are what caller is expected to handle\n-        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n+        throw jme; // propagate the JsonMappingException\n     }\n     if (deser == null) {\n         return null;\n     }\n-        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n+    // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n     boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n-                if (deser instanceof ResolvableDeserializer) {\n+    if (deser instanceof ResolvableDeserializer) {\n         _incompleteDeserializers.put(type, deser);\n         ((ResolvableDeserializer) deser).resolve(ctxt);\n         _incompleteDeserializers.remove(type);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (IllegalArgumentException iae) {\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n    }\n    if (deser == null) {\n        return null;\n    }\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n    if (addToCache) {\n        synchronized(_cachedDeserializers) {\n            // Double-check for race conditions\n            if (!_cachedDeserializers.containsKey(type)) {\n                _cachedDeserializers.put(type, deser);\n            }\n        }\n    }\n    if (deser instanceof ResolvableDeserializer) {\n        _incompleteDeserializers.put(type, deser);\n        ((ResolvableDeserializer) deser).resolve(ctxt);\n        _incompleteDeserializers.remove(type);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -12,13 +12,18 @@\n     }\n         // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n     boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n-                if (deser instanceof ResolvableDeserializer) {\n+    if (addToCache) {\n+        synchronized(_cachedDeserializers) {\n+            // Double-check for race conditions\n+            if (!_cachedDeserializers.containsKey(type)) {\n+                _cachedDeserializers.put(type, deser);\n+            }\n+        }\n+    }\n+    if (deser instanceof ResolvableDeserializer) {\n         _incompleteDeserializers.put(type, deser);\n         ((ResolvableDeserializer) deser).resolve(ctxt);\n         _incompleteDeserializers.remove(type);\n     }\n-    if (addToCache) {\n-        _cachedDeserializers.put(type, deser);\n-    }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (IllegalArgumentException iae) {\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n    }\n    if (deser == null) {\n        return null;\n    }\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n    if (deser instanceof ResolvableDeserializer) {\n        _incompleteDeserializers.put(type, deser);\n        ((ResolvableDeserializer) deser).resolve(ctxt);\n        _incompleteDeserializers.remove(type);\n    }\n    if (addToCache) {\n        synchronized(this) { // perform cache update under synchronized context\n            Map<JavaType, JsonDeserializer<Object>> copy = new HashMap<>(_cachedDeserializers);\n            copy.put(type, deser);\n            _cachedDeserializers = copy;\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -12,13 +12,17 @@\n     }\n         // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n     boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n-                if (deser instanceof ResolvableDeserializer) {\n+    if (deser instanceof ResolvableDeserializer) {\n         _incompleteDeserializers.put(type, deser);\n         ((ResolvableDeserializer) deser).resolve(ctxt);\n         _incompleteDeserializers.remove(type);\n     }\n     if (addToCache) {\n-        _cachedDeserializers.put(type, deser);\n+        synchronized(this) { // perform cache update under synchronized context\n+            Map<JavaType, JsonDeserializer<Object>> copy = new HashMap<>(_cachedDeserializers);\n+            copy.put(type, deser);\n+            _cachedDeserializers = copy;\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (IllegalArgumentException iae) {\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n    }\n    if (deser == null) {\n        return null;\n    }\n    // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n    if (deser instanceof ResolvableDeserializer) {\n        _incompleteDeserializers.put(type, deser);\n        try {\n            ((ResolvableDeserializer) deser).resolve(ctxt);\n        } catch (JsonMappingException e) {\n            // remove from incomplete cache if exception occurs during resolution\n            _incompleteDeserializers.remove(type);\n            throw e;\n        }\n        _incompleteDeserializers.remove(type);\n    }\n    if (addToCache) {\n        _cachedDeserializers.put(type, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -10,11 +10,17 @@\n     if (deser == null) {\n         return null;\n     }\n-        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n+    // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n     boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n-                if (deser instanceof ResolvableDeserializer) {\n+    if (deser instanceof ResolvableDeserializer) {\n         _incompleteDeserializers.put(type, deser);\n-        ((ResolvableDeserializer) deser).resolve(ctxt);\n+        try {\n+            ((ResolvableDeserializer) deser).resolve(ctxt);\n+        } catch (JsonMappingException e) {\n+            // remove from incomplete cache if exception occurs during resolution\n+            _incompleteDeserializers.remove(type);\n+            throw e;\n+        }\n         _incompleteDeserializers.remove(type);\n     }\n     if (addToCache) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (IllegalArgumentException iae) {\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n    }\n    if (deser == null) {\n        return null;\n    }\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n                if (deser instanceof ResolvableDeserializer) {\n        \n        // ADD THIS LINE: check if deserializer is incomplete before adding to map\n        if (!_incompleteDeserializers.containsKey(type)) {\n            _incompleteDeserializers.put(type, deser);\n            ((ResolvableDeserializer) deser).resolve(ctxt);\n            _incompleteDeserializers.remove(type);\n        }\n\n    }\n    if (addToCache) {\n        _cachedDeserializers.put(type, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -13,9 +13,14 @@\n         // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n     boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n                 if (deser instanceof ResolvableDeserializer) {\n-        _incompleteDeserializers.put(type, deser);\n-        ((ResolvableDeserializer) deser).resolve(ctxt);\n-        _incompleteDeserializers.remove(type);\n+        \n+        // ADD THIS LINE: check if deserializer is incomplete before adding to map\n+        if (!_incompleteDeserializers.containsKey(type)) {\n+            _incompleteDeserializers.put(type, deser);\n+            ((ResolvableDeserializer) deser).resolve(ctxt);\n+            _incompleteDeserializers.remove(type);\n+        }\n+\n     }\n     if (addToCache) {\n         _cachedDeserializers.put(type, deser);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (IllegalArgumentException iae) {\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n    }\n    if (deser == null) {\n        return null;\n    }\n    // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n    if (addToCache) {\n        _cachedDeserializers.put(type, deser);\n    }\n    if (deser instanceof ResolvableDeserializer) {\n        _incompleteDeserializers.put(type, deser);\n        ((ResolvableDeserializer) deser).resolve(ctxt);\n        _incompleteDeserializers.remove(type);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -10,15 +10,15 @@\n     if (deser == null) {\n         return null;\n     }\n-        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n+    // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n     boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n-                if (deser instanceof ResolvableDeserializer) {\n+    if (addToCache) {\n+        _cachedDeserializers.put(type, deser);\n+    }\n+    if (deser instanceof ResolvableDeserializer) {\n         _incompleteDeserializers.put(type, deser);\n         ((ResolvableDeserializer) deser).resolve(ctxt);\n         _incompleteDeserializers.remove(type);\n     }\n-    if (addToCache) {\n-        _cachedDeserializers.put(type, deser);\n-    }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (IllegalArgumentException iae) {\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n    }\n    if (deser == null) {\n        return null;\n    }\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n                if (deser instanceof ResolvableDeserializer) {\n        _incompleteDeserializers.put(type, deser);\n        ((ResolvableDeserializer) deser).resolve(ctxt);\n        _incompleteDeserializers.remove(type);\n    }\n    if (addToCache && !_incompleteDeserializers.containsKey(type)) { // add a check to avoid caching incomplete deserializers\n        _cachedDeserializers.put(type, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -17,7 +17,7 @@\n         ((ResolvableDeserializer) deser).resolve(ctxt);\n         _incompleteDeserializers.remove(type);\n     }\n-    if (addToCache) {\n+    if (addToCache && !_incompleteDeserializers.containsKey(type)) { // add a check to avoid caching incomplete deserializers\n         _cachedDeserializers.put(type, deser);\n     }\n     return deser;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (IllegalArgumentException iae) {\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n    }\n    if (deser == null) {\n        return null;\n    }\n    // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n    boolean addToCache = !_hasCustomHandlers(deser) && deser.isCachable();\n    if (deser instanceof ResolvableDeserializer) {\n        _incompleteDeserializers.put(type, deser);\n        ((ResolvableDeserializer) deser).resolve(ctxt);\n        _incompleteDeserializers.remove(type);\n    }\n    if (addToCache) {\n        _cachedDeserializers.put(type, deser);\n    }\n    return deser;\n}\n\nNote: The fix involves changing the method argument passed to the `_hasCustomHandlers` method from type to deser, since the method is actually looking for custom value deserializers and not custom type deserializers.", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -10,9 +10,9 @@\n     if (deser == null) {\n         return null;\n     }\n-        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n-    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n-                if (deser instanceof ResolvableDeserializer) {\n+    // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n+    boolean addToCache = !_hasCustomHandlers(deser) && deser.isCachable();\n+    if (deser instanceof ResolvableDeserializer) {\n         _incompleteDeserializers.put(type, deser);\n         ((ResolvableDeserializer) deser).resolve(ctxt);\n         _incompleteDeserializers.remove(type);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (IllegalArgumentException iae) {\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n    }\n    if (deser == null) {\n        return null;\n    }\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n    if (deser instanceof ResolvableDeserializer) {\n        _incompleteDeserializers.put(type, deser);\n        ((ResolvableDeserializer) deser).resolve(ctxt);\n        _incompleteDeserializers.remove(type);\n    }\n    if (addToCache) {\n        // Note: do not cache the deserializer if it's a custom serializer:\n        if (!(deser instanceof StdDeserializer)) {\n            return deser;\n        }\n        _cachedDeserializers.put(type, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -12,12 +12,16 @@\n     }\n         // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n     boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n-                if (deser instanceof ResolvableDeserializer) {\n+    if (deser instanceof ResolvableDeserializer) {\n         _incompleteDeserializers.put(type, deser);\n         ((ResolvableDeserializer) deser).resolve(ctxt);\n         _incompleteDeserializers.remove(type);\n     }\n     if (addToCache) {\n+        // Note: do not cache the deserializer if it's a custom serializer:\n+        if (!(deser instanceof StdDeserializer)) {\n+            return deser;\n+        }\n         _cachedDeserializers.put(type, deser);\n     }\n     return deser;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (JsonMappingException e) {\n        throw e;\n    } catch (Exception e) { // catch all exceptions\n        throw JsonMappingException.from(ctxt, e.getMessage(), e);\n    }\n    if (deser == null) {\n        return null;\n    }\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n    if (deser instanceof ResolvableDeserializer) {\n        _incompleteDeserializers.put(type, deser);\n        ((ResolvableDeserializer) deser).resolve(ctxt);\n        _incompleteDeserializers.remove(type);\n    }\n    if (addToCache) {\n        _cachedDeserializers.put(type, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -2,17 +2,16 @@\n     JsonDeserializer<Object> deser;\n     try {\n         deser = _createDeserializer(ctxt, factory, type);\n-    } catch (IllegalArgumentException iae) {\n-        // We better only expose checked exceptions, since those\n-        // are what caller is expected to handle\n-        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n+    } catch (JsonMappingException e) {\n+        throw e;\n+    } catch (Exception e) { // catch all exceptions\n+        throw JsonMappingException.from(ctxt, e.getMessage(), e);\n     }\n     if (deser == null) {\n         return null;\n     }\n-        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n     boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n-                if (deser instanceof ResolvableDeserializer) {\n+    if (deser instanceof ResolvableDeserializer) {\n         _incompleteDeserializers.put(type, deser);\n         ((ResolvableDeserializer) deser).resolve(ctxt);\n         _incompleteDeserializers.remove(type);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (IllegalArgumentException iae) {\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n    }\n    if (deser == null) {\n        return null;\n    }\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n                if (addToCache) {\n        // check if deser implements ResolvableDeserializer before caching\n        if (deser instanceof ResolvableDeserializer) {\n            _incompleteDeserializers.put(type, deser);\n            ((ResolvableDeserializer) deser).resolve(ctxt);\n            _incompleteDeserializers.remove(type);\n        }\n        _cachedDeserializers.put(type, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -12,12 +12,13 @@\n     }\n         // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n     boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n-                if (deser instanceof ResolvableDeserializer) {\n-        _incompleteDeserializers.put(type, deser);\n-        ((ResolvableDeserializer) deser).resolve(ctxt);\n-        _incompleteDeserializers.remove(type);\n-    }\n-    if (addToCache) {\n+                if (addToCache) {\n+        // check if deser implements ResolvableDeserializer before caching\n+        if (deser instanceof ResolvableDeserializer) {\n+            _incompleteDeserializers.put(type, deser);\n+            ((ResolvableDeserializer) deser).resolve(ctxt);\n+            _incompleteDeserializers.remove(type);\n+        }\n         _cachedDeserializers.put(type, deser);\n     }\n     return deser;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (IllegalArgumentException iae) {\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n    }\n    if (deser == null) {\n        return null;\n    }\n    // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n    if (!addToCache) {\n        return deser;\n    }\n    synchronized (_cachedDeserializers) { // Synchronize access to the cache\n        JsonDeserializer<Object> existing = _cachedDeserializers.get(type);\n        if (existing != null) {\n            return existing;\n        }\n        if (deser instanceof ResolvableDeserializer) {\n            _incompleteDeserializers.put(type, deser);\n            ((ResolvableDeserializer) deser).resolve(ctxt);\n            _incompleteDeserializers.remove(type);\n        }\n        _cachedDeserializers.put(type, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -10,14 +10,21 @@\n     if (deser == null) {\n         return null;\n     }\n-        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n+    // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n     boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n-                if (deser instanceof ResolvableDeserializer) {\n-        _incompleteDeserializers.put(type, deser);\n-        ((ResolvableDeserializer) deser).resolve(ctxt);\n-        _incompleteDeserializers.remove(type);\n+    if (!addToCache) {\n+        return deser;\n     }\n-    if (addToCache) {\n+    synchronized (_cachedDeserializers) { // Synchronize access to the cache\n+        JsonDeserializer<Object> existing = _cachedDeserializers.get(type);\n+        if (existing != null) {\n+            return existing;\n+        }\n+        if (deser instanceof ResolvableDeserializer) {\n+            _incompleteDeserializers.put(type, deser);\n+            ((ResolvableDeserializer) deser).resolve(ctxt);\n+            _incompleteDeserializers.remove(type);\n+        }\n         _cachedDeserializers.put(type, deser);\n     }\n     return deser;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (IllegalArgumentException iae) {\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n    }\n    if (deser == null) {\n        return null;\n    }\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n                if (deser instanceof ResolvableDeserializer) {\n        _incompleteDeserializers.put(type, deser);\n        ((ResolvableDeserializer) deser).resolve(ctxt);\n        _incompleteDeserializers.remove(type);\n    }\n    if (addToCache && !_hasCustomValueHandler(deser)) { // add a check for custom value deserializers\n        _cachedDeserializers.put(type, deser);\n    }\n    return deser;\n}\n\nprivate boolean _hasCustomValueHandler(JsonDeserializer<Object> deser) {\n    if (deser == null) {\n        return false;\n    }\n    JsonDeserializer<?> valueDeser = deser.getValueDeserializer();\n    if (valueDeser == null || valueDeser == deser) {\n        return false;\n    }\n    if (valueDeser.getClass().getClassLoader() != deser.getClass().getClassLoader()) {\n        return true; // if classloaders are different, then it's a custom value handler\n    }\n    if (valueDeser instanceof ResolvableDeserializer || valueDeser.isCachable()) {\n        return false; // regular deserializers that can be cached don't count\n    }\n    // check if value deserializer is part of the standard set of deserializers\n    Class<?> deserClass = deser.getClass();\n    while (deserClass != JsonDeserializer.class) {\n        deserClass = deserClass.getSuperclass();\n    }\n    Class<?> vdClass = valueDeser.getClass();\n    while (vdClass != JsonDeserializer.class) {\n        vdClass = vdClass.getSuperclass();\n    }\n    return deserClass != vdClass;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -17,7 +17,7 @@\n         ((ResolvableDeserializer) deser).resolve(ctxt);\n         _incompleteDeserializers.remove(type);\n     }\n-    if (addToCache) {\n+    if (addToCache && !_hasCustomValueHandler(deser)) { // add a check for custom value deserializers\n         _cachedDeserializers.put(type, deser);\n     }\n     return deser;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (IllegalArgumentException iae) {\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n    }\n    if (deser == null) {\n        return null;\n    }\n    // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n    if (deser instanceof ResolvableDeserializer) {\n        if (_incompleteDeserializers == null) {\n            _incompleteDeserializers = new ResolvableDeserializerMap();\n        }\n        _incompleteDeserializers.put(type, deser);\n        ((ResolvableDeserializer) deser).resolve(ctxt);\n        _incompleteDeserializers.remove(type);\n    }\n    if (addToCache) {\n        synchronized (_cachedDeserializers) {\n            _cachedDeserializers.put(type, deser);\n        }\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -10,15 +10,20 @@\n     if (deser == null) {\n         return null;\n     }\n-        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n+    // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n     boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n-                if (deser instanceof ResolvableDeserializer) {\n+    if (deser instanceof ResolvableDeserializer) {\n+        if (_incompleteDeserializers == null) {\n+            _incompleteDeserializers = new ResolvableDeserializerMap();\n+        }\n         _incompleteDeserializers.put(type, deser);\n         ((ResolvableDeserializer) deser).resolve(ctxt);\n         _incompleteDeserializers.remove(type);\n     }\n     if (addToCache) {\n-        _cachedDeserializers.put(type, deser);\n+        synchronized (_cachedDeserializers) {\n+            _cachedDeserializers.put(type, deser);\n+        }\n     }\n     return deser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (IllegalArgumentException iae) {\n        // We better only expose checked exceptions, since those\n        // are what caller is expected to handle\n        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n    }\n    if (deser == null) {\n        return null;\n    }\n        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n        if (deser instanceof ResolvableDeserializer) {\n            ResolvableDeserializer resolvable = (ResolvableDeserializer) deser;\n            resolvable.resolve(ctxt);\n        }\n    if (addToCache) {\n        _cachedDeserializers.put(type, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -12,11 +12,10 @@\n     }\n         // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n     boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n-                if (deser instanceof ResolvableDeserializer) {\n-        _incompleteDeserializers.put(type, deser);\n-        ((ResolvableDeserializer) deser).resolve(ctxt);\n-        _incompleteDeserializers.remove(type);\n-    }\n+        if (deser instanceof ResolvableDeserializer) {\n+            ResolvableDeserializer resolvable = (ResolvableDeserializer) deser;\n+            resolvable.resolve(ctxt);\n+        }\n     if (addToCache) {\n         _cachedDeserializers.put(type, deser);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException {\n    JsonDeserializer<Object> deser;\n    try {\n        deser = _createDeserializer(ctxt, factory, type);\n    } catch (JsonProcessingException e) {\n        String msg = String.format(\"Failed to deserialize %s: %s\", type, e.getMessage());\n        throw JsonMappingException.from(ctxt, msg, e);\n    }\n    if (deser == null) {\n        return null;\n    }\n    // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n    boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n    if (deser instanceof ResolvableDeserializer) {\n        _incompleteDeserializers.put(type, deser);\n        ((ResolvableDeserializer) deser).resolve(ctxt);\n        _incompleteDeserializers.remove(type);\n    }\n    if (addToCache) {\n        _cachedDeserializers.put(type, deser);\n    }\n    return deser;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n+++ com/fasterxml/jackson/databind/deser/DeserializerCache.java@_createAndCache2\n@@ -2,17 +2,16 @@\n     JsonDeserializer<Object> deser;\n     try {\n         deser = _createDeserializer(ctxt, factory, type);\n-    } catch (IllegalArgumentException iae) {\n-        // We better only expose checked exceptions, since those\n-        // are what caller is expected to handle\n-        throw JsonMappingException.from(ctxt, iae.getMessage(), iae);\n+    } catch (JsonProcessingException e) {\n+        String msg = String.format(\"Failed to deserialize %s: %s\", type, e.getMessage());\n+        throw JsonMappingException.from(ctxt, msg, e);\n     }\n     if (deser == null) {\n         return null;\n     }\n-        // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n+    // 27-Mar-2015, tatu: As per [databind#735], avoid caching types with custom value desers\n     boolean addToCache = !_hasCustomHandlers(type) && deser.isCachable();\n-                if (deser instanceof ResolvableDeserializer) {\n+    if (deser instanceof ResolvableDeserializer) {\n         _incompleteDeserializers.put(type, deser);\n         ((ResolvableDeserializer) deser).resolve(ctxt);\n         _incompleteDeserializers.remove(type);\n", "finish_reason": "stop", "valid": false, "num": 1}]