[{"output": "public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n    // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n    //    check if any generics info is added; and only then ask factory\n    //    to do translation when necessary\n    if (subClass.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = getTypeFactory().constructFromCanonical(subClass);\n        if (baseType.isTypeOrSuperTypeOf(t.getRawClass())) { // fixed condition\n            return t;\n        }\n    } else {\n        Class<?> cls;\n        try {\n            cls = getTypeFactory().findClass(subClass);\n        } catch (ClassNotFoundException e) {\n            // let caller handle this problem\n            return null;\n        } catch (Exception e) {\n            throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n        }\n        if (baseType.isTypeOrSuperTypeOf(cls)) {\n            return getTypeFactory().constructSpecializedType(baseType, cls);\n        }\n    }\n    throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n}", "diff": "--- com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n+++ com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n@@ -8,7 +8,7 @@\n         //    compatibility -- needed later anyway, and not doing so may open\n         //    security issues.\n         JavaType t = getTypeFactory().constructFromCanonical(subClass);\n-        if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n+        if (baseType.isTypeOrSuperTypeOf(t.getRawClass())) { // fixed condition\n             return t;\n         }\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n    // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n    //    check if any generics info is added; and only then ask factory\n    //    to do translation when necessary\n    if (subClass.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = getTypeFactory().constructFromCanonical(subClass);\n        if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n            return t;\n        }\n    } else {\n        Class<?> cls;\n        try {\n            cls = getTypeFactory().findClass(subClass);\n        } catch (ClassNotFoundException e) {\n            // let caller handle this problem\n            return null;\n        } catch (Exception e) {\n            throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n        }\n        if (baseType.isTypeOrSuperTypeOf(TypeFactory.defaultInstance().constructType(cls))) {\n            return getTypeFactory().constructSpecializedType(baseType, cls);\n        }\n    }\n    throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n}", "diff": "--- com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n+++ com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n@@ -21,7 +21,7 @@\n         } catch (Exception e) {\n             throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n         }\n-        if (baseType.isTypeOrSuperTypeOf(cls)) {\n+        if (baseType.isTypeOrSuperTypeOf(TypeFactory.defaultInstance().constructType(cls))) {\n             return getTypeFactory().constructSpecializedType(baseType, cls);\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n    // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n    //    check if any generics info is added; and only then ask factory\n    //    to do translation when necessary\n    if (subClass.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = getTypeFactory().constructFromCanonical(subClass);\n        if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n            return t;\n        }\n    } else {\n        Class<?> cls;\n        try {\n            cls = getTypeFactory().findClass(subClass);\n        } catch (ClassNotFoundException e) {\n            // let caller handle this problem\n            return null;\n        } catch (Exception e) {\n            throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n        }\n        if (baseType.isTypeOrSuperTypeOf(getTypeFactory().constructType(cls))) {\n            return getTypeFactory().constructSpecializedType(baseType, cls);\n        }\n    }\n    throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n}\n\nThe fix involves constructing a JavaType object from the Class object obtained from the TypeFactory and verifying if the baseType is a super type of this constructed JavaType object.", "diff": "--- com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n+++ com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n@@ -21,7 +21,7 @@\n         } catch (Exception e) {\n             throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n         }\n-        if (baseType.isTypeOrSuperTypeOf(cls)) {\n+        if (baseType.isTypeOrSuperTypeOf(getTypeFactory().constructType(cls))) {\n             return getTypeFactory().constructSpecializedType(baseType, cls);\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n    // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n    //    check if any generics info is added; and only then ask factory\n    //    to do translation when necessary\n    if (subClass.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = getTypeFactory().constructFromCanonical(subClass);\n        if (baseType.isTypeOrSuperTypeOf(t)) { // Fixed: check if t is subtype of baseType\n            return t;\n        }\n    } else {\n        Class<?> cls;\n        try {\n            cls = getTypeFactory().findClass(subClass);\n        } catch (ClassNotFoundException e) {\n            // let caller handle this problem\n            return null;\n        } catch (Exception e) {\n            throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n        }\n        if (baseType.isTypeOrSuperTypeOf(cls)) {\n            return getTypeFactory().constructSpecializedType(baseType, cls);\n        }\n    }\n    throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n}", "diff": "--- com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n+++ com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n@@ -8,7 +8,7 @@\n         //    compatibility -- needed later anyway, and not doing so may open\n         //    security issues.\n         JavaType t = getTypeFactory().constructFromCanonical(subClass);\n-        if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n+        if (baseType.isTypeOrSuperTypeOf(t)) { // Fixed: check if t is subtype of baseType\n             return t;\n         }\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n    // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n    //    check if any generics info is added; and only then ask factory\n    //    to do translation when necessary\n    if (subClass.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = getTypeFactory().constructFromCanonical(subClass);\n        if (baseType.isTypeOrSuperTypeOf(t.getRawClass())) {\n            return t;\n        }\n    } else {\n        Class<?> cls;\n        try {\n            cls = getTypeFactory().findClass(subClass);\n        } catch (ClassNotFoundException e) {\n            // let caller handle this problem\n            return null;\n        } catch (Exception e) {\n            throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n        }\n        if (baseType.isTypeOrSuperTypeOf(cls)) {\n            return getTypeFactory().constructSpecializedType(baseType, cls);\n        }\n    }\n    throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n}", "diff": "--- com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n+++ com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n@@ -8,7 +8,7 @@\n         //    compatibility -- needed later anyway, and not doing so may open\n         //    security issues.\n         JavaType t = getTypeFactory().constructFromCanonical(subClass);\n-        if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n+        if (baseType.isTypeOrSuperTypeOf(t.getRawClass())) {\n             return t;\n         }\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 4}, {"output": "public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n    // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n    //    check if any generics info is added; and only then ask factory\n    //    to do translation when necessary\n    if (subClass.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = getTypeFactory().constructFromCanonical(subClass);\n        if (baseType.hasRawClass(t.getRawClass()) || baseType.isTypeOrSuperTypeOf(t)) {\n            return t;\n        }\n    } else {\n        Class<?> cls;\n        try {\n            cls = getTypeFactory().findClass(subClass);\n        } catch (ClassNotFoundException e) {\n            // let caller handle this problem\n            return null;\n        } catch (Exception e) {\n            throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n        }\n        if (baseType.hasRawClass(cls) || baseType.isTypeOrSuperTypeOf(cls)) {\n            return getTypeFactory().constructSpecializedType(baseType, cls);\n        }\n    }\n    throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n}", "diff": "--- com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n+++ com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n@@ -8,7 +8,7 @@\n         //    compatibility -- needed later anyway, and not doing so may open\n         //    security issues.\n         JavaType t = getTypeFactory().constructFromCanonical(subClass);\n-        if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n+        if (baseType.hasRawClass(t.getRawClass()) || baseType.isTypeOrSuperTypeOf(t)) {\n             return t;\n         }\n     } else {\n@@ -21,7 +21,7 @@\n         } catch (Exception e) {\n             throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n         }\n-        if (baseType.isTypeOrSuperTypeOf(cls)) {\n+        if (baseType.hasRawClass(cls) || baseType.isTypeOrSuperTypeOf(cls)) {\n             return getTypeFactory().constructSpecializedType(baseType, cls);\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n    // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n    // check if any generics info is added; and only then ask factory\n    // to do translation when necessary\n    if (subClass.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        // compatibility -- needed later anyway, and not doing so may open\n        // security issues.\n        JavaType t = getTypeFactory().constructFromCanonical(subClass);\n        if (baseType.hasRawClass(t.getRawClass()) || baseType.isPrototypeOf(t.getRawClass())) {\n            return t;\n        }\n    } else {\n        Class<?> cls;\n        try {\n            cls = getTypeFactory().findClass(subClass);\n        } catch (ClassNotFoundException e) {\n            // let caller handle this problem\n            return null;\n        } catch (Exception e) {\n            throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n        }\n        if (baseType.hasRawClass(cls) || baseType.isTypeOrSuperTypeOf(cls)) {\n            return getTypeFactory().constructSpecializedType(baseType, cls);\n        }\n    }\n    throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n}", "diff": "--- com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n+++ com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n@@ -1,14 +1,14 @@\n public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n     // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n-    //    check if any generics info is added; and only then ask factory\n-    //    to do translation when necessary\n+    // check if any generics info is added; and only then ask factory\n+    // to do translation when necessary\n     if (subClass.indexOf('<') > 0) {\n         // note: may want to try combining with specialization (esp for EnumMap)?\n         // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n-        //    compatibility -- needed later anyway, and not doing so may open\n-        //    security issues.\n+        // compatibility -- needed later anyway, and not doing so may open\n+        // security issues.\n         JavaType t = getTypeFactory().constructFromCanonical(subClass);\n-        if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n+        if (baseType.hasRawClass(t.getRawClass()) || baseType.isPrototypeOf(t.getRawClass())) {\n             return t;\n         }\n     } else {\n@@ -21,7 +21,7 @@\n         } catch (Exception e) {\n             throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n         }\n-        if (baseType.isTypeOrSuperTypeOf(cls)) {\n+        if (baseType.hasRawClass(cls) || baseType.isTypeOrSuperTypeOf(cls)) {\n             return getTypeFactory().constructSpecializedType(baseType, cls);\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n    // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n    //    check if any generics info is added; and only then ask factory\n    //    to do translation when necessary\n    if (subClass.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = getTypeFactory().constructFromCanonical(subClass);\n        if (baseType.hasRawClass(t.getRawClass())) {\n            return t;\n        }\n        // [databind#1735]: And sometimes if raw class is different, it still must be assignable\n        //    although simple comparison is not enough.\n        if (baseType.isTypeOrSuperTypeOf(t)) {\n            return t;\n        }\n    } else {\n        Class<?> cls;\n        try {\n            cls = getTypeFactory().findClass(subClass);\n        } catch (ClassNotFoundException e) {\n            // let caller handle this problem\n            return null;\n        } catch (Exception e) {\n            throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n        }\n        if (baseType.hasRawClass(cls)) {\n            return baseType;\n        }\n        if (baseType.isTypeOrSuperTypeOf(cls)) {\n            return getTypeFactory().constructSpecializedType(baseType, cls);\n        }\n    }\n    throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n}", "diff": "--- com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n+++ com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n@@ -8,7 +8,12 @@\n         //    compatibility -- needed later anyway, and not doing so may open\n         //    security issues.\n         JavaType t = getTypeFactory().constructFromCanonical(subClass);\n-        if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n+        if (baseType.hasRawClass(t.getRawClass())) {\n+            return t;\n+        }\n+        // [databind#1735]: And sometimes if raw class is different, it still must be assignable\n+        //    although simple comparison is not enough.\n+        if (baseType.isTypeOrSuperTypeOf(t)) {\n             return t;\n         }\n     } else {\n@@ -21,6 +26,9 @@\n         } catch (Exception e) {\n             throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n         }\n+        if (baseType.hasRawClass(cls)) {\n+            return baseType;\n+        }\n         if (baseType.isTypeOrSuperTypeOf(cls)) {\n             return getTypeFactory().constructSpecializedType(baseType, cls);\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n    // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n    //    check if any generics info is added; and only then ask factory\n    //    to do translation when necessary\n    if (subClass.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = getTypeFactory().constructFromCanonical(subClass);\n        if (baseType.isTypeOrSuperTypeOf(t.getRawClass())) { // Fixed line\n            return t;\n        }\n    } else {\n        Class<?> cls;\n        try {\n            cls = getTypeFactory().findClass(subClass);\n        } catch (ClassNotFoundException e) {\n            // let caller handle this problem\n            return null;\n        } catch (Exception e) {\n            throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n        }\n        if (baseType.isTypeOrSuperTypeOf(cls)) {\n            return getTypeFactory().constructSpecializedType(baseType, cls);\n        }\n    }\n    throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n}", "diff": "--- com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n+++ com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n@@ -8,7 +8,7 @@\n         //    compatibility -- needed later anyway, and not doing so may open\n         //    security issues.\n         JavaType t = getTypeFactory().constructFromCanonical(subClass);\n-        if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n+        if (baseType.isTypeOrSuperTypeOf(t.getRawClass())) { // Fixed line\n             return t;\n         }\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n    // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n    //    check if any generics info is added; and only then ask factory\n    //    to do translation when necessary\n    if (subClass.contains(\"<\")) { // Changed indexOf to contains\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = getTypeFactory().constructFromCanonical(subClass);\n        if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n            return t;\n        }\n    } else {\n        Class<?> cls;\n        try {\n            cls = getTypeFactory().findClass(subClass);\n        } catch (ClassNotFoundException e) {\n            // let caller handle this problem\n            return null;\n        } catch (Exception e) {\n            throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n        }\n        if (baseType.isTypeOrSuperTypeOf(cls)) {\n            return getTypeFactory().constructSpecializedType(baseType, cls);\n        }\n    }\n    throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n}", "diff": "--- com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n+++ com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n@@ -2,7 +2,7 @@\n     // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n     //    check if any generics info is added; and only then ask factory\n     //    to do translation when necessary\n-    if (subClass.indexOf('<') > 0) {\n+    if (subClass.contains(\"<\")) { // Changed indexOf to contains\n         // note: may want to try combining with specialization (esp for EnumMap)?\n         // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n         //    compatibility -- needed later anyway, and not doing so may open\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n    // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n    //    check if any generics info is added; and only then ask factory\n    //    to do translation when necessary\n    int genericIndex = subClass.indexOf('<');\n    if (genericIndex > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = getTypeFactory().constructFromCanonical(subClass);\n        if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n            return t;\n        }\n    } else {\n        Class<?> cls;\n        try {\n            cls = getTypeFactory().findClass(subClass);\n        } catch (ClassNotFoundException e) {\n            // let caller handle this problem\n            return null;\n        } catch (Exception e) {\n            throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n        }\n        if (baseType.isTypeOrSuperTypeOf(cls)) {\n            return getTypeFactory().constructSpecializedType(baseType, cls);\n        }\n    }\n    throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n}", "diff": "--- com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n+++ com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n@@ -2,7 +2,8 @@\n     // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n     //    check if any generics info is added; and only then ask factory\n     //    to do translation when necessary\n-    if (subClass.indexOf('<') > 0) {\n+    int genericIndex = subClass.indexOf('<');\n+    if (genericIndex > 0) {\n         // note: may want to try combining with specialization (esp for EnumMap)?\n         // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n         //    compatibility -- needed later anyway, and not doing so may open\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n    // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n    //    check if any generics info is added; and only then ask factory\n    //    to do translation when necessary\n    if (subClass.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = getTypeFactory().constructFromCanonical(subClass);\n        if (baseType.getRawClass().isAssignableFrom(t.getRawClass())) {\n            return t;\n        }\n    } else {\n        Class<?> cls;\n        try {\n            cls = getTypeFactory().findClass(subClass);\n        } catch (ClassNotFoundException e) {\n            // let caller handle this problem\n            return null;\n        } catch (Exception e) {\n            throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n        }\n        if (baseType.getRawClass().isAssignableFrom(cls)) {\n            return getTypeFactory().constructSpecializedType(baseType, cls);\n        }\n    }\n    throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n}", "diff": "--- com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n+++ com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n@@ -8,7 +8,7 @@\n         //    compatibility -- needed later anyway, and not doing so may open\n         //    security issues.\n         JavaType t = getTypeFactory().constructFromCanonical(subClass);\n-        if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n+        if (baseType.getRawClass().isAssignableFrom(t.getRawClass())) {\n             return t;\n         }\n     } else {\n@@ -21,7 +21,7 @@\n         } catch (Exception e) {\n             throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n         }\n-        if (baseType.isTypeOrSuperTypeOf(cls)) {\n+        if (baseType.getRawClass().isAssignableFrom(cls)) {\n             return getTypeFactory().constructSpecializedType(baseType, cls);\n         }\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n    // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n    //    check if any generics info is added; and only then ask factory\n    //    to do translation when necessary\n    if (subClass.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = getTypeFactory().constructFromCanonical(subClass);\n        if (t.isTypeOrSubTypeOf(baseType)) {\n            return t;\n        }\n    } else {\n        Class<?> cls;\n        try {\n            cls = getTypeFactory().findClass(subClass);\n        } catch (ClassNotFoundException e) {\n            // let caller handle this problem\n            return null;\n        } catch (Exception e) {\n            throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n        }\n        if (baseType.isTypeOrSuperTypeOf(cls)) {\n            return getTypeFactory().constructSpecializedType(baseType, cls);\n        }\n    }\n    throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n}", "diff": "--- com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n+++ com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n@@ -8,7 +8,7 @@\n         //    compatibility -- needed later anyway, and not doing so may open\n         //    security issues.\n         JavaType t = getTypeFactory().constructFromCanonical(subClass);\n-        if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n+        if (t.isTypeOrSubTypeOf(baseType)) {\n             return t;\n         }\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "The provided buggy function is already fixed and does not have any errors.", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n    // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n    //    check if any generics info is added; and only then ask factory\n    //    to do translation when necessary\n    if (subClass.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = getTypeFactory().constructFromCanonical(subClass);\n        if (baseType.isTypeOrSuperTypeOf(t.getRawClass())) { // change from isTypeOrSubTypeOf to isTypeOrSuperTypeOf\n            return t;\n        }\n    } else {\n        Class<?> cls;\n        try {\n            cls = getTypeFactory().findClass(subClass);\n        } catch (ClassNotFoundException e) {\n            // let caller handle this problem\n            return null;\n        } catch (Exception e) {\n            throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n        }\n        if (baseType.isTypeOrSuperTypeOf(cls)) {\n            return getTypeFactory().constructSpecializedType(baseType, cls);\n        }\n    }\n    throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n}", "diff": "--- com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n+++ com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n@@ -8,7 +8,7 @@\n         //    compatibility -- needed later anyway, and not doing so may open\n         //    security issues.\n         JavaType t = getTypeFactory().constructFromCanonical(subClass);\n-        if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n+        if (baseType.isTypeOrSuperTypeOf(t.getRawClass())) { // change from isTypeOrSubTypeOf to isTypeOrSuperTypeOf\n             return t;\n         }\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "public JavaType resolveSubType(JavaType baseType, String subClass) throws JsonMappingException {\n    // 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n    //    check if any generics info is added; and only then ask factory\n    //    to do translation when necessary\n    if (subClass.indexOf('<') > 0) {\n        // note: may want to try combining with specialization (esp for EnumMap)?\n        // 17-Aug-2017, tatu: As per [databind#1735] need to ensure assignment\n        //    compatibility -- needed later anyway, and not doing so may open\n        //    security issues.\n        JavaType t = getTypeFactory().constructFromCanonical(subClass);\n        if (baseType.isTypeOrSuperTypeOf(t.getRawClass())) { // <---FIXED LINE\n            return t;\n        }\n    } else {\n        Class<?> cls;\n        try {\n            cls = getTypeFactory().findClass(subClass);\n        } catch (ClassNotFoundException e) {\n            // let caller handle this problem\n            return null;\n        } catch (Exception e) {\n            throw invalidTypeIdException(baseType, subClass, String.format(\"problem: (%s) %s\", e.getClass().getName(), e.getMessage()));\n        }\n        if (baseType.isTypeOrSuperTypeOf(cls)) {\n            return getTypeFactory().constructSpecializedType(baseType, cls);\n        }\n    }\n    throw invalidTypeIdException(baseType, subClass, \"Not a subtype\");\n}", "diff": "--- com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n+++ com/fasterxml/jackson/databind/DatabindContext.java@resolveSubType\n@@ -8,7 +8,7 @@\n         //    compatibility -- needed later anyway, and not doing so may open\n         //    security issues.\n         JavaType t = getTypeFactory().constructFromCanonical(subClass);\n-        if (t.isTypeOrSubTypeOf(baseType.getRawClass())) {\n+        if (baseType.isTypeOrSuperTypeOf(t.getRawClass())) { // <---FIXED LINE\n             return t;\n         }\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}]