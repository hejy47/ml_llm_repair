[{"output": "@SuppressWarnings(\"unchecked\")\nprotected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n    // Creators, anyone? (to create builder itself)\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n    }\n    final DeserializationConfig config = ctxt.getConfig();\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then \"with methods\" for deserializing from JSON Object\n    addBeanProps(ctxt, builderDesc, builder);\n    addObjectIdReader(ctxt, builderDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, builderDesc, builder);\n    addInjectables(ctxt, builderDesc, builder);\n    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n    // and lastly, find build method to use:\n    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n    if (buildMethod != null) {\n        // note: can't yet throw error; may be given build method\n        if (config.canOverrideAccessModifiers()) {\n            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n    } else {\n        buildMethod = builderDesc.getFactoryMethod();\n        if (buildMethod == null) {\n            // Throw an exception since we can't build the builder\n            throw new IllegalArgumentException(\"No suitable constructor or factory method found to construct builder instance.\");\n        }\n    }\n    builder.setPOJOBuilder(buildMethod, builderConfig);\n    // this may give us more information...\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, builderDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -1,42 +1,54 @@\n @SuppressWarnings(\"unchecked\")\n-public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n-    // First: check what creators we can use, if any\n+protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n+    // Creators, anyone? (to create builder itself)\n     ValueInstantiator valueInstantiator;\n-        try {\n-        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n+    try {\n+        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n     }\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    final DeserializationConfig config = ctxt.getConfig();\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n     builder.setValueInstantiator(valueInstantiator);\n-    // And then setters for deserializing from JSON Object\n-    addBeanProps(ctxt, beanDesc, builder);\n-    addObjectIdReader(ctxt, beanDesc, builder);\n+    // And then \"with methods\" for deserializing from JSON Object\n+    addBeanProps(ctxt, builderDesc, builder);\n+    addObjectIdReader(ctxt, builderDesc, builder);\n     // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, beanDesc, builder);\n-    addInjectables(ctxt, beanDesc, builder);\n-    final DeserializationConfig config = ctxt.getConfig();\n+    addBackReferenceProperties(ctxt, builderDesc, builder);\n+    addInjectables(ctxt, builderDesc, builder);\n+    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n+    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n+    // and lastly, find build method to use:\n+    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n+    if (buildMethod != null) {\n+        // note: can't yet throw error; may be given build method\n+        if (config.canOverrideAccessModifiers()) {\n+            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+        }\n+    } else {\n+        buildMethod = builderDesc.getFactoryMethod();\n+        if (buildMethod == null) {\n+            // Throw an exception since we can't build the builder\n+            throw new IllegalArgumentException(\"No suitable constructor or factory method found to construct builder instance.\");\n+        }\n+    }\n+    builder.setPOJOBuilder(buildMethod, builderConfig);\n+    // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n+            builder = mod.updateBuilder(config, builderDesc, builder);\n         }\n     }\n-    JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n-        deserializer = builder.buildAbstract();\n-    } else {\n-        deserializer = builder.build();\n-    }\n-    // may have modifier(s) that wants to modify or replace serializer we just built\n-    // (note that `resolve()` and `createContextual()` called later on)\n+    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n+    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -30,6 +30,12 @@\n         if (config.canOverrideAccessModifiers()) {\n             ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n         }\n+    } else {\n+        buildMethod = builderDesc.getFactoryMethod();\n+        if (buildMethod == null) {\n+            // Throw an exception since we can't build the builder\n+            throw new IllegalArgumentException(\"No suitable constructor or factory method found to construct builder instance.\");\n+        }\n     }\n     builder.setPOJOBuilder(buildMethod, builderConfig);\n     // this may give us more information...\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\nprotected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n    // Creators, anyone? (to create builder itself)\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n    }\n    final DeserializationConfig config = ctxt.getConfig();\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then \"with methods\" for deserializing from JSON Object\n    addBeanProps(ctxt, builderDesc, builder);\n    addObjectIdReader(ctxt, builderDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, builderDesc, builder);\n    addInjectables(ctxt, builderDesc, builder);\n    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n    // and lastly, find build method to use:\n    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n    if (buildMethod != null) {\n        // note: can't yet throw error; may be given build method\n        if (config.canOverrideAccessModifiers()) {\n            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n    }\n    builder.setPOJOBuilder(buildMethod, builderConfig);\n    // this may give us more information...\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, builderDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -1,42 +1,48 @@\n @SuppressWarnings(\"unchecked\")\n-public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n-    // First: check what creators we can use, if any\n+protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n+    // Creators, anyone? (to create builder itself)\n     ValueInstantiator valueInstantiator;\n-        try {\n-        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n+    try {\n+        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n     }\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    final DeserializationConfig config = ctxt.getConfig();\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n     builder.setValueInstantiator(valueInstantiator);\n-    // And then setters for deserializing from JSON Object\n-    addBeanProps(ctxt, beanDesc, builder);\n-    addObjectIdReader(ctxt, beanDesc, builder);\n+    // And then \"with methods\" for deserializing from JSON Object\n+    addBeanProps(ctxt, builderDesc, builder);\n+    addObjectIdReader(ctxt, builderDesc, builder);\n     // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, beanDesc, builder);\n-    addInjectables(ctxt, beanDesc, builder);\n-    final DeserializationConfig config = ctxt.getConfig();\n+    addBackReferenceProperties(ctxt, builderDesc, builder);\n+    addInjectables(ctxt, builderDesc, builder);\n+    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n+    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n+    // and lastly, find build method to use:\n+    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n+    if (buildMethod != null) {\n+        // note: can't yet throw error; may be given build method\n+        if (config.canOverrideAccessModifiers()) {\n+            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+        }\n+    }\n+    builder.setPOJOBuilder(buildMethod, builderConfig);\n+    // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n+            builder = mod.updateBuilder(config, builderDesc, builder);\n         }\n     }\n-    JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n-        deserializer = builder.buildAbstract();\n-    } else {\n-        deserializer = builder.build();\n-    }\n-    // may have modifier(s) that wants to modify or replace serializer we just built\n-    // (note that `resolve()` and `createContextual()` called later on)\n+    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n+    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n", "finish_reason": "stop", "valid": false, "num": 5}, {"output": "@SuppressWarnings(\"unchecked\")\nprotected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n    // Creators, anyone? (to create builder itself)\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n    }\n    final DeserializationConfig config = ctxt.getConfig();\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then \"with methods\" for deserializing from JSON Object\n    addBeanProps(ctxt, builderDesc, builder);\n    addObjectIdReader(ctxt, builderDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, builderDesc, builder);\n    addInjectables(ctxt, builderDesc, builder);\n    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n    // and lastly, find build method to use:\n    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n    if (buildMethod != null) {\n        // note: can't yet throw error; may be given build method\n        if (config.canOverrideAccessModifiers()) {\n            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n        builder.setPOJOBuilder(buildMethod, builderConfig);\n    }\n    else if (builderConfig == null && !valueInstantiator.canCreateFromObjectWith()) {\n        // 01-May-2017, tatu: Need way to support \"Vanilla\" beans as builders\n        return null;\n    }\n    else {\n        // 01-May-2017, tatu: Need to allow extension to build\n        builder = builder.withCreatorVisibility(JsonCreator.Mode.ACCEPT_EMPTY);\n    }\n    // this may give us more information...\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, builderDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -1,42 +1,56 @@\n @SuppressWarnings(\"unchecked\")\n-public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n-    // First: check what creators we can use, if any\n+protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n+    // Creators, anyone? (to create builder itself)\n     ValueInstantiator valueInstantiator;\n-        try {\n-        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n+    try {\n+        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n     }\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    final DeserializationConfig config = ctxt.getConfig();\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n     builder.setValueInstantiator(valueInstantiator);\n-    // And then setters for deserializing from JSON Object\n-    addBeanProps(ctxt, beanDesc, builder);\n-    addObjectIdReader(ctxt, beanDesc, builder);\n+    // And then \"with methods\" for deserializing from JSON Object\n+    addBeanProps(ctxt, builderDesc, builder);\n+    addObjectIdReader(ctxt, builderDesc, builder);\n     // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, beanDesc, builder);\n-    addInjectables(ctxt, beanDesc, builder);\n-    final DeserializationConfig config = ctxt.getConfig();\n+    addBackReferenceProperties(ctxt, builderDesc, builder);\n+    addInjectables(ctxt, builderDesc, builder);\n+    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n+    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n+    // and lastly, find build method to use:\n+    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n+    if (buildMethod != null) {\n+        // note: can't yet throw error; may be given build method\n+        if (config.canOverrideAccessModifiers()) {\n+            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+        }\n+        builder.setPOJOBuilder(buildMethod, builderConfig);\n+    }\n+    else if (builderConfig == null && !valueInstantiator.canCreateFromObjectWith()) {\n+        // 01-May-2017, tatu: Need way to support \"Vanilla\" beans as builders\n+        return null;\n+    }\n+    else {\n+        // 01-May-2017, tatu: Need to allow extension to build\n+        builder = builder.withCreatorVisibility(JsonCreator.Mode.ACCEPT_EMPTY);\n+    }\n+    // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n+            builder = mod.updateBuilder(config, builderDesc, builder);\n         }\n     }\n-    JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n-        deserializer = builder.buildAbstract();\n-    } else {\n-        deserializer = builder.build();\n-    }\n-    // may have modifier(s) that wants to modify or replace serializer we just built\n-    // (note that `resolve()` and `createContextual()` called later on)\n+    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n+    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -30,8 +30,16 @@\n         if (config.canOverrideAccessModifiers()) {\n             ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n         }\n+        builder.setPOJOBuilder(buildMethod, builderConfig);\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n+    else if (builderConfig == null && !valueInstantiator.canCreateFromObjectWith()) {\n+        // 01-May-2017, tatu: Need way to support \"Vanilla\" beans as builders\n+        return null;\n+    }\n+    else {\n+        // 01-May-2017, tatu: Need to allow extension to build\n+        builder = builder.withCreatorVisibility(JsonCreator.Mode.ACCEPT_EMPTY);\n+    }\n     // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\nprotected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n    // Creators, anyone? (to create builder itself)\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n    }\n    final DeserializationConfig config = ctxt.getConfig();\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then \"with methods\" for deserializing from JSON Object\n    addBeanProps(ctxt, builderDesc, builder);\n    addObjectIdReader(ctxt, builderDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, builderDesc, builder);\n    addInjectables(ctxt, builderDesc, builder);\n    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n    // and lastly, find build method to use:\n    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n    if (buildMethod != null) {\n        // note: can't yet throw error; may be given build method\n        if (config.canOverrideAccessModifiers()) {\n            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n    } else if (builderConfig == null) {\n        // 27-Apr-2017, tatu: Need to handle, should actually have been caught earlier\n        //    but better safe than sorry\n        throw new IllegalArgumentException(\"Builder class \" + builderDesc.getBeanClass().getName()\n                + \" does not have build method '\" + buildMethodName + \"()'\");\n    }\n    if(builderConfig != null) {\n        builder.setPOJOBuilder(buildMethod, builderConfig);\n    }\n    // this may give us more information...\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, builderDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -1,42 +1,55 @@\n @SuppressWarnings(\"unchecked\")\n-public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n-    // First: check what creators we can use, if any\n+protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n+    // Creators, anyone? (to create builder itself)\n     ValueInstantiator valueInstantiator;\n-        try {\n-        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n+    try {\n+        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n     }\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    final DeserializationConfig config = ctxt.getConfig();\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n     builder.setValueInstantiator(valueInstantiator);\n-    // And then setters for deserializing from JSON Object\n-    addBeanProps(ctxt, beanDesc, builder);\n-    addObjectIdReader(ctxt, beanDesc, builder);\n+    // And then \"with methods\" for deserializing from JSON Object\n+    addBeanProps(ctxt, builderDesc, builder);\n+    addObjectIdReader(ctxt, builderDesc, builder);\n     // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, beanDesc, builder);\n-    addInjectables(ctxt, beanDesc, builder);\n-    final DeserializationConfig config = ctxt.getConfig();\n+    addBackReferenceProperties(ctxt, builderDesc, builder);\n+    addInjectables(ctxt, builderDesc, builder);\n+    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n+    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n+    // and lastly, find build method to use:\n+    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n+    if (buildMethod != null) {\n+        // note: can't yet throw error; may be given build method\n+        if (config.canOverrideAccessModifiers()) {\n+            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+        }\n+    } else if (builderConfig == null) {\n+        // 27-Apr-2017, tatu: Need to handle, should actually have been caught earlier\n+        //    but better safe than sorry\n+        throw new IllegalArgumentException(\"Builder class \" + builderDesc.getBeanClass().getName()\n+                + \" does not have build method '\" + buildMethodName + \"()'\");\n+    }\n+    if(builderConfig != null) {\n+        builder.setPOJOBuilder(buildMethod, builderConfig);\n+    }\n+    // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n+            builder = mod.updateBuilder(config, builderDesc, builder);\n         }\n     }\n-    JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n-        deserializer = builder.buildAbstract();\n-    } else {\n-        deserializer = builder.build();\n-    }\n-    // may have modifier(s) that wants to modify or replace serializer we just built\n-    // (note that `resolve()` and `createContextual()` called later on)\n+    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n+    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -30,8 +30,15 @@\n         if (config.canOverrideAccessModifiers()) {\n             ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n         }\n+    } else if (builderConfig == null) {\n+        // 27-Apr-2017, tatu: Need to handle, should actually have been caught earlier\n+        //    but better safe than sorry\n+        throw new IllegalArgumentException(\"Builder class \" + builderDesc.getBeanClass().getName()\n+                + \" does not have build method '\" + buildMethodName + \"()'\");\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n+    if(builderConfig != null) {\n+        builder.setPOJOBuilder(buildMethod, builderConfig);\n+    }\n     // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\nprotected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n    // Creators, anyone? (to create builder itself)\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n    }\n    final DeserializationConfig config = ctxt.getConfig();\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then \"with methods\" for deserializing from JSON Object\n    addBeanProps(ctxt, builderDesc, builder);\n    addObjectIdReader(ctxt, builderDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, builderDesc, builder);\n    addInjectables(ctxt, builderDesc, builder);\n    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n    // and lastly, find build method to use:\n    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n    if (buildMethod != null) {\n        // note: can't yet throw error; may be given build method\n        if (config.canOverrideAccessModifiers()) {\n            buildMethod.fixAccess(config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n    }\n    builder.setPOJOBuilder(buildMethod, builderConfig);\n    // this may give us more information...\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, builderDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -1,42 +1,48 @@\n @SuppressWarnings(\"unchecked\")\n-public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n-    // First: check what creators we can use, if any\n+protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n+    // Creators, anyone? (to create builder itself)\n     ValueInstantiator valueInstantiator;\n-        try {\n-        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n+    try {\n+        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n     }\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    final DeserializationConfig config = ctxt.getConfig();\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n     builder.setValueInstantiator(valueInstantiator);\n-    // And then setters for deserializing from JSON Object\n-    addBeanProps(ctxt, beanDesc, builder);\n-    addObjectIdReader(ctxt, beanDesc, builder);\n+    // And then \"with methods\" for deserializing from JSON Object\n+    addBeanProps(ctxt, builderDesc, builder);\n+    addObjectIdReader(ctxt, builderDesc, builder);\n     // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, beanDesc, builder);\n-    addInjectables(ctxt, beanDesc, builder);\n-    final DeserializationConfig config = ctxt.getConfig();\n+    addBackReferenceProperties(ctxt, builderDesc, builder);\n+    addInjectables(ctxt, builderDesc, builder);\n+    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n+    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n+    // and lastly, find build method to use:\n+    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n+    if (buildMethod != null) {\n+        // note: can't yet throw error; may be given build method\n+        if (config.canOverrideAccessModifiers()) {\n+            buildMethod.fixAccess(config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+        }\n+    }\n+    builder.setPOJOBuilder(buildMethod, builderConfig);\n+    // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n+            builder = mod.updateBuilder(config, builderDesc, builder);\n         }\n     }\n-    JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n-        deserializer = builder.buildAbstract();\n-    } else {\n-        deserializer = builder.build();\n-    }\n-    // may have modifier(s) that wants to modify or replace serializer we just built\n-    // (note that `resolve()` and `createContextual()` called later on)\n+    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n+    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -28,7 +28,7 @@\n     if (buildMethod != null) {\n         // note: can't yet throw error; may be given build method\n         if (config.canOverrideAccessModifiers()) {\n-            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+            buildMethod.fixAccess(config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n         }\n     }\n     builder.setPOJOBuilder(buildMethod, builderConfig);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\nprotected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n    // Creators, anyone? (to create builder itself)\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n    }\n    final DeserializationConfig config = ctxt.getConfig();\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then \"with methods\" for deserializing from JSON Object\n    addBeanProps(ctxt, builderDesc, builder);\n    addObjectIdReader(ctxt, builderDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, builderDesc, builder);\n    addInjectables(ctxt, builderDesc, builder);\n    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n    // and lastly, find build method to use:\n    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n    if (buildMethod != null) {\n        // note: can't yet throw error; may be given build method\n        if (config.canOverrideAccessModifiers()) {\n            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n        builder.setPOJOBuilder(buildMethod, builderConfig);\n    }\n    // this may give us more information...\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, builderDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -1,42 +1,48 @@\n @SuppressWarnings(\"unchecked\")\n-public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n-    // First: check what creators we can use, if any\n+protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n+    // Creators, anyone? (to create builder itself)\n     ValueInstantiator valueInstantiator;\n-        try {\n-        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n+    try {\n+        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n     }\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    final DeserializationConfig config = ctxt.getConfig();\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n     builder.setValueInstantiator(valueInstantiator);\n-    // And then setters for deserializing from JSON Object\n-    addBeanProps(ctxt, beanDesc, builder);\n-    addObjectIdReader(ctxt, beanDesc, builder);\n+    // And then \"with methods\" for deserializing from JSON Object\n+    addBeanProps(ctxt, builderDesc, builder);\n+    addObjectIdReader(ctxt, builderDesc, builder);\n     // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, beanDesc, builder);\n-    addInjectables(ctxt, beanDesc, builder);\n-    final DeserializationConfig config = ctxt.getConfig();\n+    addBackReferenceProperties(ctxt, builderDesc, builder);\n+    addInjectables(ctxt, builderDesc, builder);\n+    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n+    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n+    // and lastly, find build method to use:\n+    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n+    if (buildMethod != null) {\n+        // note: can't yet throw error; may be given build method\n+        if (config.canOverrideAccessModifiers()) {\n+            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+        }\n+        builder.setPOJOBuilder(buildMethod, builderConfig);\n+    }\n+    // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n+            builder = mod.updateBuilder(config, builderDesc, builder);\n         }\n     }\n-    JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n-        deserializer = builder.buildAbstract();\n-    } else {\n-        deserializer = builder.build();\n-    }\n-    // may have modifier(s) that wants to modify or replace serializer we just built\n-    // (note that `resolve()` and `createContextual()` called later on)\n+    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n+    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -30,8 +30,8 @@\n         if (config.canOverrideAccessModifiers()) {\n             ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n         }\n+        builder.setPOJOBuilder(buildMethod, builderConfig);\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n     // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@SuppressWarnings(\"unchecked\")\nprotected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n    // Creators, anyone? (to create builder itself)\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n    }\n    final DeserializationConfig config = ctxt.getConfig();\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then \"with methods\" for deserializing from JSON Object\n    addBeanProps(ctxt, builderDesc, builder);\n    addObjectIdReader(ctxt, builderDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, builderDesc, builder);\n    addInjectables(ctxt, builderDesc, builder);\n    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n    // and lastly, find build method to use:\n    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n    if (buildMethod != null) {\n        // note: can't yet throw error; may be given build method\n        if (config.canOverrideAccessModifiers()) {\n            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n    } else {\n        // New code added to handle if build method is not found\n        throw InvalidDefinitionException.from(ctxt.getParser(), \"Build method '\" + buildMethodName + \"' not found in \" + builderDesc.getBeanClass().getName(), builderDesc, null);\n    }\n    builder.setPOJOBuilder(buildMethod, builderConfig);\n    // this may give us more information...\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, builderDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -1,42 +1,51 @@\n @SuppressWarnings(\"unchecked\")\n-public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n-    // First: check what creators we can use, if any\n+protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n+    // Creators, anyone? (to create builder itself)\n     ValueInstantiator valueInstantiator;\n-        try {\n-        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n+    try {\n+        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n     }\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    final DeserializationConfig config = ctxt.getConfig();\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n     builder.setValueInstantiator(valueInstantiator);\n-    // And then setters for deserializing from JSON Object\n-    addBeanProps(ctxt, beanDesc, builder);\n-    addObjectIdReader(ctxt, beanDesc, builder);\n+    // And then \"with methods\" for deserializing from JSON Object\n+    addBeanProps(ctxt, builderDesc, builder);\n+    addObjectIdReader(ctxt, builderDesc, builder);\n     // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, beanDesc, builder);\n-    addInjectables(ctxt, beanDesc, builder);\n-    final DeserializationConfig config = ctxt.getConfig();\n+    addBackReferenceProperties(ctxt, builderDesc, builder);\n+    addInjectables(ctxt, builderDesc, builder);\n+    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n+    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n+    // and lastly, find build method to use:\n+    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n+    if (buildMethod != null) {\n+        // note: can't yet throw error; may be given build method\n+        if (config.canOverrideAccessModifiers()) {\n+            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+        }\n+    } else {\n+        // New code added to handle if build method is not found\n+        throw InvalidDefinitionException.from(ctxt.getParser(), \"Build method '\" + buildMethodName + \"' not found in \" + builderDesc.getBeanClass().getName(), builderDesc, null);\n+    }\n+    builder.setPOJOBuilder(buildMethod, builderConfig);\n+    // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n+            builder = mod.updateBuilder(config, builderDesc, builder);\n         }\n     }\n-    JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n-        deserializer = builder.buildAbstract();\n-    } else {\n-        deserializer = builder.build();\n-    }\n-    // may have modifier(s) that wants to modify or replace serializer we just built\n-    // (note that `resolve()` and `createContextual()` called later on)\n+    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n+    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -30,6 +30,9 @@\n         if (config.canOverrideAccessModifiers()) {\n             ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n         }\n+    } else {\n+        // New code added to handle if build method is not found\n+        throw InvalidDefinitionException.from(ctxt.getParser(), \"Build method '\" + buildMethodName + \"' not found in \" + builderDesc.getBeanClass().getName(), builderDesc, null);\n     }\n     builder.setPOJOBuilder(buildMethod, builderConfig);\n     // this may give us more information...\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\nprotected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n    // Creators, anyone? (to create builder itself)\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n    }\n    final DeserializationConfig config = ctxt.getConfig();\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then \"with methods\" for deserializing from JSON Object\n    addBeanProps(ctxt, builderDesc, builder);\n    addObjectIdReader(ctxt, builderDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, builderDesc, builder);\n    addInjectables(ctxt, builderDesc, builder);\n    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n    // and lastly, find build method to use:\n    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n    if (buildMethod != null) {\n        // note: can't yet throw error; may be given build method\n        if (config.canOverrideAccessModifiers()) {\n            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n        builder.setPOJOBuilder(buildMethod, builderConfig);\n    } else {\n        // If no build method found, use the default constructor\n        if (valueInstantiator.canCreateFromDefault()) {\n            builder.setPOJOBuilder(valueInstantiator, builderConfig);\n        } else {\n            throw new IllegalArgumentException(\"No suitable constructor found for type \" + builderDesc.getType());\n        }\n    }\n    // this may give us more information...\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, builderDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -1,42 +1,55 @@\n @SuppressWarnings(\"unchecked\")\n-public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n-    // First: check what creators we can use, if any\n+protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n+    // Creators, anyone? (to create builder itself)\n     ValueInstantiator valueInstantiator;\n-        try {\n-        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n+    try {\n+        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n     }\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    final DeserializationConfig config = ctxt.getConfig();\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n     builder.setValueInstantiator(valueInstantiator);\n-    // And then setters for deserializing from JSON Object\n-    addBeanProps(ctxt, beanDesc, builder);\n-    addObjectIdReader(ctxt, beanDesc, builder);\n+    // And then \"with methods\" for deserializing from JSON Object\n+    addBeanProps(ctxt, builderDesc, builder);\n+    addObjectIdReader(ctxt, builderDesc, builder);\n     // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, beanDesc, builder);\n-    addInjectables(ctxt, beanDesc, builder);\n-    final DeserializationConfig config = ctxt.getConfig();\n+    addBackReferenceProperties(ctxt, builderDesc, builder);\n+    addInjectables(ctxt, builderDesc, builder);\n+    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n+    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n+    // and lastly, find build method to use:\n+    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n+    if (buildMethod != null) {\n+        // note: can't yet throw error; may be given build method\n+        if (config.canOverrideAccessModifiers()) {\n+            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+        }\n+        builder.setPOJOBuilder(buildMethod, builderConfig);\n+    } else {\n+        // If no build method found, use the default constructor\n+        if (valueInstantiator.canCreateFromDefault()) {\n+            builder.setPOJOBuilder(valueInstantiator, builderConfig);\n+        } else {\n+            throw new IllegalArgumentException(\"No suitable constructor found for type \" + builderDesc.getType());\n+        }\n+    }\n+    // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n+            builder = mod.updateBuilder(config, builderDesc, builder);\n         }\n     }\n-    JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n-        deserializer = builder.buildAbstract();\n-    } else {\n-        deserializer = builder.build();\n-    }\n-    // may have modifier(s) that wants to modify or replace serializer we just built\n-    // (note that `resolve()` and `createContextual()` called later on)\n+    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n+    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -30,8 +30,15 @@\n         if (config.canOverrideAccessModifiers()) {\n             ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n         }\n+        builder.setPOJOBuilder(buildMethod, builderConfig);\n+    } else {\n+        // If no build method found, use the default constructor\n+        if (valueInstantiator.canCreateFromDefault()) {\n+            builder.setPOJOBuilder(valueInstantiator, builderConfig);\n+        } else {\n+            throw new IllegalArgumentException(\"No suitable constructor found for type \" + builderDesc.getType());\n+        }\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n     // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\nprotected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n    // Creators, anyone? (to create builder itself)\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n    }\n    final DeserializationConfig config = ctxt.getConfig();\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then \"with methods\" for deserializing from JSON Object\n    addBeanProps(ctxt, builderDesc, builder);\n    addObjectIdReader(ctxt, builderDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, builderDesc, builder);\n    addInjectables(ctxt, builderDesc, builder);\n    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n    // and lastly, find build method to use:\n    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n    if (buildMethod != null) {\n        // note: can't yet throw error; may be given build method\n        if (config.canOverrideAccessModifiers()) {\n            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n    } else {\n        buildMethod = builderDesc.getClassInfo().findMethod(\"build\", null);\n    }\n    builder.setPOJOBuilder(buildMethod, builderConfig);\n    // this may give us more information...\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, builderDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -1,42 +1,50 @@\n @SuppressWarnings(\"unchecked\")\n-public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n-    // First: check what creators we can use, if any\n+protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n+    // Creators, anyone? (to create builder itself)\n     ValueInstantiator valueInstantiator;\n-        try {\n-        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n+    try {\n+        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n     }\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    final DeserializationConfig config = ctxt.getConfig();\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n     builder.setValueInstantiator(valueInstantiator);\n-    // And then setters for deserializing from JSON Object\n-    addBeanProps(ctxt, beanDesc, builder);\n-    addObjectIdReader(ctxt, beanDesc, builder);\n+    // And then \"with methods\" for deserializing from JSON Object\n+    addBeanProps(ctxt, builderDesc, builder);\n+    addObjectIdReader(ctxt, builderDesc, builder);\n     // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, beanDesc, builder);\n-    addInjectables(ctxt, beanDesc, builder);\n-    final DeserializationConfig config = ctxt.getConfig();\n+    addBackReferenceProperties(ctxt, builderDesc, builder);\n+    addInjectables(ctxt, builderDesc, builder);\n+    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n+    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n+    // and lastly, find build method to use:\n+    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n+    if (buildMethod != null) {\n+        // note: can't yet throw error; may be given build method\n+        if (config.canOverrideAccessModifiers()) {\n+            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+        }\n+    } else {\n+        buildMethod = builderDesc.getClassInfo().findMethod(\"build\", null);\n+    }\n+    builder.setPOJOBuilder(buildMethod, builderConfig);\n+    // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n+            builder = mod.updateBuilder(config, builderDesc, builder);\n         }\n     }\n-    JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n-        deserializer = builder.buildAbstract();\n-    } else {\n-        deserializer = builder.build();\n-    }\n-    // may have modifier(s) that wants to modify or replace serializer we just built\n-    // (note that `resolve()` and `createContextual()` called later on)\n+    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n+    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -30,6 +30,8 @@\n         if (config.canOverrideAccessModifiers()) {\n             ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n         }\n+    } else {\n+        buildMethod = builderDesc.getClassInfo().findMethod(\"build\", null);\n     }\n     builder.setPOJOBuilder(buildMethod, builderConfig);\n     // this may give us more information...\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\nprotected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n    // Creators, anyone? (to create builder itself)\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n    }\n    final DeserializationConfig config = ctxt.getConfig();\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then \"with methods\" for deserializing from JSON Object\n    addBeanProps(ctxt, builderDesc, builder);\n    addObjectIdReader(ctxt, builderDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, builderDesc, builder);\n    addInjectables(ctxt, builderDesc, builder);\n    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n    // and lastly, find build method to use:\n    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n    if (buildMethod != null) {\n        // note: can't yet throw error; may be given build method\n        if (config.canOverrideAccessModifiers()) {\n            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n    } else {\n        throw new IllegalArgumentException(\"Builder class \" + builderDesc.getBeanClass().getName() + \" does not have build method '\" + buildMethodName + \"()'\");\n    }\n    builder.setPOJOBuilder(buildMethod, builderConfig);\n    // this may give us more information...\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, builderDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -1,42 +1,50 @@\n @SuppressWarnings(\"unchecked\")\n-public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n-    // First: check what creators we can use, if any\n+protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n+    // Creators, anyone? (to create builder itself)\n     ValueInstantiator valueInstantiator;\n-        try {\n-        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n+    try {\n+        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n     }\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    final DeserializationConfig config = ctxt.getConfig();\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n     builder.setValueInstantiator(valueInstantiator);\n-    // And then setters for deserializing from JSON Object\n-    addBeanProps(ctxt, beanDesc, builder);\n-    addObjectIdReader(ctxt, beanDesc, builder);\n+    // And then \"with methods\" for deserializing from JSON Object\n+    addBeanProps(ctxt, builderDesc, builder);\n+    addObjectIdReader(ctxt, builderDesc, builder);\n     // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, beanDesc, builder);\n-    addInjectables(ctxt, beanDesc, builder);\n-    final DeserializationConfig config = ctxt.getConfig();\n+    addBackReferenceProperties(ctxt, builderDesc, builder);\n+    addInjectables(ctxt, builderDesc, builder);\n+    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n+    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n+    // and lastly, find build method to use:\n+    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n+    if (buildMethod != null) {\n+        // note: can't yet throw error; may be given build method\n+        if (config.canOverrideAccessModifiers()) {\n+            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+        }\n+    } else {\n+        throw new IllegalArgumentException(\"Builder class \" + builderDesc.getBeanClass().getName() + \" does not have build method '\" + buildMethodName + \"()'\");\n+    }\n+    builder.setPOJOBuilder(buildMethod, builderConfig);\n+    // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n+            builder = mod.updateBuilder(config, builderDesc, builder);\n         }\n     }\n-    JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n-        deserializer = builder.buildAbstract();\n-    } else {\n-        deserializer = builder.build();\n-    }\n-    // may have modifier(s) that wants to modify or replace serializer we just built\n-    // (note that `resolve()` and `createContextual()` called later on)\n+    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n+    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -30,6 +30,8 @@\n         if (config.canOverrideAccessModifiers()) {\n             ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n         }\n+    } else {\n+        throw new IllegalArgumentException(\"Builder class \" + builderDesc.getBeanClass().getName() + \" does not have build method '\" + buildMethodName + \"()'\");\n     }\n     builder.setPOJOBuilder(buildMethod, builderConfig);\n     // this may give us more information...\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\nprotected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n    // Creators, anyone? (to create builder itself)\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n    }\n    final DeserializationConfig config = ctxt.getConfig();\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then \"with methods\" for deserializing from JSON Object\n    addBeanProps(ctxt, builderDesc, builder);\n    addObjectIdReader(ctxt, builderDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, builderDesc, builder);\n    addInjectables(ctxt, builderDesc, builder);\n    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n    // and lastly, find build method to use:\n    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n    if (buildMethod != null) {\n        // note: can't yet throw error; may be given build method\n        if (config.canOverrideAccessModifiers()) {\n            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n    } else if (builderConfig == null) {\n        throw new IllegalArgumentException(\"Builder class \" + builderDesc.getBeanClass().getName() + \" does not have build method '\" + buildMethodName + \"()'\");\n    }\n    builder.setPOJOBuilder(buildMethod, builderConfig);\n    // this may give us more information...\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, builderDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -1,42 +1,50 @@\n @SuppressWarnings(\"unchecked\")\n-public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n-    // First: check what creators we can use, if any\n+protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n+    // Creators, anyone? (to create builder itself)\n     ValueInstantiator valueInstantiator;\n-        try {\n-        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n+    try {\n+        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n     }\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    final DeserializationConfig config = ctxt.getConfig();\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n     builder.setValueInstantiator(valueInstantiator);\n-    // And then setters for deserializing from JSON Object\n-    addBeanProps(ctxt, beanDesc, builder);\n-    addObjectIdReader(ctxt, beanDesc, builder);\n+    // And then \"with methods\" for deserializing from JSON Object\n+    addBeanProps(ctxt, builderDesc, builder);\n+    addObjectIdReader(ctxt, builderDesc, builder);\n     // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, beanDesc, builder);\n-    addInjectables(ctxt, beanDesc, builder);\n-    final DeserializationConfig config = ctxt.getConfig();\n+    addBackReferenceProperties(ctxt, builderDesc, builder);\n+    addInjectables(ctxt, builderDesc, builder);\n+    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n+    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n+    // and lastly, find build method to use:\n+    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n+    if (buildMethod != null) {\n+        // note: can't yet throw error; may be given build method\n+        if (config.canOverrideAccessModifiers()) {\n+            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+        }\n+    } else if (builderConfig == null) {\n+        throw new IllegalArgumentException(\"Builder class \" + builderDesc.getBeanClass().getName() + \" does not have build method '\" + buildMethodName + \"()'\");\n+    }\n+    builder.setPOJOBuilder(buildMethod, builderConfig);\n+    // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n+            builder = mod.updateBuilder(config, builderDesc, builder);\n         }\n     }\n-    JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n-        deserializer = builder.buildAbstract();\n-    } else {\n-        deserializer = builder.build();\n-    }\n-    // may have modifier(s) that wants to modify or replace serializer we just built\n-    // (note that `resolve()` and `createContextual()` called later on)\n+    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n+    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -30,6 +30,8 @@\n         if (config.canOverrideAccessModifiers()) {\n             ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n         }\n+    } else if (builderConfig == null) {\n+        throw new IllegalArgumentException(\"Builder class \" + builderDesc.getBeanClass().getName() + \" does not have build method '\" + buildMethodName + \"()'\");\n     }\n     builder.setPOJOBuilder(buildMethod, builderConfig);\n     // this may give us more information...\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\nprotected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n    // Creators, anyone? (to create builder itself)\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n    }\n    final DeserializationConfig config = ctxt.getConfig();\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then \"with methods\" for deserializing from JSON Object\n    addBeanProps(ctxt, builderDesc, builder);\n    addObjectIdReader(ctxt, builderDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, builderDesc, builder);\n    addInjectables(ctxt, builderDesc, builder);\n    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n    // and lastly, find build method to use:\n    List<AnnotatedMethod> candidates = builderDesc.getFactoryMethods();\n    AnnotatedMethod buildMethod = null;\n    for (AnnotatedMethod candidate : candidates) {\n        if (buildMethodName.equals(candidate.getName()) && ctxt.getAnnotationIntrospector().hasCreatorAnnotation(candidate)) {\n            if (buildMethod != null) {\n                throw new IllegalArgumentException(\"Conflict: multiple 'build' methods defined \" +\n                        \"with alternative non-default names: \" + buildMethod + \" vs \" + candidate);\n            }\n            if (config.canOverrideAccessModifiers()) {\n                ClassUtil.checkAndFixAccess(candidate.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n            buildMethod = candidate;\n        }\n    }\n    builder.setPOJOBuilder(buildMethod, builderConfig);\n    // this may give us more information...\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, builderDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -1,42 +1,55 @@\n @SuppressWarnings(\"unchecked\")\n-public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n-    // First: check what creators we can use, if any\n+protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n+    // Creators, anyone? (to create builder itself)\n     ValueInstantiator valueInstantiator;\n-        try {\n-        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n+    try {\n+        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n     }\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    final DeserializationConfig config = ctxt.getConfig();\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n     builder.setValueInstantiator(valueInstantiator);\n-    // And then setters for deserializing from JSON Object\n-    addBeanProps(ctxt, beanDesc, builder);\n-    addObjectIdReader(ctxt, beanDesc, builder);\n+    // And then \"with methods\" for deserializing from JSON Object\n+    addBeanProps(ctxt, builderDesc, builder);\n+    addObjectIdReader(ctxt, builderDesc, builder);\n     // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, beanDesc, builder);\n-    addInjectables(ctxt, beanDesc, builder);\n-    final DeserializationConfig config = ctxt.getConfig();\n+    addBackReferenceProperties(ctxt, builderDesc, builder);\n+    addInjectables(ctxt, builderDesc, builder);\n+    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n+    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n+    // and lastly, find build method to use:\n+    List<AnnotatedMethod> candidates = builderDesc.getFactoryMethods();\n+    AnnotatedMethod buildMethod = null;\n+    for (AnnotatedMethod candidate : candidates) {\n+        if (buildMethodName.equals(candidate.getName()) && ctxt.getAnnotationIntrospector().hasCreatorAnnotation(candidate)) {\n+            if (buildMethod != null) {\n+                throw new IllegalArgumentException(\"Conflict: multiple 'build' methods defined \" +\n+                        \"with alternative non-default names: \" + buildMethod + \" vs \" + candidate);\n+            }\n+            if (config.canOverrideAccessModifiers()) {\n+                ClassUtil.checkAndFixAccess(candidate.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+            }\n+            buildMethod = candidate;\n+        }\n+    }\n+    builder.setPOJOBuilder(buildMethod, builderConfig);\n+    // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n+            builder = mod.updateBuilder(config, builderDesc, builder);\n         }\n     }\n-    JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n-        deserializer = builder.buildAbstract();\n-    } else {\n-        deserializer = builder.build();\n-    }\n-    // may have modifier(s) that wants to modify or replace serializer we just built\n-    // (note that `resolve()` and `createContextual()` called later on)\n+    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n+    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -24,11 +24,18 @@\n     JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n     final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n     // and lastly, find build method to use:\n-    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n-    if (buildMethod != null) {\n-        // note: can't yet throw error; may be given build method\n-        if (config.canOverrideAccessModifiers()) {\n-            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    List<AnnotatedMethod> candidates = builderDesc.getFactoryMethods();\n+    AnnotatedMethod buildMethod = null;\n+    for (AnnotatedMethod candidate : candidates) {\n+        if (buildMethodName.equals(candidate.getName()) && ctxt.getAnnotationIntrospector().hasCreatorAnnotation(candidate)) {\n+            if (buildMethod != null) {\n+                throw new IllegalArgumentException(\"Conflict: multiple 'build' methods defined \" +\n+                        \"with alternative non-default names: \" + buildMethod + \" vs \" + candidate);\n+            }\n+            if (config.canOverrideAccessModifiers()) {\n+                ClassUtil.checkAndFixAccess(candidate.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+            }\n+            buildMethod = candidate;\n         }\n     }\n     builder.setPOJOBuilder(buildMethod, builderConfig);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\nprotected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n    // Creators, anyone? (to create builder itself)\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n    }\n    final DeserializationConfig config = ctxt.getConfig();\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then \"with methods\" for deserializing from JSON Object\n    addBeanProps(ctxt, builderDesc, builder);\n\n    ObjectMapper mapper = (ObjectMapper) ctxt.getParser().getCodec();\n    builder.setObjectIdReader(ObjectIdReader.construct(builderDesc.getClassInfo(), builderDesc.getProperty(\"id\"), mapper.readerFor(JsonNode.class), builderDesc.getBeanPropertyDefinition(\"id\")));\n\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, builderDesc, builder);\n    addInjectables(ctxt, builderDesc, builder);\n    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n    // and lastly, find build method to use:\n    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n    if (buildMethod != null) {\n        // note: can't yet throw error; may be given build method\n        if (config.canOverrideAccessModifiers()) {\n            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n    }\n    builder.setPOJOBuilder(buildMethod, builderConfig);\n    // this may give us more information...\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, builderDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -1,42 +1,51 @@\n @SuppressWarnings(\"unchecked\")\n-public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n-    // First: check what creators we can use, if any\n+protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n+    // Creators, anyone? (to create builder itself)\n     ValueInstantiator valueInstantiator;\n-        try {\n-        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n+    try {\n+        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n     }\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    final DeserializationConfig config = ctxt.getConfig();\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n     builder.setValueInstantiator(valueInstantiator);\n-    // And then setters for deserializing from JSON Object\n-    addBeanProps(ctxt, beanDesc, builder);\n-    addObjectIdReader(ctxt, beanDesc, builder);\n+    // And then \"with methods\" for deserializing from JSON Object\n+    addBeanProps(ctxt, builderDesc, builder);\n+\n+    ObjectMapper mapper = (ObjectMapper) ctxt.getParser().getCodec();\n+    builder.setObjectIdReader(ObjectIdReader.construct(builderDesc.getClassInfo(), builderDesc.getProperty(\"id\"), mapper.readerFor(JsonNode.class), builderDesc.getBeanPropertyDefinition(\"id\")));\n+\n     // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, beanDesc, builder);\n-    addInjectables(ctxt, beanDesc, builder);\n-    final DeserializationConfig config = ctxt.getConfig();\n+    addBackReferenceProperties(ctxt, builderDesc, builder);\n+    addInjectables(ctxt, builderDesc, builder);\n+    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n+    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n+    // and lastly, find build method to use:\n+    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n+    if (buildMethod != null) {\n+        // note: can't yet throw error; may be given build method\n+        if (config.canOverrideAccessModifiers()) {\n+            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+        }\n+    }\n+    builder.setPOJOBuilder(buildMethod, builderConfig);\n+    // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n+            builder = mod.updateBuilder(config, builderDesc, builder);\n         }\n     }\n-    JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n-        deserializer = builder.buildAbstract();\n-    } else {\n-        deserializer = builder.build();\n-    }\n-    // may have modifier(s) that wants to modify or replace serializer we just built\n-    // (note that `resolve()` and `createContextual()` called later on)\n+    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n+    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -17,7 +17,10 @@\n     builder.setValueInstantiator(valueInstantiator);\n     // And then \"with methods\" for deserializing from JSON Object\n     addBeanProps(ctxt, builderDesc, builder);\n-    addObjectIdReader(ctxt, builderDesc, builder);\n+\n+    ObjectMapper mapper = (ObjectMapper) ctxt.getParser().getCodec();\n+    builder.setObjectIdReader(ObjectIdReader.construct(builderDesc.getClassInfo(), builderDesc.getProperty(\"id\"), mapper.readerFor(JsonNode.class), builderDesc.getBeanPropertyDefinition(\"id\")));\n+\n     // managed/back reference fields/setters need special handling... first part\n     addBackReferenceProperties(ctxt, builderDesc, builder);\n     addInjectables(ctxt, builderDesc, builder);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\nprotected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n    // Creators, anyone? (to create builder itself)\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n    }\n    final DeserializationConfig config = ctxt.getConfig();\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then \"with methods\" for deserializing from JSON Object\n    addBeanProps(ctxt, builderDesc, builder);\n    addObjectIdReader(ctxt, builderDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, builderDesc, builder);\n    addInjectables(ctxt, builderDesc, builder);\n    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n    // and lastly, find build method to use:\n    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n    if (buildMethod != null) {\n        // note: can't yet throw error; may be given build method\n        if (config.canOverrideAccessModifiers()) {\n            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n        builder.setPOJOBuilder(buildMethod, builderConfig);\n    } else {\n        // Need to throw error to indicate a build method should be specified\n        throw new JsonMappingException(ctxt.getParser(), \"Builder class \" + builderDesc.getBeanClass().getName() + \" does not have a build method '\" + buildMethodName + \"' specified\");\n    }\n    // this may give us more information...\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, builderDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -1,42 +1,51 @@\n @SuppressWarnings(\"unchecked\")\n-public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n-    // First: check what creators we can use, if any\n+protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n+    // Creators, anyone? (to create builder itself)\n     ValueInstantiator valueInstantiator;\n-        try {\n-        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n+    try {\n+        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n     }\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    final DeserializationConfig config = ctxt.getConfig();\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n     builder.setValueInstantiator(valueInstantiator);\n-    // And then setters for deserializing from JSON Object\n-    addBeanProps(ctxt, beanDesc, builder);\n-    addObjectIdReader(ctxt, beanDesc, builder);\n+    // And then \"with methods\" for deserializing from JSON Object\n+    addBeanProps(ctxt, builderDesc, builder);\n+    addObjectIdReader(ctxt, builderDesc, builder);\n     // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, beanDesc, builder);\n-    addInjectables(ctxt, beanDesc, builder);\n-    final DeserializationConfig config = ctxt.getConfig();\n+    addBackReferenceProperties(ctxt, builderDesc, builder);\n+    addInjectables(ctxt, builderDesc, builder);\n+    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n+    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n+    // and lastly, find build method to use:\n+    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n+    if (buildMethod != null) {\n+        // note: can't yet throw error; may be given build method\n+        if (config.canOverrideAccessModifiers()) {\n+            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+        }\n+        builder.setPOJOBuilder(buildMethod, builderConfig);\n+    } else {\n+        // Need to throw error to indicate a build method should be specified\n+        throw new JsonMappingException(ctxt.getParser(), \"Builder class \" + builderDesc.getBeanClass().getName() + \" does not have a build method '\" + buildMethodName + \"' specified\");\n+    }\n+    // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n+            builder = mod.updateBuilder(config, builderDesc, builder);\n         }\n     }\n-    JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n-        deserializer = builder.buildAbstract();\n-    } else {\n-        deserializer = builder.build();\n-    }\n-    // may have modifier(s) that wants to modify or replace serializer we just built\n-    // (note that `resolve()` and `createContextual()` called later on)\n+    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n+    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -30,8 +30,11 @@\n         if (config.canOverrideAccessModifiers()) {\n             ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n         }\n+        builder.setPOJOBuilder(buildMethod, builderConfig);\n+    } else {\n+        // Need to throw error to indicate a build method should be specified\n+        throw new JsonMappingException(ctxt.getParser(), \"Builder class \" + builderDesc.getBeanClass().getName() + \" does not have a build method '\" + buildMethodName + \"' specified\");\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n     // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\nprotected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n    // Creators, anyone? (to create builder itself)\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n    }\n    final DeserializationConfig config = ctxt.getConfig();\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then \"with methods\" for deserializing from JSON Object\n    addBeanProps(ctxt, builderDesc, builder);\n    addObjectIdReader(ctxt, builderDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, builderDesc, builder);\n    addInjectables(ctxt, builderDesc, builder);\n    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n    // and lastly, find build method to use:\n    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n    if (buildMethod != null) {\n        // note: can't yet throw error; may be given build method\n        if (config.canOverrideAccessModifiers()) {\n            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n        builder.setPOJOBuilder(buildMethod, builderConfig);\n    } else {\n        builder.setPOJOBuilder(new NoOpValueInstantiator(), builderConfig);\n    }\n    // this may give us more information...\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, builderDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -1,42 +1,50 @@\n @SuppressWarnings(\"unchecked\")\n-public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n-    // First: check what creators we can use, if any\n+protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n+    // Creators, anyone? (to create builder itself)\n     ValueInstantiator valueInstantiator;\n-        try {\n-        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n+    try {\n+        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n     }\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    final DeserializationConfig config = ctxt.getConfig();\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n     builder.setValueInstantiator(valueInstantiator);\n-    // And then setters for deserializing from JSON Object\n-    addBeanProps(ctxt, beanDesc, builder);\n-    addObjectIdReader(ctxt, beanDesc, builder);\n+    // And then \"with methods\" for deserializing from JSON Object\n+    addBeanProps(ctxt, builderDesc, builder);\n+    addObjectIdReader(ctxt, builderDesc, builder);\n     // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, beanDesc, builder);\n-    addInjectables(ctxt, beanDesc, builder);\n-    final DeserializationConfig config = ctxt.getConfig();\n+    addBackReferenceProperties(ctxt, builderDesc, builder);\n+    addInjectables(ctxt, builderDesc, builder);\n+    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n+    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n+    // and lastly, find build method to use:\n+    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n+    if (buildMethod != null) {\n+        // note: can't yet throw error; may be given build method\n+        if (config.canOverrideAccessModifiers()) {\n+            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+        }\n+        builder.setPOJOBuilder(buildMethod, builderConfig);\n+    } else {\n+        builder.setPOJOBuilder(new NoOpValueInstantiator(), builderConfig);\n+    }\n+    // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n+            builder = mod.updateBuilder(config, builderDesc, builder);\n         }\n     }\n-    JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n-        deserializer = builder.buildAbstract();\n-    } else {\n-        deserializer = builder.build();\n-    }\n-    // may have modifier(s) that wants to modify or replace serializer we just built\n-    // (note that `resolve()` and `createContextual()` called later on)\n+    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n+    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -30,8 +30,10 @@\n         if (config.canOverrideAccessModifiers()) {\n             ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n         }\n+        builder.setPOJOBuilder(buildMethod, builderConfig);\n+    } else {\n+        builder.setPOJOBuilder(new NoOpValueInstantiator(), builderConfig);\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n     // this may give us more information...\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n", "finish_reason": "stop", "valid": false, "num": 1}]