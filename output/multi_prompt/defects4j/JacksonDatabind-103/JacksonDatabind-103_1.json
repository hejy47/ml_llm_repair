[{"output": "@Override\npublic TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n    AnnotatedClass ac = bean.getClassInfo();\n    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n    // Ok: if there is no explicit type info handler, we may want to\n    // use a default. If so, config object knows what to use.\n    Collection<NamedType> subtypes = null;\n    if (b == null) {\n        b = config.getDefaultTyper(baseType);\n        if (b == null) {\n            return null;\n        }\n    } else {\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n    }\n    // May need to figure out default implementation, if none found yet\n    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n        JavaType defaultType = mapAbstractType(config, baseType);\n        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n            b = b.defaultImpl(defaultType.getRawClass());\n        }\n    }\n    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n    //    map to better type here\n    try {\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    } catch (IllegalArgumentException e0) {\n        InvalidTypeIdException e = InvalidTypeIdException.from((JsonParser) null, e0.getMessage(), baseType, null);\n        e.initCause(e0);\n        throw e;\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n@@ -28,7 +28,7 @@\n     try {\n         return b.buildTypeDeserializer(config, baseType, subtypes);\n     } catch (IllegalArgumentException e0) {\n-        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        InvalidTypeIdException e = InvalidTypeIdException.from((JsonParser) null, e0.getMessage(), baseType, null);\n         e.initCause(e0);\n         throw e;\n     }\n--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,35 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage());\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidTypeIdException e = InvalidTypeIdException.from((JsonParser) null, e0.getMessage(), baseType, null);\n+        e.initCause(e0);\n+        throw e;\n     }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n@@ -1,21 +1,35 @@\n @Override\n-public Object instantiateBean(boolean fixAccess) {\n-    AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n-    if (ac == null) {\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    if (fixAccess) {\n-        ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n     }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return ac.getAnnotated().newInstance();\n-    } catch (Exception e) {\n-        Throwable t = e;\n-        while (t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        ClassUtil.throwIfError(t);\n-        ClassUtil.throwIfRTE(t);\n-        throw new IllegalArgumentException(\"Failed to instantiate bean of type \" + _classInfo.getAnnotated().getName() + \": (\" + t.getClass().getName() + \") \" + t.getMessage(), t);\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidTypeIdException e = InvalidTypeIdException.from((JsonParser) null, e0.getMessage(), baseType, null);\n+        e.initCause(e0);\n+        throw e;\n     }\n }\n--- com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n+++ com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n@@ -1,16 +1,35 @@\n @Override\n-public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n-    if (filter == null) {\n-        return true;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    // should let filter decide what to do with nulls:\n-    // But just case, let's handle unexpected (from our perspective) problems explicitly\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return filter.equals(null);\n-    } catch (Throwable t) {\n-        String msg = String.format(\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\", filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n-        reportBadDefinition(filter.getClass(), msg, t);\n-        // never gets here\n-        return false;\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidTypeIdException e = InvalidTypeIdException.from((JsonParser) null, e0.getMessage(), baseType, null);\n+        e.initCause(e0);\n+        throw e;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n    AnnotatedClass ac = bean.getClassInfo();\n    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n    // Ok: if there is no explicit type info handler, we may want to\n    // use a default. If so, config object knows what to use.\n    Collection<NamedType> subtypes = null;\n    if (b == null) {\n        b = config.getDefaultTyper(baseType);\n        if (b == null) {\n            return null;\n        }\n    } else {\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n    }\n    // May need to figure out default implementation, if none found yet\n    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n        JavaType defaultType = mapAbstractType(config, baseType);\n        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n            b = b.defaultImpl(defaultType);\n        }\n    }\n    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n    //    map to better type here\n    try {\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    } catch (IllegalArgumentException e0) {\n        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n        e.initCause(e0);\n        throw e;\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n@@ -20,7 +20,7 @@\n     if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n         JavaType defaultType = mapAbstractType(config, baseType);\n         if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n-            b = b.defaultImpl(defaultType.getRawClass());\n+            b = b.defaultImpl(defaultType);\n         }\n     }\n     // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,35 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType);\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage());\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n@@ -1,21 +1,35 @@\n @Override\n-public Object instantiateBean(boolean fixAccess) {\n-    AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n-    if (ac == null) {\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    if (fixAccess) {\n-        ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType);\n+        }\n     }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return ac.getAnnotated().newInstance();\n-    } catch (Exception e) {\n-        Throwable t = e;\n-        while (t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        ClassUtil.throwIfError(t);\n-        ClassUtil.throwIfRTE(t);\n-        throw new IllegalArgumentException(\"Failed to instantiate bean of type \" + _classInfo.getAnnotated().getName() + \": (\" + t.getClass().getName() + \") \" + t.getMessage(), t);\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n }\n--- com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n+++ com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n@@ -1,16 +1,35 @@\n @Override\n-public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n-    if (filter == null) {\n-        return true;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    // should let filter decide what to do with nulls:\n-    // But just case, let's handle unexpected (from our perspective) problems explicitly\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType);\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return filter.equals(null);\n-    } catch (Throwable t) {\n-        String msg = String.format(\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\", filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n-        reportBadDefinition(filter.getClass(), msg, t);\n-        // never gets here\n-        return false;\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 4}, {"output": "@Override\npublic TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n    AnnotatedClass ac = bean.getClassInfo();\n    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n    // Ok: if there is no explicit type info handler, we may want to\n    // use a default. If so, config object knows what to use.\n    Collection<NamedType> subtypes = null;\n    if (b == null) {\n        b = config.getDefaultTyper(baseType);\n        if (b == null) {\n            return null;\n        }\n    } else {\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n    }\n    // May need to figure out default implementation, if none found yet\n    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n        JavaType defaultType = mapAbstractType(config, baseType);\n        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n            b = b.defaultImpl(defaultType.getRawClass());\n        }\n    }\n    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n    //    map to better type here\n    try {\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    } catch (IllegalArgumentException e0) {\n        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n        e.initCause(e0);\n        throw e;\n    } catch (IllegalStateException e1) { // added catch block for IllegalStateException\n        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e1.getMessage(), baseType);\n        e.initCause(e1);\n        throw e;\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n@@ -31,5 +31,9 @@\n         InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n         e.initCause(e0);\n         throw e;\n+    } catch (IllegalStateException e1) { // added catch block for IllegalStateException\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e1.getMessage(), baseType);\n+        e.initCause(e1);\n+        throw e;\n     }\n }\n--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,39 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage());\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (IllegalStateException e1) { // added catch block for IllegalStateException\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e1.getMessage(), baseType);\n+        e.initCause(e1);\n+        throw e;\n     }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n@@ -1,21 +1,39 @@\n @Override\n-public Object instantiateBean(boolean fixAccess) {\n-    AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n-    if (ac == null) {\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    if (fixAccess) {\n-        ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n     }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return ac.getAnnotated().newInstance();\n-    } catch (Exception e) {\n-        Throwable t = e;\n-        while (t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        ClassUtil.throwIfError(t);\n-        ClassUtil.throwIfRTE(t);\n-        throw new IllegalArgumentException(\"Failed to instantiate bean of type \" + _classInfo.getAnnotated().getName() + \": (\" + t.getClass().getName() + \") \" + t.getMessage(), t);\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (IllegalStateException e1) { // added catch block for IllegalStateException\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e1.getMessage(), baseType);\n+        e.initCause(e1);\n+        throw e;\n     }\n }\n--- com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n+++ com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n@@ -1,16 +1,39 @@\n @Override\n-public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n-    if (filter == null) {\n-        return true;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    // should let filter decide what to do with nulls:\n-    // But just case, let's handle unexpected (from our perspective) problems explicitly\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return filter.equals(null);\n-    } catch (Throwable t) {\n-        String msg = String.format(\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\", filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n-        reportBadDefinition(filter.getClass(), msg, t);\n-        // never gets here\n-        return false;\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (IllegalStateException e1) { // added catch block for IllegalStateException\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e1.getMessage(), baseType);\n+        e.initCause(e1);\n+        throw e;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n    AnnotatedClass ac = bean.getClassInfo();\n    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n\n    Collection<NamedType> subtypes = null;\n    if (b == null) {\n        b = config.getDefaultTyper(baseType);\n        if (b == null) {\n            return null;\n        }\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n    } else {\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n        // May need to figure out default implementation, if none found yet\n        // (note: check for abstract type is not 100% mandatory, more of an optimization)\n        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n            JavaType defaultType = mapAbstractType(config, baseType);\n            if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n                b = b.defaultImpl(defaultType.getRawClass());\n            }\n        }\n    }\n\n    try {\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    } catch (IllegalArgumentException e0) {\n        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n        e.initCause(e0);\n        throw e;\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n@@ -4,27 +4,26 @@\n     AnnotatedClass ac = bean.getClassInfo();\n     AnnotationIntrospector ai = config.getAnnotationIntrospector();\n     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n-    // Ok: if there is no explicit type info handler, we may want to\n-    // use a default. If so, config object knows what to use.\n+\n     Collection<NamedType> subtypes = null;\n     if (b == null) {\n         b = config.getDefaultTyper(baseType);\n         if (b == null) {\n             return null;\n         }\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n     } else {\n-        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n-    }\n-    // May need to figure out default implementation, if none found yet\n-    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n-    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n-        JavaType defaultType = mapAbstractType(config, baseType);\n-        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n-            b = b.defaultImpl(defaultType.getRawClass());\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n+        // May need to figure out default implementation, if none found yet\n+        // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+            JavaType defaultType = mapAbstractType(config, baseType);\n+            if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+                b = b.defaultImpl(defaultType.getRawClass());\n+            }\n         }\n     }\n-    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n-    //    map to better type here\n+\n     try {\n         return b.buildTypeDeserializer(config, baseType, subtypes);\n     } catch (IllegalArgumentException e0) {\n--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,34 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n+        // May need to figure out default implementation, if none found yet\n+        // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+            JavaType defaultType = mapAbstractType(config, baseType);\n+            if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+                b = b.defaultImpl(defaultType.getRawClass());\n+            }\n+        }\n     }\n+\n     try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage());\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n@@ -1,21 +1,34 @@\n @Override\n-public Object instantiateBean(boolean fixAccess) {\n-    AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n-    if (ac == null) {\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n+        // May need to figure out default implementation, if none found yet\n+        // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+            JavaType defaultType = mapAbstractType(config, baseType);\n+            if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+                b = b.defaultImpl(defaultType.getRawClass());\n+            }\n+        }\n     }\n-    if (fixAccess) {\n-        ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-    }\n+\n     try {\n-        return ac.getAnnotated().newInstance();\n-    } catch (Exception e) {\n-        Throwable t = e;\n-        while (t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        ClassUtil.throwIfError(t);\n-        ClassUtil.throwIfRTE(t);\n-        throw new IllegalArgumentException(\"Failed to instantiate bean of type \" + _classInfo.getAnnotated().getName() + \": (\" + t.getClass().getName() + \") \" + t.getMessage(), t);\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n }\n--- com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n+++ com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n@@ -1,16 +1,34 @@\n @Override\n-public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n-    if (filter == null) {\n-        return true;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n+        // May need to figure out default implementation, if none found yet\n+        // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+            JavaType defaultType = mapAbstractType(config, baseType);\n+            if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+                b = b.defaultImpl(defaultType.getRawClass());\n+            }\n+        }\n     }\n-    // should let filter decide what to do with nulls:\n-    // But just case, let's handle unexpected (from our perspective) problems explicitly\n+\n     try {\n-        return filter.equals(null);\n-    } catch (Throwable t) {\n-        String msg = String.format(\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\", filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n-        reportBadDefinition(filter.getClass(), msg, t);\n-        // never gets here\n-        return false;\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n    AnnotatedClass ac = bean.getClassInfo();\n    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n    Collection<NamedType> subtypes = null;\n    if (b == null) {\n        b = config.getDefaultTyper(baseType);\n        if (b == null) {\n            return null;\n        }\n    } else {\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n    }\n    if (b.getDefaultImpl() == null) {\n        JavaType defaultType = mapAbstractType(config, baseType);\n        if (defaultType != null && !defaultType.hasRawClass(baseType.getRawClass())) {\n            b = b.defaultImpl(defaultType.getRawClass());\n        }\n    }\n    try {\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    } catch (IllegalArgumentException e0) {\n        throw InvalidDefinitionException.from(config.getParser(), e0.getMessage(),\n                baseType, e0);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n@@ -4,8 +4,6 @@\n     AnnotatedClass ac = bean.getClassInfo();\n     AnnotationIntrospector ai = config.getAnnotationIntrospector();\n     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n-    // Ok: if there is no explicit type info handler, we may want to\n-    // use a default. If so, config object knows what to use.\n     Collection<NamedType> subtypes = null;\n     if (b == null) {\n         b = config.getDefaultTyper(baseType);\n@@ -15,21 +13,16 @@\n     } else {\n         subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    // May need to figure out default implementation, if none found yet\n-    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n-    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+    if (b.getDefaultImpl() == null) {\n         JavaType defaultType = mapAbstractType(config, baseType);\n-        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+        if (defaultType != null && !defaultType.hasRawClass(baseType.getRawClass())) {\n             b = b.defaultImpl(defaultType.getRawClass());\n         }\n     }\n-    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n-    //    map to better type here\n     try {\n         return b.buildTypeDeserializer(config, baseType, subtypes);\n     } catch (IllegalArgumentException e0) {\n-        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n-        e.initCause(e0);\n-        throw e;\n+        throw InvalidDefinitionException.from(config.getParser(), e0.getMessage(),\n+                baseType, e0);\n     }\n }\n--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,28 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n+    }\n+    if (b.getDefaultImpl() == null) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if (defaultType != null && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n     }\n     try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage());\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        throw InvalidDefinitionException.from(config.getParser(), e0.getMessage(),\n+                baseType, e0);\n     }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n@@ -1,21 +1,28 @@\n @Override\n-public Object instantiateBean(boolean fixAccess) {\n-    AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n-    if (ac == null) {\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    if (fixAccess) {\n-        ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    if (b.getDefaultImpl() == null) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if (defaultType != null && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n     }\n     try {\n-        return ac.getAnnotated().newInstance();\n-    } catch (Exception e) {\n-        Throwable t = e;\n-        while (t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        ClassUtil.throwIfError(t);\n-        ClassUtil.throwIfRTE(t);\n-        throw new IllegalArgumentException(\"Failed to instantiate bean of type \" + _classInfo.getAnnotated().getName() + \": (\" + t.getClass().getName() + \") \" + t.getMessage(), t);\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        throw InvalidDefinitionException.from(config.getParser(), e0.getMessage(),\n+                baseType, e0);\n     }\n }\n--- com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n+++ com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n@@ -1,16 +1,28 @@\n @Override\n-public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n-    if (filter == null) {\n-        return true;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    // should let filter decide what to do with nulls:\n-    // But just case, let's handle unexpected (from our perspective) problems explicitly\n+    if (b.getDefaultImpl() == null) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if (defaultType != null && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n     try {\n-        return filter.equals(null);\n-    } catch (Throwable t) {\n-        String msg = String.format(\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\", filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n-        reportBadDefinition(filter.getClass(), msg, t);\n-        // never gets here\n-        return false;\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        throw InvalidDefinitionException.from(config.getParser(), e0.getMessage(),\n+                baseType, e0);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n    AnnotatedClass ac = bean.getClassInfo();\n    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n    // Ok: if there is no explicit type info handler, we may want to\n    // use a default. If so, config object knows what to use.\n    Collection<NamedType> subtypes = null;\n    if (b == null) {\n        b = config.getDefaultTyper(baseType);\n        if (b == null) {\n            return null;\n        }\n    } else {\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n    }\n    // May need to figure out default implementation, if none found yet\n    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n        JavaType defaultType = mapAbstractType(config, baseType);\n        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n            b = b.defaultImpl(defaultType.getRawClass());\n        }\n    }\n    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n    //    map to better type here\n    try {\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    } catch (IllegalArgumentException e0) {\n        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n        e.initCause(e0);\n        throw e;\n    } catch (JsonMappingException e1) {\n        throw e1;\n    } catch (RuntimeException e2) {\n        throw JsonMappingException.from(config.getGenerator(), e2.getMessage(), e2);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n@@ -31,5 +31,9 @@\n         InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n         e.initCause(e0);\n         throw e;\n+    } catch (JsonMappingException e1) {\n+        throw e1;\n+    } catch (RuntimeException e2) {\n+        throw JsonMappingException.from(config.getGenerator(), e2.getMessage(), e2);\n     }\n }\n--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,39 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage());\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (JsonMappingException e1) {\n+        throw e1;\n+    } catch (RuntimeException e2) {\n+        throw JsonMappingException.from(config.getGenerator(), e2.getMessage(), e2);\n     }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n@@ -1,21 +1,39 @@\n @Override\n-public Object instantiateBean(boolean fixAccess) {\n-    AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n-    if (ac == null) {\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    if (fixAccess) {\n-        ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n     }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return ac.getAnnotated().newInstance();\n-    } catch (Exception e) {\n-        Throwable t = e;\n-        while (t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        ClassUtil.throwIfError(t);\n-        ClassUtil.throwIfRTE(t);\n-        throw new IllegalArgumentException(\"Failed to instantiate bean of type \" + _classInfo.getAnnotated().getName() + \": (\" + t.getClass().getName() + \") \" + t.getMessage(), t);\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (JsonMappingException e1) {\n+        throw e1;\n+    } catch (RuntimeException e2) {\n+        throw JsonMappingException.from(config.getGenerator(), e2.getMessage(), e2);\n     }\n }\n--- com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n+++ com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n@@ -1,16 +1,39 @@\n @Override\n-public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n-    if (filter == null) {\n-        return true;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    // should let filter decide what to do with nulls:\n-    // But just case, let's handle unexpected (from our perspective) problems explicitly\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return filter.equals(null);\n-    } catch (Throwable t) {\n-        String msg = String.format(\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\", filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n-        reportBadDefinition(filter.getClass(), msg, t);\n-        // never gets here\n-        return false;\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (JsonMappingException e1) {\n+        throw e1;\n+    } catch (RuntimeException e2) {\n+        throw JsonMappingException.from(config.getGenerator(), e2.getMessage(), e2);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n    AnnotatedClass ac = bean.getClassInfo();\n    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n    // Ok: if there is no explicit type info handler, we may want to\n    // use a default. If so, config object knows what to use.\n    Collection<NamedType> subtypes = null;\n    if (b == null) {\n        b = config.getDefaultTyper(baseType);\n        if (b == null) {\n            return null;\n        }\n    } else {\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n    }\n    // May need to figure out default implementation, if none found yet\n    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n        JavaType defaultType = mapAbstractType(config, baseType);\n        if (defaultType != null && !defaultType.hasRawClass(baseType.getRawClass())) {\n            b = b.defaultImpl(defaultType.getRawClass());\n        }\n    }\n    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n    //    map to better type here\n    try {\n        TypeDeserializer deser = b.buildTypeDeserializer(config, baseType, subtypes);\n        if (deser != null) { // Fixes Jackson Databind issue #1462\n            return deser;\n        }\n    } catch (IllegalArgumentException e0) {\n        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n        e.initCause(e0);\n        throw e;\n    }\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n@@ -19,17 +19,21 @@\n     // (note: check for abstract type is not 100% mandatory, more of an optimization)\n     if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n         JavaType defaultType = mapAbstractType(config, baseType);\n-        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+        if (defaultType != null && !defaultType.hasRawClass(baseType.getRawClass())) {\n             b = b.defaultImpl(defaultType.getRawClass());\n         }\n     }\n     // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n     //    map to better type here\n     try {\n-        return b.buildTypeDeserializer(config, baseType, subtypes);\n+        TypeDeserializer deser = b.buildTypeDeserializer(config, baseType, subtypes);\n+        if (deser != null) { // Fixes Jackson Databind issue #1462\n+            return deser;\n+        }\n     } catch (IllegalArgumentException e0) {\n         InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n         e.initCause(e0);\n         throw e;\n     }\n+    return null;\n }\n--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,39 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if (defaultType != null && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n+        TypeDeserializer deser = b.buildTypeDeserializer(config, baseType, subtypes);\n+        if (deser != null) { // Fixes Jackson Databind issue #1462\n+            return deser;\n         }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage());\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n@@ -1,21 +1,39 @@\n @Override\n-public Object instantiateBean(boolean fixAccess) {\n-    AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n-    if (ac == null) {\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    if (fixAccess) {\n-        ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if (defaultType != null && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n     }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return ac.getAnnotated().newInstance();\n-    } catch (Exception e) {\n-        Throwable t = e;\n-        while (t.getCause() != null) {\n-            t = t.getCause();\n+        TypeDeserializer deser = b.buildTypeDeserializer(config, baseType, subtypes);\n+        if (deser != null) { // Fixes Jackson Databind issue #1462\n+            return deser;\n         }\n-        ClassUtil.throwIfError(t);\n-        ClassUtil.throwIfRTE(t);\n-        throw new IllegalArgumentException(\"Failed to instantiate bean of type \" + _classInfo.getAnnotated().getName() + \": (\" + t.getClass().getName() + \") \" + t.getMessage(), t);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n+    return null;\n }\n--- com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n+++ com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n@@ -1,16 +1,39 @@\n @Override\n-public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n-    if (filter == null) {\n-        return true;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    // should let filter decide what to do with nulls:\n-    // But just case, let's handle unexpected (from our perspective) problems explicitly\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if (defaultType != null && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return filter.equals(null);\n-    } catch (Throwable t) {\n-        String msg = String.format(\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\", filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n-        reportBadDefinition(filter.getClass(), msg, t);\n-        // never gets here\n-        return false;\n+        TypeDeserializer deser = b.buildTypeDeserializer(config, baseType, subtypes);\n+        if (deser != null) { // Fixes Jackson Databind issue #1462\n+            return deser;\n+        }\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n+    return null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n    AnnotatedClass ac = bean.getClassInfo();\n    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n    // Ok: if there is no explicit type info handler, we may want to\n    // use a default. If so, config object knows what to use.\n    Collection<NamedType> subtypes = null;\n    if (b == null) {\n        b = config.getDefaultTyper(baseType);\n        if (b == null) {\n            return null;\n        }\n    } else {\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n    }\n    // May need to figure out default implementation, if none found yet\n    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n        JavaType defaultType = mapAbstractType(config, baseType);\n        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n            b = b.defaultImpl(defaultType.getRawClass());\n        }\n    }\n    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n    //    map to better type here\n    try {\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    } catch (IllegalArgumentException e0) {\n        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n        e.initCause(e0);\n        throw e;\n    } catch (JsonMappingException e1) {  // Added catch block to handle new exception\n        throw e1;\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n@@ -31,5 +31,7 @@\n         InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n         e.initCause(e0);\n         throw e;\n+    } catch (JsonMappingException e1) {  // Added catch block to handle new exception\n+        throw e1;\n     }\n }\n--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,37 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage());\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (JsonMappingException e1) {  // Added catch block to handle new exception\n+        throw e1;\n     }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n@@ -1,21 +1,37 @@\n @Override\n-public Object instantiateBean(boolean fixAccess) {\n-    AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n-    if (ac == null) {\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    if (fixAccess) {\n-        ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n     }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return ac.getAnnotated().newInstance();\n-    } catch (Exception e) {\n-        Throwable t = e;\n-        while (t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        ClassUtil.throwIfError(t);\n-        ClassUtil.throwIfRTE(t);\n-        throw new IllegalArgumentException(\"Failed to instantiate bean of type \" + _classInfo.getAnnotated().getName() + \": (\" + t.getClass().getName() + \") \" + t.getMessage(), t);\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (JsonMappingException e1) {  // Added catch block to handle new exception\n+        throw e1;\n     }\n }\n--- com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n+++ com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n@@ -1,16 +1,37 @@\n @Override\n-public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n-    if (filter == null) {\n-        return true;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    // should let filter decide what to do with nulls:\n-    // But just case, let's handle unexpected (from our perspective) problems explicitly\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return filter.equals(null);\n-    } catch (Throwable t) {\n-        String msg = String.format(\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\", filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n-        reportBadDefinition(filter.getClass(), msg, t);\n-        // never gets here\n-        return false;\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (JsonMappingException e1) {  // Added catch block to handle new exception\n+        throw e1;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n    AnnotatedClass ac = bean.getClassInfo();\n    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n    // Ok: if there is no explicit type info handler, we may want to\n    // use a default. If so, config object knows what to use.\n    Collection<NamedType> subtypes = null;\n    if (b == null) {\n        b = config.getDefaultTyper(baseType);\n        if (b == null) {\n            return null;\n        }\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n    } else {\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n    }\n    // May need to figure out default implementation, if none found yet\n    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n        JavaType defaultType = mapAbstractType(config, baseType);\n        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n            b = b.defaultImpl(defaultType.getRawClass());\n        }\n    }\n    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n    //    map to better type here\n    try {\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    } catch (IllegalArgumentException e0) {\n        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n        e.initCause(e0);\n        throw e;\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n@@ -12,8 +12,9 @@\n         if (b == null) {\n             return null;\n         }\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n     } else {\n-        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n     }\n     // May need to figure out default implementation, if none found yet\n     // (note: check for abstract type is not 100% mandatory, more of an optimization)\n--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,36 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n     }\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage());\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n@@ -1,21 +1,36 @@\n @Override\n-public Object instantiateBean(boolean fixAccess) {\n-    AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n-    if (ac == null) {\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n     }\n-    if (fixAccess) {\n-        ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n     }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return ac.getAnnotated().newInstance();\n-    } catch (Exception e) {\n-        Throwable t = e;\n-        while (t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        ClassUtil.throwIfError(t);\n-        ClassUtil.throwIfRTE(t);\n-        throw new IllegalArgumentException(\"Failed to instantiate bean of type \" + _classInfo.getAnnotated().getName() + \": (\" + t.getClass().getName() + \") \" + t.getMessage(), t);\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n }\n--- com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n+++ com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n@@ -1,16 +1,36 @@\n @Override\n-public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n-    if (filter == null) {\n-        return true;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac, b);\n     }\n-    // should let filter decide what to do with nulls:\n-    // But just case, let's handle unexpected (from our perspective) problems explicitly\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return filter.equals(null);\n-    } catch (Throwable t) {\n-        String msg = String.format(\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\", filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n-        reportBadDefinition(filter.getClass(), msg, t);\n-        // never gets here\n-        return false;\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n    AnnotatedClass ac = bean.getClassInfo();\n    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n    // Ok: if there is no explicit type info handler, we may want to\n    // use a default. If so, config object knows what to use.\n    Collection<NamedType> subtypes = null;\n    if (b == null) {\n        b = config.getDefaultTyper(baseType);\n        if (b == null) {\n            return null;\n        }\n    } else {\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n    }\n    // May need to figure out default implementation, if none found yet\n    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n        JavaType defaultType = mapAbstractType(config, baseType);\n        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n            b = b.defaultImpl(defaultType.getRawClass());\n        }\n    }\n    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n    //    map to better type here\n    try {\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    } catch (IllegalArgumentException e0) {\n        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n        e.initCause(e0);\n        throw e;\n    } catch (IllegalStateException e1) {\n        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e1.getMessage(), baseType);\n        e.initCause(e1);\n        throw e;\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n@@ -31,5 +31,9 @@\n         InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n         e.initCause(e0);\n         throw e;\n+    } catch (IllegalStateException e1) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e1.getMessage(), baseType);\n+        e.initCause(e1);\n+        throw e;\n     }\n }\n--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,39 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage());\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (IllegalStateException e1) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e1.getMessage(), baseType);\n+        e.initCause(e1);\n+        throw e;\n     }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n@@ -1,21 +1,39 @@\n @Override\n-public Object instantiateBean(boolean fixAccess) {\n-    AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n-    if (ac == null) {\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    if (fixAccess) {\n-        ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n     }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return ac.getAnnotated().newInstance();\n-    } catch (Exception e) {\n-        Throwable t = e;\n-        while (t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        ClassUtil.throwIfError(t);\n-        ClassUtil.throwIfRTE(t);\n-        throw new IllegalArgumentException(\"Failed to instantiate bean of type \" + _classInfo.getAnnotated().getName() + \": (\" + t.getClass().getName() + \") \" + t.getMessage(), t);\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (IllegalStateException e1) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e1.getMessage(), baseType);\n+        e.initCause(e1);\n+        throw e;\n     }\n }\n--- com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n+++ com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n@@ -1,16 +1,39 @@\n @Override\n-public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n-    if (filter == null) {\n-        return true;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    // should let filter decide what to do with nulls:\n-    // But just case, let's handle unexpected (from our perspective) problems explicitly\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return filter.equals(null);\n-    } catch (Throwable t) {\n-        String msg = String.format(\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\", filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n-        reportBadDefinition(filter.getClass(), msg, t);\n-        // never gets here\n-        return false;\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (IllegalStateException e1) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e1.getMessage(), baseType);\n+        e.initCause(e1);\n+        throw e;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n    AnnotatedClass ac = bean.getClassInfo();\n    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n    // Ok: if there is no explicit type info handler, we may want to\n    // use a default. If so, config object knows what to use.\n    Collection<NamedType> subtypes = null;\n    if (b == null) {\n        b = config.getDefaultTyper(baseType);\n        if (b == null) {\n            return null;\n        }\n    } else {\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n    }\n    // May need to figure out default implementation, if none found yet\n    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n        JavaType defaultType = mapAbstractType(config, baseType);\n        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n            b = b.defaultImpl(defaultType.getRawClass());\n        }\n    }\n    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n    //    map to better type here\n    try {\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    } catch (IllegalArgumentException e0) {\n        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n        e.initCause(e0);\n        throw e;\n    }\n    // Added return statement to handle all cases\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n@@ -32,4 +32,6 @@\n         e.initCause(e0);\n         throw e;\n     }\n+    // Added return statement to handle all cases\n+    return null;\n }\n--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,37 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage());\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n+    // Added return statement to handle all cases\n+    return null;\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n@@ -1,21 +1,37 @@\n @Override\n-public Object instantiateBean(boolean fixAccess) {\n-    AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n-    if (ac == null) {\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    if (fixAccess) {\n-        ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n     }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return ac.getAnnotated().newInstance();\n-    } catch (Exception e) {\n-        Throwable t = e;\n-        while (t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        ClassUtil.throwIfError(t);\n-        ClassUtil.throwIfRTE(t);\n-        throw new IllegalArgumentException(\"Failed to instantiate bean of type \" + _classInfo.getAnnotated().getName() + \": (\" + t.getClass().getName() + \") \" + t.getMessage(), t);\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n+    // Added return statement to handle all cases\n+    return null;\n }\n--- com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n+++ com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n@@ -1,16 +1,37 @@\n @Override\n-public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n-    if (filter == null) {\n-        return true;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    // should let filter decide what to do with nulls:\n-    // But just case, let's handle unexpected (from our perspective) problems explicitly\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return filter.equals(null);\n-    } catch (Throwable t) {\n-        String msg = String.format(\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\", filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n-        reportBadDefinition(filter.getClass(), msg, t);\n-        // never gets here\n-        return false;\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n+    // Added return statement to handle all cases\n+    return null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n    AnnotatedClass ac = bean.getClassInfo();\n    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n    // Ok: if there is no explicit type info handler, we may want to\n    // use a default. If so, config object knows what to use.\n    Collection<NamedType> subtypes = null;\n    if (b == null) {\n        b = config.getDefaultTyper(baseType);\n        if (b == null) {\n            return null;\n        }\n    } else {\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n    }\n    // May need to figure out default implementation, if none found yet\n    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n        JavaType defaultType = mapAbstractType(config, baseType);\n        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n            b = b.defaultImpl(defaultType.getRawClass());\n        }\n    }\n    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n    //    map to better type here\n    try {\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    } catch (IllegalArgumentException e0) {\n        throw InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n@@ -28,8 +28,6 @@\n     try {\n         return b.buildTypeDeserializer(config, baseType, subtypes);\n     } catch (IllegalArgumentException e0) {\n-        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n-        e.initCause(e0);\n-        throw e;\n+        throw InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n     }\n }\n--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,33 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage());\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        throw InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n     }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n@@ -1,21 +1,33 @@\n @Override\n-public Object instantiateBean(boolean fixAccess) {\n-    AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n-    if (ac == null) {\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    if (fixAccess) {\n-        ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n     }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return ac.getAnnotated().newInstance();\n-    } catch (Exception e) {\n-        Throwable t = e;\n-        while (t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        ClassUtil.throwIfError(t);\n-        ClassUtil.throwIfRTE(t);\n-        throw new IllegalArgumentException(\"Failed to instantiate bean of type \" + _classInfo.getAnnotated().getName() + \": (\" + t.getClass().getName() + \") \" + t.getMessage(), t);\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        throw InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n     }\n }\n--- com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n+++ com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n@@ -1,16 +1,33 @@\n @Override\n-public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n-    if (filter == null) {\n-        return true;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    // should let filter decide what to do with nulls:\n-    // But just case, let's handle unexpected (from our perspective) problems explicitly\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return filter.equals(null);\n-    } catch (Throwable t) {\n-        String msg = String.format(\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\", filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n-        reportBadDefinition(filter.getClass(), msg, t);\n-        // never gets here\n-        return false;\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        throw InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n    AnnotatedClass ac = bean.getClassInfo();\n    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n    // Ok: if there is no explicit type info handler, we may want to\n    // use a default. If so, config object knows what to use.\n    Collection<NamedType> subtypes = null;\n    if (b == null) {\n        b = config.getDefaultTyper(baseType);\n        if (b == null) {\n            return null;\n        }\n    } else {\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n    }\n    // May need to figure out default implementation, if none found yet\n    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n        JavaType defaultType = mapAbstractType(config, baseType);\n        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n            b = b.defaultImpl(defaultType.getRawClass());\n        }\n    }\n    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n    //    map to better type here\n    try {\n        TypeDeserializer typeDeserializer = b.buildTypeDeserializer(config, baseType, subtypes);\n        if(typeDeserializer == null){\n            return null;\n        }\n        return typeDeserializer;\n    } catch (IllegalArgumentException e0) {\n        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n        e.initCause(e0);\n        throw e;\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n@@ -26,7 +26,11 @@\n     // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n     //    map to better type here\n     try {\n-        return b.buildTypeDeserializer(config, baseType, subtypes);\n+        TypeDeserializer typeDeserializer = b.buildTypeDeserializer(config, baseType, subtypes);\n+        if(typeDeserializer == null){\n+            return null;\n+        }\n+        return typeDeserializer;\n     } catch (IllegalArgumentException e0) {\n         InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n         e.initCause(e0);\n--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,39 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n+        TypeDeserializer typeDeserializer = b.buildTypeDeserializer(config, baseType, subtypes);\n+        if(typeDeserializer == null){\n+            return null;\n         }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage());\n+        return typeDeserializer;\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n@@ -1,21 +1,39 @@\n @Override\n-public Object instantiateBean(boolean fixAccess) {\n-    AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n-    if (ac == null) {\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    if (fixAccess) {\n-        ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n     }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return ac.getAnnotated().newInstance();\n-    } catch (Exception e) {\n-        Throwable t = e;\n-        while (t.getCause() != null) {\n-            t = t.getCause();\n+        TypeDeserializer typeDeserializer = b.buildTypeDeserializer(config, baseType, subtypes);\n+        if(typeDeserializer == null){\n+            return null;\n         }\n-        ClassUtil.throwIfError(t);\n-        ClassUtil.throwIfRTE(t);\n-        throw new IllegalArgumentException(\"Failed to instantiate bean of type \" + _classInfo.getAnnotated().getName() + \": (\" + t.getClass().getName() + \") \" + t.getMessage(), t);\n+        return typeDeserializer;\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n }\n--- com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n+++ com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n@@ -1,16 +1,39 @@\n @Override\n-public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n-    if (filter == null) {\n-        return true;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    // should let filter decide what to do with nulls:\n-    // But just case, let's handle unexpected (from our perspective) problems explicitly\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return filter.equals(null);\n-    } catch (Throwable t) {\n-        String msg = String.format(\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\", filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n-        reportBadDefinition(filter.getClass(), msg, t);\n-        // never gets here\n-        return false;\n+        TypeDeserializer typeDeserializer = b.buildTypeDeserializer(config, baseType, subtypes);\n+        if(typeDeserializer == null){\n+            return null;\n+        }\n+        return typeDeserializer;\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n    AnnotatedClass ac = bean.getClassInfo();\n    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n    // Ok: if there is no explicit type info handler, we may want to\n    // use a default. If so, config object knows what to use.\n    Collection<NamedType> subtypes = null;\n    if (b == null) {\n        b = config.getDefaultTyper(baseType);\n        if (b == null) {\n            return null;\n        }\n    } else {\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n    }\n    // May need to figure out default implementation, if none found yet\n    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n        JavaType defaultType = mapAbstractType(config, baseType);\n        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n            b = b.defaultImpl(defaultType.getRawClass());\n        }\n    }\n    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n    //    map to better type here\n    try {\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    } catch (IllegalArgumentException e0) {\n        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n        e.initCause(e0);\n        throw e;\n    } catch (JsonMappingException e1) {\n        throw e1;\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n@@ -31,5 +31,7 @@\n         InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n         e.initCause(e0);\n         throw e;\n+    } catch (JsonMappingException e1) {\n+        throw e1;\n     }\n }\n--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,37 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage());\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (JsonMappingException e1) {\n+        throw e1;\n     }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n@@ -1,21 +1,37 @@\n @Override\n-public Object instantiateBean(boolean fixAccess) {\n-    AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n-    if (ac == null) {\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    if (fixAccess) {\n-        ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n     }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return ac.getAnnotated().newInstance();\n-    } catch (Exception e) {\n-        Throwable t = e;\n-        while (t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        ClassUtil.throwIfError(t);\n-        ClassUtil.throwIfRTE(t);\n-        throw new IllegalArgumentException(\"Failed to instantiate bean of type \" + _classInfo.getAnnotated().getName() + \": (\" + t.getClass().getName() + \") \" + t.getMessage(), t);\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (JsonMappingException e1) {\n+        throw e1;\n     }\n }\n--- com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n+++ com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n@@ -1,16 +1,37 @@\n @Override\n-public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n-    if (filter == null) {\n-        return true;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    // should let filter decide what to do with nulls:\n-    // But just case, let's handle unexpected (from our perspective) problems explicitly\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return filter.equals(null);\n-    } catch (Throwable t) {\n-        String msg = String.format(\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\", filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n-        reportBadDefinition(filter.getClass(), msg, t);\n-        // never gets here\n-        return false;\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (JsonMappingException e1) {\n+        throw e1;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n    AnnotatedClass ac = bean.getClassInfo();\n    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n    // Ok: if there is no explicit type info handler, we may want to\n    // use a default. If so, config object knows what to use.\n    Collection<NamedType> subtypes = null;\n    if (b == null) {\n        b = config.getDefaultTyper(baseType);\n        if (b == null) {\n            return null;\n        }\n    } else {\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n    }\n    // May need to figure out default implementation, if none found yet\n    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n        JavaType defaultType = mapAbstractType(config, baseType);\n        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n            b = b.defaultImpl(defaultType.getRawClass());\n        }\n    }\n    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n    //    map to better type here\n    try {\n        TypeDeserializer deser = b.buildTypeDeserializer(config, baseType, subtypes);\n        return (deser != null) ? deser : super.findTypeDeserializer(config, baseType);\n    } catch (IllegalArgumentException e0) {\n        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n        e.initCause(e0);\n        throw e;\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n@@ -26,7 +26,8 @@\n     // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n     //    map to better type here\n     try {\n-        return b.buildTypeDeserializer(config, baseType, subtypes);\n+        TypeDeserializer deser = b.buildTypeDeserializer(config, baseType, subtypes);\n+        return (deser != null) ? deser : super.findTypeDeserializer(config, baseType);\n     } catch (IllegalArgumentException e0) {\n         InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n         e.initCause(e0);\n--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,36 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage());\n+        TypeDeserializer deser = b.buildTypeDeserializer(config, baseType, subtypes);\n+        return (deser != null) ? deser : super.findTypeDeserializer(config, baseType);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n@@ -1,21 +1,36 @@\n @Override\n-public Object instantiateBean(boolean fixAccess) {\n-    AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n-    if (ac == null) {\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    if (fixAccess) {\n-        ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n     }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return ac.getAnnotated().newInstance();\n-    } catch (Exception e) {\n-        Throwable t = e;\n-        while (t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        ClassUtil.throwIfError(t);\n-        ClassUtil.throwIfRTE(t);\n-        throw new IllegalArgumentException(\"Failed to instantiate bean of type \" + _classInfo.getAnnotated().getName() + \": (\" + t.getClass().getName() + \") \" + t.getMessage(), t);\n+        TypeDeserializer deser = b.buildTypeDeserializer(config, baseType, subtypes);\n+        return (deser != null) ? deser : super.findTypeDeserializer(config, baseType);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n }\n--- com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n+++ com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n@@ -1,16 +1,36 @@\n @Override\n-public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n-    if (filter == null) {\n-        return true;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    // should let filter decide what to do with nulls:\n-    // But just case, let's handle unexpected (from our perspective) problems explicitly\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return filter.equals(null);\n-    } catch (Throwable t) {\n-        String msg = String.format(\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\", filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n-        reportBadDefinition(filter.getClass(), msg, t);\n-        // never gets here\n-        return false;\n+        TypeDeserializer deser = b.buildTypeDeserializer(config, baseType, subtypes);\n+        return (deser != null) ? deser : super.findTypeDeserializer(config, baseType);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n    AnnotatedClass ac = bean.getClassInfo();\n    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n    // Ok: if there is no explicit type info handler, we may want to\n    // use a default. If so, config object knows what to use.\n    Collection<NamedType> subtypes = null;\n    if (b == null) {\n        b = config.getDefaultTyper(baseType);\n        if (b == null) {\n            return null;\n        }\n    } else {\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n    }\n    // May need to figure out default implementation, if none found yet\n    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n        JavaType defaultType = mapAbstractType(config, baseType);\n        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n            b = b.defaultImpl(defaultType.getRawClass());\n        }\n    }\n    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n    //    map to better type here\n    try {\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    } catch (IllegalArgumentException e0) {\n        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n        e.initCause(e0);\n        throw e;\n    } catch (IllegalStateException e1) { // Added catch block for IllegalStateException\n        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e1.getMessage(), baseType);\n        e.initCause(e1);\n        throw e;\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n@@ -31,5 +31,9 @@\n         InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n         e.initCause(e0);\n         throw e;\n+    } catch (IllegalStateException e1) { // Added catch block for IllegalStateException\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e1.getMessage(), baseType);\n+        e.initCause(e1);\n+        throw e;\n     }\n }\n--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,39 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage());\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (IllegalStateException e1) { // Added catch block for IllegalStateException\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e1.getMessage(), baseType);\n+        e.initCause(e1);\n+        throw e;\n     }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n@@ -1,21 +1,39 @@\n @Override\n-public Object instantiateBean(boolean fixAccess) {\n-    AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n-    if (ac == null) {\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    if (fixAccess) {\n-        ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n     }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return ac.getAnnotated().newInstance();\n-    } catch (Exception e) {\n-        Throwable t = e;\n-        while (t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        ClassUtil.throwIfError(t);\n-        ClassUtil.throwIfRTE(t);\n-        throw new IllegalArgumentException(\"Failed to instantiate bean of type \" + _classInfo.getAnnotated().getName() + \": (\" + t.getClass().getName() + \") \" + t.getMessage(), t);\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (IllegalStateException e1) { // Added catch block for IllegalStateException\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e1.getMessage(), baseType);\n+        e.initCause(e1);\n+        throw e;\n     }\n }\n--- com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n+++ com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n@@ -1,16 +1,39 @@\n @Override\n-public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n-    if (filter == null) {\n-        return true;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    // should let filter decide what to do with nulls:\n-    // But just case, let's handle unexpected (from our perspective) problems explicitly\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return filter.equals(null);\n-    } catch (Throwable t) {\n-        String msg = String.format(\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\", filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n-        reportBadDefinition(filter.getClass(), msg, t);\n-        // never gets here\n-        return false;\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (IllegalStateException e1) { // Added catch block for IllegalStateException\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e1.getMessage(), baseType);\n+        e.initCause(e1);\n+        throw e;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n    AnnotatedClass ac = bean.getClassInfo();\n    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n    // Ok: if there is no explicit type info handler, we may want to\n    // use a default. If so, config object knows what to use.\n    Collection<NamedType> subtypes = null;\n    if (b == null) {\n        b = config.getDefaultTyper(baseType);\n        if (b == null) {\n            return null;\n        }\n    } else {\n        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n    }\n    // May need to figure out default implementation, if none found yet\n    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n        JavaType defaultType = mapAbstractType(config, baseType);\n        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n            b = b.defaultImpl(defaultType.getRawClass());\n        }\n    }\n    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n    //    map to better type here\n    try {\n        return b.buildTypeDeserializer(config, baseType, subtypes);\n    } catch (IllegalArgumentException e0) {\n        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n        e.initCause(e0);\n        throw e;\n    } catch (IllegalStateException e1) {\n        throw JsonMappingException.from(config.getParserFactory().createParser(config.getBaseSettings().getFormatReadFeatures(), baseType),\n                e1.getMessage(), e1);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n+++ com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java@findTypeDeserializer\n@@ -31,5 +31,8 @@\n         InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n         e.initCause(e0);\n         throw e;\n+    } catch (IllegalStateException e1) {\n+        throw JsonMappingException.from(config.getParserFactory().createParser(config.getBaseSettings().getFormatReadFeatures(), baseType),\n+                e1.getMessage(), e1);\n     }\n }\n--- com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n+++ com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java@deserializeKey\n@@ -1,19 +1,38 @@\n @Override\n-public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n-    if (key == null) {\n-        // is this even legal call?\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        Object result = _parse(key, ctxt);\n-        if (result != null) {\n-            return result;\n-        }\n-    } catch (Exception re) {\n-        return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation, problem: (%s) %s\", re.getClass().getName(), re.getMessage());\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (IllegalStateException e1) {\n+        throw JsonMappingException.from(config.getParserFactory().createParser(config.getBaseSettings().getFormatReadFeatures(), baseType),\n+                e1.getMessage(), e1);\n     }\n-    if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        return null;\n-    }\n-    return ctxt.handleWeirdKey(_keyClass, key, \"not a valid representation\");\n }\n--- com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n+++ com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java@instantiateBean\n@@ -1,21 +1,38 @@\n @Override\n-public Object instantiateBean(boolean fixAccess) {\n-    AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n-    if (ac == null) {\n-        return null;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    if (fixAccess) {\n-        ac.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n     }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return ac.getAnnotated().newInstance();\n-    } catch (Exception e) {\n-        Throwable t = e;\n-        while (t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        ClassUtil.throwIfError(t);\n-        ClassUtil.throwIfRTE(t);\n-        throw new IllegalArgumentException(\"Failed to instantiate bean of type \" + _classInfo.getAnnotated().getName() + \": (\" + t.getClass().getName() + \") \" + t.getMessage(), t);\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (IllegalStateException e1) {\n+        throw JsonMappingException.from(config.getParserFactory().createParser(config.getBaseSettings().getFormatReadFeatures(), baseType),\n+                e1.getMessage(), e1);\n     }\n }\n--- com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n+++ com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java@includeFilterSuppressNulls\n@@ -1,16 +1,38 @@\n @Override\n-public boolean includeFilterSuppressNulls(Object filter) throws JsonMappingException {\n-    if (filter == null) {\n-        return true;\n+public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException {\n+    BeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+    AnnotatedClass ac = bean.getClassInfo();\n+    AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+    TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+    // Ok: if there is no explicit type info handler, we may want to\n+    // use a default. If so, config object knows what to use.\n+    Collection<NamedType> subtypes = null;\n+    if (b == null) {\n+        b = config.getDefaultTyper(baseType);\n+        if (b == null) {\n+            return null;\n+        }\n+    } else {\n+        subtypes = config.getSubtypeResolver().collectAndResolveSubtypesByTypeId(config, ac);\n     }\n-    // should let filter decide what to do with nulls:\n-    // But just case, let's handle unexpected (from our perspective) problems explicitly\n+    // May need to figure out default implementation, if none found yet\n+    // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+    if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+        JavaType defaultType = mapAbstractType(config, baseType);\n+        if ((defaultType != null) && !defaultType.hasRawClass(baseType.getRawClass())) {\n+            b = b.defaultImpl(defaultType.getRawClass());\n+        }\n+    }\n+    // 05-Apt-2018, tatu: Since we get non-mapping exception due to various limitations,\n+    //    map to better type here\n     try {\n-        return filter.equals(null);\n-    } catch (Throwable t) {\n-        String msg = String.format(\"Problem determining whether filter of type '%s' should filter out `null` values: (%s) %s\", filter.getClass().getName(), t.getClass().getName(), t.getMessage());\n-        reportBadDefinition(filter.getClass(), msg, t);\n-        // never gets here\n-        return false;\n+        return b.buildTypeDeserializer(config, baseType, subtypes);\n+    } catch (IllegalArgumentException e0) {\n+        InvalidDefinitionException e = InvalidDefinitionException.from((JsonParser) null, e0.getMessage(), baseType);\n+        e.initCause(e0);\n+        throw e;\n+    } catch (IllegalStateException e1) {\n+        throw JsonMappingException.from(config.getParserFactory().createParser(config.getBaseSettings().getFormatReadFeatures(), baseType),\n+                e1.getMessage(), e1);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]