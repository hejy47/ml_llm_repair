[{"output": "@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    // First: check what creators we can use, if any\n    ValueInstantiator valueInstantiator;\n        try {\n        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n    }\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then setters for deserializing from JSON Object\n    addBeanProps(ctxt, beanDesc, builder);\n    addObjectIdReader(ctxt, beanDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, beanDesc, builder);\n    addInjectables(ctxt, beanDesc, builder);\n    final DeserializationConfig config = ctxt.getConfig();\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer;\n    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n        deserializer = builder.buildAbstract(type);\n    } else {\n        deserializer = builder.build();\n    }\n    // may have modifier(s) that wants to modify or replace serializer we just built\n    // (note that `resolve()` and `createContextual()` called later on)\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -28,7 +28,7 @@\n     }\n     JsonDeserializer<?> deserializer;\n     if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n-        deserializer = builder.buildAbstract();\n+        deserializer = builder.buildAbstract(type);\n     } else {\n         deserializer = builder.build();\n     }\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -1,48 +1,42 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n-    // Creators, anyone? (to create builder itself)\n+public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n+    // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n-    try {\n-        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n+        try {\n+        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n     }\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    builder.setValueInstantiator(valueInstantiator);\n+    // And then setters for deserializing from JSON Object\n+    addBeanProps(ctxt, beanDesc, builder);\n+    addObjectIdReader(ctxt, beanDesc, builder);\n+    // managed/back reference fields/setters need special handling... first part\n+    addBackReferenceProperties(ctxt, beanDesc, builder);\n+    addInjectables(ctxt, beanDesc, builder);\n     final DeserializationConfig config = ctxt.getConfig();\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n-    builder.setValueInstantiator(valueInstantiator);\n-    // And then \"with methods\" for deserializing from JSON Object\n-    addBeanProps(ctxt, builderDesc, builder);\n-    addObjectIdReader(ctxt, builderDesc, builder);\n-    // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, builderDesc, builder);\n-    addInjectables(ctxt, builderDesc, builder);\n-    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n-    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n-    // and lastly, find build method to use:\n-    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n-    if (buildMethod != null) {\n-        // note: can't yet throw error; may be given build method\n-        if (config.canOverrideAccessModifiers()) {\n-            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    if (_factoryConfig.hasDeserializerModifiers()) {\n+        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+            builder = mod.updateBuilder(config, beanDesc, builder);\n         }\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n-    // this may give us more information...\n+    JsonDeserializer<?> deserializer;\n+    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n+        deserializer = builder.buildAbstract(type);\n+    } else {\n+        deserializer = builder.build();\n+    }\n+    // may have modifier(s) that wants to modify or replace serializer we just built\n+    // (note that `resolve()` and `createContextual()` called later on)\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, builderDesc, builder);\n-        }\n-    }\n-    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n-    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n-    if (_factoryConfig.hasDeserializerModifiers()) {\n-        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    // First: check what creators we can use, if any\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n    }\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then setters for deserializing from JSON Object\n    addBeanProps(ctxt, beanDesc, builder);\n    addObjectIdReader(ctxt, beanDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, beanDesc, builder);\n    addInjectables(ctxt, beanDesc, builder);\n    final DeserializationConfig config = ctxt.getConfig();\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer;\n    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n        deserializer = builder.buildAbstract(type);\n    } else {\n        deserializer = builder.build();\n    }\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -2,14 +2,11 @@\n public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n     // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n-        try {\n+    try {\n         valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n-        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n-        //   to throw proper exception, it doesn't actually have reference to this\n-        //   instance so...\n         throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n     }\n     BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n@@ -28,12 +25,10 @@\n     }\n     JsonDeserializer<?> deserializer;\n     if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n-        deserializer = builder.buildAbstract();\n+        deserializer = builder.buildAbstract(type);\n     } else {\n         deserializer = builder.build();\n     }\n-    // may have modifier(s) that wants to modify or replace serializer we just built\n-    // (note that `resolve()` and `createContextual()` called later on)\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n             deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -1,48 +1,37 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n-    // Creators, anyone? (to create builder itself)\n+public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n+    // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n     try {\n-        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n+        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n-        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n-        //   to throw proper exception, it doesn't actually have reference to this\n-        //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n     }\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    builder.setValueInstantiator(valueInstantiator);\n+    // And then setters for deserializing from JSON Object\n+    addBeanProps(ctxt, beanDesc, builder);\n+    addObjectIdReader(ctxt, beanDesc, builder);\n+    // managed/back reference fields/setters need special handling... first part\n+    addBackReferenceProperties(ctxt, beanDesc, builder);\n+    addInjectables(ctxt, beanDesc, builder);\n     final DeserializationConfig config = ctxt.getConfig();\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n-    builder.setValueInstantiator(valueInstantiator);\n-    // And then \"with methods\" for deserializing from JSON Object\n-    addBeanProps(ctxt, builderDesc, builder);\n-    addObjectIdReader(ctxt, builderDesc, builder);\n-    // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, builderDesc, builder);\n-    addInjectables(ctxt, builderDesc, builder);\n-    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n-    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n-    // and lastly, find build method to use:\n-    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n-    if (buildMethod != null) {\n-        // note: can't yet throw error; may be given build method\n-        if (config.canOverrideAccessModifiers()) {\n-            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    if (_factoryConfig.hasDeserializerModifiers()) {\n+        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+            builder = mod.updateBuilder(config, beanDesc, builder);\n         }\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n-    // this may give us more information...\n+    JsonDeserializer<?> deserializer;\n+    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n+        deserializer = builder.buildAbstract(type);\n+    } else {\n+        deserializer = builder.build();\n+    }\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, builderDesc, builder);\n-        }\n-    }\n-    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n-    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n-    if (_factoryConfig.hasDeserializerModifiers()) {\n-        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    // First: check what creators we can use, if any\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n    }\n\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then setters for deserializing from JSON Object\n    addBeanProps(ctxt, beanDesc, builder);\n    addObjectIdReader(ctxt, beanDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, beanDesc, builder);\n    addInjectables(ctxt, beanDesc, builder);\n    final DeserializationConfig config = ctxt.getConfig();\n\n    // Apply deserializer modifiers to builder\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n\n    JsonDeserializer<?> deserializer;\n    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n        deserializer = builder.buildAbstract();\n    } else {\n        deserializer = builder.build();\n    }\n\n    // Apply deserializer modifiers to final deserializer\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n\n    // Resolve and contextualize deserializer before returning\n    deserializer = deserializer.unwrappingDeserializer(ctxt.getFactory());\n    deserializer = ctxt.handlePrimaryContextualization(deserializer, beanDesc);\n    TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n    if (typeDeser != null) {\n        typeDeser = typeDeser.forProperty(ctxt.getConfig(), beanDesc.getClassInfo());\n        deserializer = new TypeWrappedDeserializer(typeDeser, deserializer);\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -2,7 +2,7 @@\n public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n     // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n-        try {\n+    try {\n         valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n@@ -12,6 +12,7 @@\n         //   instance so...\n         throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n     }\n+\n     BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n     builder.setValueInstantiator(valueInstantiator);\n     // And then setters for deserializing from JSON Object\n@@ -21,23 +22,35 @@\n     addBackReferenceProperties(ctxt, beanDesc, builder);\n     addInjectables(ctxt, beanDesc, builder);\n     final DeserializationConfig config = ctxt.getConfig();\n+\n+    // Apply deserializer modifiers to builder\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n             builder = mod.updateBuilder(config, beanDesc, builder);\n         }\n     }\n+\n     JsonDeserializer<?> deserializer;\n     if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n         deserializer = builder.buildAbstract();\n     } else {\n         deserializer = builder.build();\n     }\n-    // may have modifier(s) that wants to modify or replace serializer we just built\n-    // (note that `resolve()` and `createContextual()` called later on)\n+\n+    // Apply deserializer modifiers to final deserializer\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n             deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n         }\n     }\n+\n+    // Resolve and contextualize deserializer before returning\n+    deserializer = deserializer.unwrappingDeserializer(ctxt.getFactory());\n+    deserializer = ctxt.handlePrimaryContextualization(deserializer, beanDesc);\n+    TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n+    if (typeDeser != null) {\n+        typeDeser = typeDeser.forProperty(ctxt.getConfig(), beanDesc.getClassInfo());\n+        deserializer = new TypeWrappedDeserializer(typeDeser, deserializer);\n+    }\n     return (JsonDeserializer<Object>) deserializer;\n }\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -1,49 +1,56 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n-    // Creators, anyone? (to create builder itself)\n+public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n+    // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n     try {\n-        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n+        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n     }\n+\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    builder.setValueInstantiator(valueInstantiator);\n+    // And then setters for deserializing from JSON Object\n+    addBeanProps(ctxt, beanDesc, builder);\n+    addObjectIdReader(ctxt, beanDesc, builder);\n+    // managed/back reference fields/setters need special handling... first part\n+    addBackReferenceProperties(ctxt, beanDesc, builder);\n+    addInjectables(ctxt, beanDesc, builder);\n     final DeserializationConfig config = ctxt.getConfig();\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n-    builder.setValueInstantiator(valueInstantiator);\n-    // And then \"with methods\" for deserializing from JSON Object\n-    addBeanProps(ctxt, builderDesc, builder);\n-    addObjectIdReader(ctxt, builderDesc, builder);\n-    // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, builderDesc, builder);\n-    addInjectables(ctxt, builderDesc, builder);\n-    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n-    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n-    // and lastly, find build method to use:\n-    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n-    if (buildMethod != null) {\n-        // note: can't yet throw error; may be given build method\n-        if (config.canOverrideAccessModifiers()) {\n-            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+\n+    // Apply deserializer modifiers to builder\n+    if (_factoryConfig.hasDeserializerModifiers()) {\n+        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+            builder = mod.updateBuilder(config, beanDesc, builder);\n         }\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n-    // this may give us more information...\n+\n+    JsonDeserializer<?> deserializer;\n+    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n+        deserializer = builder.buildAbstract();\n+    } else {\n+        deserializer = builder.build();\n+    }\n+\n+    // Apply deserializer modifiers to final deserializer\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, builderDesc, builder);\n+            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n         }\n     }\n-    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n-    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n-    if (_factoryConfig.hasDeserializerModifiers()) {\n-        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n-        }\n+\n+    // Resolve and contextualize deserializer before returning\n+    deserializer = deserializer.unwrappingDeserializer(ctxt.getFactory());\n+    deserializer = ctxt.handlePrimaryContextualization(deserializer, beanDesc);\n+    TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n+    if (typeDeser != null) {\n+        typeDeser = typeDeser.forProperty(ctxt.getConfig(), beanDesc.getClassInfo());\n+        deserializer = new TypeWrappedDeserializer(typeDeser, deserializer);\n     }\n     return (JsonDeserializer<Object>) deserializer;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    // First: check what creators we can use, if any\n    ValueInstantiator valueInstantiator;\n        try {\n        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to\n        // require collector to throw proper exception, it doesn't actually\n        // have reference to this\n        // instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n    }\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then setters for deserializing from JSON Object\n    addBeanProps(ctxt, beanDesc, builder);\n    addObjectIdReader(ctxt, beanDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, beanDesc, builder);\n    addInjectables(ctxt, beanDesc, builder);\n    final DeserializationConfig config = ctxt.getConfig();\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer;\n    if (type.isAbstract() && !valueInstantiator.canCreateFromObjectWith()) {\n        deserializer = builder.buildAbstract();\n    } else {\n        deserializer = builder.build();\n    }\n    // may have modifier(s) that wants to modify or replace serializer we just built\n    // (note that `resolve()` and `createContextual()` called later on)\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -7,9 +7,10 @@\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n-        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n-        //   to throw proper exception, it doesn't actually have reference to this\n-        //   instance so...\n+        // 05-Apr-2017, tatu: Although it might appear cleaner to\n+        // require collector to throw proper exception, it doesn't actually\n+        // have reference to this\n+        // instance so...\n         throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n     }\n     BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n@@ -27,7 +28,7 @@\n         }\n     }\n     JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n+    if (type.isAbstract() && !valueInstantiator.canCreateFromObjectWith()) {\n         deserializer = builder.buildAbstract();\n     } else {\n         deserializer = builder.build();\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -1,48 +1,43 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n-    // Creators, anyone? (to create builder itself)\n+public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n+    // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n-    try {\n-        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n+        try {\n+        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n-        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n-        //   to throw proper exception, it doesn't actually have reference to this\n-        //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n+        // 05-Apr-2017, tatu: Although it might appear cleaner to\n+        // require collector to throw proper exception, it doesn't actually\n+        // have reference to this\n+        // instance so...\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n     }\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    builder.setValueInstantiator(valueInstantiator);\n+    // And then setters for deserializing from JSON Object\n+    addBeanProps(ctxt, beanDesc, builder);\n+    addObjectIdReader(ctxt, beanDesc, builder);\n+    // managed/back reference fields/setters need special handling... first part\n+    addBackReferenceProperties(ctxt, beanDesc, builder);\n+    addInjectables(ctxt, beanDesc, builder);\n     final DeserializationConfig config = ctxt.getConfig();\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n-    builder.setValueInstantiator(valueInstantiator);\n-    // And then \"with methods\" for deserializing from JSON Object\n-    addBeanProps(ctxt, builderDesc, builder);\n-    addObjectIdReader(ctxt, builderDesc, builder);\n-    // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, builderDesc, builder);\n-    addInjectables(ctxt, builderDesc, builder);\n-    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n-    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n-    // and lastly, find build method to use:\n-    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n-    if (buildMethod != null) {\n-        // note: can't yet throw error; may be given build method\n-        if (config.canOverrideAccessModifiers()) {\n-            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    if (_factoryConfig.hasDeserializerModifiers()) {\n+        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+            builder = mod.updateBuilder(config, beanDesc, builder);\n         }\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n-    // this may give us more information...\n+    JsonDeserializer<?> deserializer;\n+    if (type.isAbstract() && !valueInstantiator.canCreateFromObjectWith()) {\n+        deserializer = builder.buildAbstract();\n+    } else {\n+        deserializer = builder.build();\n+    }\n+    // may have modifier(s) that wants to modify or replace serializer we just built\n+    // (note that `resolve()` and `createContextual()` called later on)\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, builderDesc, builder);\n-        }\n-    }\n-    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n-    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n-    if (_factoryConfig.hasDeserializerModifiers()) {\n-        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    // First: check what creators we can use, if any\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n    }\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then setters for deserializing from JSON Object\n    addBeanProps(ctxt, beanDesc, builder);\n    addObjectIdReader(ctxt, beanDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, beanDesc, builder);\n    addInjectables(ctxt, beanDesc, builder);\n    final DeserializationConfig config = ctxt.getConfig();\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer;\n    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n        deserializer = builder.buildAbstract();\n    } else {\n        deserializer = builder.build();\n    }\n    // may have modifier(s) that wants to modify or replace serializer we just built\n    // (note that `resolve()` and `createContextual()` called later on)\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -2,7 +2,7 @@\n public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n     // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n-        try {\n+    try {\n         valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -1,48 +1,42 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n-    // Creators, anyone? (to create builder itself)\n+public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n+    // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n     try {\n-        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n+        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n     }\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    builder.setValueInstantiator(valueInstantiator);\n+    // And then setters for deserializing from JSON Object\n+    addBeanProps(ctxt, beanDesc, builder);\n+    addObjectIdReader(ctxt, beanDesc, builder);\n+    // managed/back reference fields/setters need special handling... first part\n+    addBackReferenceProperties(ctxt, beanDesc, builder);\n+    addInjectables(ctxt, beanDesc, builder);\n     final DeserializationConfig config = ctxt.getConfig();\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n-    builder.setValueInstantiator(valueInstantiator);\n-    // And then \"with methods\" for deserializing from JSON Object\n-    addBeanProps(ctxt, builderDesc, builder);\n-    addObjectIdReader(ctxt, builderDesc, builder);\n-    // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, builderDesc, builder);\n-    addInjectables(ctxt, builderDesc, builder);\n-    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n-    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n-    // and lastly, find build method to use:\n-    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n-    if (buildMethod != null) {\n-        // note: can't yet throw error; may be given build method\n-        if (config.canOverrideAccessModifiers()) {\n-            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    if (_factoryConfig.hasDeserializerModifiers()) {\n+        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+            builder = mod.updateBuilder(config, beanDesc, builder);\n         }\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n-    // this may give us more information...\n+    JsonDeserializer<?> deserializer;\n+    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n+        deserializer = builder.buildAbstract();\n+    } else {\n+        deserializer = builder.build();\n+    }\n+    // may have modifier(s) that wants to modify or replace serializer we just built\n+    // (note that `resolve()` and `createContextual()` called later on)\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, builderDesc, builder);\n-        }\n-    }\n-    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n-    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n-    if (_factoryConfig.hasDeserializerModifiers()) {\n-        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n", "finish_reason": "stop", "valid": false, "num": 5}, {"output": "@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    // First: check what creators we can use, if any\n    ValueInstantiator valueInstantiator;\n        try {\n        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n    }\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then setters for deserializing from JSON Object\n    addBeanProps(ctxt, beanDesc, builder);\n    addObjectIdReader(ctxt, beanDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, beanDesc, builder);\n    addInjectables(ctxt, beanDesc, builder);\n    final DeserializationConfig config = ctxt.getConfig();\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer;\n    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n        deserializer = builder.buildAbstract();\n    } else {\n        deserializer = builder.build();\n    }\n    // may have modifier(s) that wants to modify or replace serializer we just built\n    // (note that `resolve()` and `createContextual()` called later on)\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -1,48 +1,42 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n-    // Creators, anyone? (to create builder itself)\n+public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n+    // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n-    try {\n-        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n+        try {\n+        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n     }\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    builder.setValueInstantiator(valueInstantiator);\n+    // And then setters for deserializing from JSON Object\n+    addBeanProps(ctxt, beanDesc, builder);\n+    addObjectIdReader(ctxt, beanDesc, builder);\n+    // managed/back reference fields/setters need special handling... first part\n+    addBackReferenceProperties(ctxt, beanDesc, builder);\n+    addInjectables(ctxt, beanDesc, builder);\n     final DeserializationConfig config = ctxt.getConfig();\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n-    builder.setValueInstantiator(valueInstantiator);\n-    // And then \"with methods\" for deserializing from JSON Object\n-    addBeanProps(ctxt, builderDesc, builder);\n-    addObjectIdReader(ctxt, builderDesc, builder);\n-    // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, builderDesc, builder);\n-    addInjectables(ctxt, builderDesc, builder);\n-    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n-    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n-    // and lastly, find build method to use:\n-    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n-    if (buildMethod != null) {\n-        // note: can't yet throw error; may be given build method\n-        if (config.canOverrideAccessModifiers()) {\n-            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    if (_factoryConfig.hasDeserializerModifiers()) {\n+        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+            builder = mod.updateBuilder(config, beanDesc, builder);\n         }\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n-    // this may give us more information...\n+    JsonDeserializer<?> deserializer;\n+    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n+        deserializer = builder.buildAbstract();\n+    } else {\n+        deserializer = builder.build();\n+    }\n+    // may have modifier(s) that wants to modify or replace serializer we just built\n+    // (note that `resolve()` and `createContextual()` called later on)\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, builderDesc, builder);\n-        }\n-    }\n-    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n-    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n-    if (_factoryConfig.hasDeserializerModifiers()) {\n-        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    // First: check what creators we can use, if any\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n    }\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then setters for deserializing from JSON Object\n    addBeanProps(ctxt, beanDesc, builder);\n    addObjectIdReader(ctxt, beanDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, beanDesc, builder);\n    addInjectables(ctxt, beanDesc, builder);\n    final DeserializationConfig config = ctxt.getConfig();\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer;\n    if (type.isAbstract() && !valueInstantiator.canCreateFromString()) { // use canCreateFromString() instead of canInstantiate()\n        deserializer = builder.buildAbstract();\n    } else {\n        deserializer = builder.build();\n    }\n    // may have modifier(s) that wants to modify or replace serializer we just built\n    // (note that `resolve()` and `createContextual()` called later on)\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -2,7 +2,7 @@\n public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n     // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n-        try {\n+    try {\n         valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n@@ -27,7 +27,7 @@\n         }\n     }\n     JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n+    if (type.isAbstract() && !valueInstantiator.canCreateFromString()) { // use canCreateFromString() instead of canInstantiate()\n         deserializer = builder.buildAbstract();\n     } else {\n         deserializer = builder.build();\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -1,48 +1,42 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n-    // Creators, anyone? (to create builder itself)\n+public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n+    // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n     try {\n-        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n+        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n     }\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    builder.setValueInstantiator(valueInstantiator);\n+    // And then setters for deserializing from JSON Object\n+    addBeanProps(ctxt, beanDesc, builder);\n+    addObjectIdReader(ctxt, beanDesc, builder);\n+    // managed/back reference fields/setters need special handling... first part\n+    addBackReferenceProperties(ctxt, beanDesc, builder);\n+    addInjectables(ctxt, beanDesc, builder);\n     final DeserializationConfig config = ctxt.getConfig();\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n-    builder.setValueInstantiator(valueInstantiator);\n-    // And then \"with methods\" for deserializing from JSON Object\n-    addBeanProps(ctxt, builderDesc, builder);\n-    addObjectIdReader(ctxt, builderDesc, builder);\n-    // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, builderDesc, builder);\n-    addInjectables(ctxt, builderDesc, builder);\n-    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n-    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n-    // and lastly, find build method to use:\n-    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n-    if (buildMethod != null) {\n-        // note: can't yet throw error; may be given build method\n-        if (config.canOverrideAccessModifiers()) {\n-            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    if (_factoryConfig.hasDeserializerModifiers()) {\n+        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+            builder = mod.updateBuilder(config, beanDesc, builder);\n         }\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n-    // this may give us more information...\n+    JsonDeserializer<?> deserializer;\n+    if (type.isAbstract() && !valueInstantiator.canCreateFromString()) { // use canCreateFromString() instead of canInstantiate()\n+        deserializer = builder.buildAbstract();\n+    } else {\n+        deserializer = builder.build();\n+    }\n+    // may have modifier(s) that wants to modify or replace serializer we just built\n+    // (note that `resolve()` and `createContextual()` called later on)\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, builderDesc, builder);\n-        }\n-    }\n-    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n-    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n-    if (_factoryConfig.hasDeserializerModifiers()) {\n-        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    // First: check what creators we can use, if any\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n    }\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then setters for deserializing from JSON Object\n    addBeanProps(ctxt, beanDesc, builder);\n    addObjectIdReader(ctxt, beanDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, beanDesc, builder);\n    addInjectables(ctxt, beanDesc, builder);\n    final DeserializationConfig config = ctxt.getConfig();\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer;\n    if (type.isAbstract() && !valueInstantiator.canInstantiate() && !type.isPrimitive()) {\n        deserializer = builder.buildAbstract();\n    } else {\n        deserializer = builder.build();\n    }\n    // may have modifier(s) that wants to modify or replace serializer we just built\n    // (note that `resolve()` and `createContextual()` called later on)\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -2,7 +2,7 @@\n public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n     // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n-        try {\n+    try {\n         valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n@@ -27,7 +27,7 @@\n         }\n     }\n     JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n+    if (type.isAbstract() && !valueInstantiator.canInstantiate() && !type.isPrimitive()) {\n         deserializer = builder.buildAbstract();\n     } else {\n         deserializer = builder.build();\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -1,48 +1,42 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n-    // Creators, anyone? (to create builder itself)\n+public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n+    // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n     try {\n-        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n+        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n     }\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    builder.setValueInstantiator(valueInstantiator);\n+    // And then setters for deserializing from JSON Object\n+    addBeanProps(ctxt, beanDesc, builder);\n+    addObjectIdReader(ctxt, beanDesc, builder);\n+    // managed/back reference fields/setters need special handling... first part\n+    addBackReferenceProperties(ctxt, beanDesc, builder);\n+    addInjectables(ctxt, beanDesc, builder);\n     final DeserializationConfig config = ctxt.getConfig();\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n-    builder.setValueInstantiator(valueInstantiator);\n-    // And then \"with methods\" for deserializing from JSON Object\n-    addBeanProps(ctxt, builderDesc, builder);\n-    addObjectIdReader(ctxt, builderDesc, builder);\n-    // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, builderDesc, builder);\n-    addInjectables(ctxt, builderDesc, builder);\n-    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n-    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n-    // and lastly, find build method to use:\n-    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n-    if (buildMethod != null) {\n-        // note: can't yet throw error; may be given build method\n-        if (config.canOverrideAccessModifiers()) {\n-            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    if (_factoryConfig.hasDeserializerModifiers()) {\n+        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+            builder = mod.updateBuilder(config, beanDesc, builder);\n         }\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n-    // this may give us more information...\n+    JsonDeserializer<?> deserializer;\n+    if (type.isAbstract() && !valueInstantiator.canInstantiate() && !type.isPrimitive()) {\n+        deserializer = builder.buildAbstract();\n+    } else {\n+        deserializer = builder.build();\n+    }\n+    // may have modifier(s) that wants to modify or replace serializer we just built\n+    // (note that `resolve()` and `createContextual()` called later on)\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, builderDesc, builder);\n-        }\n-    }\n-    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n-    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n-    if (_factoryConfig.hasDeserializerModifiers()) {\n-        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    // First: check what creators we can use, if any\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n    }\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then setters for deserializing from JSON Object\n    addBeanProps(ctxt, beanDesc, builder);\n    addObjectIdReader(ctxt, beanDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, beanDesc, builder);\n    addInjectables(ctxt, beanDesc, builder);\n    final DeserializationConfig config = ctxt.getConfig();\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer;\n    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n        deserializer = builder.buildAbstract(type);\n    } else {\n        deserializer = builder.build();\n    }\n    // may have modifier(s) that wants to modify or replace serializer we just built\n    // (note that `resolve()` and `createContextual()` called later on)\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -2,7 +2,7 @@\n public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n     // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n-        try {\n+    try {\n         valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n@@ -28,7 +28,7 @@\n     }\n     JsonDeserializer<?> deserializer;\n     if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n-        deserializer = builder.buildAbstract();\n+        deserializer = builder.buildAbstract(type);\n     } else {\n         deserializer = builder.build();\n     }\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -1,48 +1,42 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n-    // Creators, anyone? (to create builder itself)\n+public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n+    // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n     try {\n-        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n+        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n     }\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    builder.setValueInstantiator(valueInstantiator);\n+    // And then setters for deserializing from JSON Object\n+    addBeanProps(ctxt, beanDesc, builder);\n+    addObjectIdReader(ctxt, beanDesc, builder);\n+    // managed/back reference fields/setters need special handling... first part\n+    addBackReferenceProperties(ctxt, beanDesc, builder);\n+    addInjectables(ctxt, beanDesc, builder);\n     final DeserializationConfig config = ctxt.getConfig();\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n-    builder.setValueInstantiator(valueInstantiator);\n-    // And then \"with methods\" for deserializing from JSON Object\n-    addBeanProps(ctxt, builderDesc, builder);\n-    addObjectIdReader(ctxt, builderDesc, builder);\n-    // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, builderDesc, builder);\n-    addInjectables(ctxt, builderDesc, builder);\n-    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n-    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n-    // and lastly, find build method to use:\n-    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n-    if (buildMethod != null) {\n-        // note: can't yet throw error; may be given build method\n-        if (config.canOverrideAccessModifiers()) {\n-            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    if (_factoryConfig.hasDeserializerModifiers()) {\n+        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+            builder = mod.updateBuilder(config, beanDesc, builder);\n         }\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n-    // this may give us more information...\n+    JsonDeserializer<?> deserializer;\n+    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n+        deserializer = builder.buildAbstract(type);\n+    } else {\n+        deserializer = builder.build();\n+    }\n+    // may have modifier(s) that wants to modify or replace serializer we just built\n+    // (note that `resolve()` and `createContextual()` called later on)\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, builderDesc, builder);\n-        }\n-    }\n-    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n-    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n-    if (_factoryConfig.hasDeserializerModifiers()) {\n-        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    // First: check what creators we can use, if any\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n    }\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then setters for deserializing from JSON Object\n    addBeanProps(ctxt, beanDesc, builder);\n    addObjectIdReader(ctxt, beanDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, beanDesc, builder);\n    addInjectables(ctxt, beanDesc, builder);\n    final DeserializationConfig config = ctxt.getConfig();\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer;\n    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n        deserializer = builder.buildAbstract();\n    } else {\n        deserializer = builder.build();\n    }\n    // may have modifier(s) that wants to modify or replace serializer we just built\n    // (note that `resolve()` and `createContextual()` called later on)\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer, _factoryConfig);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -2,7 +2,7 @@\n public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n     // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n-        try {\n+    try {\n         valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n@@ -36,7 +36,7 @@\n     // (note that `resolve()` and `createContextual()` called later on)\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer, _factoryConfig);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -1,48 +1,42 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n-    // Creators, anyone? (to create builder itself)\n+public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n+    // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n     try {\n-        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n+        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n     }\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    builder.setValueInstantiator(valueInstantiator);\n+    // And then setters for deserializing from JSON Object\n+    addBeanProps(ctxt, beanDesc, builder);\n+    addObjectIdReader(ctxt, beanDesc, builder);\n+    // managed/back reference fields/setters need special handling... first part\n+    addBackReferenceProperties(ctxt, beanDesc, builder);\n+    addInjectables(ctxt, beanDesc, builder);\n     final DeserializationConfig config = ctxt.getConfig();\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n-    builder.setValueInstantiator(valueInstantiator);\n-    // And then \"with methods\" for deserializing from JSON Object\n-    addBeanProps(ctxt, builderDesc, builder);\n-    addObjectIdReader(ctxt, builderDesc, builder);\n-    // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, builderDesc, builder);\n-    addInjectables(ctxt, builderDesc, builder);\n-    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n-    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n-    // and lastly, find build method to use:\n-    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n-    if (buildMethod != null) {\n-        // note: can't yet throw error; may be given build method\n-        if (config.canOverrideAccessModifiers()) {\n-            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    if (_factoryConfig.hasDeserializerModifiers()) {\n+        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+            builder = mod.updateBuilder(config, beanDesc, builder);\n         }\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n-    // this may give us more information...\n+    JsonDeserializer<?> deserializer;\n+    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n+        deserializer = builder.buildAbstract();\n+    } else {\n+        deserializer = builder.build();\n+    }\n+    // may have modifier(s) that wants to modify or replace serializer we just built\n+    // (note that `resolve()` and `createContextual()` called later on)\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, builderDesc, builder);\n-        }\n-    }\n-    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n-    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n-    if (_factoryConfig.hasDeserializerModifiers()) {\n-        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer, _factoryConfig);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    // First: check what creators we can use, if any\n    ValueInstantiator valueInstantiator;\n        try {\n        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n    }\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then setters for deserializing from JSON Object\n    addBeanProps(ctxt, beanDesc, builder);\n    addObjectIdReader(ctxt, beanDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, beanDesc, builder);\n    addInjectables(ctxt, beanDesc, builder);\n    final DeserializationConfig config = ctxt.getConfig();\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer;\n    if (type.isAbstract() && !valueInstantiator.canCreateUsingDefault()) {\n        deserializer = builder.buildAbstract();\n    } else {\n        deserializer = builder.build();\n    }\n    // may have modifier(s) that wants to modify or replace serializer we just built\n    // (note that `resolve()` and `createContextual()` called later on)\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -27,7 +27,7 @@\n         }\n     }\n     JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n+    if (type.isAbstract() && !valueInstantiator.canCreateUsingDefault()) {\n         deserializer = builder.buildAbstract();\n     } else {\n         deserializer = builder.build();\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -1,48 +1,42 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n-    // Creators, anyone? (to create builder itself)\n+public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n+    // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n-    try {\n-        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n+        try {\n+        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n     }\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    builder.setValueInstantiator(valueInstantiator);\n+    // And then setters for deserializing from JSON Object\n+    addBeanProps(ctxt, beanDesc, builder);\n+    addObjectIdReader(ctxt, beanDesc, builder);\n+    // managed/back reference fields/setters need special handling... first part\n+    addBackReferenceProperties(ctxt, beanDesc, builder);\n+    addInjectables(ctxt, beanDesc, builder);\n     final DeserializationConfig config = ctxt.getConfig();\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n-    builder.setValueInstantiator(valueInstantiator);\n-    // And then \"with methods\" for deserializing from JSON Object\n-    addBeanProps(ctxt, builderDesc, builder);\n-    addObjectIdReader(ctxt, builderDesc, builder);\n-    // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, builderDesc, builder);\n-    addInjectables(ctxt, builderDesc, builder);\n-    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n-    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n-    // and lastly, find build method to use:\n-    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n-    if (buildMethod != null) {\n-        // note: can't yet throw error; may be given build method\n-        if (config.canOverrideAccessModifiers()) {\n-            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    if (_factoryConfig.hasDeserializerModifiers()) {\n+        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+            builder = mod.updateBuilder(config, beanDesc, builder);\n         }\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n-    // this may give us more information...\n+    JsonDeserializer<?> deserializer;\n+    if (type.isAbstract() && !valueInstantiator.canCreateUsingDefault()) {\n+        deserializer = builder.buildAbstract();\n+    } else {\n+        deserializer = builder.build();\n+    }\n+    // may have modifier(s) that wants to modify or replace serializer we just built\n+    // (note that `resolve()` and `createContextual()` called later on)\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, builderDesc, builder);\n-        }\n-    }\n-    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n-    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n-    if (_factoryConfig.hasDeserializerModifiers()) {\n-        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    // First: check what creators we can use, if any\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n    }\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then setters for deserializing from JSON Object\n    addBeanProps(ctxt, beanDesc, builder);\n    addObjectIdReader(ctxt, beanDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, beanDesc, builder);\n    addInjectables(ctxt, beanDesc, builder);\n    final DeserializationConfig config = ctxt.getConfig();\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer;\n    if (type.isAbstract() && !valueInstantiator.canCreateUsingDefault()) {\n        deserializer = builder.buildAbstract();\n    } else {\n        deserializer = builder.build();\n    }\n    // may have modifier(s) that wants to modify or replace serializer we just built\n    // (note that `resolve()` and `createContextual()` called later on)\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -2,7 +2,7 @@\n public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n     // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n-        try {\n+    try {\n         valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n@@ -27,7 +27,7 @@\n         }\n     }\n     JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n+    if (type.isAbstract() && !valueInstantiator.canCreateUsingDefault()) {\n         deserializer = builder.buildAbstract();\n     } else {\n         deserializer = builder.build();\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -1,48 +1,42 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n-    // Creators, anyone? (to create builder itself)\n+public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n+    // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n     try {\n-        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n+        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n     }\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    builder.setValueInstantiator(valueInstantiator);\n+    // And then setters for deserializing from JSON Object\n+    addBeanProps(ctxt, beanDesc, builder);\n+    addObjectIdReader(ctxt, beanDesc, builder);\n+    // managed/back reference fields/setters need special handling... first part\n+    addBackReferenceProperties(ctxt, beanDesc, builder);\n+    addInjectables(ctxt, beanDesc, builder);\n     final DeserializationConfig config = ctxt.getConfig();\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n-    builder.setValueInstantiator(valueInstantiator);\n-    // And then \"with methods\" for deserializing from JSON Object\n-    addBeanProps(ctxt, builderDesc, builder);\n-    addObjectIdReader(ctxt, builderDesc, builder);\n-    // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, builderDesc, builder);\n-    addInjectables(ctxt, builderDesc, builder);\n-    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n-    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n-    // and lastly, find build method to use:\n-    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n-    if (buildMethod != null) {\n-        // note: can't yet throw error; may be given build method\n-        if (config.canOverrideAccessModifiers()) {\n-            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    if (_factoryConfig.hasDeserializerModifiers()) {\n+        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+            builder = mod.updateBuilder(config, beanDesc, builder);\n         }\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n-    // this may give us more information...\n+    JsonDeserializer<?> deserializer;\n+    if (type.isAbstract() && !valueInstantiator.canCreateUsingDefault()) {\n+        deserializer = builder.buildAbstract();\n+    } else {\n+        deserializer = builder.build();\n+    }\n+    // may have modifier(s) that wants to modify or replace serializer we just built\n+    // (note that `resolve()` and `createContextual()` called later on)\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, builderDesc, builder);\n-        }\n-    }\n-    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n-    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n-    if (_factoryConfig.hasDeserializerModifiers()) {\n-        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    // First: check what creators we can use, if any\n    ValueInstantiator valueInstantiator;\n        try {\n        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n    }\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then setters for deserializing from JSON Object\n    addBeanProps(ctxt, beanDesc, builder);\n    addObjectIdReader(ctxt, beanDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, beanDesc, builder);\n    addInjectables(ctxt, beanDesc, builder);\n    final DeserializationConfig config = ctxt.getConfig();\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer;\n    if (type.isAbstract() && !valueInstantiator.canCreateUsingDefault() && !valueInstantiator.canCreateFromObjectWith()) {\n        deserializer = builder.buildAbstract();\n    } else {\n        deserializer = builder.build();\n    }\n    // may have modifier(s) that wants to modify or replace serializer we just built\n    // (note that `resolve()` and `createContextual()` called later on)\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -27,7 +27,7 @@\n         }\n     }\n     JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n+    if (type.isAbstract() && !valueInstantiator.canCreateUsingDefault() && !valueInstantiator.canCreateFromObjectWith()) {\n         deserializer = builder.buildAbstract();\n     } else {\n         deserializer = builder.build();\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -1,48 +1,42 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n-    // Creators, anyone? (to create builder itself)\n+public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n+    // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n-    try {\n-        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n+        try {\n+        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n     }\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    builder.setValueInstantiator(valueInstantiator);\n+    // And then setters for deserializing from JSON Object\n+    addBeanProps(ctxt, beanDesc, builder);\n+    addObjectIdReader(ctxt, beanDesc, builder);\n+    // managed/back reference fields/setters need special handling... first part\n+    addBackReferenceProperties(ctxt, beanDesc, builder);\n+    addInjectables(ctxt, beanDesc, builder);\n     final DeserializationConfig config = ctxt.getConfig();\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n-    builder.setValueInstantiator(valueInstantiator);\n-    // And then \"with methods\" for deserializing from JSON Object\n-    addBeanProps(ctxt, builderDesc, builder);\n-    addObjectIdReader(ctxt, builderDesc, builder);\n-    // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, builderDesc, builder);\n-    addInjectables(ctxt, builderDesc, builder);\n-    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n-    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n-    // and lastly, find build method to use:\n-    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n-    if (buildMethod != null) {\n-        // note: can't yet throw error; may be given build method\n-        if (config.canOverrideAccessModifiers()) {\n-            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    if (_factoryConfig.hasDeserializerModifiers()) {\n+        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+            builder = mod.updateBuilder(config, beanDesc, builder);\n         }\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n-    // this may give us more information...\n+    JsonDeserializer<?> deserializer;\n+    if (type.isAbstract() && !valueInstantiator.canCreateUsingDefault() && !valueInstantiator.canCreateFromObjectWith()) {\n+        deserializer = builder.buildAbstract();\n+    } else {\n+        deserializer = builder.build();\n+    }\n+    // may have modifier(s) that wants to modify or replace serializer we just built\n+    // (note that `resolve()` and `createContextual()` called later on)\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, builderDesc, builder);\n-        }\n-    }\n-    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n-    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n-    if (_factoryConfig.hasDeserializerModifiers()) {\n-        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    // First: check what creators we can use, if any\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n    }\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then setters for deserializing from JSON Object\n    addBeanProps(ctxt, beanDesc, builder);\n    addObjectIdReader(ctxt, beanDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, beanDesc, builder);\n    addInjectables(ctxt, beanDesc, builder);\n    final DeserializationConfig config = ctxt.getConfig();\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer;\n    if (type.isAbstract() && !valueInstantiator.canCreateUsingDefault()) {\n        deserializer = builder.buildAbstract();\n    } else {\n        deserializer = builder.build();\n    }\n    // may have modifier(s) that want to modify or replace serializer we just built\n    // (note that `resolve()` and `createContextual()` called later on)\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -2,7 +2,7 @@\n public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n     // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n-        try {\n+    try {\n         valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n@@ -27,12 +27,12 @@\n         }\n     }\n     JsonDeserializer<?> deserializer;\n-    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n+    if (type.isAbstract() && !valueInstantiator.canCreateUsingDefault()) {\n         deserializer = builder.buildAbstract();\n     } else {\n         deserializer = builder.build();\n     }\n-    // may have modifier(s) that wants to modify or replace serializer we just built\n+    // may have modifier(s) that want to modify or replace serializer we just built\n     // (note that `resolve()` and `createContextual()` called later on)\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -1,48 +1,42 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n-    // Creators, anyone? (to create builder itself)\n+public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n+    // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n     try {\n-        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n+        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n     }\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    builder.setValueInstantiator(valueInstantiator);\n+    // And then setters for deserializing from JSON Object\n+    addBeanProps(ctxt, beanDesc, builder);\n+    addObjectIdReader(ctxt, beanDesc, builder);\n+    // managed/back reference fields/setters need special handling... first part\n+    addBackReferenceProperties(ctxt, beanDesc, builder);\n+    addInjectables(ctxt, beanDesc, builder);\n     final DeserializationConfig config = ctxt.getConfig();\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n-    builder.setValueInstantiator(valueInstantiator);\n-    // And then \"with methods\" for deserializing from JSON Object\n-    addBeanProps(ctxt, builderDesc, builder);\n-    addObjectIdReader(ctxt, builderDesc, builder);\n-    // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, builderDesc, builder);\n-    addInjectables(ctxt, builderDesc, builder);\n-    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n-    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n-    // and lastly, find build method to use:\n-    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n-    if (buildMethod != null) {\n-        // note: can't yet throw error; may be given build method\n-        if (config.canOverrideAccessModifiers()) {\n-            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    if (_factoryConfig.hasDeserializerModifiers()) {\n+        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+            builder = mod.updateBuilder(config, beanDesc, builder);\n         }\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n-    // this may give us more information...\n+    JsonDeserializer<?> deserializer;\n+    if (type.isAbstract() && !valueInstantiator.canCreateUsingDefault()) {\n+        deserializer = builder.buildAbstract();\n+    } else {\n+        deserializer = builder.build();\n+    }\n+    // may have modifier(s) that want to modify or replace serializer we just built\n+    // (note that `resolve()` and `createContextual()` called later on)\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, builderDesc, builder);\n-        }\n-    }\n-    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n-    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n-    if (_factoryConfig.hasDeserializerModifiers()) {\n-        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@SuppressWarnings(\"unchecked\")\npublic JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n    // First: check what creators we can use, if any\n    ValueInstantiator valueInstantiator;\n    try {\n        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n    } catch (NoClassDefFoundError error) {\n        return new ErrorThrowingDeserializer(error);\n    } catch (IllegalArgumentException e) {\n        // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n        //   to throw proper exception, it doesn't actually have reference to this\n        //   instance so...\n        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n    }\n    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n    builder.setValueInstantiator(valueInstantiator);\n    // And then setters for deserializing from JSON Object\n    addBeanProps(ctxt, beanDesc, builder);\n    addObjectIdReader(ctxt, beanDesc, builder);\n    // managed/back reference fields/setters need special handling... first part\n    addBackReferenceProperties(ctxt, beanDesc, builder);\n    addInjectables(ctxt, beanDesc, builder);\n    final DeserializationConfig config = ctxt.getConfig();\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonDeserializer<?> deserializer;\n    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n        deserializer = builder.buildAbstract();\n    } else {\n        deserializer = builder.build();\n    }\n    // may have modifier(s) that wants to modify or replace serializer we just built\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    // resolve deserializer and create contextual instances (if requested)\n    deserializer = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n    if (deserializer != null) {\n        deserializer = ctxt.handlePrimaryContextualization(deserializer, beanDesc);\n    }\n    if (_factoryConfig.hasDeserializerModifiers()) {\n        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n        }\n    }\n    return (JsonDeserializer<Object>) deserializer;\n}", "diff": "--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBeanDeserializer\n@@ -2,7 +2,7 @@\n public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n     // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n-        try {\n+    try {\n         valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n@@ -33,7 +33,16 @@\n         deserializer = builder.build();\n     }\n     // may have modifier(s) that wants to modify or replace serializer we just built\n-    // (note that `resolve()` and `createContextual()` called later on)\n+    if (_factoryConfig.hasDeserializerModifiers()) {\n+        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+        }\n+    }\n+    // resolve deserializer and create contextual instances (if requested)\n+    deserializer = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n+    if (deserializer != null) {\n+        deserializer = ctxt.handlePrimaryContextualization(deserializer, beanDesc);\n+    }\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n             deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n--- com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n+++ com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java@buildBuilderBasedDeserializer\n@@ -1,48 +1,51 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException {\n-    // Creators, anyone? (to create builder itself)\n+public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException {\n+    // First: check what creators we can use, if any\n     ValueInstantiator valueInstantiator;\n     try {\n-        valueInstantiator = findValueInstantiator(ctxt, builderDesc);\n+        valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n     } catch (NoClassDefFoundError error) {\n         return new ErrorThrowingDeserializer(error);\n     } catch (IllegalArgumentException e) {\n         // 05-Apr-2017, tatu: Although it might appear cleaner to require collector\n         //   to throw proper exception, it doesn't actually have reference to this\n         //   instance so...\n-        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), builderDesc, null);\n+        throw InvalidDefinitionException.from(ctxt.getParser(), e.getMessage(), beanDesc, null);\n     }\n+    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n+    builder.setValueInstantiator(valueInstantiator);\n+    // And then setters for deserializing from JSON Object\n+    addBeanProps(ctxt, beanDesc, builder);\n+    addObjectIdReader(ctxt, beanDesc, builder);\n+    // managed/back reference fields/setters need special handling... first part\n+    addBackReferenceProperties(ctxt, beanDesc, builder);\n+    addInjectables(ctxt, beanDesc, builder);\n     final DeserializationConfig config = ctxt.getConfig();\n-    BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, builderDesc);\n-    builder.setValueInstantiator(valueInstantiator);\n-    // And then \"with methods\" for deserializing from JSON Object\n-    addBeanProps(ctxt, builderDesc, builder);\n-    addObjectIdReader(ctxt, builderDesc, builder);\n-    // managed/back reference fields/setters need special handling... first part\n-    addBackReferenceProperties(ctxt, builderDesc, builder);\n-    addInjectables(ctxt, builderDesc, builder);\n-    JsonPOJOBuilder.Value builderConfig = builderDesc.findPOJOBuilderConfig();\n-    final String buildMethodName = (builderConfig == null) ? JsonPOJOBuilder.DEFAULT_BUILD_METHOD : builderConfig.buildMethodName;\n-    // and lastly, find build method to use:\n-    AnnotatedMethod buildMethod = builderDesc.findMethod(buildMethodName, null);\n-    if (buildMethod != null) {\n-        // note: can't yet throw error; may be given build method\n-        if (config.canOverrideAccessModifiers()) {\n-            ClassUtil.checkAndFixAccess(buildMethod.getMember(), config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+    if (_factoryConfig.hasDeserializerModifiers()) {\n+        for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+            builder = mod.updateBuilder(config, beanDesc, builder);\n         }\n     }\n-    builder.setPOJOBuilder(buildMethod, builderConfig);\n-    // this may give us more information...\n+    JsonDeserializer<?> deserializer;\n+    if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n+        deserializer = builder.buildAbstract();\n+    } else {\n+        deserializer = builder.build();\n+    }\n+    // may have modifier(s) that wants to modify or replace serializer we just built\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            builder = mod.updateBuilder(config, builderDesc, builder);\n+            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n         }\n     }\n-    JsonDeserializer<?> deserializer = builder.buildBuilderBased(valueType, buildMethodName);\n-    // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n+    // resolve deserializer and create contextual instances (if requested)\n+    deserializer = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n+    if (deserializer != null) {\n+        deserializer = ctxt.handlePrimaryContextualization(deserializer, beanDesc);\n+    }\n     if (_factoryConfig.hasDeserializerModifiers()) {\n         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-            deserializer = mod.modifyDeserializer(config, builderDesc, deserializer);\n+            deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n         }\n     }\n     return (JsonDeserializer<Object>) deserializer;\n", "finish_reason": "stop", "valid": false, "num": 1}]