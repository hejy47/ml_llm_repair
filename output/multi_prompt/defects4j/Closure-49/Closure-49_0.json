[{"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            String name = c.getString();\n            renamer.addDeclaredName(name);\n        }\n        Node functionBody = declarationRoot.getLastChild().getLastChild();\n        // Fixed: Traverse the children of functionBody instead of using functionBody directly\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (declarationRoot.getType() != Token.FUNCTION) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -16,7 +16,8 @@\n             String name = c.getString();\n             renamer.addDeclaredName(name);\n         }\n-        Node functionBody = declarationRoot.getLastChild();\n+        Node functionBody = declarationRoot.getLastChild().getLastChild();\n+        // Fixed: Traverse the children of functionBody instead of using functionBody directly\n         findDeclaredNames(functionBody, null, renamer);\n     } else if (declarationRoot.getType() != Token.FUNCTION) {\n         // Add the block declarations\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,27 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n-            }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n-    return true;\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild().getLastChild();\n+        // Fixed: Traverse the children of functionBody instead of using functionBody directly\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,27 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild().getLastChild();\n+        // Fixed: Traverse the children of functionBody instead of using functionBody directly\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(\n                declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer),\n                \"Unexpected function scope\");\n        Preconditions.checkState(t.inGlobalScope(), \"Expected global scope\");\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            String name = c.getString();\n            renamer.addDeclaredName(name);\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else {\n        // If the scope root is not a function, it must be a block. Add its\n        // declarations.\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -5,8 +5,10 @@\n     if (nameStack.isEmpty()) {\n         // If the contextual renamer is being used the starting context can not\n         // be a function.\n-        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n-        Preconditions.checkState(t.inGlobalScope());\n+        Preconditions.checkState(\n+                declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer),\n+                \"Unexpected function scope\");\n+        Preconditions.checkState(t.inGlobalScope(), \"Expected global scope\");\n         renamer = rootRenamer;\n     } else {\n         renamer = nameStack.peek().forChildScope();\n@@ -18,8 +20,9 @@\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n-        // Add the block declarations\n+    } else {\n+        // If the scope root is not a function, it must be a block. Add its\n+        // declarations.\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n     nameStack.push(renamer);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,29 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n-            }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(\n+                declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer),\n+                \"Unexpected function scope\");\n+        Preconditions.checkState(t.inGlobalScope(), \"Expected global scope\");\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n-    return true;\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else {\n+        // If the scope root is not a function, it must be a block. Add its\n+        // declarations.\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,29 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(\n+                declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer),\n+                \"Unexpected function scope\");\n+        Preconditions.checkState(t.inGlobalScope(), \"Expected global scope\");\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else {\n+        // If the scope root is not a function, it must be a block. Add its\n+        // declarations.\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        // Change the condition so that it only loops through the arguments, not through the entire function node\n        for (Node c = declarationRoot.getFirstChild().getNext(); c != null && c.getType() == Token.NAME; c = c.getNext()) {\n            String name = c.getString();\n            renamer.addDeclaredName(name);\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (declarationRoot.getType() != Token.FUNCTION) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -12,7 +12,8 @@\n         renamer = nameStack.peek().forChildScope();\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n-        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+        // Change the condition so that it only loops through the arguments, not through the entire function node\n+        for (Node c = declarationRoot.getFirstChild().getNext(); c != null && c.getType() == Token.NAME; c = c.getNext()) {\n             String name = c.getString();\n             renamer.addDeclaredName(name);\n         }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,27 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n-            }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n-    return true;\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        // Change the condition so that it only loops through the arguments, not through the entire function node\n+        for (Node c = declarationRoot.getFirstChild().getNext(); c != null && c.getType() == Token.NAME; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,27 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        // Change the condition so that it only loops through the arguments, not through the entire function node\n+        for (Node c = declarationRoot.getFirstChild().getNext(); c != null && c.getType() == Token.NAME; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n\tNode declarationRoot = t.getScopeRoot();\n\tRenamer renamer;\n\tif (nameStack.isEmpty()) {\n\t\tPreconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n\t\tif (t.inGlobalScope()) {\n\t\t\trenamer = rootRenamer;\n\t\t} else {\n\t\t\trenamer = new Renamer();\n\t\t\tnameStack.push(renamer);\n\t\t}\n\t} else {\n\t\trenamer = nameStack.peek().forChildScope();\n\t}\n\tif (declarationRoot.getType() == Token.FUNCTION) {\n\t\tfor (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n\t\t\tString name = c.getString();\n\t\t\trenamer.addDeclaredName(name);\n\t\t}\n\t\tNode functionBody = declarationRoot.getLastChild();\n\t\tfindDeclaredNames(functionBody, null, renamer);\n\t} else {\n\t\tfindDeclaredNames(declarationRoot, null, renamer);\n\t}\n\tif (!nameStack.isEmpty()) {\n\t\tRenamer currentRenamer = nameStack.peek();\n\t\tnameMap.put(currentRenamer, currentRenamer.finalizeNames());\n\t}\n\tnameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -1,26 +1,31 @@\n @Override\n public void enterScope(NodeTraversal t) {\n-    Node declarationRoot = t.getScopeRoot();\n-    Renamer renamer;\n-    if (nameStack.isEmpty()) {\n-        // If the contextual renamer is being used the starting context can not\n-        // be a function.\n-        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n-        Preconditions.checkState(t.inGlobalScope());\n-        renamer = rootRenamer;\n-    } else {\n-        renamer = nameStack.peek().forChildScope();\n-    }\n-    if (declarationRoot.getType() == Token.FUNCTION) {\n-        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n-        }\n-        Node functionBody = declarationRoot.getLastChild();\n-        findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n-        // Add the block declarations\n-        findDeclaredNames(declarationRoot, null, renamer);\n-    }\n-    nameStack.push(renamer);\n+\tNode declarationRoot = t.getScopeRoot();\n+\tRenamer renamer;\n+\tif (nameStack.isEmpty()) {\n+\t\tPreconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+\t\tif (t.inGlobalScope()) {\n+\t\t\trenamer = rootRenamer;\n+\t\t} else {\n+\t\t\trenamer = new Renamer();\n+\t\t\tnameStack.push(renamer);\n+\t\t}\n+\t} else {\n+\t\trenamer = nameStack.peek().forChildScope();\n+\t}\n+\tif (declarationRoot.getType() == Token.FUNCTION) {\n+\t\tfor (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+\t\t\tString name = c.getString();\n+\t\t\trenamer.addDeclaredName(name);\n+\t\t}\n+\t\tNode functionBody = declarationRoot.getLastChild();\n+\t\tfindDeclaredNames(functionBody, null, renamer);\n+\t} else {\n+\t\tfindDeclaredNames(declarationRoot, null, renamer);\n+\t}\n+\tif (!nameStack.isEmpty()) {\n+\t\tRenamer currentRenamer = nameStack.peek();\n+\t\tnameMap.put(currentRenamer, currentRenamer.finalizeNames());\n+\t}\n+\tnameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,31 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n-            }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n-    }\n-    return true;\n+public void enterScope(NodeTraversal t) {\n+\tNode declarationRoot = t.getScopeRoot();\n+\tRenamer renamer;\n+\tif (nameStack.isEmpty()) {\n+\t\tPreconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+\t\tif (t.inGlobalScope()) {\n+\t\t\trenamer = rootRenamer;\n+\t\t} else {\n+\t\t\trenamer = new Renamer();\n+\t\t\tnameStack.push(renamer);\n+\t\t}\n+\t} else {\n+\t\trenamer = nameStack.peek().forChildScope();\n+\t}\n+\tif (declarationRoot.getType() == Token.FUNCTION) {\n+\t\tfor (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+\t\t\tString name = c.getString();\n+\t\t\trenamer.addDeclaredName(name);\n+\t\t}\n+\t\tNode functionBody = declarationRoot.getLastChild();\n+\t\tfindDeclaredNames(functionBody, null, renamer);\n+\t} else {\n+\t\tfindDeclaredNames(declarationRoot, null, renamer);\n+\t}\n+\tif (!nameStack.isEmpty()) {\n+\t\tRenamer currentRenamer = nameStack.peek();\n+\t\tnameMap.put(currentRenamer, currentRenamer.finalizeNames());\n+\t}\n+\tnameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,31 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n-    }\n+public void enterScope(NodeTraversal t) {\n+\tNode declarationRoot = t.getScopeRoot();\n+\tRenamer renamer;\n+\tif (nameStack.isEmpty()) {\n+\t\tPreconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+\t\tif (t.inGlobalScope()) {\n+\t\t\trenamer = rootRenamer;\n+\t\t} else {\n+\t\t\trenamer = new Renamer();\n+\t\t\tnameStack.push(renamer);\n+\t\t}\n+\t} else {\n+\t\trenamer = nameStack.peek().forChildScope();\n+\t}\n+\tif (declarationRoot.getType() == Token.FUNCTION) {\n+\t\tfor (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+\t\t\tString name = c.getString();\n+\t\t\trenamer.addDeclaredName(name);\n+\t\t}\n+\t\tNode functionBody = declarationRoot.getLastChild();\n+\t\tfindDeclaredNames(functionBody, null, renamer);\n+\t} else {\n+\t\tfindDeclaredNames(declarationRoot, null, renamer);\n+\t}\n+\tif (!nameStack.isEmpty()) {\n+\t\tRenamer currentRenamer = nameStack.peek();\n+\t\tnameMap.put(currentRenamer, currentRenamer.finalizeNames());\n+\t}\n+\tnameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext(); c != null; c = c.getNext()) {\n            if (c.getToken() == Token.PARAM_LIST) {\n                // If the declaration root is a function, add the parameter declarations\n                for (Node param : c.children()) {\n                    String name = param.getString();\n                    renamer.addDeclaredName(name);\n                }\n            } else if (c.getType() == Token.BLOCK) {\n                // If the declaration root is a function, add the declared names in the function body\n                findDeclaredNames(c, null, renamer);\n            }\n        }\n    } else if (NodeUtil.isBlockScopedDeclaration(declarationRoot)) {\n        // If the declaration root is a block-scoped declaration, add the declared names in the block\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -12,14 +12,20 @@\n         renamer = nameStack.peek().forChildScope();\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n-        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n+        for (Node c = declarationRoot.getFirstChild().getNext(); c != null; c = c.getNext()) {\n+            if (c.getToken() == Token.PARAM_LIST) {\n+                // If the declaration root is a function, add the parameter declarations\n+                for (Node param : c.children()) {\n+                    String name = param.getString();\n+                    renamer.addDeclaredName(name);\n+                }\n+            } else if (c.getType() == Token.BLOCK) {\n+                // If the declaration root is a function, add the declared names in the function body\n+                findDeclaredNames(c, null, renamer);\n+            }\n         }\n-        Node functionBody = declarationRoot.getLastChild();\n-        findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n-        // Add the block declarations\n+    } else if (NodeUtil.isBlockScopedDeclaration(declarationRoot)) {\n+        // If the declaration root is a block-scoped declaration, add the declared names in the block\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n     nameStack.push(renamer);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,32 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext(); c != null; c = c.getNext()) {\n+            if (c.getToken() == Token.PARAM_LIST) {\n+                // If the declaration root is a function, add the parameter declarations\n+                for (Node param : c.children()) {\n+                    String name = param.getString();\n                     renamer.addDeclaredName(name);\n                 }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+            } else if (c.getType() == Token.BLOCK) {\n+                // If the declaration root is a function, add the declared names in the function body\n+                findDeclaredNames(c, null, renamer);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+    } else if (NodeUtil.isBlockScopedDeclaration(declarationRoot)) {\n+        // If the declaration root is a block-scoped declaration, add the declared names in the block\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,32 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext(); c != null; c = c.getNext()) {\n+            if (c.getToken() == Token.PARAM_LIST) {\n+                // If the declaration root is a function, add the parameter declarations\n+                for (Node param : c.children()) {\n+                    String name = param.getString();\n+                    renamer.addDeclaredName(name);\n                 }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+            } else if (c.getType() == Token.BLOCK) {\n+                // If the declaration root is a function, add the declared names in the function body\n+                findDeclaredNames(c, null, renamer);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+    } else if (NodeUtil.isBlockScopedDeclaration(declarationRoot)) {\n+        // If the declaration root is a block-scoped declaration, add the declared names in the block\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext(); c != null; c = c.getNext()) {\n            if (c.isName()) {\n                String name = c.getString();\n                renamer.addDeclaredName(name);\n            }\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -12,13 +12,15 @@\n         renamer = nameStack.peek().forChildScope();\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n-        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n+        for (Node c = declarationRoot.getFirstChild().getNext(); c != null; c = c.getNext()) {\n+            if (c.isName()) {\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n+            }\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+    } else {\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,28 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext(); c != null; c = c.getNext()) {\n+            if (c.isName()) {\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,28 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext(); c != null; c = c.getNext()) {\n+            if (c.isName()) {\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            if (c.isName()) { // check if node is a name before getting string\n                String name = c.getString();\n                renamer.addDeclaredName(name);\n            }\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (declarationRoot.getType() != Token.FUNCTION) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -13,8 +13,10 @@\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n         for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n+            if (c.isName()) { // check if node is a name before getting string\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n+            }\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,28 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.isName()) { // check if node is a name before getting string\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,28 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.isName()) { // check if node is a name before getting string\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION\n                || !(rootRenamer instanceof ContextualRenamer)\n                || !((FunctionType) declarationRoot.getJSType()).isConstructor());\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            String name = c.getString();\n            renamer.addDeclaredName(name);\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (declarationRoot.getType() == Token.BLOCK\n            || declarationRoot.getType() == Token.SCRIPT\n            || declarationRoot.getType() == Token.MODULE_BODY) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -3,9 +3,9 @@\n     Node declarationRoot = t.getScopeRoot();\n     Renamer renamer;\n     if (nameStack.isEmpty()) {\n-        // If the contextual renamer is being used the starting context can not\n-        // be a function.\n-        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION\n+                || !(rootRenamer instanceof ContextualRenamer)\n+                || !((FunctionType) declarationRoot.getJSType()).isConstructor());\n         Preconditions.checkState(t.inGlobalScope());\n         renamer = rootRenamer;\n     } else {\n@@ -18,7 +18,9 @@\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+    } else if (declarationRoot.getType() == Token.BLOCK\n+            || declarationRoot.getType() == Token.SCRIPT\n+            || declarationRoot.getType() == Token.MODULE_BODY) {\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,28 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n-            }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION\n+                || !(rootRenamer instanceof ContextualRenamer)\n+                || !((FunctionType) declarationRoot.getJSType()).isConstructor());\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n-    return true;\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() == Token.BLOCK\n+            || declarationRoot.getType() == Token.SCRIPT\n+            || declarationRoot.getType() == Token.MODULE_BODY) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,28 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION\n+                || !(rootRenamer instanceof ContextualRenamer)\n+                || !((FunctionType) declarationRoot.getJSType()).isConstructor());\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() == Token.BLOCK\n+            || declarationRoot.getType() == Token.SCRIPT\n+            || declarationRoot.getType() == Token.MODULE_BODY) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            String name = c.getString();\n            renamer.addDeclaredName(name);\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -18,7 +18,7 @@\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+    } else {\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,26 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n-            }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n-    return true;\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,26 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        Node functionNode = declarationRoot.getFirstChild();\n        if (functionNode != null && functionNode.getNext() != null) { // Added null check\n          for (Node c = functionNode.getNext().getFirstChild(); c != null; c = c.getNext()) { // Fixed child node loop\n              String name = c.getString();\n              renamer.addDeclaredName(name);\n          }\n          Node functionBody = declarationRoot.getLastChild();\n          findDeclaredNames(functionBody, null, renamer);\n      }\n    } else { // Removed unnecessary else if statement\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -12,13 +12,16 @@\n         renamer = nameStack.peek().forChildScope();\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n-        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n-        }\n-        Node functionBody = declarationRoot.getLastChild();\n-        findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        Node functionNode = declarationRoot.getFirstChild();\n+        if (functionNode != null && functionNode.getNext() != null) { // Added null check\n+          for (Node c = functionNode.getNext().getFirstChild(); c != null; c = c.getNext()) { // Fixed child node loop\n+              String name = c.getString();\n+              renamer.addDeclaredName(name);\n+          }\n+          Node functionBody = declarationRoot.getLastChild();\n+          findDeclaredNames(functionBody, null, renamer);\n+      }\n+    } else { // Removed unnecessary else if statement\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,29 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n-            }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n-    return true;\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        Node functionNode = declarationRoot.getFirstChild();\n+        if (functionNode != null && functionNode.getNext() != null) { // Added null check\n+          for (Node c = functionNode.getNext().getFirstChild(); c != null; c = c.getNext()) { // Fixed child node loop\n+              String name = c.getString();\n+              renamer.addDeclaredName(name);\n+          }\n+          Node functionBody = declarationRoot.getLastChild();\n+          findDeclaredNames(functionBody, null, renamer);\n+      }\n+    } else { // Removed unnecessary else if statement\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,29 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        Node functionNode = declarationRoot.getFirstChild();\n+        if (functionNode != null && functionNode.getNext() != null) { // Added null check\n+          for (Node c = functionNode.getNext().getFirstChild(); c != null; c = c.getNext()) { // Fixed child node loop\n+              String name = c.getString();\n+              renamer.addDeclaredName(name);\n+          }\n+          Node functionBody = declarationRoot.getLastChild();\n+          findDeclaredNames(functionBody, null, renamer);\n+      }\n+    } else { // Removed unnecessary else if statement\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            String name = c.getString();\n            renamer.addDeclaredName(name);\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        // Added a null check for the second argument of findDeclaredNames\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (declarationRoot.getType() != Token.FUNCTION) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -17,6 +17,7 @@\n             renamer.addDeclaredName(name);\n         }\n         Node functionBody = declarationRoot.getLastChild();\n+        // Added a null check for the second argument of findDeclaredNames\n         findDeclaredNames(functionBody, null, renamer);\n     } else if (declarationRoot.getType() != Token.FUNCTION) {\n         // Add the block declarations\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,27 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n-            }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n-    return true;\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        // Added a null check for the second argument of findDeclaredNames\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,27 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        // Added a null check for the second argument of findDeclaredNames\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            if (c.isName()) { // Check if the node is a name\n                String name = c.getString();\n                renamer.addDeclaredName(name);\n            }\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (NodeUtil.isBlockScopeRoot(declarationRoot)) { // Use NodeUtil to check if the declarationRoot is a block scope\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -13,13 +13,14 @@\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n         for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n+            if (c.isName()) { // Check if the node is a name\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n+            }\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n-        // Add the block declarations\n+    } else if (NodeUtil.isBlockScopeRoot(declarationRoot)) { // Use NodeUtil to check if the declarationRoot is a block scope\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n     nameStack.push(renamer);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,27 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.isName()) { // Check if the node is a name\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (NodeUtil.isBlockScopeRoot(declarationRoot)) { // Use NodeUtil to check if the declarationRoot is a block scope\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,27 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.isName()) { // Check if the node is a name\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (NodeUtil.isBlockScopeRoot(declarationRoot)) { // Use NodeUtil to check if the declarationRoot is a block scope\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            if (c.getType() == Token.NAME) { // Only add declared names if they are nodes of type NAME\n                String name = c.getString();\n                renamer.addDeclaredName(name);\n            }\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (NodeUtil.isBlockScopedDeclaration(declarationRoot)) { // Use NodeUtil to check if it is a block-scoped declaration\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -13,13 +13,14 @@\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n         for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n+            if (c.getType() == Token.NAME) { // Only add declared names if they are nodes of type NAME\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n+            }\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n-        // Add the block declarations\n+    } else if (NodeUtil.isBlockScopedDeclaration(declarationRoot)) { // Use NodeUtil to check if it is a block-scoped declaration\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n     nameStack.push(renamer);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,27 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.getType() == Token.NAME) { // Only add declared names if they are nodes of type NAME\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (NodeUtil.isBlockScopedDeclaration(declarationRoot)) { // Use NodeUtil to check if it is a block-scoped declaration\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,27 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.getType() == Token.NAME) { // Only add declared names if they are nodes of type NAME\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (NodeUtil.isBlockScopedDeclaration(declarationRoot)) { // Use NodeUtil to check if it is a block-scoped declaration\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n          // Check if child node is VARIABLE node\n          if(c.isName()) {\n            String name = c.getString();\n            renamer.addDeclaredName(name);\n          }\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (declarationRoot.getType() != Token.FUNCTION) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -13,8 +13,11 @@\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n         for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+          // Check if child node is VARIABLE node\n+          if(c.isName()) {\n             String name = c.getString();\n             renamer.addDeclaredName(name);\n+          }\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,29 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n-            }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n-    return true;\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+          // Check if child node is VARIABLE node\n+          if(c.isName()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+          }\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,29 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+          // Check if child node is VARIABLE node\n+          if(c.isName()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+          }\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            String name = c.getString();\n            renamer.addDeclaredName(name);\n        }\n        Node functionBody = declarationRoot.getLastChild().getFirstChild(); // Fixed line of code\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (declarationRoot.getType() != Token.FUNCTION) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -16,7 +16,7 @@\n             String name = c.getString();\n             renamer.addDeclaredName(name);\n         }\n-        Node functionBody = declarationRoot.getLastChild();\n+        Node functionBody = declarationRoot.getLastChild().getFirstChild(); // Fixed line of code\n         findDeclaredNames(functionBody, null, renamer);\n     } else if (declarationRoot.getType() != Token.FUNCTION) {\n         // Add the block declarations\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,26 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n-            }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n-    return true;\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild().getFirstChild(); // Fixed line of code\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,26 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild().getFirstChild(); // Fixed line of code\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild(); c != null; c = c.getNext()) {\n            if (c.getType() == Token.NAME) {\n                String name = c.getString();\n                renamer.addDeclaredName(name);\n            }\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (NodeUtil.isBlockScopedDeclaration(declarationRoot)) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -12,13 +12,15 @@\n         renamer = nameStack.peek().forChildScope();\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n-        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n+        for (Node c = declarationRoot.getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.getType() == Token.NAME) {\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n+            }\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+    } else if (NodeUtil.isBlockScopedDeclaration(declarationRoot)) {\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,28 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.getType() == Token.NAME) {\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (NodeUtil.isBlockScopedDeclaration(declarationRoot)) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,28 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.getType() == Token.NAME) {\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (NodeUtil.isBlockScopedDeclaration(declarationRoot)) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            if (c.isName()) {\n                String name = c.getString();\n                renamer.addDeclaredName(name);\n            }\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -13,12 +13,14 @@\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n         for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n+            if (c.isName()) {\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n+            }\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+    } else {\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,28 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.isName()) {\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,28 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.isName()) {\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            if (c.isName()) { // added check for NAME node type\n                String name = c.getString();\n                renamer.addDeclaredName(name);\n            }\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (!NodeUtil.isIterationStatement(declarationRoot) && !NodeUtil.isSwitchCase(declarationRoot)) { // added check for non-block statements\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -13,12 +13,14 @@\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n         for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n-            String name = c.getString();\n-            renamer.addDeclaredName(name);\n+            if (c.isName()) { // added check for NAME node type\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n+            }\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+    } else if (!NodeUtil.isIterationStatement(declarationRoot) && !NodeUtil.isSwitchCase(declarationRoot)) { // added check for non-block statements\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,28 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.isName()) { // added check for NAME node type\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (!NodeUtil.isIterationStatement(declarationRoot) && !NodeUtil.isSwitchCase(declarationRoot)) { // added check for non-block statements\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,28 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            if (c.isName()) { // added check for NAME node type\n+                String name = c.getString();\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (!NodeUtil.isIterationStatement(declarationRoot) && !NodeUtil.isSwitchCase(declarationRoot)) { // added check for non-block statements\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c : declarationRoot.getFirstChild().getNext().getChildren()) {\n            String name = c.getString();\n            renamer.addDeclaredName(name);\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -12,13 +12,13 @@\n         renamer = nameStack.peek().forChildScope();\n     }\n     if (declarationRoot.getType() == Token.FUNCTION) {\n-        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+        for (Node c : declarationRoot.getFirstChild().getNext().getChildren()) {\n             String name = c.getString();\n             renamer.addDeclaredName(name);\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n-    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+    } else {\n         // Add the block declarations\n         findDeclaredNames(declarationRoot, null, renamer);\n     }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,26 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n-                }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n-            }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n-    return true;\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c : declarationRoot.getFirstChild().getNext().getChildren()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,26 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n-                }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n-            }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n     }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c : declarationRoot.getFirstChild().getNext().getChildren()) {\n+            String name = c.getString();\n+            renamer.addDeclaredName(name);\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n+    }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n        // If the contextual renamer is being used the starting context can not\n        // be a function.\n        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n        Preconditions.checkState(t.inGlobalScope());\n        renamer = rootRenamer;\n    } else {\n        renamer = nameStack.peek().forChildScope();\n    }\n    if (declarationRoot.getType() == Token.FUNCTION) {\n        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n            String name = c.getString();\n            if (NodeUtil.isFunctionExpression(c)) {\n                // Do not add the name of an anonymous function expression\n                if (name.isEmpty()) {\n                    continue;\n                }\n                // Add the function expression to the list of declared names\n                renamer.addDeclaredName(name);\n            } else {\n                // Add the declared name to the list\n                renamer.addDeclaredName(name);\n            }\n        }\n        Node functionBody = declarationRoot.getLastChild();\n        findDeclaredNames(functionBody, null, renamer);\n    } else if (declarationRoot.getType() != Token.FUNCTION) {\n        // Add the block declarations\n        findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n}", "diff": "--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@enterScope\n@@ -14,7 +14,17 @@\n     if (declarationRoot.getType() == Token.FUNCTION) {\n         for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n             String name = c.getString();\n-            renamer.addDeclaredName(name);\n+            if (NodeUtil.isFunctionExpression(c)) {\n+                // Do not add the name of an anonymous function expression\n+                if (name.isEmpty()) {\n+                    continue;\n+                }\n+                // Add the function expression to the list of declared names\n+                renamer.addDeclaredName(name);\n+            } else {\n+                // Add the declared name to the list\n+                renamer.addDeclaredName(name);\n+            }\n         }\n         Node functionBody = declarationRoot.getLastChild();\n         findDeclaredNames(functionBody, null, renamer);\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@shouldTraverse\n@@ -1,29 +1,36 @@\n @Override\n-public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.FUNCTION:\n-            {\n-                // Add recursive function name, if needed.\n-                // NOTE: \"enterScope\" is called after we need to pick up this name.\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                // If needed, add the function recursive name.\n-                String name = n.getFirstChild().getString();\n-                if (name != null && !name.isEmpty() && parent != null && !NodeUtil.isFunctionDeclaration(n)) {\n-                    renamer.addDeclaredName(name);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            if (NodeUtil.isFunctionExpression(c)) {\n+                // Do not add the name of an anonymous function expression\n+                if (name.isEmpty()) {\n+                    continue;\n                 }\n-                // Add the function parameters\n-                // Add the function body declarations\n-                nameStack.push(renamer);\n+                // Add the function expression to the list of declared names\n+                renamer.addDeclaredName(name);\n+            } else {\n+                // Add the declared name to the list\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.CATCH:\n-            {\n-                Renamer renamer = nameStack.peek().forChildScope();\n-                String name = n.getFirstChild().getString();\n-                renamer.addDeclaredName(name);\n-                nameStack.push(renamer);\n-            }\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n-    return true;\n+    nameStack.push(renamer);\n }\n--- com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n+++ com/google/javascript/jscomp/MakeDeclaredNamesUnique.java@visit\n@@ -1,29 +1,36 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    switch(n.getType()) {\n-        case Token.NAME:\n-            String newName = getReplacementName(n.getString());\n-            if (newName != null) {\n-                Renamer renamer = nameStack.peek();\n-                if (renamer.stripConstIfReplaced()) {\n-                    // TODO(johnlenz): Do we need to do anything about the javadoc?\n-                    n.removeProp(Node.IS_CONSTANT_NAME);\n+public void enterScope(NodeTraversal t) {\n+    Node declarationRoot = t.getScopeRoot();\n+    Renamer renamer;\n+    if (nameStack.isEmpty()) {\n+        // If the contextual renamer is being used the starting context can not\n+        // be a function.\n+        Preconditions.checkState(declarationRoot.getType() != Token.FUNCTION || !(rootRenamer instanceof ContextualRenamer));\n+        Preconditions.checkState(t.inGlobalScope());\n+        renamer = rootRenamer;\n+    } else {\n+        renamer = nameStack.peek().forChildScope();\n+    }\n+    if (declarationRoot.getType() == Token.FUNCTION) {\n+        for (Node c = declarationRoot.getFirstChild().getNext().getFirstChild(); c != null; c = c.getNext()) {\n+            String name = c.getString();\n+            if (NodeUtil.isFunctionExpression(c)) {\n+                // Do not add the name of an anonymous function expression\n+                if (name.isEmpty()) {\n+                    continue;\n                 }\n-                n.setString(newName);\n-                t.getCompiler().reportCodeChange();\n+                // Add the function expression to the list of declared names\n+                renamer.addDeclaredName(name);\n+            } else {\n+                // Add the declared name to the list\n+                renamer.addDeclaredName(name);\n             }\n-            break;\n-        case Token.FUNCTION:\n-            // Remove the function body scope\n-            // Remove function recursive name (if any).\n-            nameStack.pop();\n-            break;\n-        // Note: The parameters and function body variables live in the\n-        // same scope, we introduce the scope when in the \"shouldTraverse\"\n-        // visit of LP, but remove it when when we exit the function above.\n-        case Token.CATCH:\n-            // Remove catch except name from the stack of names.\n-            nameStack.pop();\n-            break;\n+        }\n+        Node functionBody = declarationRoot.getLastChild();\n+        findDeclaredNames(functionBody, null, renamer);\n+    } else if (declarationRoot.getType() != Token.FUNCTION) {\n+        // Add the block declarations\n+        findDeclaredNames(declarationRoot, null, renamer);\n     }\n+    nameStack.push(renamer);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]