[{"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        JSType resolved = safeResolve(iface, t, scope);\n        if (resolved instanceof ObjectType) {\n            resolvedInterfaces.add((ObjectType) resolved);\n            changed = true;   \n        } else {\n            resolvedInterfaces.add(iface);\n        }\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            subTypes.set(i, (FunctionType) safeResolve(subTypes.get(i), t, scope));\n        }\n    }\n    return super.resolveInternal(t, scope);\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,41 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = (ArrowType) safeResolve(call, t, scope);\n+    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n+    // is handled further upstream.\n+    //\n+    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n+    //\n+    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n+    // activation object. In ES5, it leaves it as null. Just punt on this\n+    // issue for now by coercing out null. This is complicated by the\n+    // fact that when most people write @this {Foo}, they really don't\n+    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n+    // the name for them.\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    if (maybeTypeOfThis instanceof ObjectType) {\n+        typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n+    for (ObjectType iface : implementedInterfaces) {\n+        JSType resolved = safeResolve(iface, t, scope);\n+        if (resolved instanceof ObjectType) {\n+            resolvedInterfaces.add((ObjectType) resolved);\n+            changed = true;   \n+        } else {\n+            resolvedInterfaces.add(iface);\n+        }\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+            subTypes.set(i, (FunctionType) safeResolve(subTypes.get(i), t, scope));\n+        }\n+    }\n+    return super.resolveInternal(t, scope);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -21,16 +21,20 @@\n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n-        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n-        resolvedInterfaces.add(resolvedIface);\n-        changed |= (resolvedIface != iface);\n+        JSType resolved = safeResolve(iface, t, scope);\n+        if (resolved instanceof ObjectType) {\n+            resolvedInterfaces.add((ObjectType) resolved);\n+            changed = true;   \n+        } else {\n+            resolvedInterfaces.add(iface);\n+        }\n     }\n     if (changed) {\n         implementedInterfaces = resolvedInterfaces.build();\n     }\n     if (subTypes != null) {\n         for (int i = 0; i < subTypes.size(); i++) {\n-            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+            subTypes.set(i, (FunctionType) safeResolve(subTypes.get(i), t, scope));\n         }\n     }\n     return super.resolveInternal(t, scope);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis != null && maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        JSType resolvedIface = safeResolve(iface, t, scope);\n        if (resolvedIface instanceof ObjectType) {\n            resolvedInterfaces.add((ObjectType) resolvedIface);\n            changed |= (resolvedIface != iface);\n        }\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            JSType resolvedSubType = safeResolve(subTypes.get(i), t, scope);\n            if (resolvedSubType instanceof FunctionType) {\n                subTypes.set(i, (FunctionType) resolvedSubType);\n            }\n        }\n    }\n    return super.resolveInternal(t, scope);\n}\n\n# Explanation\n1. Fixed handling of typeOfThis: Check if maybeTypeOfThis is not null before checking instanceof to prevent possible NullPointerException.\n2. Fixed handling of implementedInterfaces: Check if resolvedIface is an instance of ObjectType before adding it to resolvedInterfaces and setting changed to true. Also, handle the case where safeResolve returns null for any elements in implementedInterfaces.\n3. Fixed handling of subTypes: Check if resolvedSubType is an instance of FunctionType before setting it at index i in subTypes. Also, handle the case where safeResolve returns null for any elements in subTypes.", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,31 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = (ArrowType) safeResolve(call, t, scope);\n+    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    if (maybeTypeOfThis != null && maybeTypeOfThis instanceof ObjectType) {\n+        typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n+    for (ObjectType iface : implementedInterfaces) {\n+        JSType resolvedIface = safeResolve(iface, t, scope);\n+        if (resolvedIface instanceof ObjectType) {\n+            resolvedInterfaces.add((ObjectType) resolvedIface);\n+            changed |= (resolvedIface != iface);\n+        }\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+            JSType resolvedSubType = safeResolve(subTypes.get(i), t, scope);\n+            if (resolvedSubType instanceof FunctionType) {\n+                subTypes.set(i, (FunctionType) resolvedSubType);\n+            }\n+        }\n+    }\n+    return super.resolveInternal(t, scope);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -3,34 +3,28 @@\n     setResolvedTypeInternal(this);\n     call = (ArrowType) safeResolve(call, t, scope);\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n-    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n-    // is handled further upstream.\n-    //\n-    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    //\n-    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n-    // activation object. In ES5, it leaves it as null. Just punt on this\n-    // issue for now by coercing out null. This is complicated by the\n-    // fact that when most people write @this {Foo}, they really don't\n-    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n-    // the name for them.\n     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n-    if (maybeTypeOfThis instanceof ObjectType) {\n+    if (maybeTypeOfThis != null && maybeTypeOfThis instanceof ObjectType) {\n         typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n-        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n-        resolvedInterfaces.add(resolvedIface);\n-        changed |= (resolvedIface != iface);\n+        JSType resolvedIface = safeResolve(iface, t, scope);\n+        if (resolvedIface instanceof ObjectType) {\n+            resolvedInterfaces.add((ObjectType) resolvedIface);\n+            changed |= (resolvedIface != iface);\n+        }\n     }\n     if (changed) {\n         implementedInterfaces = resolvedInterfaces.build();\n     }\n     if (subTypes != null) {\n         for (int i = 0; i < subTypes.size(); i++) {\n-            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+            JSType resolvedSubType = safeResolve(subTypes.get(i), t, scope);\n+            if (resolvedSubType instanceof FunctionType) {\n+                subTypes.set(i, (FunctionType) resolvedSubType);\n+            }\n         }\n     }\n     return super.resolveInternal(t, scope);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis != null && maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n        resolvedInterfaces.add(resolvedIface);\n        changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n        }\n    }\n    return super.resolveInternal(t, scope);\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,37 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = (ArrowType) safeResolve(call, t, scope);\n+    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n+    // is handled further upstream.\n+    //\n+    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n+    //\n+    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n+    // activation object. In ES5, it leaves it as null. Just punt on this\n+    // issue for now by coercing out null. This is complicated by the\n+    // fact that when most people write @this {Foo}, they really don't\n+    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n+    // the name for them.\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    if (maybeTypeOfThis != null && maybeTypeOfThis instanceof ObjectType) {\n+        typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n+    for (ObjectType iface : implementedInterfaces) {\n+        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n+        resolvedInterfaces.add(resolvedIface);\n+        changed |= (resolvedIface != iface);\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+        }\n+    }\n+    return super.resolveInternal(t, scope);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -15,7 +15,7 @@\n     // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n     // the name for them.\n     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n-    if (maybeTypeOfThis instanceof ObjectType) {\n+    if (maybeTypeOfThis != null && maybeTypeOfThis instanceof ObjectType) {\n         typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n     boolean changed = false;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = safeResolve(call, t, scope).autobox();\n    prototype = safeResolve(prototype, t, scope).autobox();\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope).autobox();\n    if (maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope).autobox();\n        resolvedInterfaces.add(resolvedIface);\n        changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n        }\n    }\n    return super.resolveInternal(t, scope);\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,37 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = safeResolve(call, t, scope).autobox();\n+    prototype = safeResolve(prototype, t, scope).autobox();\n+    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n+    // is handled further upstream.\n+    //\n+    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n+    //\n+    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n+    // activation object. In ES5, it leaves it as null. Just punt on this\n+    // issue for now by coercing out null. This is complicated by the\n+    // fact that when most people write @this {Foo}, they really don't\n+    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n+    // the name for them.\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope).autobox();\n+    if (maybeTypeOfThis instanceof ObjectType) {\n+        typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n+    for (ObjectType iface : implementedInterfaces) {\n+        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope).autobox();\n+        resolvedInterfaces.add(resolvedIface);\n+        changed |= (resolvedIface != iface);\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+        }\n+    }\n+    return super.resolveInternal(t, scope);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -1,8 +1,8 @@\n @Override\n JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n     setResolvedTypeInternal(this);\n-    call = (ArrowType) safeResolve(call, t, scope);\n-    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    call = safeResolve(call, t, scope).autobox();\n+    prototype = safeResolve(prototype, t, scope).autobox();\n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     //\n@@ -14,14 +14,14 @@\n     // fact that when most people write @this {Foo}, they really don't\n     // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n     // the name for them.\n-    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope).autobox();\n     if (maybeTypeOfThis instanceof ObjectType) {\n         typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n-        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n+        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope).autobox();\n         resolvedInterfaces.add(resolvedIface);\n         changed |= (resolvedIface != iface);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (!(maybeTypeOfThis instanceof ObjectType) && maybeTypeOfThis != null) {\n        t.error(\"Expected an object type\", this);\n    } else {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        JSType resolvedType = safeResolve(iface, t, scope);\n        if (!(resolvedType instanceof ObjectType) && resolvedType != null) {\n            t.error(\"Expected an object type\", this);\n            continue;\n        }\n        ObjectType resolvedIface = (ObjectType) resolvedType;\n        resolvedInterfaces.add(resolvedIface);\n        changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            subTypes.set(i, (FunctionType) safeResolve(subTypes.get(i), t, scope));\n        }\n    }\n    return super.resolveInternal(t, scope);\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,33 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = (ArrowType) safeResolve(call, t, scope);\n+    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    if (!(maybeTypeOfThis instanceof ObjectType) && maybeTypeOfThis != null) {\n+        t.error(\"Expected an object type\", this);\n+    } else {\n+        typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n+    for (ObjectType iface : implementedInterfaces) {\n+        JSType resolvedType = safeResolve(iface, t, scope);\n+        if (!(resolvedType instanceof ObjectType) && resolvedType != null) {\n+            t.error(\"Expected an object type\", this);\n+            continue;\n+        }\n+        ObjectType resolvedIface = (ObjectType) resolvedType;\n+        resolvedInterfaces.add(resolvedIface);\n+        changed |= (resolvedIface != iface);\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+            subTypes.set(i, (FunctionType) safeResolve(subTypes.get(i), t, scope));\n+        }\n+    }\n+    return super.resolveInternal(t, scope);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -3,25 +3,21 @@\n     setResolvedTypeInternal(this);\n     call = (ArrowType) safeResolve(call, t, scope);\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n-    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n-    // is handled further upstream.\n-    //\n-    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    //\n-    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n-    // activation object. In ES5, it leaves it as null. Just punt on this\n-    // issue for now by coercing out null. This is complicated by the\n-    // fact that when most people write @this {Foo}, they really don't\n-    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n-    // the name for them.\n     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n-    if (maybeTypeOfThis instanceof ObjectType) {\n+    if (!(maybeTypeOfThis instanceof ObjectType) && maybeTypeOfThis != null) {\n+        t.error(\"Expected an object type\", this);\n+    } else {\n         typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n-        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n+        JSType resolvedType = safeResolve(iface, t, scope);\n+        if (!(resolvedType instanceof ObjectType) && resolvedType != null) {\n+            t.error(\"Expected an object type\", this);\n+            continue;\n+        }\n+        ObjectType resolvedIface = (ObjectType) resolvedType;\n         resolvedInterfaces.add(resolvedIface);\n         changed |= (resolvedIface != iface);\n     }\n@@ -30,7 +26,7 @@\n     }\n     if (subTypes != null) {\n         for (int i = 0; i < subTypes.size(); i++) {\n-            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+            subTypes.set(i, (FunctionType) safeResolve(subTypes.get(i), t, scope));\n         }\n     }\n     return super.resolveInternal(t, scope);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = safeResolve(call, t, scope);\n    prototype = safeResolve(prototype, t, scope);\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        ObjectType resolvedIface = (ObjectType) safeResolve(iface, t, scope);\n        resolvedInterfaces.add(resolvedIface);\n        changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            subTypes.set(i, (FunctionType) safeResolve(subTypes.get(i), t, scope));\n        }\n    }\n    return super.resolveInternal(t, scope);\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,37 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = safeResolve(call, t, scope);\n+    prototype = safeResolve(prototype, t, scope);\n+    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n+    // is handled further upstream.\n+    //\n+    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n+    //\n+    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n+    // activation object. In ES5, it leaves it as null. Just punt on this\n+    // issue for now by coercing out null. This is complicated by the\n+    // fact that when most people write @this {Foo}, they really don't\n+    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n+    // the name for them.\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    if (maybeTypeOfThis instanceof ObjectType) {\n+        typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n+    for (ObjectType iface : implementedInterfaces) {\n+        ObjectType resolvedIface = (ObjectType) safeResolve(iface, t, scope);\n+        resolvedInterfaces.add(resolvedIface);\n+        changed |= (resolvedIface != iface);\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+            subTypes.set(i, (FunctionType) safeResolve(subTypes.get(i), t, scope));\n+        }\n+    }\n+    return super.resolveInternal(t, scope);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -1,8 +1,8 @@\n @Override\n JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n     setResolvedTypeInternal(this);\n-    call = (ArrowType) safeResolve(call, t, scope);\n-    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    call = safeResolve(call, t, scope);\n+    prototype = safeResolve(prototype, t, scope);\n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     //\n@@ -21,7 +21,7 @@\n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n-        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n+        ObjectType resolvedIface = (ObjectType) safeResolve(iface, t, scope);\n         resolvedInterfaces.add(resolvedIface);\n         changed |= (resolvedIface != iface);\n     }\n@@ -30,7 +30,7 @@\n     }\n     if (subTypes != null) {\n         for (int i = 0; i < subTypes.size(); i++) {\n-            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+            subTypes.set(i, (FunctionType) safeResolve(subTypes.get(i), t, scope));\n         }\n     }\n     return super.resolveInternal(t, scope);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write `@this {Foo}`, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis != null && maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        JSType resolvedIface = safeResolve(iface, t, scope);\n        if (resolvedIface instanceof ObjectType) {\n            resolvedInterfaces.add((ObjectType) resolvedIface);\n        } else {\n            resolvedInterfaces.add(iface);\n        }\n        changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            JSType resolvedSubType = safeResolve(subTypes.get(i), t, scope);\n            if (resolvedSubType instanceof FunctionType) {\n                subTypes.set(i, (FunctionType) resolvedSubType);\n            }\n        }\n    }\n    return super.resolveInternal(t, scope);\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,44 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = (ArrowType) safeResolve(call, t, scope);\n+    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n+    // is handled further upstream.\n+    //\n+    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n+    //\n+    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n+    // activation object. In ES5, it leaves it as null. Just punt on this\n+    // issue for now by coercing out null. This is complicated by the\n+    // fact that when most people write `@this {Foo}`, they really don't\n+    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n+    // the name for them.\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    if (maybeTypeOfThis != null && maybeTypeOfThis instanceof ObjectType) {\n+        typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n+    for (ObjectType iface : implementedInterfaces) {\n+        JSType resolvedIface = safeResolve(iface, t, scope);\n+        if (resolvedIface instanceof ObjectType) {\n+            resolvedInterfaces.add((ObjectType) resolvedIface);\n+        } else {\n+            resolvedInterfaces.add(iface);\n+        }\n+        changed |= (resolvedIface != iface);\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+            JSType resolvedSubType = safeResolve(subTypes.get(i), t, scope);\n+            if (resolvedSubType instanceof FunctionType) {\n+                subTypes.set(i, (FunctionType) resolvedSubType);\n+            }\n+        }\n+    }\n+    return super.resolveInternal(t, scope);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -11,18 +11,22 @@\n     // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n     // activation object. In ES5, it leaves it as null. Just punt on this\n     // issue for now by coercing out null. This is complicated by the\n-    // fact that when most people write @this {Foo}, they really don't\n+    // fact that when most people write `@this {Foo}`, they really don't\n     // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n     // the name for them.\n     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n-    if (maybeTypeOfThis instanceof ObjectType) {\n+    if (maybeTypeOfThis != null && maybeTypeOfThis instanceof ObjectType) {\n         typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n-        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n-        resolvedInterfaces.add(resolvedIface);\n+        JSType resolvedIface = safeResolve(iface, t, scope);\n+        if (resolvedIface instanceof ObjectType) {\n+            resolvedInterfaces.add((ObjectType) resolvedIface);\n+        } else {\n+            resolvedInterfaces.add(iface);\n+        }\n         changed |= (resolvedIface != iface);\n     }\n     if (changed) {\n@@ -30,7 +34,10 @@\n     }\n     if (subTypes != null) {\n         for (int i = 0; i < subTypes.size(); i++) {\n-            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+            JSType resolvedSubType = safeResolve(subTypes.get(i), t, scope);\n+            if (resolvedSubType instanceof FunctionType) {\n+                subTypes.set(i, (FunctionType) resolvedSubType);\n+            }\n         }\n     }\n     return super.resolveInternal(t, scope);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        ObjectType resolvedIface = null;\n        if (iface != null) {\n            resolvedIface = (ObjectType) iface.resolve(t, scope);\n            resolvedInterfaces.add(resolvedIface);\n            changed |= (resolvedIface != iface);\n        }\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            if (subTypes.get(i) != null) {\n                subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n            }\n        }\n    }\n    return super.resolveInternal(t, scope);\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,42 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = (ArrowType) safeResolve(call, t, scope);\n+    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n+    // is handled further upstream.\n+    //\n+    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n+    //\n+    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n+    // activation object. In ES5, it leaves it as null. Just punt on this\n+    // issue for now by coercing out null. This is complicated by the\n+    // fact that when most people write @this {Foo}, they really don't\n+    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n+    // the name for them.\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    if (maybeTypeOfThis instanceof ObjectType) {\n+        typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n+    for (ObjectType iface : implementedInterfaces) {\n+        ObjectType resolvedIface = null;\n+        if (iface != null) {\n+            resolvedIface = (ObjectType) iface.resolve(t, scope);\n+            resolvedInterfaces.add(resolvedIface);\n+            changed |= (resolvedIface != iface);\n+        }\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+            if (subTypes.get(i) != null) {\n+                subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+            }\n+        }\n+    }\n+    return super.resolveInternal(t, scope);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -21,16 +21,21 @@\n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n-        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n-        resolvedInterfaces.add(resolvedIface);\n-        changed |= (resolvedIface != iface);\n+        ObjectType resolvedIface = null;\n+        if (iface != null) {\n+            resolvedIface = (ObjectType) iface.resolve(t, scope);\n+            resolvedInterfaces.add(resolvedIface);\n+            changed |= (resolvedIface != iface);\n+        }\n     }\n     if (changed) {\n         implementedInterfaces = resolvedInterfaces.build();\n     }\n     if (subTypes != null) {\n         for (int i = 0; i < subTypes.size(); i++) {\n-            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+            if (subTypes.get(i) != null) {\n+                subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+            }\n         }\n     }\n     return super.resolveInternal(t, scope);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis != null && maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        JSType resolved = safeResolve(iface, t, scope);\n        if (resolved instanceof ObjectType) {\n            ObjectType resolvedIface = (ObjectType) resolved;\n            resolvedInterfaces.add(resolvedIface);\n            changed |= (resolvedIface != iface);\n        }\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n          JSType resolved = safeResolve(subTypes.get(i), t, scope);\n            if (resolved instanceof FunctionType) {\n                subTypes.set(i, (FunctionType) resolved);\n            }\n        }\n    }\n    return super.resolveInternal(t, scope);\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,43 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = (ArrowType) safeResolve(call, t, scope);\n+    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n+    // is handled further upstream.\n+    //\n+    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n+    //\n+    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n+    // activation object. In ES5, it leaves it as null. Just punt on this\n+    // issue for now by coercing out null. This is complicated by the\n+    // fact that when most people write @this {Foo}, they really don't\n+    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n+    // the name for them.\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    if (maybeTypeOfThis != null && maybeTypeOfThis instanceof ObjectType) {\n+        typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n+    for (ObjectType iface : implementedInterfaces) {\n+        JSType resolved = safeResolve(iface, t, scope);\n+        if (resolved instanceof ObjectType) {\n+            ObjectType resolvedIface = (ObjectType) resolved;\n+            resolvedInterfaces.add(resolvedIface);\n+            changed |= (resolvedIface != iface);\n+        }\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+          JSType resolved = safeResolve(subTypes.get(i), t, scope);\n+            if (resolved instanceof FunctionType) {\n+                subTypes.set(i, (FunctionType) resolved);\n+            }\n+        }\n+    }\n+    return super.resolveInternal(t, scope);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -15,22 +15,28 @@\n     // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n     // the name for them.\n     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n-    if (maybeTypeOfThis instanceof ObjectType) {\n+    if (maybeTypeOfThis != null && maybeTypeOfThis instanceof ObjectType) {\n         typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n-        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n-        resolvedInterfaces.add(resolvedIface);\n-        changed |= (resolvedIface != iface);\n+        JSType resolved = safeResolve(iface, t, scope);\n+        if (resolved instanceof ObjectType) {\n+            ObjectType resolvedIface = (ObjectType) resolved;\n+            resolvedInterfaces.add(resolvedIface);\n+            changed |= (resolvedIface != iface);\n+        }\n     }\n     if (changed) {\n         implementedInterfaces = resolvedInterfaces.build();\n     }\n     if (subTypes != null) {\n         for (int i = 0; i < subTypes.size(); i++) {\n-            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+          JSType resolved = safeResolve(subTypes.get(i), t, scope);\n+            if (resolved instanceof FunctionType) {\n+                subTypes.set(i, (FunctionType) resolved);\n+            }\n         }\n     }\n     return super.resolveInternal(t, scope);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n        resolvedInterfaces.add((ObjectType) resolvedIface.autobox());\n        changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n        }\n    }\n    return super.resolveInternal(t, scope);\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,37 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = (ArrowType) safeResolve(call, t, scope);\n+    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n+    // is handled further upstream.\n+    //\n+    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n+    //\n+    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n+    // activation object. In ES5, it leaves it as null. Just punt on this\n+    // issue for now by coercing out null. This is complicated by the\n+    // fact that when most people write @this {Foo}, they really don't\n+    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n+    // the name for them.\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    if (maybeTypeOfThis instanceof ObjectType) {\n+        typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n+    for (ObjectType iface : implementedInterfaces) {\n+        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n+        resolvedInterfaces.add((ObjectType) resolvedIface.autobox());\n+        changed |= (resolvedIface != iface);\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+        }\n+    }\n+    return super.resolveInternal(t, scope);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -22,7 +22,7 @@\n     ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n         ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n-        resolvedInterfaces.add(resolvedIface);\n+        resolvedInterfaces.add((ObjectType) resolvedIface.autobox());\n         changed |= (resolvedIface != iface);\n     }\n     if (changed) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope).autobox();\n        resolvedInterfaces.add(resolvedIface);\n        changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n        }\n    }\n    return super.resolveInternal(t, scope);\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,37 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = (ArrowType) safeResolve(call, t, scope);\n+    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n+    // is handled further upstream.\n+    //\n+    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n+    //\n+    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n+    // activation object. In ES5, it leaves it as null. Just punt on this\n+    // issue for now by coercing out null. This is complicated by the\n+    // fact that when most people write @this {Foo}, they really don't\n+    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n+    // the name for them.\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    if (maybeTypeOfThis instanceof ObjectType) {\n+        typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n+    for (ObjectType iface : implementedInterfaces) {\n+        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope).autobox();\n+        resolvedInterfaces.add(resolvedIface);\n+        changed |= (resolvedIface != iface);\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+        }\n+    }\n+    return super.resolveInternal(t, scope);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -21,7 +21,7 @@\n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n-        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n+        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope).autobox();\n         resolvedInterfaces.add(resolvedIface);\n         changed |= (resolvedIface != iface);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = safeResolve(call, t, scope).autobox();\n    prototype = safeResolve(prototype, t, scope).autobox();\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = ((ObjectType) maybeTypeOfThis).autobox();\n    }\n    boolean changed = false;\n    ImmutableList.Builder<JSType> resolvedInterfaces = ImmutableList.builder();\n    for (JSType iface : implementedInterfaces) {\n        JSType resolvedIface = iface.resolve(t, scope).autobox();\n        resolvedInterfaces.add(resolvedIface);\n        changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            subTypes.set(i, subTypes.get(i).resolve(t, scope).autobox().toMaybeFunctionType());\n        }\n    }\n    return super.resolveInternal(t, scope);\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,37 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = safeResolve(call, t, scope).autobox();\n+    prototype = safeResolve(prototype, t, scope).autobox();\n+    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n+    // is handled further upstream.\n+    //\n+    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n+    //\n+    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n+    // activation object. In ES5, it leaves it as null. Just punt on this\n+    // issue for now by coercing out null. This is complicated by the\n+    // fact that when most people write @this {Foo}, they really don't\n+    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n+    // the name for them.\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    if (maybeTypeOfThis instanceof ObjectType) {\n+        typeOfThis = ((ObjectType) maybeTypeOfThis).autobox();\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<JSType> resolvedInterfaces = ImmutableList.builder();\n+    for (JSType iface : implementedInterfaces) {\n+        JSType resolvedIface = iface.resolve(t, scope).autobox();\n+        resolvedInterfaces.add(resolvedIface);\n+        changed |= (resolvedIface != iface);\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+            subTypes.set(i, subTypes.get(i).resolve(t, scope).autobox().toMaybeFunctionType());\n+        }\n+    }\n+    return super.resolveInternal(t, scope);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -1,8 +1,8 @@\n @Override\n JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n     setResolvedTypeInternal(this);\n-    call = (ArrowType) safeResolve(call, t, scope);\n-    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    call = safeResolve(call, t, scope).autobox();\n+    prototype = safeResolve(prototype, t, scope).autobox();\n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     //\n@@ -16,12 +16,12 @@\n     // the name for them.\n     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n     if (maybeTypeOfThis instanceof ObjectType) {\n-        typeOfThis = (ObjectType) maybeTypeOfThis;\n+        typeOfThis = ((ObjectType) maybeTypeOfThis).autobox();\n     }\n     boolean changed = false;\n-    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n-    for (ObjectType iface : implementedInterfaces) {\n-        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n+    ImmutableList.Builder<JSType> resolvedInterfaces = ImmutableList.builder();\n+    for (JSType iface : implementedInterfaces) {\n+        JSType resolvedIface = iface.resolve(t, scope).autobox();\n         resolvedInterfaces.add(resolvedIface);\n         changed |= (resolvedIface != iface);\n     }\n@@ -30,7 +30,7 @@\n     }\n     if (subTypes != null) {\n         for (int i = 0; i < subTypes.size(); i++) {\n-            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+            subTypes.set(i, subTypes.get(i).resolve(t, scope).autobox().toMaybeFunctionType());\n         }\n     }\n     return super.resolveInternal(t, scope);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        JSType resolvedIface = safeResolve(iface, t, scope);\n        if (resolvedIface.isObjectType()) {\n            resolvedInterfaces.add((ObjectType) resolvedIface);\n            changed |= true;\n        } else {\n            resolvedInterfaces.add(iface);\n        }\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n        }\n    }\n    return super.resolveInternal(t, scope);\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,41 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = (ArrowType) safeResolve(call, t, scope);\n+    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n+    // is handled further upstream.\n+    //\n+    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n+    //\n+    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n+    // activation object. In ES5, it leaves it as null. Just punt on this\n+    // issue for now by coercing out null. This is complicated by the\n+    // fact that when most people write @this {Foo}, they really don't\n+    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n+    // the name for them.\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    if (maybeTypeOfThis instanceof ObjectType) {\n+        typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n+    for (ObjectType iface : implementedInterfaces) {\n+        JSType resolvedIface = safeResolve(iface, t, scope);\n+        if (resolvedIface.isObjectType()) {\n+            resolvedInterfaces.add((ObjectType) resolvedIface);\n+            changed |= true;\n+        } else {\n+            resolvedInterfaces.add(iface);\n+        }\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+        }\n+    }\n+    return super.resolveInternal(t, scope);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -21,9 +21,13 @@\n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n-        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n-        resolvedInterfaces.add(resolvedIface);\n-        changed |= (resolvedIface != iface);\n+        JSType resolvedIface = safeResolve(iface, t, scope);\n+        if (resolvedIface.isObjectType()) {\n+            resolvedInterfaces.add((ObjectType) resolvedIface);\n+            changed |= true;\n+        } else {\n+            resolvedInterfaces.add(iface);\n+        }\n     }\n     if (changed) {\n         implementedInterfaces = resolvedInterfaces.build();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        ObjectType resolvedIface = (ObjectType) safeResolve(iface, t, scope);\n        resolvedInterfaces.add(resolvedIface);\n        changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            subTypes.set(i, (FunctionType) safeResolve(subTypes.get(i), t, scope));\n        }\n    }\n    return super.resolveInternal(t, scope);\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,37 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = (ArrowType) safeResolve(call, t, scope);\n+    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n+    // is handled further upstream.\n+    //\n+    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n+    //\n+    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n+    // activation object. In ES5, it leaves it as null. Just punt on this\n+    // issue for now by coercing out null. This is complicated by the\n+    // fact that when most people write @this {Foo}, they really don't\n+    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n+    // the name for them.\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    if (maybeTypeOfThis instanceof ObjectType) {\n+        typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n+    for (ObjectType iface : implementedInterfaces) {\n+        ObjectType resolvedIface = (ObjectType) safeResolve(iface, t, scope);\n+        resolvedInterfaces.add(resolvedIface);\n+        changed |= (resolvedIface != iface);\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+            subTypes.set(i, (FunctionType) safeResolve(subTypes.get(i), t, scope));\n+        }\n+    }\n+    return super.resolveInternal(t, scope);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -21,7 +21,7 @@\n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n-        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n+        ObjectType resolvedIface = (ObjectType) safeResolve(iface, t, scope);\n         resolvedInterfaces.add(resolvedIface);\n         changed |= (resolvedIface != iface);\n     }\n@@ -30,7 +30,7 @@\n     }\n     if (subTypes != null) {\n         for (int i = 0; i < subTypes.size(); i++) {\n-            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+            subTypes.set(i, (FunctionType) safeResolve(subTypes.get(i), t, scope));\n         }\n     }\n     return super.resolveInternal(t, scope);\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n    } else {\n        typeOfThis = ObjectType.cast(maybeTypeOfThis);\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        ObjectType resolvedIface = ObjectType.cast(iface.resolve(t, scope));\n        resolvedInterfaces.add(resolvedIface);\n        if (resolvedIface != iface) {\n            changed = true;\n        }\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            subTypes.set(i, FunctionType.cast(subTypes.get(i).resolve(t, scope)));\n        }\n    }\n    return super.resolveInternal(t, scope);\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,41 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = (ArrowType) safeResolve(call, t, scope);\n+    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n+    // is handled further upstream.\n+    //\n+    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n+    //\n+    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n+    // activation object. In ES5, it leaves it as null. Just punt on this\n+    // issue for now by coercing out null. This is complicated by the\n+    // fact that when most people write @this {Foo}, they really don't\n+    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n+    // the name for them.\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    if (maybeTypeOfThis instanceof ObjectType) {\n+        typeOfThis = (ObjectType) maybeTypeOfThis;\n+    } else {\n+        typeOfThis = ObjectType.cast(maybeTypeOfThis);\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n+    for (ObjectType iface : implementedInterfaces) {\n+        ObjectType resolvedIface = ObjectType.cast(iface.resolve(t, scope));\n+        resolvedInterfaces.add(resolvedIface);\n+        if (resolvedIface != iface) {\n+            changed = true;\n+        }\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+            subTypes.set(i, FunctionType.cast(subTypes.get(i).resolve(t, scope)));\n+        }\n+    }\n+    return super.resolveInternal(t, scope);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -17,20 +17,24 @@\n     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n     if (maybeTypeOfThis instanceof ObjectType) {\n         typeOfThis = (ObjectType) maybeTypeOfThis;\n+    } else {\n+        typeOfThis = ObjectType.cast(maybeTypeOfThis);\n     }\n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n-        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n+        ObjectType resolvedIface = ObjectType.cast(iface.resolve(t, scope));\n         resolvedInterfaces.add(resolvedIface);\n-        changed |= (resolvedIface != iface);\n+        if (resolvedIface != iface) {\n+            changed = true;\n+        }\n     }\n     if (changed) {\n         implementedInterfaces = resolvedInterfaces.build();\n     }\n     if (subTypes != null) {\n         for (int i = 0; i < subTypes.size(); i++) {\n-            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+            subTypes.set(i, FunctionType.cast(subTypes.get(i).resolve(t, scope)));\n         }\n     }\n     return super.resolveInternal(t, scope);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (int i = 0; i < implementedInterfaces.size(); i++) {\n        ObjectType iface = implementedInterfaces.get(i);\n        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n        resolvedInterfaces.add(resolvedIface);\n        changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n        }\n    }\n    return super.resolveInternal(t, scope);\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,38 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = (ArrowType) safeResolve(call, t, scope);\n+    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n+    // is handled further upstream.\n+    //\n+    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n+    //\n+    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n+    // activation object. In ES5, it leaves it as null. Just punt on this\n+    // issue for now by coercing out null. This is complicated by the\n+    // fact that when most people write @this {Foo}, they really don't\n+    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n+    // the name for them.\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    if (maybeTypeOfThis instanceof ObjectType) {\n+        typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n+    for (int i = 0; i < implementedInterfaces.size(); i++) {\n+        ObjectType iface = implementedInterfaces.get(i);\n+        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n+        resolvedInterfaces.add(resolvedIface);\n+        changed |= (resolvedIface != iface);\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+        }\n+    }\n+    return super.resolveInternal(t, scope);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -20,7 +20,8 @@\n     }\n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n-    for (ObjectType iface : implementedInterfaces) {\n+    for (int i = 0; i < implementedInterfaces.size(); i++) {\n+        ObjectType iface = implementedInterfaces.get(i);\n         ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n         resolvedInterfaces.add(resolvedIface);\n         changed |= (resolvedIface != iface);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n        resolvedInterfaces.add(resolvedIface);\n        changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            FunctionType type = subTypes.get(i);\n            if (type != null) {\n                subTypes.set(i, (FunctionType) type.resolve(t, scope));\n            }\n        }\n    }\n    return super.resolveInternal(t, scope);\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,40 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = (ArrowType) safeResolve(call, t, scope);\n+    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n+    // is handled further upstream.\n+    //\n+    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n+    //\n+    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n+    // activation object. In ES5, it leaves it as null. Just punt on this\n+    // issue for now by coercing out null. This is complicated by the\n+    // fact that when most people write @this {Foo}, they really don't\n+    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n+    // the name for them.\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    if (maybeTypeOfThis instanceof ObjectType) {\n+        typeOfThis = (ObjectType) maybeTypeOfThis;\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n+    for (ObjectType iface : implementedInterfaces) {\n+        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n+        resolvedInterfaces.add(resolvedIface);\n+        changed |= (resolvedIface != iface);\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+            FunctionType type = subTypes.get(i);\n+            if (type != null) {\n+                subTypes.set(i, (FunctionType) type.resolve(t, scope));\n+            }\n+        }\n+    }\n+    return super.resolveInternal(t, scope);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -30,7 +30,10 @@\n     }\n     if (subTypes != null) {\n         for (int i = 0; i < subTypes.size(); i++) {\n-            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+            FunctionType type = subTypes.get(i);\n+            if (type != null) {\n+                subTypes.set(i, (FunctionType) type.resolve(t, scope));\n+            }\n         }\n     }\n     return super.resolveInternal(t, scope);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = safeResolve(call, t, scope).autobox();\n    prototype = safeResolve(prototype, t, scope).autobox();\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope).autobox();\n    if (maybeTypeOfThis instanceof ObjectType) {\n        typeOfThis = (ObjectType) maybeTypeOfThis.autobox();\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope).autobox();\n        resolvedInterfaces.add(resolvedIface);\n        changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope).autobox());\n        }\n    }\n    return super.resolveInternal(t, scope).autobox();\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,26 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = safeResolve(call, t, scope).autobox();\n+    prototype = safeResolve(prototype, t, scope).autobox();\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope).autobox();\n+    if (maybeTypeOfThis instanceof ObjectType) {\n+        typeOfThis = (ObjectType) maybeTypeOfThis.autobox();\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n+    for (ObjectType iface : implementedInterfaces) {\n+        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope).autobox();\n+        resolvedInterfaces.add(resolvedIface);\n+        changed |= (resolvedIface != iface);\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope).autobox());\n+        }\n+    }\n+    return super.resolveInternal(t, scope).autobox();\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -1,27 +1,16 @@\n @Override\n JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n     setResolvedTypeInternal(this);\n-    call = (ArrowType) safeResolve(call, t, scope);\n-    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n-    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n-    // is handled further upstream.\n-    //\n-    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    //\n-    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n-    // activation object. In ES5, it leaves it as null. Just punt on this\n-    // issue for now by coercing out null. This is complicated by the\n-    // fact that when most people write @this {Foo}, they really don't\n-    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n-    // the name for them.\n-    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    call = safeResolve(call, t, scope).autobox();\n+    prototype = safeResolve(prototype, t, scope).autobox();\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope).autobox();\n     if (maybeTypeOfThis instanceof ObjectType) {\n-        typeOfThis = (ObjectType) maybeTypeOfThis;\n+        typeOfThis = (ObjectType) maybeTypeOfThis.autobox();\n     }\n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n-        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n+        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope).autobox();\n         resolvedInterfaces.add(resolvedIface);\n         changed |= (resolvedIface != iface);\n     }\n@@ -30,8 +19,8 @@\n     }\n     if (subTypes != null) {\n         for (int i = 0; i < subTypes.size(); i++) {\n-            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope).autobox());\n         }\n     }\n-    return super.resolveInternal(t, scope);\n+    return super.resolveInternal(t, scope).autobox();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if(maybeTypeOfThis == null){\n        return null;\n    }else{\n        if (maybeTypeOfThis instanceof ObjectType) {\n                typeOfThis = (ObjectType) maybeTypeOfThis;\n        }\n    }\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n        resolvedInterfaces.add(resolvedIface);\n        changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n        implementedInterfaces = resolvedInterfaces.build();\n    }\n    if (subTypes != null) {\n        for (int i = 0; i < subTypes.size(); i++) {\n            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n        }\n    }\n    return super.resolveInternal(t, scope);\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.java@apply\n@@ -1,14 +1,41 @@\n @Override\n-public boolean apply(JSType type) {\n-    // TODO(user): Doing an instanceof check here is too\n-    // restrictive as (Date,Error) is, for instance, an object type\n-    // even though its implementation is a UnionType. Would need to\n-    // create interfaces JSType, ObjectType, FunctionType etc and have\n-    // separate implementation instead of the class hierarchy, so that\n-    // union types can also be object types, etc.\n-    if (!type.isSubtype(typeRegistry.getNativeType(OBJECT_TYPE))) {\n-        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n-        return false;\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n+    setResolvedTypeInternal(this);\n+    call = (ArrowType) safeResolve(call, t, scope);\n+    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n+    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n+    // is handled further upstream.\n+    //\n+    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n+    //\n+    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n+    // activation object. In ES5, it leaves it as null. Just punt on this\n+    // issue for now by coercing out null. This is complicated by the\n+    // fact that when most people write @this {Foo}, they really don't\n+    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n+    // the name for them.\n+    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n+    if(maybeTypeOfThis == null){\n+        return null;\n+    }else{\n+        if (maybeTypeOfThis instanceof ObjectType) {\n+                typeOfThis = (ObjectType) maybeTypeOfThis;\n+        }\n     }\n-    return true;\n+    boolean changed = false;\n+    ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n+    for (ObjectType iface : implementedInterfaces) {\n+        ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n+        resolvedInterfaces.add(resolvedIface);\n+        changed |= (resolvedIface != iface);\n+    }\n+    if (changed) {\n+        implementedInterfaces = resolvedInterfaces.build();\n+    }\n+    if (subTypes != null) {\n+        for (int i = 0; i < subTypes.size(); i++) {\n+            subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n+        }\n+    }\n+    return super.resolveInternal(t, scope);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n+++ com/google/javascript/rhino/jstype/FunctionType.java@resolveInternal\n@@ -15,8 +15,12 @@\n     // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n     // the name for them.\n     JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n-    if (maybeTypeOfThis instanceof ObjectType) {\n-        typeOfThis = (ObjectType) maybeTypeOfThis;\n+    if(maybeTypeOfThis == null){\n+        return null;\n+    }else{\n+        if (maybeTypeOfThis instanceof ObjectType) {\n+                typeOfThis = (ObjectType) maybeTypeOfThis;\n+        }\n     }\n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder();\n", "finish_reason": "stop", "valid": false, "num": 1}]