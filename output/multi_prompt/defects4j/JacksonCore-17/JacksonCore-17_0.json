[{"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        buf = _charBuffer; // fix here: reset buffer after each iteration\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,6 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        buf = _charBuffer; // fix here: reset buffer after each iteration\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        if (len2 < len) {\n            // check for split surrogate\n            char lastChar = text.charAt(offset + len2 - 1);\n            if (Character.isHighSurrogate(lastChar)) {\n                len2--;\n            }\n        }\n        offset += len2;\n        len -= len2;\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -11,6 +11,13 @@\n         writeRaw(buf, 0, len2);\n         // If this is NOT the last segment and if the last character looks like\n         // split surrogate second half, drop it\n+        if (len2 < len) {\n+            // check for split surrogate\n+            char lastChar = text.charAt(offset + len2 - 1);\n+            if (Character.isHighSurrogate(lastChar)) {\n+                len2--;\n+            }\n+        }\n         offset += len2;\n         len -= len2;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        flush(); // Add flush() after writing each segment to ensure all data is written to output stream\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,6 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        flush(); // Add flush() after writing each segment to ensure all data is written to output stream\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // a split surrogate second half, drop it\n        if (len > len2 && Character.isSurrogatePair(text.charAt(offset + len2 - 1), text.charAt(offset + len2))) {\n            len2--;\n        }\n        offset += len2;\n        len -= len2;\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -10,7 +10,10 @@\n         text.getChars(offset, offset + len2, buf, 0);\n         writeRaw(buf, 0, len2);\n         // If this is NOT the last segment and if the last character looks like\n-        // split surrogate second half, drop it\n+        // a split surrogate second half, drop it\n+        if (len > len2 && Character.isSurrogatePair(text.charAt(offset + len2 - 1), text.charAt(offset + len2))) {\n+            len2--;\n+        }\n         offset += len2;\n         len -= len2;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        if (len2 < buf.length) {\n            Arrays.fill(buf, 0, len2, (char)0);\n        }\n        offset += len2;\n        len -= len2;\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -11,6 +11,9 @@\n         writeRaw(buf, 0, len2);\n         // If this is NOT the last segment and if the last character looks like\n         // split surrogate second half, drop it\n+        if (len2 < buf.length) {\n+            Arrays.fill(buf, 0, len2, (char)0);\n+        }\n         offset += len2;\n         len -= len2;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        //clear the char buffer after writing\n        _charBuffer = new char[0];\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,7 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        //clear the char buffer after writing\n+        _charBuffer = new char[0];\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        if(len > len2 && Character.isSurrogatePair(text.charAt(offset + len2 - 1), text.charAt(offset + len2))){\n            len2--;\n        }\n        offset += len2;\n        len -= len2;\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -11,6 +11,9 @@\n         writeRaw(buf, 0, len2);\n         // If this is NOT the last segment and if the last character looks like\n         // split surrogate second half, drop it\n+        if(len > len2 && Character.isSurrogatePair(text.charAt(offset + len2 - 1), text.charAt(offset + len2))){\n+            len2--;\n+        }\n         offset += len2;\n         len -= len2;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        if (len2 < len && Character.isSurrogate(buf[len2 - 1])) {\n            --len2;\n            offset += len2;\n            len -= len2;\n        } else {\n            offset += len2;\n            len -= len2;\n        }\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -11,7 +11,13 @@\n         writeRaw(buf, 0, len2);\n         // If this is NOT the last segment and if the last character looks like\n         // split surrogate second half, drop it\n-        offset += len2;\n-        len -= len2;\n+        if (len2 < len && Character.isSurrogate(buf[len2 - 1])) {\n+            --len2;\n+            offset += len2;\n+            len -= len2;\n+        } else {\n+            offset += len2;\n+            len -= len2;\n+        }\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        buf = _charBuffer; // reset buffer for next iteration\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,6 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        buf = _charBuffer; // reset buffer for next iteration\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        if (len > 0 && Character.isHighSurrogate(text.charAt(offset))) {\n            // must skip first half of surrogate pair, otherwise it will break\n            ++offset;\n        }\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,9 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        if (len > 0 && Character.isHighSurrogate(text.charAt(offset))) {\n+            // must skip first half of surrogate pair, otherwise it will break\n+            ++offset;\n+        }\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        // Clear the buffer after each iteration\n        buf = new char[buf.length];\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,7 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        // Clear the buffer after each iteration\n+        buf = new char[buf.length];\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        flush(); // added line to flush output buffer\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,6 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        flush(); // added line to flush output buffer\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        if (len2 < buf.length && Character.isHighSurrogate(text.charAt(offset + len2 - 1))) {\n            --len2;\n        }\n        offset += len2;\n        len -= len2;\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -11,6 +11,9 @@\n         writeRaw(buf, 0, len2);\n         // If this is NOT the last segment and if the last character looks like\n         // split surrogate second half, drop it\n+        if (len2 < buf.length && Character.isHighSurrogate(text.charAt(offset + len2 - 1))) {\n+            --len2;\n+        }\n         offset += len2;\n         len -= len2;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    // Ensure the offset is within the bounds of the text\n    if (offset < 0 || offset > text.length()) {\n        throw new IndexOutOfBoundsException(\"Offset (\" + offset + \") is out of bounds for the length of the text: \" + text.length());\n    }\n    final char[] buf = _charBuffer;\n    int end = offset + len;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (offset < end) {\n        int len2 = Math.min(buf.length, end - offset);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -1,17 +1,21 @@\n @Override\n public void writeRaw(String text, int offset, int len) throws IOException {\n+    // Ensure the offset is within the bounds of the text\n+    if (offset < 0 || offset > text.length()) {\n+        throw new IndexOutOfBoundsException(\"Offset (\" + offset + \") is out of bounds for the length of the text: \" + text.length());\n+    }\n     final char[] buf = _charBuffer;\n+    int end = offset + len;\n     // minor optimization: see if we can just get and copy\n     // If not, need segmented approach. For speed, let's also use input buffer\n     // size that is guaranteed to fit in output buffer; each char can expand to\n     // at most 3 bytes, so at most 1/3 of buffer size.\n-    while (len > 0) {\n-        int len2 = Math.min(buf.length, len);\n+    while (offset < end) {\n+        int len2 = Math.min(buf.length, end - offset);\n         text.getChars(offset, offset + len2, buf, 0);\n         writeRaw(buf, 0, len2);\n         // If this is NOT the last segment and if the last character looks like\n         // split surrogate second half, drop it\n         offset += len2;\n-        len -= len2;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // a split surrogate second half, drop it\n        if (len - len2 == 1 && Character.isHighSurrogate(text.charAt(offset + len2 - 1))) {\n            offset += len2 - 1;\n            len = 1;\n        } else {\n            offset += len2;\n            len -= len2;\n        }\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -10,8 +10,13 @@\n         text.getChars(offset, offset + len2, buf, 0);\n         writeRaw(buf, 0, len2);\n         // If this is NOT the last segment and if the last character looks like\n-        // split surrogate second half, drop it\n-        offset += len2;\n-        len -= len2;\n+        // a split surrogate second half, drop it\n+        if (len - len2 == 1 && Character.isHighSurrogate(text.charAt(offset + len2 - 1))) {\n+            offset += len2 - 1;\n+            len = 1;\n+        } else {\n+            offset += len2;\n+            len -= len2;\n+        }\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        // clear the buffer after each iteration to avoid carrying any previous characters\n        Arrays.fill(buf, '\\0');\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,7 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        // clear the buffer after each iteration to avoid carrying any previous characters\n+        Arrays.fill(buf, '\\0');\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        // clear the buffer to avoid having any old characters in subsequent iterations\n        Arrays.fill(buf, '\\0');\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,7 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        // clear the buffer to avoid having any old characters in subsequent iterations\n+        Arrays.fill(buf, '\\0');\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n        // Clear buffer to avoid carrying previous text over\n        for(int i = 0; i < len2; i++) {\n            buf[i] = 0;\n        }\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -13,5 +13,9 @@\n         // split surrogate second half, drop it\n         offset += len2;\n         len -= len2;\n+        // Clear buffer to avoid carrying previous text over\n+        for(int i = 0; i < len2; i++) {\n+            buf[i] = 0;\n+        }\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        offset += len2;\n        len -= len2;\n    }\n    flush(); // flush the output stream after writing raw data\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -14,4 +14,5 @@\n         offset += len2;\n         len -= len2;\n     }\n+    flush(); // flush the output stream after writing raw data\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "@Override\npublic void writeRaw(String text, int offset, int len) throws IOException {\n    final char[] buf = _charBuffer;\n    // minor optimization: see if we can just get and copy\n    // If not, need segmented approach. For speed, let's also use input buffer\n    // size that is guaranteed to fit in output buffer; each char can expand to\n    // at most 3 bytes, so at most 1/3 of buffer size.\n    while (len > 0) {\n        int len2 = Math.min(buf.length, len);\n        text.getChars(offset, offset + len2, buf, 0);\n        writeRaw(buf, 0, len2);\n        // If this is NOT the last segment and if the last character looks like\n        // split surrogate second half, drop it\n        if(len > len2 && buf[len2-1] >= 0xD800 && buf[len2-1] <= 0xDBFF){\n            len2--;\n            offset++;\n            len--;\n        }\n        offset += len2;\n        len -= len2;\n    }\n}", "diff": "--- com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n+++ com/fasterxml/jackson/core/json/UTF8JsonGenerator.java@writeRaw\n@@ -11,6 +11,11 @@\n         writeRaw(buf, 0, len2);\n         // If this is NOT the last segment and if the last character looks like\n         // split surrogate second half, drop it\n+        if(len > len2 && buf[len2-1] >= 0xD800 && buf[len2-1] <= 0xDBFF){\n+            len2--;\n+            offset++;\n+            len--;\n+        }\n         offset += len2;\n         len -= len2;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}]