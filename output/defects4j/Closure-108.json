[{"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n        scopedAliasNames.clear(); // clear scopedAliasNames to avoid duplicates\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n    scopedAliasNames.clear(); // clear scopedAliasNames to avoid duplicates\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.inGlobalScope() && !t.getInput().isModule()) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -9,5 +9,6 @@\n         forbiddenLocals.clear();\n         transformation = null;\n         hasNamespaceShadows = false;\n+        scopedAliasNames.clear(); // clear scopedAliasNames to avoid duplicates\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -66,4 +66,5 @@\n             report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n         }\n     }\n+    scopedAliasNames.clear(); // clear scopedAliasNames to avoid duplicates\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,14 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n+        scopedAliasNames.clear(); // clear scopedAliasNames to avoid duplicates\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n        scopedAliasNames.clear(); // Added line to clear the set of scoped alias names\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        boolean isBlockScopedDeclaration = NodeUtil.isBlockScopedDeclaration(parent);\n        if ((isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName())\n                || (isBlockScopedDeclaration && n.hasChildren() && n.getFirstChild().isQualifiedName())) { // Added condition to handle block-scoped declarations\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl || isBlockScopedDeclaration) { // Added condition to handle block-scoped declarations\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n        if (NodeUtil.isForIn(parent) || NodeUtil.isForOf(parent)) { // Added condition to handle for...in/of loops\n            Node lhs = NodeUtil.getLhsOfFor(parent);\n            if (lhs.isName() && lhs.matchesQualifiedName(\"$jscomp.scope.\" + n.getString())) {\n                report(t, n, GOOG_SCOPE_FORIN_WITHIN_SCOPE);\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -9,5 +9,6 @@\n         forbiddenLocals.clear();\n         transformation = null;\n         hasNamespaceShadows = false;\n+        scopedAliasNames.clear(); // Added line to clear the set of scoped alias names\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -5,7 +5,9 @@\n         Node parent = n.getParent();\n         boolean isVar = parent.isVar();\n         boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n-        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n+        boolean isBlockScopedDeclaration = NodeUtil.isBlockScopedDeclaration(parent);\n+        if ((isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName())\n+                || (isBlockScopedDeclaration && n.hasChildren() && n.getFirstChild().isQualifiedName())) { // Added condition to handle block-scoped declarations\n             recordAlias(v);\n         } else if (v.isBleedingFunction()) {\n             // Bleeding functions already get a BAD_PARAMETERS error, so just\n@@ -13,7 +15,7 @@\n         } else if (parent.getType() == Token.LP) {\n             // Parameters of the scope function also get a BAD_PARAMETERS\n             // error.\n-        } else if (isVar || isFunctionDecl) {\n+        } else if (isVar || isFunctionDecl || isBlockScopedDeclaration) { // Added condition to handle block-scoped declarations\n             boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n             Node grandparent = parent.getParent();\n             Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,14 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n+        scopedAliasNames.clear(); // Added line to clear the set of scoped alias names\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    if (t.getScopeDepth() >= 2) {\n        if (aliasVar != null) {\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // Check if the goog.scope() call is an immediate child of the SCRIPT\n        // node. Depth > 2 refers to calls not at the root.\n        if (t.getScopeDepth() > 2 && parent != null && parent.getType() == Token.SCRIPT) {\n            report(t, n, GOOG_SCOPE_NOT_AT_ROOT);\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -23,8 +23,7 @@\n             scopedAliasNames.add(name);\n             String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n             compiler.ensureLibraryInjected(\"base\");\n-            // First, we need to free up the function expression (EXPR)\n-            // to be used in another expression.\n+\n             if (isFunctionDecl) {\n                 // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                 Node existingName = v.getNameNode();\n@@ -47,8 +46,7 @@\n                 }\n                 varNode = parent;\n             }\n-            // Add $jscomp.scope.name = EXPR;\n-            // Make sure we copy over all the jsdoc and debug info.\n+\n             if (value != null || v.getJSDocInfo() != null) {\n                 Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                 NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n@@ -58,7 +56,7 @@\n                     grandparent.addChildBefore(newDecl, varNode);\n                 }\n             }\n-            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n+\n             v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n             recordAlias(v);\n         } else {\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,13 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    } else if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.PARAM_LIST) { // Fix: use Token.PARAM_LIST instead of Token.LP.\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, parent); // Fix: pass parent instead of n.getParent()\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -2,8 +2,7 @@\n public void exitScope(NodeTraversal t) {\n     if (t.getScopeDepth() > 2) {\n         findNamespaceShadows(t);\n-    }\n-    if (t.getScopeDepth() == 2) {\n+    } else if (t.getScopeDepth() == 2) {\n         renameNamespaceShadows(t);\n         aliases.clear();\n         forbiddenLocals.clear();\n--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -10,7 +10,7 @@\n         } else if (v.isBleedingFunction()) {\n             // Bleeding functions already get a BAD_PARAMETERS error, so just\n             // do nothing.\n-        } else if (parent.getType() == Token.LP) {\n+        } else if (parent.getType() == Token.PARAM_LIST) { // Fix: use Token.PARAM_LIST instead of Token.LP.\n             // Parameters of the scope function also get a BAD_PARAMETERS\n             // error.\n         } else if (isVar || isFunctionDecl) {\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,12 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n+    } else if (t.getScopeDepth() == 2) {\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        // Clear local variables and aliases for closure scope\n        if (closureScopeDepth > 0 && t.getScopeDepth() == closureScopeDepth) {\n            aliases.clear();\n            forbiddenLocals.clear();\n            transformation = null;\n            hasNamespaceShadows = false;\n            closureScopeDepth = 0;\n        }\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        } else if (type == Token.VAR || type == Token.LET || type == Token.CONST) {\n            String name = n.getFirstChild().getString();\n            if (isGoogScopeAlias(name)) {\n                report(t, n, GOOG_SCOPE_ALIAS_BLOCK_VAR);\n            }\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // Check if this is a goog.scope block\n        if (type == Token.CALL && NodeUtil.isFunctionObjectCall(n)) {\n            Node callee = n.getFirstChild();\n            if (callee.getType() == Token.GETPROP &&\n                    callee.getFirstChild().matchesQualifiedName(\"goog\") &&\n                    callee.getLastChild().getString().equals(\"scope\")) {\n                if (closureScopeDepth == 0) {\n                    closureScopeDepth = t.getScopeDepth();\n                } else {\n                    report(t, n, INVALID_GOOG_SCOPE_MISPLACED);\n                }\n            }\n        }\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -5,9 +5,13 @@\n     }\n     if (t.getScopeDepth() == 2) {\n         renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+        // Clear local variables and aliases for closure scope\n+        if (closureScopeDepth > 0 && t.getScopeDepth() == closureScopeDepth) {\n+            aliases.clear();\n+            forbiddenLocals.clear();\n+            transformation = null;\n+            hasNamespaceShadows = false;\n+            closureScopeDepth = 0;\n+        }\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,17 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n+    if (t.getScopeDepth() == 2) {\n+        renameNamespaceShadows(t);\n+        // Clear local variables and aliases for closure scope\n+        if (closureScopeDepth > 0 && t.getScopeDepth() == closureScopeDepth) {\n+            aliases.clear();\n+            forbiddenLocals.clear();\n+            transformation = null;\n+            hasNamespaceShadows = false;\n+            closureScopeDepth = 0;\n         }\n     }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n-    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    } else if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue().cloneTree() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, parent);\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasDefinitionsInOrder.contains(n)) {\n                aliasDefinitionsInOrder.remove(n);\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            Node typeRoot = info.getTypeRoot();\n            if (typeRoot != null) {\n                fixTypeNode(typeRoot.getFirstChild());\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -2,8 +2,7 @@\n public void exitScope(NodeTraversal t) {\n     if (t.getScopeDepth() > 2) {\n         findNamespaceShadows(t);\n-    }\n-    if (t.getScopeDepth() == 2) {\n+    } else if (t.getScopeDepth() == 2) {\n         renameNamespaceShadows(t);\n         aliases.clear();\n         forbiddenLocals.clear();\n--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -16,7 +16,7 @@\n         } else if (isVar || isFunctionDecl) {\n             boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n             Node grandparent = parent.getParent();\n-            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n+            Node value = v.getInitialValue() != null ? v.getInitialValue().cloneTree() : null;\n             Node varNode = null;\n             String name = n.getString();\n             int nameCount = scopedAliasNames.count(name);\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,12 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n+    } else if (t.getScopeDepth() == 2) {\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}\n\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value == null ? NodeUtil.newUndefinedNode(null) : value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, parent);\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendant scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n            for (Node node : info.getReturnTypeNodes()) {\n                fixTypeNode(node);\n            }\n            for (Node node : info.getParameterTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO: Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -50,7 +50,7 @@\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n             if (value != null || v.getJSDocInfo() != null) {\n-                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n+                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value == null ? NodeUtil.newUndefinedNode(null) : value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                 NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                 if (isHoisted) {\n                     grandparent.addChildToFront(newDecl);\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,13 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n    // Clear scopedAliasNames when exiting all scopes, not just scope depth 2.\n    scopedAliasNames.clear();\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue().detach() : null; // Fix: detach initial value if it is not null\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            n.replaceWith(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            // Fix: record alias with the new Node instance\n            recordAlias(new Var(n));\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            aliasUsages.add(new AliasedNode(aliasVar, n.detach())); // Fix: detach current node\n            // Fix: record alias usage with the new Node instance\n            aliasVar.addReference(n);\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO: Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -10,4 +10,6 @@\n         transformation = null;\n         hasNamespaceShadows = false;\n     }\n+    // Clear scopedAliasNames when exiting all scopes, not just scope depth 2.\n+    scopedAliasNames.clear();\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -16,7 +16,7 @@\n         } else if (isVar || isFunctionDecl) {\n             boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n             Node grandparent = parent.getParent();\n-            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n+            Node value = v.getInitialValue() != null ? v.getInitialValue().detach() : null; // Fix: detach initial value if it is not null\n             Node varNode = null;\n             String name = n.getString();\n             int nameCount = scopedAliasNames.count(name);\n@@ -59,8 +59,9 @@\n                 }\n             }\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n-            recordAlias(v);\n+            n.replaceWith(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            // Fix: record alias with the new Node instance\n+            recordAlias(new Var(n));\n         } else {\n             // Do not other kinds of local symbols, like catch params.\n             report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,15 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n+    if (t.getScopeDepth() == 2) {\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n-    }\n+    // Clear scopedAliasNames when exiting all scopes, not just scope depth 2.\n+    scopedAliasNames.clear();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n        // Clear scopedAliasNames to ensure that alias renaming does not\n        // incorrectly reuse previously used alias names in nested scopes.\n        scopedAliasNames.clear();\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.PARAM_LIST) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendant scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            Node aliasedNode = NodeUtil.getBestLValue(aliasVar.getNode());\n            if (aliasedNode == null) {\n                aliasedNode = aliasVar.getNode();\n            }\n            aliasUsages.add(new AliasedNode(aliasVar, aliasedNode));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -9,5 +9,8 @@\n         forbiddenLocals.clear();\n         transformation = null;\n         hasNamespaceShadows = false;\n+        // Clear scopedAliasNames to ensure that alias renaming does not\n+        // incorrectly reuse previously used alias names in nested scopes.\n+        scopedAliasNames.clear();\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -10,7 +10,7 @@\n         } else if (v.isBleedingFunction()) {\n             // Bleeding functions already get a BAD_PARAMETERS error, so just\n             // do nothing.\n-        } else if (parent.getType() == Token.LP) {\n+        } else if (parent.getType() == Token.PARAM_LIST) {\n             // Parameters of the scope function also get a BAD_PARAMETERS\n             // error.\n         } else if (isVar || isFunctionDecl) {\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,16 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n+        // Clear scopedAliasNames to ensure that alias renaming does not\n+        // incorrectly reuse previously used alias names in nested scopes.\n+        scopedAliasNames.clear();\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n    // Clear aliasDefinitionsInOrder to avoid referencing undefined nodes\n    // in the next scope that gets visited.\n    aliasDefinitionsInOrder.clear();\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    ScopedAliasNames scopedAliasNames = new ScopedAliasNames();\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = NodeUtil.isNameDeclaration(parent);\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction() || parent.getType() == Token.LP) {\n            // Bleeding functions and parameters of the scope function already\n            // get a BAD_PARAMETERS error, so just do nothing.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue().detachFromParent() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n                        compiler.getCodingConvention(), globalName, value,\n                        v.getJSDocInfo());\n                newDecl.useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            Node newQualifiedNameNode = NodeUtil.newQualifiedNameNode(\n                    compiler.getCodingConvention(), globalName, n, name);\n            n.getParent().replaceChild(n, newQualifiedNameNode);\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n, parent) && t.getScopeDepth() >= 2) {\n        validateScopeCall(t, n, parent.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendant scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here. For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\". If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node typeNode : info.getTypeNodes()) {\n                fixTypeNode(typeNode);\n            }\n        }\n        // TODO(b/16166980): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -10,4 +10,7 @@\n         transformation = null;\n         hasNamespaceShadows = false;\n     }\n+    // Clear aliasDefinitionsInOrder to avoid referencing undefined nodes\n+    // in the next scope that gets visited.\n+    aliasDefinitionsInOrder.clear();\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -1,22 +1,20 @@\n private void findAliases(NodeTraversal t) {\n+    ScopedAliasNames scopedAliasNames = new ScopedAliasNames();\n     Scope scope = t.getScope();\n     for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         Node parent = n.getParent();\n-        boolean isVar = parent.isVar();\n+        boolean isVar = NodeUtil.isNameDeclaration(parent);\n         boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n             recordAlias(v);\n-        } else if (v.isBleedingFunction()) {\n-            // Bleeding functions already get a BAD_PARAMETERS error, so just\n-            // do nothing.\n-        } else if (parent.getType() == Token.LP) {\n-            // Parameters of the scope function also get a BAD_PARAMETERS\n-            // error.\n+        } else if (v.isBleedingFunction() || parent.getType() == Token.LP) {\n+            // Bleeding functions and parameters of the scope function already\n+            // get a BAD_PARAMETERS error, so just do nothing.\n         } else if (isVar || isFunctionDecl) {\n             boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n             Node grandparent = parent.getParent();\n-            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n+            Node value = v.getInitialValue() != null ? v.getInitialValue().detachFromParent() : null;\n             Node varNode = null;\n             String name = n.getString();\n             int nameCount = scopedAliasNames.count(name);\n@@ -40,17 +38,15 @@\n                 varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                 grandparent.replaceChild(parent, varNode);\n             } else {\n-                if (value != null) {\n-                    // If this is a VAR, we can just detach the expression and\n-                    // the tree will still be valid.\n-                    value.detachFromParent();\n-                }\n                 varNode = parent;\n             }\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n-            if (value != null || v.getJSDocInfo() != null) {\n-                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n+            if (value != null) {\n+                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(\n+                        compiler.getCodingConvention(), globalName, value,\n+                        v.getJSDocInfo());\n+                newDecl.useSourceInfoIfMissingFromForTree(n);\n                 NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                 if (isHoisted) {\n                     grandparent.addChildToFront(newDecl);\n@@ -59,7 +55,9 @@\n                 }\n             }\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            Node newQualifiedNameNode = NodeUtil.newQualifiedNameNode(\n+                    compiler.getCodingConvention(), globalName, n, name);\n+            n.getParent().replaceChild(n, newQualifiedNameNode);\n             recordAlias(v);\n         } else {\n             // Do not other kinds of local symbols, like catch params.\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,16 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n+    if (t.getScopeDepth() == 2) {\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n-    }\n+    // Clear aliasDefinitionsInOrder to avoid referencing undefined nodes\n+    // in the next scope that gets visited.\n+    aliasDefinitionsInOrder.clear();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n    // Add this condition to handle the case when a nested function exits the current scope\n    if (t.getScopeDepth() >= 2 && t.getScopeDepth() <= 3) {\n        findNamespaceShadows(t);\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n    // Call t.reportCodeChange() to inform the compiler to record a code change\n    t.reportCodeChange();\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n    // Call t.reportCodeChange() to inform the compiler to record a code change\n    t.reportCodeChange();\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -10,4 +10,8 @@\n         transformation = null;\n         hasNamespaceShadows = false;\n     }\n+    // Add this condition to handle the case when a nested function exits the current scope\n+    if (t.getScopeDepth() >= 2 && t.getScopeDepth() <= 3) {\n+        findNamespaceShadows(t);\n+    }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -66,4 +66,6 @@\n             report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n         }\n     }\n+    // Call t.reportCodeChange() to inform the compiler to record a code change\n+    t.reportCodeChange();\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,17 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n+    if (t.getScopeDepth() == 2) {\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+    // Add this condition to handle the case when a nested function exits the current scope\n+    if (t.getScopeDepth() >= 2 && t.getScopeDepth() <= 3) {\n+        findNamespaceShadows(t);\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n        currentScopeNamespaces.clear(); // Add this line of code to clear the currentScopeNamespaces\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getOwnVars()) { // Change getVarIterable() to getOwnVars()\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) { // Add this condition to check if the name is an alias\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -9,5 +9,6 @@\n         forbiddenLocals.clear();\n         transformation = null;\n         hasNamespaceShadows = false;\n+        currentScopeNamespaces.clear(); // Add this line of code to clear the currentScopeNamespaces\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -1,6 +1,6 @@\n private void findAliases(NodeTraversal t) {\n     Scope scope = t.getScope();\n-    for (Var v : scope.getVarIterable()) {\n+    for (Var v : scope.getOwnVars()) { // Change getVarIterable() to getOwnVars()\n         Node n = v.getNode();\n         Node parent = n.getParent();\n         boolean isVar = parent.isVar();\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,14 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n+        currentScopeNamespaces.clear(); // Add this line of code to clear the currentScopeNamespaces\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n    // Remove any aliases defined in the scope we are exiting.\n    int currentDepth = t.getScopeDepth();\n    Iterator<Map.Entry<String, Var>> iter = aliases.entrySet().iterator();\n    while (iter.hasNext()) {\n        Map.Entry<String, Var> entry = iter.next();\n        Var aliasVar = entry.getValue();\n        if (aliasVar.isGlobal()) {\n            continue;\n        }\n        if (aliasVar.getScope().getDepth() == currentDepth) {\n            iter.remove();\n        }\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue().cloneTree() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n.cloneTree()));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -10,4 +10,17 @@\n         transformation = null;\n         hasNamespaceShadows = false;\n     }\n+    // Remove any aliases defined in the scope we are exiting.\n+    int currentDepth = t.getScopeDepth();\n+    Iterator<Map.Entry<String, Var>> iter = aliases.entrySet().iterator();\n+    while (iter.hasNext()) {\n+        Map.Entry<String, Var> entry = iter.next();\n+        Var aliasVar = entry.getValue();\n+        if (aliasVar.isGlobal()) {\n+            continue;\n+        }\n+        if (aliasVar.getScope().getDepth() == currentDepth) {\n+            iter.remove();\n+        }\n+    }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -16,7 +16,7 @@\n         } else if (isVar || isFunctionDecl) {\n             boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n             Node grandparent = parent.getParent();\n-            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n+            Node value = v.getInitialValue() != null ? v.getInitialValue().cloneTree() : null;\n             Node varNode = null;\n             String name = n.getString();\n             int nameCount = scopedAliasNames.count(name);\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,26 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n+    if (t.getScopeDepth() == 2) {\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n+    // Remove any aliases defined in the scope we are exiting.\n+    int currentDepth = t.getScopeDepth();\n+    Iterator<Map.Entry<String, Var>> iter = aliases.entrySet().iterator();\n+    while (iter.hasNext()) {\n+        Map.Entry<String, Var> entry = iter.next();\n+        Var aliasVar = entry.getValue();\n+        if (aliasVar.isGlobal()) {\n+            continue;\n+        }\n+        if (aliasVar.getScope().getDepth() == currentDepth) {\n+            iter.remove();\n         }\n     }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n-    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction() || parent.getType() == Token.LP) {\n            // Bleeding functions and parameters of the scope function already get a BAD_PARAMETERS error,\n            // so just do nothing.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue().detachFromParent() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendant scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't clone aliasedNode here.\n            // For example, var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the changes pass above with \"goog\".\n            // If we cloned here, we'd end up with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        if (n != null) {\n            JSDocInfo info = n.getJSDocInfo();\n            if (info != null) {\n                for (Node node : info.getTypeNodes()) {\n                    fixTypeNode(node);\n                }\n            }\n        }\n        // TODO: Add an error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -7,16 +7,13 @@\n         boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n         if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n             recordAlias(v);\n-        } else if (v.isBleedingFunction()) {\n-            // Bleeding functions already get a BAD_PARAMETERS error, so just\n-            // do nothing.\n-        } else if (parent.getType() == Token.LP) {\n-            // Parameters of the scope function also get a BAD_PARAMETERS\n-            // error.\n+        } else if (v.isBleedingFunction() || parent.getType() == Token.LP) {\n+            // Bleeding functions and parameters of the scope function already get a BAD_PARAMETERS error,\n+            // so just do nothing.\n         } else if (isVar || isFunctionDecl) {\n             boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n             Node grandparent = parent.getParent();\n-            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n+            Node value = v.getInitialValue() != null ? v.getInitialValue().detachFromParent() : null;\n             Node varNode = null;\n             String name = n.getString();\n             int nameCount = scopedAliasNames.count(name);\n@@ -40,11 +37,6 @@\n                 varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                 grandparent.replaceChild(parent, varNode);\n             } else {\n-                if (value != null) {\n-                    // If this is a VAR, we can just detach the expression and\n-                    // the tree will still be valid.\n-                    value.detachFromParent();\n-                }\n                 varNode = parent;\n             }\n             // Add $jscomp.scope.name = EXPR;\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,13 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    } else if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            n.replaceWith(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && aliases.containsKey(name) && aliases.get(name) == lexicalVar) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO: Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -2,8 +2,7 @@\n public void exitScope(NodeTraversal t) {\n     if (t.getScopeDepth() > 2) {\n         findNamespaceShadows(t);\n-    }\n-    if (t.getScopeDepth() == 2) {\n+    } else if (t.getScopeDepth() == 2) {\n         renameNamespaceShadows(t);\n         aliases.clear();\n         forbiddenLocals.clear();\n--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -59,7 +59,7 @@\n                 }\n             }\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            n.replaceWith(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n             recordAlias(v);\n         } else {\n             // Do not other kinds of local symbols, like catch params.\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,12 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n-    }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n+    } else if (t.getScopeDepth() == 2) {\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n    // add a check to clear scopedAliasNames at the end of each scope\n    if (scopedAliasNames != null) {\n        scopedAliasNames.clear();\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n    // add a check to clear scopedAliasNames at the end of each scope\n    if (scopedAliasNames != null) {\n        scopedAliasNames.clear();\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendant scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // add a check to clear scopedAliasNames at the end of each scope\n        if (scopedAliasNames != null) {\n            scopedAliasNames.clear();\n        }\n        // TODO (robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -10,4 +10,8 @@\n         transformation = null;\n         hasNamespaceShadows = false;\n     }\n+    // add a check to clear scopedAliasNames at the end of each scope\n+    if (scopedAliasNames != null) {\n+        scopedAliasNames.clear();\n+    }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -66,4 +66,8 @@\n             report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n         }\n     }\n+    // add a check to clear scopedAliasNames at the end of each scope\n+    if (scopedAliasNames != null) {\n+        scopedAliasNames.clear();\n+    }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,17 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n+    if (t.getScopeDepth() == 2) {\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+    // add a check to clear scopedAliasNames at the end of each scope\n+    if (scopedAliasNames != null) {\n+        scopedAliasNames.clear();\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n        scopedAliasNames.clear(); // added to fix bug\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue().detachFromParent() : null; // added to remove node\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                varNode = isVar ? parent : IR.exprResult(value).useSourceInfoFrom(parent); // modified to account for cases where value is not a Variable Reference\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) { // modified to check if aliases contains key\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -9,5 +9,6 @@\n         forbiddenLocals.clear();\n         transformation = null;\n         hasNamespaceShadows = false;\n+        scopedAliasNames.clear(); // added to fix bug\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -16,7 +16,7 @@\n         } else if (isVar || isFunctionDecl) {\n             boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n             Node grandparent = parent.getParent();\n-            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n+            Node value = v.getInitialValue() != null ? v.getInitialValue().detachFromParent() : null; // added to remove node\n             Node varNode = null;\n             String name = n.getString();\n             int nameCount = scopedAliasNames.count(name);\n@@ -40,12 +40,7 @@\n                 varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                 grandparent.replaceChild(parent, varNode);\n             } else {\n-                if (value != null) {\n-                    // If this is a VAR, we can just detach the expression and\n-                    // the tree will still be valid.\n-                    value.detachFromParent();\n-                }\n-                varNode = parent;\n+                varNode = isVar ? parent : IR.exprResult(value).useSourceInfoFrom(parent); // modified to account for cases where value is not a Variable Reference\n             }\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,14 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n+        scopedAliasNames.clear(); // added to fix bug\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n        scopedAliasNames.clear(); // FIX: clear scopedAliasNames\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n    // FIX: clear scopedAliasNames after processing vars\n    scopedAliasNames.clear();\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n            // FIX: clear typeNodes after processing\n            info.getTypeNodes().clear();\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -9,5 +9,6 @@\n         forbiddenLocals.clear();\n         transformation = null;\n         hasNamespaceShadows = false;\n+        scopedAliasNames.clear(); // FIX: clear scopedAliasNames\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -66,4 +66,6 @@\n             report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n         }\n     }\n+    // FIX: clear scopedAliasNames after processing vars\n+    scopedAliasNames.clear();\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,14 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n+        scopedAliasNames.clear(); // FIX: clear scopedAliasNames\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n            continue;\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n            continue;\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = IR.var(IR.name(\"\").useSourceInfoIfMissingFromForTree(n)).useSourceInfoIfMissingFromForTree(n);\n                Node lhs = newDecl.getFirstChild();\n                lhs.setString(globalName);\n                Node rhs = value != null ? value.cloneTree() : IR.name(\"undefined\").useSourceInfoIfMissingFromForTree(n);\n                lhs.addChildAfter(rhs, null);\n                JSDocInfo info = v.getJSDocInfo();\n                JSDocInfoBuilder builder = JSDocInfoBuilder.copyFrom(info);\n                builder.recordAliasForName(globalName);\n                builder.recordSuppressions(info != null ? info.getSuppressions() : ImmutableList.<String>of());\n                NodeUtil.setJsDocInfo(lhs, builder.build(scope, null));\n                NodeUtil.setDebugInformation(lhs.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(IR.name(globalName).useSourceInfoFrom(n));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(name);\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                if (!aliasDefinitionsInOrder.contains(n)) {\n                    aliasDefinitionsInOrder.add(n);\n                }\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -10,9 +10,11 @@\n         } else if (v.isBleedingFunction()) {\n             // Bleeding functions already get a BAD_PARAMETERS error, so just\n             // do nothing.\n+            continue;\n         } else if (parent.getType() == Token.LP) {\n             // Parameters of the scope function also get a BAD_PARAMETERS\n             // error.\n+            continue;\n         } else if (isVar || isFunctionDecl) {\n             boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n             Node grandparent = parent.getParent();\n@@ -50,8 +52,17 @@\n             // Add $jscomp.scope.name = EXPR;\n             // Make sure we copy over all the jsdoc and debug info.\n             if (value != null || v.getJSDocInfo() != null) {\n-                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+                Node newDecl = IR.var(IR.name(\"\").useSourceInfoIfMissingFromForTree(n)).useSourceInfoIfMissingFromForTree(n);\n+                Node lhs = newDecl.getFirstChild();\n+                lhs.setString(globalName);\n+                Node rhs = value != null ? value.cloneTree() : IR.name(\"undefined\").useSourceInfoIfMissingFromForTree(n);\n+                lhs.addChildAfter(rhs, null);\n+                JSDocInfo info = v.getJSDocInfo();\n+                JSDocInfoBuilder builder = JSDocInfoBuilder.copyFrom(info);\n+                builder.recordAliasForName(globalName);\n+                builder.recordSuppressions(info != null ? info.getSuppressions() : ImmutableList.<String>of());\n+                NodeUtil.setJsDocInfo(lhs, builder.build(scope, null));\n+                NodeUtil.setDebugInformation(lhs.getFirstChild().getFirstChild(), n, name);\n                 if (isHoisted) {\n                     grandparent.addChildToFront(newDecl);\n                 } else {\n@@ -59,7 +70,7 @@\n                 }\n             }\n             // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            v.getNameNode().addChildToFront(IR.name(globalName).useSourceInfoFrom(n));\n             recordAlias(v);\n         } else {\n             // Do not other kinds of local symbols, like catch params.\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,13 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n-    }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n     if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n    // Clear scopedAliasNames to avoid referencing old names\n    scopedAliasNames.clear();\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\"\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n    // Clear scopedAliasNames to avoid referencing old names\n    scopedAliasNames.clear();\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    boolean isAliasDefinition = aliasDefinitionsInOrder.contains(n);\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2 && !isAliasDefinition) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2 || isAliasDefinition) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.java@exitScope\n+++ com/google/javascript/jscomp/ScopedAliases.java@exitScope\n@@ -10,4 +10,6 @@\n         transformation = null;\n         hasNamespaceShadows = false;\n     }\n+    // Clear scopedAliasNames to avoid referencing old names\n+    scopedAliasNames.clear();\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@findAliases\n+++ com/google/javascript/jscomp/ScopedAliases.java@findAliases\n@@ -26,7 +26,7 @@\n             // First, we need to free up the function expression (EXPR)\n             // to be used in another expression.\n             if (isFunctionDecl) {\n-                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n+                // Replace \"function NAME() { ... }\" with \"var NAME;\"\n                 Node existingName = v.getNameNode();\n                 // We can't keep the local name on the function expression,\n                 // because IE is buggy and will leak the name into the global\n@@ -66,4 +66,6 @@\n             report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n         }\n     }\n+    // Clear scopedAliasNames to avoid referencing old names\n+    scopedAliasNames.clear();\n }\n--- com/google/javascript/jscomp/ScopedAliases.java@visit\n+++ com/google/javascript/jscomp/ScopedAliases.java@visit\n@@ -1,60 +1,15 @@\n @Override\n-public void visit(NodeTraversal t, Node n, Node parent) {\n-    if (isCallToScopeMethod(n)) {\n-        validateScopeCall(t, n, n.getParent());\n+public void exitScope(NodeTraversal t) {\n+    if (t.getScopeDepth() > 2) {\n+        findNamespaceShadows(t);\n     }\n-    if (t.getScopeDepth() < 2) {\n-        return;\n+    if (t.getScopeDepth() == 2) {\n+        renameNamespaceShadows(t);\n+        aliases.clear();\n+        forbiddenLocals.clear();\n+        transformation = null;\n+        hasNamespaceShadows = false;\n     }\n-    int type = n.getType();\n-    Var aliasVar = null;\n-    if (type == Token.NAME) {\n-        String name = n.getString();\n-        Var lexicalVar = t.getScope().getVar(n.getString());\n-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n-            aliasVar = lexicalVar;\n-        }\n-    }\n-    // Validate the top-level of the goog.scope block.\n-    if (t.getScopeDepth() == 2) {\n-        if (aliasVar != null && NodeUtil.isLValue(n)) {\n-            if (aliasVar.getNode() == n) {\n-                aliasDefinitionsInOrder.add(n);\n-                // Return early, to ensure that we don't record a definition\n-                // twice.\n-                return;\n-            } else {\n-                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n-            }\n-        }\n-        if (type == Token.RETURN) {\n-            report(t, n, GOOG_SCOPE_USES_RETURN);\n-        } else if (type == Token.THIS) {\n-            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n-        } else if (type == Token.THROW) {\n-            report(t, n, GOOG_SCOPE_USES_THROW);\n-        }\n-    }\n-    // Validate all descendent scopes of the goog.scope block.\n-    if (t.getScopeDepth() >= 2) {\n-        // Check if this name points to an alias.\n-        if (aliasVar != null) {\n-            // Note, to support the transitive case, it's important we don't\n-            // clone aliasedNode here.  For example,\n-            // var g = goog; var d = g.dom; d.createElement('DIV');\n-            // The node in aliasedNode (which is \"g\") will be replaced in the\n-            // changes pass above with \"goog\".  If we cloned here, we'd end up\n-            // with <code>g.dom.createElement('DIV')</code>.\n-            aliasUsages.add(new AliasedNode(aliasVar, n));\n-        }\n-        // When we inject declarations, we duplicate jsdoc. Make sure\n-        // we only process that jsdoc once.\n-        JSDocInfo info = n.getJSDocInfo();\n-        if (info != null) {\n-            for (Node node : info.getTypeNodes()) {\n-                fixTypeNode(node);\n-            }\n-        }\n-        // TODO(robbyw): Error for goog.scope not at root.\n-    }\n+    // Clear scopedAliasNames to avoid referencing old names\n+    scopedAliasNames.clear();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]