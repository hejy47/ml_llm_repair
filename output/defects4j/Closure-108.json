[{"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    } else if (t.getScopeDepth() == 2) { // Use else if to avoid unnecessary checks\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            n.getFirstChild().replaceWith(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n.getFirstChild(), name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, parent); // Use parent instead of n.getParent() for consistency with validateScopeCall\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && aliases.containsKey(name) && aliases.get(name) == lexicalVar) { // Use containsKey and get for consistency with recordAlias\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO: Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.javaexitScope\n+++ com/google/javascript/jscomp/ScopedAliases.javaexitScope\n@@ -1,13 +1,69 @@\n-@Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n-    }\n-    if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+private void findAliases(NodeTraversal t) {\n+    Scope scope = t.getScope();\n+    for (Var v : scope.getVarIterable()) {\n+        Node n = v.getNode();\n+        Node parent = n.getParent();\n+        boolean isVar = parent.isVar();\n+        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n+        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n+            recordAlias(v);\n+        } else if (v.isBleedingFunction()) {\n+            // Bleeding functions already get a BAD_PARAMETERS error, so just\n+            // do nothing.\n+        } else if (parent.getType() == Token.LP) {\n+            // Parameters of the scope function also get a BAD_PARAMETERS\n+            // error.\n+        } else if (isVar || isFunctionDecl) {\n+            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n+            Node grandparent = parent.getParent();\n+            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n+            Node varNode = null;\n+            String name = n.getString();\n+            int nameCount = scopedAliasNames.count(name);\n+            scopedAliasNames.add(name);\n+            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n+            compiler.ensureLibraryInjected(\"base\");\n+            // First, we need to free up the function expression (EXPR)\n+            // to be used in another expression.\n+            if (isFunctionDecl) {\n+                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n+                Node existingName = v.getNameNode();\n+                // We can't keep the local name on the function expression,\n+                // because IE is buggy and will leak the name into the global\n+                // scope. This is covered in more detail here:\n+                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n+                //\n+                // This will only cause problems if this is a hoisted, recursive\n+                // function, and the programmer is using the hoisting.\n+                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n+                value.replaceChild(existingName, newName);\n+                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n+                grandparent.replaceChild(parent, varNode);\n+            } else {\n+                if (value != null) {\n+                    // If this is a VAR, we can just detach the expression and\n+                    // the tree will still be valid.\n+                    value.detachFromParent();\n+                }\n+                varNode = parent;\n+            }\n+            // Add $jscomp.scope.name = EXPR;\n+            // Make sure we copy over all the jsdoc and debug info.\n+            if (value != null || v.getJSDocInfo() != null) {\n+                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n+                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+                if (isHoisted) {\n+                    grandparent.addChildToFront(newDecl);\n+                } else {\n+                    grandparent.addChildBefore(newDecl, varNode);\n+                }\n+            }\n+            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n+            n.getFirstChild().replaceWith(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n.getFirstChild(), name));\n+            recordAlias(v);\n+        } else {\n+            // Do not other kinds of local symbols, like catch params.\n+            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n+        }\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.javafindAliases\n+++ com/google/javascript/jscomp/ScopedAliases.javafindAliases\n@@ -1,69 +1,60 @@\n-private void findAliases(NodeTraversal t) {\n-    Scope scope = t.getScope();\n-    for (Var v : scope.getVarIterable()) {\n-        Node n = v.getNode();\n-        Node parent = n.getParent();\n-        boolean isVar = parent.isVar();\n-        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n-        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n-            recordAlias(v);\n-        } else if (v.isBleedingFunction()) {\n-            // Bleeding functions already get a BAD_PARAMETERS error, so just\n-            // do nothing.\n-        } else if (parent.getType() == Token.LP) {\n-            // Parameters of the scope function also get a BAD_PARAMETERS\n-            // error.\n-        } else if (isVar || isFunctionDecl) {\n-            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n-            Node grandparent = parent.getParent();\n-            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n-            Node varNode = null;\n-            String name = n.getString();\n-            int nameCount = scopedAliasNames.count(name);\n-            scopedAliasNames.add(name);\n-            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n-            compiler.ensureLibraryInjected(\"base\");\n-            // First, we need to free up the function expression (EXPR)\n-            // to be used in another expression.\n-            if (isFunctionDecl) {\n-                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n-                Node existingName = v.getNameNode();\n-                // We can't keep the local name on the function expression,\n-                // because IE is buggy and will leak the name into the global\n-                // scope. This is covered in more detail here:\n-                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n-                //\n-                // This will only cause problems if this is a hoisted, recursive\n-                // function, and the programmer is using the hoisting.\n-                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n-                value.replaceChild(existingName, newName);\n-                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n-                grandparent.replaceChild(parent, varNode);\n-            } else {\n-                if (value != null) {\n-                    // If this is a VAR, we can just detach the expression and\n-                    // the tree will still be valid.\n-                    value.detachFromParent();\n-                }\n-                varNode = parent;\n-            }\n-            // Add $jscomp.scope.name = EXPR;\n-            // Make sure we copy over all the jsdoc and debug info.\n-            if (value != null || v.getJSDocInfo() != null) {\n-                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n-                if (isHoisted) {\n-                    grandparent.addChildToFront(newDecl);\n-                } else {\n-                    grandparent.addChildBefore(newDecl, varNode);\n-                }\n-            }\n-            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n-            recordAlias(v);\n-        } else {\n-            // Do not other kinds of local symbols, like catch params.\n-            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n+@Override\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, parent); // Use parent instead of n.getParent() for consistency with validateScopeCall\n+    }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(n.getString());\n+        if (lexicalVar != null && aliases.containsKey(name) && aliases.get(name) == lexicalVar) { // Use containsKey and get for consistency with recordAlias\n+            aliasVar = lexicalVar;\n         }\n     }\n+    // Validate the top-level of the goog.scope block.\n+    if (t.getScopeDepth() == 2) {\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendent scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO: Error for goog.scope not at root.\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n    // Clear the scoped alias names regardless of the scope depth.\n    scopedAliasNames = HashMultiset.create();\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n    // Make sure we clear the scoped alias names for each scope.\n    scopedAliasNames.clear();\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        // TODO: Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.javaexitScope\n+++ com/google/javascript/jscomp/ScopedAliases.javaexitScope\n@@ -1,13 +1,71 @@\n-@Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n+private void findAliases(NodeTraversal t) {\n+    Scope scope = t.getScope();\n+    for (Var v : scope.getVarIterable()) {\n+        Node n = v.getNode();\n+        Node parent = n.getParent();\n+        boolean isVar = parent.isVar();\n+        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n+        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n+            recordAlias(v);\n+        } else if (v.isBleedingFunction()) {\n+            // Bleeding functions already get a BAD_PARAMETERS error, so just\n+            // do nothing.\n+        } else if (parent.getType() == Token.LP) {\n+            // Parameters of the scope function also get a BAD_PARAMETERS\n+            // error.\n+        } else if (isVar || isFunctionDecl) {\n+            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n+            Node grandparent = parent.getParent();\n+            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n+            Node varNode = null;\n+            String name = n.getString();\n+            int nameCount = scopedAliasNames.count(name);\n+            scopedAliasNames.add(name);\n+            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n+            compiler.ensureLibraryInjected(\"base\");\n+            // First, we need to free up the function expression (EXPR)\n+            // to be used in another expression.\n+            if (isFunctionDecl) {\n+                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n+                Node existingName = v.getNameNode();\n+                // We can't keep the local name on the function expression,\n+                // because IE is buggy and will leak the name into the global\n+                // scope. This is covered in more detail here:\n+                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n+                //\n+                // This will only cause problems if this is a hoisted, recursive\n+                // function, and the programmer is using the hoisting.\n+                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n+                value.replaceChild(existingName, newName);\n+                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n+                grandparent.replaceChild(parent, varNode);\n+            } else {\n+                if (value != null) {\n+                    // If this is a VAR, we can just detach the expression and\n+                    // the tree will still be valid.\n+                    value.detachFromParent();\n+                }\n+                varNode = parent;\n+            }\n+            // Add $jscomp.scope.name = EXPR;\n+            // Make sure we copy over all the jsdoc and debug info.\n+            if (value != null || v.getJSDocInfo() != null) {\n+                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n+                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+                if (isHoisted) {\n+                    grandparent.addChildToFront(newDecl);\n+                } else {\n+                    grandparent.addChildBefore(newDecl, varNode);\n+                }\n+            }\n+            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n+            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            recordAlias(v);\n+        } else {\n+            // Do not other kinds of local symbols, like catch params.\n+            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n+        }\n     }\n-    if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n-    }\n+    // Make sure we clear the scoped alias names for each scope.\n+    scopedAliasNames.clear();\n }\n--- com/google/javascript/jscomp/ScopedAliases.javafindAliases\n+++ com/google/javascript/jscomp/ScopedAliases.javafindAliases\n@@ -1,69 +1,60 @@\n-private void findAliases(NodeTraversal t) {\n-    Scope scope = t.getScope();\n-    for (Var v : scope.getVarIterable()) {\n-        Node n = v.getNode();\n-        Node parent = n.getParent();\n-        boolean isVar = parent.isVar();\n-        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n-        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n-            recordAlias(v);\n-        } else if (v.isBleedingFunction()) {\n-            // Bleeding functions already get a BAD_PARAMETERS error, so just\n-            // do nothing.\n-        } else if (parent.getType() == Token.LP) {\n-            // Parameters of the scope function also get a BAD_PARAMETERS\n-            // error.\n-        } else if (isVar || isFunctionDecl) {\n-            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n-            Node grandparent = parent.getParent();\n-            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n-            Node varNode = null;\n-            String name = n.getString();\n-            int nameCount = scopedAliasNames.count(name);\n-            scopedAliasNames.add(name);\n-            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n-            compiler.ensureLibraryInjected(\"base\");\n-            // First, we need to free up the function expression (EXPR)\n-            // to be used in another expression.\n-            if (isFunctionDecl) {\n-                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n-                Node existingName = v.getNameNode();\n-                // We can't keep the local name on the function expression,\n-                // because IE is buggy and will leak the name into the global\n-                // scope. This is covered in more detail here:\n-                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n-                //\n-                // This will only cause problems if this is a hoisted, recursive\n-                // function, and the programmer is using the hoisting.\n-                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n-                value.replaceChild(existingName, newName);\n-                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n-                grandparent.replaceChild(parent, varNode);\n-            } else {\n-                if (value != null) {\n-                    // If this is a VAR, we can just detach the expression and\n-                    // the tree will still be valid.\n-                    value.detachFromParent();\n-                }\n-                varNode = parent;\n-            }\n-            // Add $jscomp.scope.name = EXPR;\n-            // Make sure we copy over all the jsdoc and debug info.\n-            if (value != null || v.getJSDocInfo() != null) {\n-                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n-                if (isHoisted) {\n-                    grandparent.addChildToFront(newDecl);\n-                } else {\n-                    grandparent.addChildBefore(newDecl, varNode);\n-                }\n-            }\n-            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n-            recordAlias(v);\n-        } else {\n-            // Do not other kinds of local symbols, like catch params.\n-            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n+@Override\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n+    }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(n.getString());\n+        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n         }\n     }\n+    // Validate the top-level of the goog.scope block.\n+    if (t.getScopeDepth() == 2) {\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendent scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        // TODO: Error for goog.scope not at root.\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2 && hasNamespaceShadows) { // Only rename if there are namespace shadows\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) { // check if name points to an alias\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node typeNode : info.getTypeNodes()) { // fix all type nodes\n                fixTypeNode(typeNode);\n            }\n        }\n        // TODO: Re-implement this error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.javaexitScope\n+++ com/google/javascript/jscomp/ScopedAliases.javaexitScope\n@@ -1,13 +1,69 @@\n-@Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n-    }\n-    if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+private void findAliases(NodeTraversal t) {\n+    Scope scope = t.getScope();\n+    for (Var v : scope.getVarIterable()) {\n+        Node n = v.getNode();\n+        Node parent = n.getParent();\n+        boolean isVar = parent.isVar();\n+        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n+        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n+            recordAlias(v);\n+        } else if (v.isBleedingFunction()) {\n+            // Bleeding functions already get a BAD_PARAMETERS error, so just\n+            // do nothing.\n+        } else if (parent.getType() == Token.LP) {\n+            // Parameters of the scope function also get a BAD_PARAMETERS\n+            // error.\n+        } else if (isVar || isFunctionDecl) {\n+            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n+            Node grandparent = parent.getParent();\n+            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n+            Node varNode = null;\n+            String name = n.getString();\n+            int nameCount = scopedAliasNames.count(name);\n+            scopedAliasNames.add(name);\n+            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n+            compiler.ensureLibraryInjected(\"base\");\n+            // First, we need to free up the function expression (EXPR)\n+            // to be used in another expression.\n+            if (isFunctionDecl) {\n+                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n+                Node existingName = v.getNameNode();\n+                // We can't keep the local name on the function expression,\n+                // because IE is buggy and will leak the name into the global\n+                // scope. This is covered in more detail here:\n+                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n+                //\n+                // This will only cause problems if this is a hoisted, recursive\n+                // function, and the programmer is using the hoisting.\n+                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n+                value.replaceChild(existingName, newName);\n+                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n+                grandparent.replaceChild(parent, varNode);\n+            } else {\n+                if (value != null) {\n+                    // If this is a VAR, we can just detach the expression and\n+                    // the tree will still be valid.\n+                    value.detachFromParent();\n+                }\n+                varNode = parent;\n+            }\n+            // Add $jscomp.scope.name = EXPR;\n+            // Make sure we copy over all the jsdoc and debug info.\n+            if (value != null || v.getJSDocInfo() != null) {\n+                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n+                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+                if (isHoisted) {\n+                    grandparent.addChildToFront(newDecl);\n+                } else {\n+                    grandparent.addChildBefore(newDecl, varNode);\n+                }\n+            }\n+            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n+            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            recordAlias(v);\n+        } else {\n+            // Do not other kinds of local symbols, like catch params.\n+            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n+        }\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.javafindAliases\n+++ com/google/javascript/jscomp/ScopedAliases.javafindAliases\n@@ -1,69 +1,60 @@\n-private void findAliases(NodeTraversal t) {\n-    Scope scope = t.getScope();\n-    for (Var v : scope.getVarIterable()) {\n-        Node n = v.getNode();\n-        Node parent = n.getParent();\n-        boolean isVar = parent.isVar();\n-        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n-        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n-            recordAlias(v);\n-        } else if (v.isBleedingFunction()) {\n-            // Bleeding functions already get a BAD_PARAMETERS error, so just\n-            // do nothing.\n-        } else if (parent.getType() == Token.LP) {\n-            // Parameters of the scope function also get a BAD_PARAMETERS\n-            // error.\n-        } else if (isVar || isFunctionDecl) {\n-            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n-            Node grandparent = parent.getParent();\n-            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n-            Node varNode = null;\n-            String name = n.getString();\n-            int nameCount = scopedAliasNames.count(name);\n-            scopedAliasNames.add(name);\n-            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n-            compiler.ensureLibraryInjected(\"base\");\n-            // First, we need to free up the function expression (EXPR)\n-            // to be used in another expression.\n-            if (isFunctionDecl) {\n-                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n-                Node existingName = v.getNameNode();\n-                // We can't keep the local name on the function expression,\n-                // because IE is buggy and will leak the name into the global\n-                // scope. This is covered in more detail here:\n-                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n-                //\n-                // This will only cause problems if this is a hoisted, recursive\n-                // function, and the programmer is using the hoisting.\n-                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n-                value.replaceChild(existingName, newName);\n-                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n-                grandparent.replaceChild(parent, varNode);\n-            } else {\n-                if (value != null) {\n-                    // If this is a VAR, we can just detach the expression and\n-                    // the tree will still be valid.\n-                    value.detachFromParent();\n-                }\n-                varNode = parent;\n-            }\n-            // Add $jscomp.scope.name = EXPR;\n-            // Make sure we copy over all the jsdoc and debug info.\n-            if (value != null || v.getJSDocInfo() != null) {\n-                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n-                if (isHoisted) {\n-                    grandparent.addChildToFront(newDecl);\n-                } else {\n-                    grandparent.addChildBefore(newDecl, varNode);\n-                }\n-            }\n-            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n-            recordAlias(v);\n-        } else {\n-            // Do not other kinds of local symbols, like catch params.\n-            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n+@Override\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n+    }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(n.getString());\n+        if (lexicalVar != null && aliases.containsKey(name) && lexicalVar == aliases.get(name)) { // check if name points to an alias\n+            aliasVar = lexicalVar;\n         }\n     }\n+    // Validate the top-level of the goog.scope block.\n+    if (t.getScopeDepth() == 2) {\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendent scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node typeNode : info.getTypeNodes()) { // fix all type nodes\n+                fixTypeNode(typeNode);\n+            }\n+        }\n+        // TODO: Re-implement this error for goog.scope not at root.\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformScopedVars.clear(); // ADD THIS LINE TO FIX THE BUG\n        transformation = null;\n        hasNamespaceShadows = false;\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendent scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            for (Node node : info.getTypeNodes()) {\n                fixTypeNode(node);\n            }\n        }\n        if (type == Token.IF && n.hasChildren()) { // ADD THIS BLOCK TO FIX THE BUG\n            Node firstChild = n.getFirstChild();\n            int firstChildType = firstChild.getType();\n            if (firstChildType == Token.AND || firstChildType == Token.OR) {\n                boolean leftOperandIsScopeName = isScopeName(firstChild.getFirstChild(), t.getScope());\n                boolean rightOperandIsScopeName = isScopeName(firstChild.getLastChild(), t.getScope());\n                if (leftOperandIsScopeName && !rightOperandIsScopeName) {\n                    report(t, firstChild.getLastChild(), INVALID_SCOPE_REFERENCE);\n                } else if (rightOperandIsScopeName && !leftOperandIsScopeName) {\n                    report(t, firstChild.getFirstChild(), INVALID_SCOPE_REFERENCE);\n                }\n            }\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}\n\nprivate boolean isScopeName(Node n, Scope scope) { // ADD THIS FUNCTION TO FIX THE BUG\n    if (n.getType() == Token.NAME) {\n        Var var = scope.getVar(n.getString());\n        return var != null && aliases.values().contains(var);\n    }\n    return false;\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.javaexitScope\n+++ com/google/javascript/jscomp/ScopedAliases.javaexitScope\n@@ -1,13 +1,69 @@\n-@Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n-    }\n-    if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+private void findAliases(NodeTraversal t) {\n+    Scope scope = t.getScope();\n+    for (Var v : scope.getVarIterable()) {\n+        Node n = v.getNode();\n+        Node parent = n.getParent();\n+        boolean isVar = parent.isVar();\n+        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n+        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n+            recordAlias(v);\n+        } else if (v.isBleedingFunction()) {\n+            // Bleeding functions already get a BAD_PARAMETERS error, so just\n+            // do nothing.\n+        } else if (parent.getType() == Token.LP) {\n+            // Parameters of the scope function also get a BAD_PARAMETERS\n+            // error.\n+        } else if (isVar || isFunctionDecl) {\n+            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n+            Node grandparent = parent.getParent();\n+            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n+            Node varNode = null;\n+            String name = n.getString();\n+            int nameCount = scopedAliasNames.count(name);\n+            scopedAliasNames.add(name);\n+            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n+            compiler.ensureLibraryInjected(\"base\");\n+            // First, we need to free up the function expression (EXPR)\n+            // to be used in another expression.\n+            if (isFunctionDecl) {\n+                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n+                Node existingName = v.getNameNode();\n+                // We can't keep the local name on the function expression,\n+                // because IE is buggy and will leak the name into the global\n+                // scope. This is covered in more detail here:\n+                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n+                //\n+                // This will only cause problems if this is a hoisted, recursive\n+                // function, and the programmer is using the hoisting.\n+                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n+                value.replaceChild(existingName, newName);\n+                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n+                grandparent.replaceChild(parent, varNode);\n+            } else {\n+                if (value != null) {\n+                    // If this is a VAR, we can just detach the expression and\n+                    // the tree will still be valid.\n+                    value.detachFromParent();\n+                }\n+                varNode = parent;\n+            }\n+            // Add $jscomp.scope.name = EXPR;\n+            // Make sure we copy over all the jsdoc and debug info.\n+            if (value != null || v.getJSDocInfo() != null) {\n+                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n+                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+                if (isHoisted) {\n+                    grandparent.addChildToFront(newDecl);\n+                } else {\n+                    grandparent.addChildBefore(newDecl, varNode);\n+                }\n+            }\n+            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n+            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            recordAlias(v);\n+        } else {\n+            // Do not other kinds of local symbols, like catch params.\n+            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n+        }\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.javafindAliases\n+++ com/google/javascript/jscomp/ScopedAliases.javafindAliases\n@@ -1,69 +1,73 @@\n-private void findAliases(NodeTraversal t) {\n-    Scope scope = t.getScope();\n-    for (Var v : scope.getVarIterable()) {\n-        Node n = v.getNode();\n-        Node parent = n.getParent();\n-        boolean isVar = parent.isVar();\n-        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n-        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n-            recordAlias(v);\n-        } else if (v.isBleedingFunction()) {\n-            // Bleeding functions already get a BAD_PARAMETERS error, so just\n-            // do nothing.\n-        } else if (parent.getType() == Token.LP) {\n-            // Parameters of the scope function also get a BAD_PARAMETERS\n-            // error.\n-        } else if (isVar || isFunctionDecl) {\n-            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n-            Node grandparent = parent.getParent();\n-            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n-            Node varNode = null;\n-            String name = n.getString();\n-            int nameCount = scopedAliasNames.count(name);\n-            scopedAliasNames.add(name);\n-            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n-            compiler.ensureLibraryInjected(\"base\");\n-            // First, we need to free up the function expression (EXPR)\n-            // to be used in another expression.\n-            if (isFunctionDecl) {\n-                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n-                Node existingName = v.getNameNode();\n-                // We can't keep the local name on the function expression,\n-                // because IE is buggy and will leak the name into the global\n-                // scope. This is covered in more detail here:\n-                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n-                //\n-                // This will only cause problems if this is a hoisted, recursive\n-                // function, and the programmer is using the hoisting.\n-                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n-                value.replaceChild(existingName, newName);\n-                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n-                grandparent.replaceChild(parent, varNode);\n+@Override\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n+    }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(n.getString());\n+        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n+        }\n+    }\n+    // Validate the top-level of the goog.scope block.\n+    if (t.getScopeDepth() == 2) {\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n             } else {\n-                if (value != null) {\n-                    // If this is a VAR, we can just detach the expression and\n-                    // the tree will still be valid.\n-                    value.detachFromParent();\n-                }\n-                varNode = parent;\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n             }\n-            // Add $jscomp.scope.name = EXPR;\n-            // Make sure we copy over all the jsdoc and debug info.\n-            if (value != null || v.getJSDocInfo() != null) {\n-                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n-                if (isHoisted) {\n-                    grandparent.addChildToFront(newDecl);\n-                } else {\n-                    grandparent.addChildBefore(newDecl, varNode);\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendent scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            for (Node node : info.getTypeNodes()) {\n+                fixTypeNode(node);\n+            }\n+        }\n+        if (type == Token.IF && n.hasChildren()) { // ADD THIS BLOCK TO FIX THE BUG\n+            Node firstChild = n.getFirstChild();\n+            int firstChildType = firstChild.getType();\n+            if (firstChildType == Token.AND || firstChildType == Token.OR) {\n+                boolean leftOperandIsScopeName = isScopeName(firstChild.getFirstChild(), t.getScope());\n+                boolean rightOperandIsScopeName = isScopeName(firstChild.getLastChild(), t.getScope());\n+                if (leftOperandIsScopeName && !rightOperandIsScopeName) {\n+                    report(t, firstChild.getLastChild(), INVALID_SCOPE_REFERENCE);\n+                } else if (rightOperandIsScopeName && !leftOperandIsScopeName) {\n+                    report(t, firstChild.getFirstChild(), INVALID_SCOPE_REFERENCE);\n                 }\n             }\n-            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n-            recordAlias(v);\n-        } else {\n-            // Do not other kinds of local symbols, like catch params.\n-            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n         }\n+        // TODO(robbyw): Error for goog.scope not at root.\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void exitScope(NodeTraversal t) {\n    if (t.getScopeDepth() > 2) {\n        findNamespaceShadows(t);\n    }\n    if (t.getScopeDepth() == 2) {\n        renameNamespaceShadows(t);\n        aliases.clear();\n        forbiddenLocals.clear();\n        transformation = null;\n        hasNamespaceShadows = false;\n        scopedAliasNames.clear();\n    }\n}\n\n## Fixed Function 2\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isVar = parent.isVar();\n        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n            recordAlias(v);\n        } else if (v.isBleedingFunction()) {\n            // Bleeding functions already get a BAD_PARAMETERS error, so just\n            // do nothing.\n        } else if (parent.getType() == Token.LP) {\n            // Parameters of the scope function also get a BAD_PARAMETERS\n            // error.\n        } else if (isVar || isFunctionDecl) {\n            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n            Node grandparent = parent.getParent();\n            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n            Node varNode = null;\n            String name = n.getString();\n            int nameCount = scopedAliasNames.count(name);\n            scopedAliasNames.add(name);\n            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n            compiler.ensureLibraryInjected(\"base\");\n            // First, we need to free up the function expression (EXPR)\n            // to be used in another expression.\n            if (isFunctionDecl) {\n                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n                Node existingName = v.getNameNode();\n                // We can't keep the local name on the function expression,\n                // because IE is buggy and will leak the name into the global\n                // scope. This is covered in more detail here:\n                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n                //\n                // This will only cause problems if this is a hoisted, recursive\n                // function, and the programmer is using the hoisting.\n                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n                value.replaceChild(existingName, newName);\n                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n                grandparent.replaceChild(parent, varNode);\n            } else {\n                if (value != null) {\n                    // If this is a VAR, we can just detach the expression and\n                    // the tree will still be valid.\n                    value.detachFromParent();\n                }\n                varNode = parent;\n            }\n            // Add $jscomp.scope.name = EXPR;\n            // Make sure we copy over all the jsdoc and debug info.\n            if (value != null || v.getJSDocInfo() != null) {\n                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n                if (isHoisted) {\n                    grandparent.addChildToFront(newDecl);\n                } else {\n                    grandparent.addChildBefore(newDecl, varNode);\n                }\n            }\n            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n            recordAlias(v);\n        } else {\n            // Do not report other kinds of local symbols, like catch params.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n        }\n    }\n}\n\n## Fixed Function 3\n@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (isCallToScopeMethod(n)) {\n        validateScopeCall(t, n, n.getParent());\n    }\n    if (t.getScopeDepth() < 2) {\n        return;\n    }\n    int type = n.getType();\n    Var aliasVar = null;\n    if (type == Token.NAME) {\n        String name = n.getString();\n        Var lexicalVar = t.getScope().getVar(n.getString());\n        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n            aliasVar = lexicalVar;\n        }\n    }\n    // Validate the top-level of the goog.scope block.\n    if (t.getScopeDepth() == 2) {\n        if (aliasVar != null && NodeUtil.isLValue(n)) {\n            if (aliasVar.getNode() == n) {\n                aliasDefinitionsInOrder.add(n);\n                // Return early, to ensure that we don't record a definition\n                // twice.\n                return;\n            } else {\n                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n            }\n        }\n        if (type == Token.RETURN) {\n            report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n            report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n    }\n    // Validate all descendant scopes of the goog.scope block.\n    if (t.getScopeDepth() >= 2) {\n        // Check if this name points to an alias.\n        if (aliasVar != null) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            aliasUsages.add(new AliasedNode(aliasVar, n));\n        }\n        // When we inject declarations, we duplicate jsdoc. Make sure\n        // we only process that jsdoc once.\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n            info.unnormalize();\n        }\n        // TODO(robbyw): Error for goog.scope not at root.\n    }\n}", "diff": "--- com/google/javascript/jscomp/ScopedAliases.javaexitScope\n+++ com/google/javascript/jscomp/ScopedAliases.javaexitScope\n@@ -1,13 +1,69 @@\n-@Override\n-public void exitScope(NodeTraversal t) {\n-    if (t.getScopeDepth() > 2) {\n-        findNamespaceShadows(t);\n-    }\n-    if (t.getScopeDepth() == 2) {\n-        renameNamespaceShadows(t);\n-        aliases.clear();\n-        forbiddenLocals.clear();\n-        transformation = null;\n-        hasNamespaceShadows = false;\n+private void findAliases(NodeTraversal t) {\n+    Scope scope = t.getScope();\n+    for (Var v : scope.getVarIterable()) {\n+        Node n = v.getNode();\n+        Node parent = n.getParent();\n+        boolean isVar = parent.isVar();\n+        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n+        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n+            recordAlias(v);\n+        } else if (v.isBleedingFunction()) {\n+            // Bleeding functions already get a BAD_PARAMETERS error, so just\n+            // do nothing.\n+        } else if (parent.getType() == Token.LP) {\n+            // Parameters of the scope function also get a BAD_PARAMETERS\n+            // error.\n+        } else if (isVar || isFunctionDecl) {\n+            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n+            Node grandparent = parent.getParent();\n+            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n+            Node varNode = null;\n+            String name = n.getString();\n+            int nameCount = scopedAliasNames.count(name);\n+            scopedAliasNames.add(name);\n+            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n+            compiler.ensureLibraryInjected(\"base\");\n+            // First, we need to free up the function expression (EXPR)\n+            // to be used in another expression.\n+            if (isFunctionDecl) {\n+                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n+                Node existingName = v.getNameNode();\n+                // We can't keep the local name on the function expression,\n+                // because IE is buggy and will leak the name into the global\n+                // scope. This is covered in more detail here:\n+                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n+                //\n+                // This will only cause problems if this is a hoisted, recursive\n+                // function, and the programmer is using the hoisting.\n+                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n+                value.replaceChild(existingName, newName);\n+                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n+                grandparent.replaceChild(parent, varNode);\n+            } else {\n+                if (value != null) {\n+                    // If this is a VAR, we can just detach the expression and\n+                    // the tree will still be valid.\n+                    value.detachFromParent();\n+                }\n+                varNode = parent;\n+            }\n+            // Add $jscomp.scope.name = EXPR;\n+            // Make sure we copy over all the jsdoc and debug info.\n+            if (value != null || v.getJSDocInfo() != null) {\n+                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n+                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n+                if (isHoisted) {\n+                    grandparent.addChildToFront(newDecl);\n+                } else {\n+                    grandparent.addChildBefore(newDecl, varNode);\n+                }\n+            }\n+            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n+            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n+            recordAlias(v);\n+        } else {\n+            // Do not report other kinds of local symbols, like catch params.\n+            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n+        }\n     }\n }\n--- com/google/javascript/jscomp/ScopedAliases.javafindAliases\n+++ com/google/javascript/jscomp/ScopedAliases.javafindAliases\n@@ -1,69 +1,58 @@\n-private void findAliases(NodeTraversal t) {\n-    Scope scope = t.getScope();\n-    for (Var v : scope.getVarIterable()) {\n-        Node n = v.getNode();\n-        Node parent = n.getParent();\n-        boolean isVar = parent.isVar();\n-        boolean isFunctionDecl = NodeUtil.isFunctionDeclaration(parent);\n-        if (isVar && n.getFirstChild() != null && n.getFirstChild().isQualifiedName()) {\n-            recordAlias(v);\n-        } else if (v.isBleedingFunction()) {\n-            // Bleeding functions already get a BAD_PARAMETERS error, so just\n-            // do nothing.\n-        } else if (parent.getType() == Token.LP) {\n-            // Parameters of the scope function also get a BAD_PARAMETERS\n-            // error.\n-        } else if (isVar || isFunctionDecl) {\n-            boolean isHoisted = NodeUtil.isHoistedFunctionDeclaration(parent);\n-            Node grandparent = parent.getParent();\n-            Node value = v.getInitialValue() != null ? v.getInitialValue() : null;\n-            Node varNode = null;\n-            String name = n.getString();\n-            int nameCount = scopedAliasNames.count(name);\n-            scopedAliasNames.add(name);\n-            String globalName = \"$jscomp.scope.\" + name + (nameCount == 0 ? \"\" : (\"$\" + nameCount));\n-            compiler.ensureLibraryInjected(\"base\");\n-            // First, we need to free up the function expression (EXPR)\n-            // to be used in another expression.\n-            if (isFunctionDecl) {\n-                // Replace \"function NAME() { ... }\" with \"var NAME;\".\n-                Node existingName = v.getNameNode();\n-                // We can't keep the local name on the function expression,\n-                // because IE is buggy and will leak the name into the global\n-                // scope. This is covered in more detail here:\n-                // http://wiki.ecmascript.org/lib/exe/fetch.php?id=resources:resources&cache=cache&media=resources:jscriptdeviationsfromes3.pdf\n-                //\n-                // This will only cause problems if this is a hoisted, recursive\n-                // function, and the programmer is using the hoisting.\n-                Node newName = IR.name(\"\").useSourceInfoFrom(existingName);\n-                value.replaceChild(existingName, newName);\n-                varNode = IR.var(existingName).useSourceInfoFrom(existingName);\n-                grandparent.replaceChild(parent, varNode);\n-            } else {\n-                if (value != null) {\n-                    // If this is a VAR, we can just detach the expression and\n-                    // the tree will still be valid.\n-                    value.detachFromParent();\n-                }\n-                varNode = parent;\n-            }\n-            // Add $jscomp.scope.name = EXPR;\n-            // Make sure we copy over all the jsdoc and debug info.\n-            if (value != null || v.getJSDocInfo() != null) {\n-                Node newDecl = NodeUtil.newQualifiedNameNodeDeclaration(compiler.getCodingConvention(), globalName, value, v.getJSDocInfo()).useSourceInfoIfMissingFromForTree(n);\n-                NodeUtil.setDebugInformation(newDecl.getFirstChild().getFirstChild(), n, name);\n-                if (isHoisted) {\n-                    grandparent.addChildToFront(newDecl);\n-                } else {\n-                    grandparent.addChildBefore(newDecl, varNode);\n-                }\n-            }\n-            // Rewrite \"var name = EXPR;\" to \"var name = $jscomp.scope.name;\"\n-            v.getNameNode().addChildToFront(NodeUtil.newQualifiedNameNode(compiler.getCodingConvention(), globalName, n, name));\n-            recordAlias(v);\n-        } else {\n-            // Do not other kinds of local symbols, like catch params.\n-            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n+@Override\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (isCallToScopeMethod(n)) {\n+        validateScopeCall(t, n, n.getParent());\n+    }\n+    if (t.getScopeDepth() < 2) {\n+        return;\n+    }\n+    int type = n.getType();\n+    Var aliasVar = null;\n+    if (type == Token.NAME) {\n+        String name = n.getString();\n+        Var lexicalVar = t.getScope().getVar(n.getString());\n+        if (lexicalVar != null && lexicalVar == aliases.get(name)) {\n+            aliasVar = lexicalVar;\n         }\n     }\n+    // Validate the top-level of the goog.scope block.\n+    if (t.getScopeDepth() == 2) {\n+        if (aliasVar != null && NodeUtil.isLValue(n)) {\n+            if (aliasVar.getNode() == n) {\n+                aliasDefinitionsInOrder.add(n);\n+                // Return early, to ensure that we don't record a definition\n+                // twice.\n+                return;\n+            } else {\n+                report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n+            }\n+        }\n+        if (type == Token.RETURN) {\n+            report(t, n, GOOG_SCOPE_USES_RETURN);\n+        } else if (type == Token.THIS) {\n+            report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n+        } else if (type == Token.THROW) {\n+            report(t, n, GOOG_SCOPE_USES_THROW);\n+        }\n+    }\n+    // Validate all descendant scopes of the goog.scope block.\n+    if (t.getScopeDepth() >= 2) {\n+        // Check if this name points to an alias.\n+        if (aliasVar != null) {\n+            // Note, to support the transitive case, it's important we don't\n+            // clone aliasedNode here.  For example,\n+            // var g = goog; var d = g.dom; d.createElement('DIV');\n+            // The node in aliasedNode (which is \"g\") will be replaced in the\n+            // changes pass above with \"goog\".  If we cloned here, we'd end up\n+            // with <code>g.dom.createElement('DIV')</code>.\n+            aliasUsages.add(new AliasedNode(aliasVar, n));\n+        }\n+        // When we inject declarations, we duplicate jsdoc. Make sure\n+        // we only process that jsdoc once.\n+        JSDocInfo info = n.getJSDocInfo();\n+        if (info != null) {\n+            info.unnormalize();\n+        }\n+        // TODO(robbyw): Error for goog.scope not at root.\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]