[{"output": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n        return null;\n    }\n\n    switch (parent.getType()) {\n        case Token.IF:\n            return computeFollowNode(fromNode, parent, cfa);\n        case Token.CASE:\n        case Token.DEFAULT_CASE:\n            if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                    return computeFirstExecutedNode(parent.getNext().getFirstChild().getNext());\n                } else if (parent.getNext().isDefaultCase()) {\n                    return computeFirstExecutedNode(parent.getNext().getFirstChild());\n                } else {\n                    Preconditions.checkState(false, \"Not reachable\");\n                }\n            } else {\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n            break;\n        case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            } else {\n                return computeFirstExecutedNode(parent.getFirstChild().getNext().getNext());\n            }\n        case Token.WHILE:\n        case Token.DO:\n            return parent;\n        case Token.TRY:\n            if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    return computeFirstExecutedNode(parent.getLastChild());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n            } else if (NodeUtil.getCatchBlock(parent) == node) {\n                if (NodeUtil.hasFinally(parent)) {\n                    return computeFirstExecutedNode(node.getNext());\n                } else {\n                    return computeFollowNode(fromNode, parent, cfa);\n                }\n            } else if (parent.getLastChild() == node) {\n                if (cfa != null) {\n                    for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                        cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n            }\n    }\n\n    Node nextNode = node.getNext();\n    while (nextNode != null && nextNode.isFunction()) {\n        nextNode = nextNode.getNext();\n    }\n\n    if (nextNode != null) {\n        return computeFirstExecutedNode(nextNode);\n    } else {\n        return computeFollowNode(fromNode, parent, cfa);\n    }\n}\n\nprivate static Node computeFirstExecutedNode(Node node) {\n    if (node.hasChildren()) {\n        return node.getFirstChild();\n    } else {\n        return node;\n    }\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 5}]