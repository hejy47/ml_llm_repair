[{"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    new MoveNamedFunctionExpression().process(externs, root);\n    Node globalScope = root.getFirstChild();\n    declareVars(externs, globalScope);\n    removeDuplicateDeclarations(externs, globalScope);\n    new MoveFunctionDeclarations(compiler, assertOnChange).process(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, I'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    // If the variable is marked as constant, ensure that it is declared\n    // with \"const\" instead of \"var\".\n    int tokenType = Token.VAR;\n    if (nameNode.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n        tokenType = Token.CONST;\n    }\n    Node varNode = new Node(tokenType);\n    varNode.addChildToBack(nameNode);\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -9,7 +9,7 @@\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n+    // only valid within the catch block, but our current Scope logic\n     // has no concept of this and includes it in the containing function\n     // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n     // names unique so that removeDuplicateDeclarations() will properly handle\n@@ -19,8 +19,12 @@\n     //      var e = 1; // f scope 'e'\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    removeDuplicateDeclarations(externs, root);\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n+    new MoveNamedFunctionExpression().process(externs, root);\n+    Node globalScope = root.getFirstChild();\n+    declareVars(externs, globalScope);\n+    removeDuplicateDeclarations(externs, globalScope);\n+    new MoveFunctionDeclarations(compiler, assertOnChange).process(externs, root);\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n         compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -2,13 +2,21 @@\n     Node nameNode = Node.newString(Token.NAME, varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n-    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n+    // NOTE(nicksantos): honestly, I'm not sure how much this matters.\n     // AFAIK, all people who use the CONST coding convention also\n     // compile with undeclaredVars as errors. We have some test\n     // cases for this configuration though, and it makes them happier.\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    // If the variable is marked as constant, ensure that it is declared\n+    // with \"const\" instead of \"var\".\n+    int tokenType = Token.VAR;\n+    if (nameNode.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n+        tokenType = Token.CONST;\n+    }\n+    Node varNode = new Node(tokenType);\n+    varNode.addChildToBack(nameNode);\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n        // Fix: Ensure that removeDuplicateDeclarations runs after MakeDeclaredNamesUnique\n        // in order for catch block exception names to be handled properly.\n        removeDuplicateDeclarations(externs, root);\n    }\n    else {\n        removeDuplicateDeclarations(externs, root);\n    }\n\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n    // Fix: Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node varNode = new Node(Token.VAR, nameNode);\n    varNode.putBooleanProp(Node.IS_SYNTHETIC_VAR, true);\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -5,22 +5,14 @@\n         MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n         NodeTraversal t = new NodeTraversal(compiler, renamer);\n         t.traverseRoots(externs, root);\n+        // Fix: Ensure that removeDuplicateDeclarations runs after MakeDeclaredNamesUnique\n+        // in order for catch block exception names to be handled properly.\n+        removeDuplicateDeclarations(externs, root);\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    removeDuplicateDeclarations(externs, root);\n+    else {\n+        removeDuplicateDeclarations(externs, root);\n+    }\n+\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n         compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -1,14 +1,12 @@\n private void createSynthesizedExternVar(String varName) {\n     Node nameNode = Node.newString(Token.NAME, varName);\n-    // Mark the variable as constant if it matches the coding convention\n+    // Fix: Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n-    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n-    // AFAIK, all people who use the CONST coding convention also\n-    // compile with undeclaredVars as errors. We have some test\n-    // cases for this configuration though, and it makes them happier.\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node varNode = new Node(Token.VAR, nameNode);\n+    varNode.putBooleanProp(Node.IS_SYNTHETIC_VAR, true);\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    new NodeTraversal(compiler, new MoveCodeFromFinallyBlocks(compiler)).traverse(root);\n    removeDuplicateDeclarations(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    getSynthesizedExternsRoot().addChildToBack(IR.var(nameNode));\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -9,7 +9,7 @@\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n+    // only valid within the catch block, but our current Scope logic\n     // has no concept of this and includes it in the containing function\n     // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n     // names unique so that removeDuplicateDeclarations() will properly handle\n@@ -19,7 +19,8 @@\n     //      var e = 1; // f scope 'e'\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n+    new NodeTraversal(compiler, new MoveCodeFromFinallyBlocks(compiler)).traverse(root);\n     removeDuplicateDeclarations(externs, root);\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -1,5 +1,5 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n     // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n@@ -9,6 +9,6 @@\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    getSynthesizedExternsRoot().addChildToBack(IR.var(nameNode));\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with an exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //      e++;\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1' and\n    // 'e++' would become a reference error.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    removeDuplicateDeclarations(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, I'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node varNode = IR.var(nameNode);\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -9,17 +9,19 @@\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n+    // only valid within the catch block, but our current Scope logic\n     // has no concept of this and includes it in the containing function\n     // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n     // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n+    // cases where a function scope variable conflict with an exception name:\n     //   function f() {\n     //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n     //      var e = 1; // f scope 'e'\n+    //      e++;\n     //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n+    // otherwise 'var e = 1' would be rewritten as 'e = 1' and\n+    // 'e++' would become a reference error.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n     removeDuplicateDeclarations(externs, root);\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -1,14 +1,15 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n-    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n+    // NOTE(nicksantos): honestly, I'm not sure how much this matters.\n     // AFAIK, all people who use the CONST coding convention also\n     // compile with undeclaredVars as errors. We have some test\n     // cases for this configuration though, and it makes them happier.\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node varNode = IR.var(nameNode);\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflicts with an exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    new RemoveDuplicateDeclarations(compiler).process(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    getSynthesizedExternsRoot().addChildToBack(IR.var(nameNode));\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -9,18 +9,18 @@\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n+    // only valid within the catch block, but our current Scope logic\n     // has no concept of this and includes it in the containing function\n     // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n     // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n+    // cases where a function scope variable conflicts with an exception name:\n     //   function f() {\n     //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n     //      var e = 1; // f scope 'e'\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    removeDuplicateDeclarations(externs, root);\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n+    new RemoveDuplicateDeclarations(compiler).process(externs, root);\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n         compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -1,5 +1,5 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n     // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n@@ -9,6 +9,6 @@\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    getSynthesizedExternsRoot().addChildToBack(IR.var(nameNode));\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    // We needed to add \"root\" to the call to removeDuplicateDeclarations\n    // for the fix as it is called on the scope created for `root`\n    removeDuplicateDeclarations(externs, root, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // We updated the code to use IR.var to create a VAR node which properly contains the NAME node.\n    Node varNode = IR.var(nameNode);\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -9,7 +9,7 @@\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n+    // only valid within the catch block, but our current Scope logic\n     // has no concept of this and includes it in the containing function\n     // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n     // names unique so that removeDuplicateDeclarations() will properly handle\n@@ -19,8 +19,10 @@\n     //      var e = 1; // f scope 'e'\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    removeDuplicateDeclarations(externs, root);\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n+    // We needed to add \"root\" to the call to removeDuplicateDeclarations\n+    // for the fix as it is called on the scope created for `root`\n+    removeDuplicateDeclarations(externs, root, root);\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n         compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -1,14 +1,12 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n-    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n-    // AFAIK, all people who use the CONST coding convention also\n-    // compile with undeclaredVars as errors. We have some test\n-    // cases for this configuration though, and it makes them happier.\n+    // We updated the code to use IR.var to create a VAR node which properly contains the NAME node.\n+    Node varNode = IR.var(nameNode);\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(true);\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    removeDuplicateDeclarations(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node varNode = IR.var(nameNode);\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -2,24 +2,10 @@\n public void process(Node externs, Node root) {\n     new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n+        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(true);\n         NodeTraversal t = new NodeTraversal(compiler, renamer);\n         t.traverseRoots(externs, root);\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n     removeDuplicateDeclarations(externs, root);\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -1,14 +1,11 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n-    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n-    // AFAIK, all people who use the CONST coding convention also\n-    // compile with undeclaredVars as errors. We have some test\n-    // cases for this configuration though, and it makes them happier.\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node varNode = IR.var(nameNode);\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n        removeDuplicateDeclarations(externs, root); // Fixed: Remove duplicate declarations after renaming\n    } else {\n        removeDuplicateDeclarations(externs, root); // Fixed: Remove duplicate declarations before propagate constant annotations\n    }\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node varNode = new Node(Token.VAR, nameNode);\n    varNode.putBooleanProp(Node.IS_SYNTHETIC_VAR, true); // Fixed: Add IS_SYNTHETIC_VAR property\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -5,22 +5,10 @@\n         MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n         NodeTraversal t = new NodeTraversal(compiler, renamer);\n         t.traverseRoots(externs, root);\n+        removeDuplicateDeclarations(externs, root); // Fixed: Remove duplicate declarations after renaming\n+    } else {\n+        removeDuplicateDeclarations(externs, root); // Fixed: Remove duplicate declarations before propagate constant annotations\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    removeDuplicateDeclarations(externs, root);\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n         compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -9,6 +9,8 @@\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node varNode = new Node(Token.VAR, nameNode);\n+    varNode.putBooleanProp(Node.IS_SYNTHETIC_VAR, true); // Fixed: Add IS_SYNTHETIC_VAR property\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflicts with an exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    removeDuplicateDeclarations(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node varNode = IR.var(nameNode);\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -9,17 +9,17 @@\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n+    // only valid within the catch block, but our current Scope logic\n     // has no concept of this and includes it in the containing function\n     // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n     // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n+    // cases where a function scope variable conflicts with an exception name:\n     //   function f() {\n     //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n     //      var e = 1; // f scope 'e'\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n     removeDuplicateDeclarations(externs, root);\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -1,5 +1,5 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n     // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n@@ -9,6 +9,7 @@\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node varNode = IR.var(nameNode);\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with an exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    removeDuplicateDeclarations(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, I'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node var = IR.var(nameNode);\n    getSynthesizedExternsRoot().addChildToBack(var);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -9,17 +9,17 @@\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n+    // only valid within the catch block, but our current Scope logic\n     // has no concept of this and includes it in the containing function\n     // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n     // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n+    // cases where a function scope variable conflict with an exception name:\n     //   function f() {\n     //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n     //      var e = 1; // f scope 'e'\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n     removeDuplicateDeclarations(externs, root);\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -1,14 +1,15 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n-    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n+    // NOTE(nicksantos): honestly, I'm not sure how much this matters.\n     // AFAIK, all people who use the CONST coding convention also\n     // compile with undeclaredVars as errors. We have some test\n     // cases for this configuration though, and it makes them happier.\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node var = IR.var(nameNode);\n+    getSynthesizedExternsRoot().addChildToBack(var);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with an exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    new RemoveDuplicateDeclarations(compiler).process(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node varNode = IR.var(nameNode);\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -9,18 +9,18 @@\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n+    // only valid within the catch block, but our current Scope logic\n     // has no concept of this and includes it in the containing function\n     // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n     // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n+    // cases where a function scope variable conflict with an exception name:\n     //   function f() {\n     //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n     //      var e = 1; // f scope 'e'\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    removeDuplicateDeclarations(externs, root);\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n+    new RemoveDuplicateDeclarations(compiler).process(externs, root);\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n         compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -1,5 +1,5 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n     // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n@@ -9,6 +9,7 @@\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node varNode = IR.var(nameNode);\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n        removeDuplicateDeclarations(externs, root);\n    } else {\n        // It is important that removeDuplicateDeclarations runs after\n        // MakeDeclaredNamesUnique in order for catch block exception names to be\n        // handled properly. Specifically, catch block exception names are\n        // only valid within the catch block, but our currect Scope logic\n        // has no concept of this and includes it in the containing function\n        // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n        // names unique so that removeDuplicateDeclarations() will properly handle\n        // cases where a function scope variable conflict with a exception name:\n        //   function f() {\n        //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n        //      var e = 1; // f scope 'e'\n        //   }\n        // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n        // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n        removeDuplicateDeclarations(externs, root);\n    }\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node varNode = IR.var(nameNode);\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -5,22 +5,24 @@\n         MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n         NodeTraversal t = new NodeTraversal(compiler, renamer);\n         t.traverseRoots(externs, root);\n+        removeDuplicateDeclarations(externs, root);\n+    } else {\n+        // It is important that removeDuplicateDeclarations runs after\n+        // MakeDeclaredNamesUnique in order for catch block exception names to be\n+        // handled properly. Specifically, catch block exception names are\n+        // only valid within the catch block, but our currect Scope logic\n+        // has no concept of this and includes it in the containing function\n+        // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n+        // names unique so that removeDuplicateDeclarations() will properly handle\n+        // cases where a function scope variable conflict with a exception name:\n+        //   function f() {\n+        //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n+        //      var e = 1; // f scope 'e'\n+        //   }\n+        // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n+        // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n+        removeDuplicateDeclarations(externs, root);\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    removeDuplicateDeclarations(externs, root);\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n         compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -1,5 +1,5 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n     // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n@@ -9,6 +9,7 @@\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node varNode = IR.var(nameNode);\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n        // Move removeDuplicateDeclarations() here to ensure it runs after MakeDeclaredNamesUnique\n        removeDuplicateDeclarations(externs, root);\n    } else {\n        removeDuplicateDeclarations(externs, root);\n    }\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node varStmt = IR.var(nameNode).srcref(nameNode);\n    getSynthesizedExternsRoot().addChildToBack(varStmt);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -5,22 +5,11 @@\n         MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n         NodeTraversal t = new NodeTraversal(compiler, renamer);\n         t.traverseRoots(externs, root);\n+        // Move removeDuplicateDeclarations() here to ensure it runs after MakeDeclaredNamesUnique\n+        removeDuplicateDeclarations(externs, root);\n+    } else {\n+        removeDuplicateDeclarations(externs, root);\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    removeDuplicateDeclarations(externs, root);\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n         compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -1,5 +1,5 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n     // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n@@ -9,6 +9,7 @@\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node varStmt = IR.var(nameNode).srcref(nameNode);\n+    getSynthesizedExternsRoot().addChildToBack(varStmt);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n        removeDuplicateDeclarations(externs, root); // moved from end of original function\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);  // Use IR builder to create new name node\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    getSynthesizedExternsRoot().addChildToBack(IR.var(nameNode));  // Use IR builder to create new var node\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -5,6 +5,7 @@\n         MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n         NodeTraversal t = new NodeTraversal(compiler, renamer);\n         t.traverseRoots(externs, root);\n+        removeDuplicateDeclarations(externs, root); // moved from end of original function\n     }\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n@@ -20,7 +21,6 @@\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n     // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    removeDuplicateDeclarations(externs, root);\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n         compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -1,5 +1,5 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);  // Use IR builder to create new name node\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n     // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n@@ -9,6 +9,6 @@\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    getSynthesizedExternsRoot().addChildToBack(IR.var(nameNode));  // Use IR builder to create new var node\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with an exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // Otherwise, 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    NodeTraversal.traverseRoots(compiler, externs, root, new RemoveDuplicateDeclarations());\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node varNode = new Node(Token.VAR, nameNode);\n    varNode.setJSDocInfo(Node.JSDocInfo.builder().setSynthesizedExtern().build());\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -9,18 +9,18 @@\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n+    // only valid within the catch block, but our current Scope logic\n     // has no concept of this and includes it in the containing function\n     // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n     // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n+    // cases where a function scope variable conflict with an exception name:\n     //   function f() {\n     //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n     //      var e = 1; // f scope 'e'\n     //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    removeDuplicateDeclarations(externs, root);\n+    // Otherwise, 'var e = 1' would be rewritten as 'e = 1'.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n+    NodeTraversal.traverseRoots(compiler, externs, root, new RemoveDuplicateDeclarations());\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n         compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -9,6 +9,8 @@\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node varNode = new Node(Token.VAR, nameNode);\n+    varNode.setJSDocInfo(Node.JSDocInfo.builder().setSynthesizedExtern().build());\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    removeDuplicateDeclarations(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, I'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node varNode = IR.var(nameNode);\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -9,7 +9,7 @@\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n+    // only valid within the catch block, but our current Scope logic\n     // has no concept of this and includes it in the containing function\n     // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n     // names unique so that removeDuplicateDeclarations() will properly handle\n@@ -19,7 +19,7 @@\n     //      var e = 1; // f scope 'e'\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n     removeDuplicateDeclarations(externs, root);\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -1,14 +1,15 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n-    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n+    // NOTE(nicksantos): honestly, I'm not sure how much this matters.\n     // AFAIK, all people who use the CONST coding convention also\n     // compile with undeclaredVars as errors. We have some test\n     // cases for this configuration though, and it makes them happier.\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node varNode = IR.var(nameNode);\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    // Update NormalizeStatements to return the modified AST so that it can be re-used\n    // by later passes that may depend on it.\n    NormalizeStatements norm = new NormalizeStatements(compiler, assertOnChange);\n    NodeTraversal.traverse(compiler, root, norm);\n    Node transformedRoot = norm.getResult();\n\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseWithScope(transformedRoot, Scope.createGlobalScope(transformedRoot));\n    }\n\n    // Update removeDuplicateDeclarations to use the transformed root instead of root\n    removeDuplicateDeclarations(externs, transformedRoot);\n\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, transformedRoot);\n\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node varNode = IR.var(nameNode);\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -1,27 +1,22 @@\n @Override\n public void process(Node externs, Node root) {\n-    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n+    // Update NormalizeStatements to return the modified AST so that it can be re-used\n+    // by later passes that may depend on it.\n+    NormalizeStatements norm = new NormalizeStatements(compiler, assertOnChange);\n+    NodeTraversal.traverse(compiler, root, norm);\n+    Node transformedRoot = norm.getResult();\n+\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n         MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n         NodeTraversal t = new NodeTraversal(compiler, renamer);\n-        t.traverseRoots(externs, root);\n+        t.traverseWithScope(transformedRoot, Scope.createGlobalScope(transformedRoot));\n     }\n-    // It is important that removeDuplicateDeclarations runs after\n-    // MakeDeclaredNamesUnique in order for catch block exception names to be\n-    // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n-    // has no concept of this and includes it in the containing function\n-    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n-    // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n-    //   function f() {\n-    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n-    //      var e = 1; // f scope 'e'\n-    //   }\n-    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    removeDuplicateDeclarations(externs, root);\n-    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n+\n+    // Update removeDuplicateDeclarations to use the transformed root instead of root\n+    removeDuplicateDeclarations(externs, transformedRoot);\n+\n+    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, transformedRoot);\n+\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n         compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n     }\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -1,5 +1,5 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n     // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n@@ -9,6 +9,7 @@\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node varNode = IR.var(nameNode);\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverseRoots(externs, root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(compiler);\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n    new NodeTraversal(compiler, new RemoveDuplicateDeclarations()).traverseRoots(externs, root);\n    new PropagateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node varNode = IR.var(nameNode);\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -1,8 +1,8 @@\n @Override\n public void process(Node externs, Node root) {\n-    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n+    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverseRoots(externs, root);\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n-        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n+        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(compiler);\n         NodeTraversal t = new NodeTraversal(compiler, renamer);\n         t.traverseRoots(externs, root);\n     }\n@@ -20,8 +20,8 @@\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n     // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    removeDuplicateDeclarations(externs, root);\n-    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n+    new NodeTraversal(compiler, new RemoveDuplicateDeclarations()).traverseRoots(externs, root);\n+    new PropagateConstantAnnotations(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n         compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n     }\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -1,5 +1,5 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n     // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n@@ -9,6 +9,7 @@\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node varNode = IR.var(nameNode);\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with an exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    removeDuplicateDeclarations(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.string(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, I'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node varNode = IR.var(nameNode);\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -9,17 +9,17 @@\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n+    // only valid within the catch block, but our current Scope logic\n     // has no concept of this and includes it in the containing function\n     // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n     // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n+    // cases where a function scope variable conflict with an exception name:\n     //   function f() {\n     //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n     //      var e = 1; // f scope 'e'\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n     removeDuplicateDeclarations(externs, root);\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -1,14 +1,15 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.string(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n-    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n+    // NOTE(nicksantos): honestly, I'm not sure how much this matters.\n     // AFAIK, all people who use the CONST coding convention also\n     // compile with undeclaredVars as errors. We have some test\n     // cases for this configuration though, and it makes them happier.\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node varNode = IR.var(nameNode);\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void process(Node externs, Node root) {\n    new NodeTraversal(compiler, new NormalizeStatements(compiler, assertOnChange)).traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n        MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n        NodeTraversal t = new NodeTraversal(compiler, renamer);\n        t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our current Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with an exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n    ScopeCreator scopeCreator = new Es6SyntacticScopeCreator(compiler);\n    Scope topScope = scopeCreator.createScope(root.getParent(), null);\n    removeDuplicateDeclarations(scopeCreator, topScope);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n        compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n}\n\n## Fixed Function 2\nprivate void createSynthesizedExternVar(String varName) {\n    Node nameNode = IR.name(varName);\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    Node varNode = IR.var(nameNode);\n    getSynthesizedExternsRoot().addChildToBack(varNode);\n    varsToDeclareInExterns.remove(varName);\n}", "diff": "--- com/google/javascript/jscomp/Normalize.javaprocess\n+++ com/google/javascript/jscomp/Normalize.javaprocess\n@@ -9,18 +9,20 @@\n     // It is important that removeDuplicateDeclarations runs after\n     // MakeDeclaredNamesUnique in order for catch block exception names to be\n     // handled properly. Specifically, catch block exception names are\n-    // only valid within the catch block, but our currect Scope logic\n+    // only valid within the catch block, but our current Scope logic\n     // has no concept of this and includes it in the containing function\n     // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n     // names unique so that removeDuplicateDeclarations() will properly handle\n-    // cases where a function scope variable conflict with a exception name:\n+    // cases where a function scope variable conflict with an exception name:\n     //   function f() {\n     //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n     //      var e = 1; // f scope 'e'\n     //   }\n     // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n-    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n-    removeDuplicateDeclarations(externs, root);\n+    // TODO(johnlenz): Introduce a separate scope for catch nodes.\n+    ScopeCreator scopeCreator = new Es6SyntacticScopeCreator(compiler);\n+    Scope topScope = scopeCreator.createScope(root.getParent(), null);\n+    removeDuplicateDeclarations(scopeCreator, topScope);\n     new PropagateConstantAnnotationsOverVars(compiler, assertOnChange).process(externs, root);\n     if (!compiler.getLifeCycleStage().isNormalized()) {\n         compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n--- com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n+++ com/google/javascript/jscomp/VarCheck.javacreateSynthesizedExternVar\n@@ -1,5 +1,5 @@\n private void createSynthesizedExternVar(String varName) {\n-    Node nameNode = Node.newString(Token.NAME, varName);\n+    Node nameNode = IR.name(varName);\n     // Mark the variable as constant if it matches the coding convention\n     // for constant vars.\n     // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n@@ -9,6 +9,7 @@\n     if (compiler.getCodingConvention().isConstant(varName)) {\n         nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n     }\n-    getSynthesizedExternsRoot().addChildToBack(new Node(Token.VAR, nameNode));\n+    Node varNode = IR.var(nameNode);\n+    getSynthesizedExternsRoot().addChildToBack(varNode);\n     varsToDeclareInExterns.remove(varName);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]