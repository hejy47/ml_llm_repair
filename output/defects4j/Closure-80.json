[{"output": "## Fixed Function 1\nstatic boolean isBooleanResultHelper(Node n) {\n    switch(n.getType()) {\n        // Primitives\n        case Token.TRUE:\n        case Token.FALSE:\n        // Comparisons\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.LT:\n        case Token.GT:\n        case Token.LE:\n        case Token.GE:\n        // Queries\n        case Token.INSTANCEOF:\n        // Inversion\n        case Token.NOT:\n            // delete operator returns a boolean.\n            return true;\n        default:\n            return false;\n    }\n}\n\n## Fixed Function 2\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch(value.getType()) {\n        case Token.ASSIGN:\n            // A result that is aliased by a non-local name, is the effectively the\n            // same as returning a non-local name, but this doesn't matter if the\n            // value is immutable.\n            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.test(value.getFirstChild()) && evaluatesToLocalValue(value.getLastChild(), locals));\n        case Token.COMMA:\n            return evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.AND:\n        case Token.OR:\n            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.HOOK:\n            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.INC:\n        case Token.DEC:\n            if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n                return evaluatesToLocalValue(value.getFirstChild(), locals);\n            } else {\n                return true;\n            }\n        case Token.THIS:\n            return locals.test(value);\n        case Token.NAME:\n            return isImmutableValue(value) || locals.test(value);\n        case Token.GETELEM:\n        case Token.GETPROP:\n            // There is no information about the locality of object properties.\n            return locals.test(value);\n        case Token.CALL:\n            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.test(value);\n        case Token.NEW:\n            return newHasLocalResult(value) || locals.test(value);\n        case Token.FUNCTION:\n        case Token.REGEXP:\n        case Token.ARRAYLIT:\n        case Token.OBJECTLIT:\n            // Literal objects with non-literal children are allowed.\n            return true;\n        case Token.IN:\n            // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n            return true;\n        default:\n            // Other operators force a local value:\n            //  x = '' + g (x is now a local string)\n            //  x -= g (x is now a local number)\n            if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {\n                return true;\n            }\n            throw new IllegalStateException(\"Unexpected expression node \" + value + \"\\n parent:\" + value.getParent());\n    }\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.javaisBooleanResultHelper\n+++ com/google/javascript/jscomp/NodeUtil.javaisBooleanResultHelper\n@@ -1,25 +1,52 @@\n-static boolean isBooleanResultHelper(Node n) {\n-    switch(n.getType()) {\n-        // Primitives\n-        case Token.TRUE:\n-        case Token.FALSE:\n-        // Comparisons\n-        case Token.EQ:\n-        case Token.NE:\n-        case Token.SHEQ:\n-        case Token.SHNE:\n-        case Token.LT:\n-        case Token.GT:\n-        case Token.LE:\n-        case Token.GE:\n-        // Queryies\n+static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n+    switch(value.getType()) {\n+        case Token.ASSIGN:\n+            // A result that is aliased by a non-local name, is the effectively the\n+            // same as returning a non-local name, but this doesn't matter if the\n+            // value is immutable.\n+            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.test(value.getFirstChild()) && evaluatesToLocalValue(value.getLastChild(), locals));\n+        case Token.COMMA:\n+            return evaluatesToLocalValue(value.getLastChild(), locals);\n+        case Token.AND:\n+        case Token.OR:\n+            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n+        case Token.HOOK:\n+            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n+        case Token.INC:\n+        case Token.DEC:\n+            if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n+                return evaluatesToLocalValue(value.getFirstChild(), locals);\n+            } else {\n+                return true;\n+            }\n+        case Token.THIS:\n+            return locals.test(value);\n+        case Token.NAME:\n+            return isImmutableValue(value) || locals.test(value);\n+        case Token.GETELEM:\n+        case Token.GETPROP:\n+            // There is no information about the locality of object properties.\n+            return locals.test(value);\n+        case Token.CALL:\n+            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.test(value);\n+        case Token.NEW:\n+            return newHasLocalResult(value) || locals.test(value);\n+        case Token.FUNCTION:\n+        case Token.REGEXP:\n+        case Token.ARRAYLIT:\n+        case Token.OBJECTLIT:\n+            // Literal objects with non-literal children are allowed.\n+            return true;\n         case Token.IN:\n-        case Token.INSTANCEOF:\n-        // Inversion\n-        case Token.NOT:\n-            // delete operator returns a boolean.\n+            // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n             return true;\n         default:\n-            return false;\n+            // Other operators force a local value:\n+            //  x = '' + g (x is now a local string)\n+            //  x -= g (x is now a local number)\n+            if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {\n+                return true;\n+            }\n+            throw new IllegalStateException(\"Unexpected expression node \" + value + \"\\n parent:\" + value.getParent());\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean isBooleanResultHelper(Node n) {\n    switch(n.getType()) {\n        // Primitives\n        case Token.TRUE:\n        case Token.FALSE:\n        // Comparisons\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.LT:\n        case Token.GT:\n        case Token.LE:\n        case Token.GE:\n        // Queryies\n        case Token.IN:\n        case Token.INSTANCEOF:\n        // Inversion\n        case Token.NOT:\n            // delete operator returns a boolean.\n            return true;\n        // Add a case for Token.TYPEOF\n        case Token.TYPEOF:\n            return true;\n        default:\n            return false;\n    }\n}\n\n## Fixed Function 2\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch(value.getType()) {\n        case Token.ASSIGN:\n            // A result that is aliased by a non-local name, is the effectively the\n            // same as returning a non-local name, but this doesn't matter if the\n            // value is immutable.\n            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.test(value) && evaluatesToLocalValue(value.getLastChild(), locals));\n        case Token.COMMA:\n            return evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.AND:\n        case Token.OR:\n            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.HOOK:\n            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.INC:\n        case Token.DEC:\n            if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n                return evaluatesToLocalValue(value.getFirstChild(), locals);\n            } else {\n                return true;\n            }\n        case Token.THIS:\n            return locals.test(value);\n        case Token.NAME:\n            // Use NodeUtil.isImmutableValue instead of isImmutableValue\n            return NodeUtil.isImmutableValue(value) || locals.test(value);\n        case Token.GETELEM:\n        case Token.GETPROP:\n            // There is no information about the locality of object properties.\n            return locals.test(value);\n        case Token.CALL:\n            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.test(value);\n        case Token.NEW:\n            return newHasLocalResult(value) || locals.test(value);\n        case Token.FUNCTION:\n        case Token.REGEXP:\n        case Token.ARRAYLIT:\n        case Token.OBJECTLIT:\n            // Literals objects with non-literal children are allowed.\n            return true;\n        case Token.IN:\n            // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n            return true;\n        default:\n            // Other op force a local value:\n            //  x = '' + g (x is now an local string)\n            //  x -= g (x is now an local number)\n            // Use NodeUtil.isSimpleOperator instead of isSimpleOperator\n            if (isAssignmentOp(value) || NodeUtil.isSimpleOperator(value) || NodeUtil.isImmutableValue(value)) {\n                return true;\n            }\n            throw new IllegalStateException(\"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent());\n    }\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.javaisBooleanResultHelper\n+++ com/google/javascript/jscomp/NodeUtil.javaisBooleanResultHelper\n@@ -1,25 +1,54 @@\n-static boolean isBooleanResultHelper(Node n) {\n-    switch(n.getType()) {\n-        // Primitives\n-        case Token.TRUE:\n-        case Token.FALSE:\n-        // Comparisons\n-        case Token.EQ:\n-        case Token.NE:\n-        case Token.SHEQ:\n-        case Token.SHNE:\n-        case Token.LT:\n-        case Token.GT:\n-        case Token.LE:\n-        case Token.GE:\n-        // Queryies\n+static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n+    switch(value.getType()) {\n+        case Token.ASSIGN:\n+            // A result that is aliased by a non-local name, is the effectively the\n+            // same as returning a non-local name, but this doesn't matter if the\n+            // value is immutable.\n+            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.test(value) && evaluatesToLocalValue(value.getLastChild(), locals));\n+        case Token.COMMA:\n+            return evaluatesToLocalValue(value.getLastChild(), locals);\n+        case Token.AND:\n+        case Token.OR:\n+            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n+        case Token.HOOK:\n+            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n+        case Token.INC:\n+        case Token.DEC:\n+            if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n+                return evaluatesToLocalValue(value.getFirstChild(), locals);\n+            } else {\n+                return true;\n+            }\n+        case Token.THIS:\n+            return locals.test(value);\n+        case Token.NAME:\n+            // Use NodeUtil.isImmutableValue instead of isImmutableValue\n+            return NodeUtil.isImmutableValue(value) || locals.test(value);\n+        case Token.GETELEM:\n+        case Token.GETPROP:\n+            // There is no information about the locality of object properties.\n+            return locals.test(value);\n+        case Token.CALL:\n+            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.test(value);\n+        case Token.NEW:\n+            return newHasLocalResult(value) || locals.test(value);\n+        case Token.FUNCTION:\n+        case Token.REGEXP:\n+        case Token.ARRAYLIT:\n+        case Token.OBJECTLIT:\n+            // Literals objects with non-literal children are allowed.\n+            return true;\n         case Token.IN:\n-        case Token.INSTANCEOF:\n-        // Inversion\n-        case Token.NOT:\n-            // delete operator returns a boolean.\n+            // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n             return true;\n         default:\n-            return false;\n+            // Other op force a local value:\n+            //  x = '' + g (x is now an local string)\n+            //  x -= g (x is now an local number)\n+            // Use NodeUtil.isSimpleOperator instead of isSimpleOperator\n+            if (isAssignmentOp(value) || NodeUtil.isSimpleOperator(value) || NodeUtil.isImmutableValue(value)) {\n+                return true;\n+            }\n+            throw new IllegalStateException(\"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent());\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean isBooleanResultHelper(Node n) {\n    switch(n.getType()) {\n        // Primitives\n        case Token.TRUE:\n        case Token.FALSE:\n        // Comparisons\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.LT:\n        case Token.GT:\n        case Token.LE:\n        case Token.GE:\n        // Queryies\n        case Token.IN:\n        case Token.INSTANCEOF:\n        // Inversion\n        case Token.NOT:\n        // Unary plus and minus operations also return a boolean.\n        case Token.POS:\n        case Token.NEG:\n            // delete operator returns a boolean.\n            return true;\n        default:\n            return false;\n    }\n}\n\n## Fixed Function 2\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch(value.getType()) {\n        case Token.ASSIGN:\n            // A result that is aliased by a non-local name, is the effectively the\n            // same as returning a non-local name, but this doesn't matter if the\n            // value is immutable.\n            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals));\n        case Token.COMMA:\n            return evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.AND:\n        case Token.OR:\n            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.HOOK:\n            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.INC:\n        case Token.DEC:\n            if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n                return evaluatesToLocalValue(value.getFirstChild(), locals);\n            } else {\n                return true;\n            }\n        case Token.THIS:\n            return locals.apply(value);\n        case Token.NAME:\n            return isImmutableValue(value) || locals.apply(value);\n        case Token.GETELEM:\n        case Token.GETPROP:\n            // There is no information about the locality of object properties.\n            return locals.apply(value);\n        case Token.CALL:\n            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value);\n        case Token.NEW:\n            return newHasLocalResult(value) || locals.apply(value);\n        case Token.FUNCTION:\n        case Token.REGEXP:\n        case Token.ARRAYLIT:\n        case Token.OBJECTLIT:\n            // Literals objects with non-literal children are allowed.\n            return true;\n        case Token.IN:\n            // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n            return true;\n        case Token.POS:\n        case Token.NEG:\n            return isBooleanResultHelper(value.getFirstChild());\n        default:\n            // Other op force a local value:\n            //  x = '' + g (x is now an local string)\n            //  x -= g (x is now an local number)\n            if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {\n                return true;\n            }\n            throw new IllegalStateException(\"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent());\n    }\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.javaisBooleanResultHelper\n+++ com/google/javascript/jscomp/NodeUtil.javaisBooleanResultHelper\n@@ -1,25 +1,55 @@\n-static boolean isBooleanResultHelper(Node n) {\n-    switch(n.getType()) {\n-        // Primitives\n-        case Token.TRUE:\n-        case Token.FALSE:\n-        // Comparisons\n-        case Token.EQ:\n-        case Token.NE:\n-        case Token.SHEQ:\n-        case Token.SHNE:\n-        case Token.LT:\n-        case Token.GT:\n-        case Token.LE:\n-        case Token.GE:\n-        // Queryies\n+static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n+    switch(value.getType()) {\n+        case Token.ASSIGN:\n+            // A result that is aliased by a non-local name, is the effectively the\n+            // same as returning a non-local name, but this doesn't matter if the\n+            // value is immutable.\n+            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals));\n+        case Token.COMMA:\n+            return evaluatesToLocalValue(value.getLastChild(), locals);\n+        case Token.AND:\n+        case Token.OR:\n+            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n+        case Token.HOOK:\n+            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n+        case Token.INC:\n+        case Token.DEC:\n+            if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n+                return evaluatesToLocalValue(value.getFirstChild(), locals);\n+            } else {\n+                return true;\n+            }\n+        case Token.THIS:\n+            return locals.apply(value);\n+        case Token.NAME:\n+            return isImmutableValue(value) || locals.apply(value);\n+        case Token.GETELEM:\n+        case Token.GETPROP:\n+            // There is no information about the locality of object properties.\n+            return locals.apply(value);\n+        case Token.CALL:\n+            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value);\n+        case Token.NEW:\n+            return newHasLocalResult(value) || locals.apply(value);\n+        case Token.FUNCTION:\n+        case Token.REGEXP:\n+        case Token.ARRAYLIT:\n+        case Token.OBJECTLIT:\n+            // Literals objects with non-literal children are allowed.\n+            return true;\n         case Token.IN:\n-        case Token.INSTANCEOF:\n-        // Inversion\n-        case Token.NOT:\n-            // delete operator returns a boolean.\n+            // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n             return true;\n+        case Token.POS:\n+        case Token.NEG:\n+            return isBooleanResultHelper(value.getFirstChild());\n         default:\n-            return false;\n+            // Other op force a local value:\n+            //  x = '' + g (x is now an local string)\n+            //  x -= g (x is now an local number)\n+            if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {\n+                return true;\n+            }\n+            throw new IllegalStateException(\"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent());\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean isBooleanResultHelper(Node n) {\n    switch(n.getType()) {\n        // Primitives\n        case Token.TRUE:\n        case Token.FALSE:\n        // Comparisons\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.LT:\n        case Token.GT:\n        case Token.LE:\n        case Token.GE:\n        // Queryies\n        case Token.IN:\n        case Token.INSTANCEOF:\n        // Inversion\n        case Token.NOT:\n        // Typeof, void, and delete operators return a boolean.\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.DELPROP:\n            return true;\n        default:\n            return false;\n    }\n}\n\n## Fixed Function 2\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch(value.getType()) {\n        case Token.ASSIGN:\n            // A result that is aliased by a non-local name, is the effectively the\n            // same as returning a non-local name, but this doesn't matter if the\n            // value is immutable.\n            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.test(value) && evaluatesToLocalValue(value.getLastChild(), locals));\n        case Token.COMMA:\n            return evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.AND:\n        case Token.OR:\n            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.HOOK:\n            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.INC:\n        case Token.DEC:\n            if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n                return evaluatesToLocalValue(value.getFirstChild(), locals);\n            } else {\n                return true;\n            }\n        case Token.THIS:\n            return locals.test(value);\n        case Token.NAME:\n            // Include typeof and delete\n            return isImmutableValue(value) || locals.test(value) || value.getBooleanProp(Node.TYPEOF) || value.getBooleanProp(Node.DELPROP);\n        case Token.GETELEM:\n        case Token.GETPROP:\n            // There is no information about the locality of object properties.\n            return locals.test(value);\n        case Token.CALL:\n            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.test(value);\n        case Token.NEW:\n            return newHasLocalResult(value) || locals.test(value);\n        case Token.FUNCTION:\n        case Token.REGEXP:\n        case Token.ARRAYLIT:\n        case Token.OBJECTLIT:\n            // Literals objects with non-literal children are allowed.\n            return true;\n        case Token.IN:\n            // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n            return true;\n        default:\n            // Other op force a local value:\n            //  x = '' + g (x is now an local string)\n            //  x -= g (x is now an local number)\n            if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {\n                return true;\n            }\n            throw new IllegalStateException(\"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent());\n    }\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.javaisBooleanResultHelper\n+++ com/google/javascript/jscomp/NodeUtil.javaisBooleanResultHelper\n@@ -1,25 +1,53 @@\n-static boolean isBooleanResultHelper(Node n) {\n-    switch(n.getType()) {\n-        // Primitives\n-        case Token.TRUE:\n-        case Token.FALSE:\n-        // Comparisons\n-        case Token.EQ:\n-        case Token.NE:\n-        case Token.SHEQ:\n-        case Token.SHNE:\n-        case Token.LT:\n-        case Token.GT:\n-        case Token.LE:\n-        case Token.GE:\n-        // Queryies\n+static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n+    switch(value.getType()) {\n+        case Token.ASSIGN:\n+            // A result that is aliased by a non-local name, is the effectively the\n+            // same as returning a non-local name, but this doesn't matter if the\n+            // value is immutable.\n+            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.test(value) && evaluatesToLocalValue(value.getLastChild(), locals));\n+        case Token.COMMA:\n+            return evaluatesToLocalValue(value.getLastChild(), locals);\n+        case Token.AND:\n+        case Token.OR:\n+            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n+        case Token.HOOK:\n+            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n+        case Token.INC:\n+        case Token.DEC:\n+            if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n+                return evaluatesToLocalValue(value.getFirstChild(), locals);\n+            } else {\n+                return true;\n+            }\n+        case Token.THIS:\n+            return locals.test(value);\n+        case Token.NAME:\n+            // Include typeof and delete\n+            return isImmutableValue(value) || locals.test(value) || value.getBooleanProp(Node.TYPEOF) || value.getBooleanProp(Node.DELPROP);\n+        case Token.GETELEM:\n+        case Token.GETPROP:\n+            // There is no information about the locality of object properties.\n+            return locals.test(value);\n+        case Token.CALL:\n+            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.test(value);\n+        case Token.NEW:\n+            return newHasLocalResult(value) || locals.test(value);\n+        case Token.FUNCTION:\n+        case Token.REGEXP:\n+        case Token.ARRAYLIT:\n+        case Token.OBJECTLIT:\n+            // Literals objects with non-literal children are allowed.\n+            return true;\n         case Token.IN:\n-        case Token.INSTANCEOF:\n-        // Inversion\n-        case Token.NOT:\n-            // delete operator returns a boolean.\n+            // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n             return true;\n         default:\n-            return false;\n+            // Other op force a local value:\n+            //  x = '' + g (x is now an local string)\n+            //  x -= g (x is now an local number)\n+            if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {\n+                return true;\n+            }\n+            throw new IllegalStateException(\"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent());\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic boolean isBooleanResultHelper(Node n) {\n    switch(n.getType()) {\n        // Primitives\n        case Token.TRUE:\n        case Token.FALSE:\n        // Comparisons\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.LT:\n        case Token.GT:\n        case Token.LE:\n        case Token.GE:\n        // Queries\n        case Token.IN:\n        case Token.INSTANCEOF:\n        // Inversion\n        case Token.NOT:\n        // Type checks\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.TYPE:\n            // delete operator returns a boolean.\n            return true;\n        default:\n            return false;\n    }\n}\n\n## Fixed Function 2\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch(value.getType()) {\n        case Token.ASSIGN:\n            // A result that is aliased by a non-local name, is the effectively the\n            // same as returning a non-local name, but this doesn't matter if the\n            // value is immutable.\n            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.test(value) && evaluatesToLocalValue(value.getLastChild(), locals));\n        case Token.COMMA:\n            return evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.AND:\n        case Token.OR:\n            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.HOOK:\n            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n        case Token.INC:\n        case Token.DEC:\n            if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n                return evaluatesToLocalValue(value.getFirstChild(), locals);\n            } else {\n                return true;\n            }\n        case Token.THIS:\n            return locals.test(value);\n        case Token.NAME:\n            return isImmutableValue(value) || locals.test(value);\n        case Token.GETELEM:\n        case Token.GETPROP:\n            // There is no information about the locality of object properties.\n            return locals.test(value);\n        case Token.CALL:\n            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.test(value);\n        case Token.NEW:\n            return newHasLocalResult(value) || locals.test(value);\n        case Token.FUNCTION:\n        case Token.REGEXP:\n        case Token.ARRAYLIT:\n        case Token.OBJECTLIT:\n            // Literal objects with non-literal children are allowed.\n            return true;\n        case Token.IN:\n            // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n            return true;\n        default:\n            // Other ops force a local value:\n            //  x = '' + g (x is now an local string)\n            //  x -= g (x is now an local number)\n            if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {\n                return true;\n            }\n            throw new IllegalStateException(\"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent());\n    }\n}", "diff": "--- com/google/javascript/jscomp/NodeUtil.javaisBooleanResultHelper\n+++ com/google/javascript/jscomp/NodeUtil.javaisBooleanResultHelper\n@@ -1,25 +1,52 @@\n-static boolean isBooleanResultHelper(Node n) {\n-    switch(n.getType()) {\n-        // Primitives\n-        case Token.TRUE:\n-        case Token.FALSE:\n-        // Comparisons\n-        case Token.EQ:\n-        case Token.NE:\n-        case Token.SHEQ:\n-        case Token.SHNE:\n-        case Token.LT:\n-        case Token.GT:\n-        case Token.LE:\n-        case Token.GE:\n-        // Queryies\n+static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n+    switch(value.getType()) {\n+        case Token.ASSIGN:\n+            // A result that is aliased by a non-local name, is the effectively the\n+            // same as returning a non-local name, but this doesn't matter if the\n+            // value is immutable.\n+            return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.test(value) && evaluatesToLocalValue(value.getLastChild(), locals));\n+        case Token.COMMA:\n+            return evaluatesToLocalValue(value.getLastChild(), locals);\n+        case Token.AND:\n+        case Token.OR:\n+            return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n+        case Token.HOOK:\n+            return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals);\n+        case Token.INC:\n+        case Token.DEC:\n+            if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n+                return evaluatesToLocalValue(value.getFirstChild(), locals);\n+            } else {\n+                return true;\n+            }\n+        case Token.THIS:\n+            return locals.test(value);\n+        case Token.NAME:\n+            return isImmutableValue(value) || locals.test(value);\n+        case Token.GETELEM:\n+        case Token.GETPROP:\n+            // There is no information about the locality of object properties.\n+            return locals.test(value);\n+        case Token.CALL:\n+            return callHasLocalResult(value) || isToStringMethodCall(value) || locals.test(value);\n+        case Token.NEW:\n+            return newHasLocalResult(value) || locals.test(value);\n+        case Token.FUNCTION:\n+        case Token.REGEXP:\n+        case Token.ARRAYLIT:\n+        case Token.OBJECTLIT:\n+            // Literal objects with non-literal children are allowed.\n+            return true;\n         case Token.IN:\n-        case Token.INSTANCEOF:\n-        // Inversion\n-        case Token.NOT:\n-            // delete operator returns a boolean.\n+            // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n             return true;\n         default:\n-            return false;\n+            // Other ops force a local value:\n+            //  x = '' + g (x is now an local string)\n+            //  x -= g (x is now an local number)\n+            if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) {\n+                return true;\n+            }\n+            throw new IllegalStateException(\"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent());\n     }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]