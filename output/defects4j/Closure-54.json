[{"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    // add this line to ensure the scope is available\n    TypedScope scope = t.getTypedScope();\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        // add this line to ensure the scope is available\n        TypedVar qVar = scope.getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == scope) {\n                scope.undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setInstanceType((PrototypeObjectType) baseType); // changed to setInstanceType\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -1,92 +1,23 @@\n-void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    Node ownerNode = n.getFirstChild();\n-    String ownerName = ownerNode.getQualifiedName();\n-    String qName = n.getQualifiedName();\n-    String propName = n.getLastChild().getString();\n-    Preconditions.checkArgument(qName != null && ownerName != null);\n-    // Precedence of type information on GETPROPs:\n-    // 1) @type annnotation / @enum annotation\n-    // 2) ASSIGN to FUNCTION literal\n-    // 3) @param/@return annotation (with no function literal)\n-    // 4) ASSIGN to something marked @const\n-    // 5) ASSIGN to anything else\n+public void setPrototypeBasedOn(ObjectType baseType) {\n+    // This is a bit weird. We need to successfully handle these\n+    // two cases:\n+    // Foo.prototype = new Bar();\n+    // and\n+    // Foo.prototype = {baz: 3};\n+    // In the first case, we do not want new properties to get\n+    // added to Bar. In the second case, we do want new properties\n+    // to get added to the type of the anonymous object.\n     //\n-    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n-    // the function has jsdoc or has not been declared before.\n+    // We handle this by breaking it into two cases:\n     //\n-    // FUNCTION literals are special because TypedScopeCreator is very smart\n-    // about getting as much type information as possible for them.\n-    // Determining type for #1 + #2 + #3 + #4\n-    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n-    if (valueType == null && rhsValue != null) {\n-        // Determining type for #5\n-        valueType = rhsValue.getJSType();\n+    // In the first case, we create a new PrototypeObjectType and set\n+    // its implicit prototype to the type being assigned. This ensures\n+    // that Bar will not get any properties of Foo.prototype, but properties\n+    // later assigned to Bar will get inherited properly.\n+    //\n+    // In the second case, we just use the anonymous object as the prototype.\n+    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n+        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n     }\n-    // Function prototypes are special.\n-    // It's a common JS idiom to do:\n-    // F.prototype = { ... };\n-    // So if F does not have an explicitly declared super type,\n-    // allow F.prototype to be redefined arbitrarily.\n-    if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n-        if (qVar != null) {\n-            // If the programmer has declared that F inherits from Super,\n-            // and they assign F.prototype to an object literal,\n-            // then they are responsible for making sure that the object literal's\n-            // implicit prototype is set up appropriately. We just obey\n-            // the @extends tag.\n-            if (!qVar.isTypeInferred()) {\n-                // If the programmer has declared that F inherits from Super,\n-                // and they assign F.prototype to some arbitrary expression,\n-                // there's not much we can do. We just ignore the expression,\n-                // and hope they've annotated their code in a way to tell us\n-                // what props are going to be on that prototype.\n-                return;\n-            }\n-            if (qVar.getScope() == scope) {\n-                scope.undeclare(qVar);\n-            }\n-        }\n-    }\n-    if (valueType == null) {\n-        if (parent.getType() == Token.EXPR_RESULT) {\n-            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n-        }\n-        return;\n-    }\n-    boolean inferred = true;\n-    if (info != null) {\n-        // Determining declaration for #1 + #3 + #4\n-        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-    }\n-    if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n-    }\n-    if (!inferred) {\n-        ObjectType ownerType = getObjectSlot(ownerName);\n-        if (ownerType != null) {\n-            // Only declare this as an official property if it has not been\n-            // declared yet.\n-            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n-            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n-                // If the property is undeclared or inferred, declare it now.\n-                ownerType.defineDeclaredProperty(propName, valueType, n);\n-            }\n-        }\n-        // If the property is already declared, the error will be\n-        // caught when we try to declare it in the current scope.\n-        defineSlot(n, parent, valueType, inferred);\n-    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n-        // We declare these for delegate proxy method properties.\n-        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n-        if (ownerType != null) {\n-            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n-            String delegateName = codingConvention.getDelegateSuperclassName();\n-            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n-            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n-                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n-            }\n-        }\n-    }\n+    setInstanceType((PrototypeObjectType) baseType); // changed to setInstanceType\n }\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -1,23 +1,32 @@\n-public void setPrototypeBasedOn(ObjectType baseType) {\n-    // This is a bit weird. We need to successfully handle these\n-    // two cases:\n-    // Foo.prototype = new Bar();\n-    // and\n-    // Foo.prototype = {baz: 3};\n-    // In the first case, we do not want new properties to get\n-    // added to Bar. In the second case, we do want new properties\n-    // to get added to the type of the anonymous object.\n-    //\n-    // We handle this by breaking it into two cases:\n-    //\n-    // In the first case, we create a new PrototypeObjectType and set\n-    // its implicit prototype to the type being assigned. This ensures\n-    // that Bar will not get any properties of Foo.prototype, but properties\n-    // later assigned to Bar will get inherited properly.\n-    //\n-    // In the second case, we just use the anonymous object as the prototype.\n-    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n-        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n+public boolean setPrototype(PrototypeObjectType prototype) {\n+    if (prototype == null) {\n+        return false;\n     }\n-    setPrototype((PrototypeObjectType) baseType);\n+    // getInstanceType fails if the function is not a constructor\n+    if (isConstructor() && prototype == getInstanceType()) {\n+        return false;\n+    }\n+    boolean replacedPrototype = prototype != null;\n+    this.prototype = prototype;\n+    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n+    this.prototype.setOwnerFunction(this);\n+    // Disassociating the old prototype makes this easier to debug--\n+    // we don't have to worry about two prototypes running around.\n+    if (isConstructor() || isInterface()) {\n+        FunctionType superClass = getSuperClassConstructor();\n+        if (superClass != null) {\n+            superClass.addSubType(this);\n+        }\n+        if (isInterface()) {\n+            for (ObjectType interfaceType : getExtendedInterfaces()) {\n+                if (interfaceType.getConstructor() != null) {\n+                    interfaceType.getConstructor().addSubType(this);\n+                }\n+            }\n+        }\n+    }\n+    if (replacedPrototype) {\n+        clearCachedValues();\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = t.getScope().getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == t.getScope()) {\n                t.getScope().undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    if (baseType.isInterface() && !isInterface()) {\n        // Fill the function with an empty object type\n        this.instanceType = registry.createAnonymousObjectType(this);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null && !superClass.isInterface() && !isInterface()) {\n            superClass.addSubType(this);\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -1,92 +1,27 @@\n-void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    Node ownerNode = n.getFirstChild();\n-    String ownerName = ownerNode.getQualifiedName();\n-    String qName = n.getQualifiedName();\n-    String propName = n.getLastChild().getString();\n-    Preconditions.checkArgument(qName != null && ownerName != null);\n-    // Precedence of type information on GETPROPs:\n-    // 1) @type annnotation / @enum annotation\n-    // 2) ASSIGN to FUNCTION literal\n-    // 3) @param/@return annotation (with no function literal)\n-    // 4) ASSIGN to something marked @const\n-    // 5) ASSIGN to anything else\n+public void setPrototypeBasedOn(ObjectType baseType) {\n+    // This is a bit weird. We need to successfully handle these\n+    // two cases:\n+    // Foo.prototype = new Bar();\n+    // and\n+    // Foo.prototype = {baz: 3};\n+    // In the first case, we do not want new properties to get\n+    // added to Bar. In the second case, we do want new properties\n+    // to get added to the type of the anonymous object.\n     //\n-    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n-    // the function has jsdoc or has not been declared before.\n+    // We handle this by breaking it into two cases:\n     //\n-    // FUNCTION literals are special because TypedScopeCreator is very smart\n-    // about getting as much type information as possible for them.\n-    // Determining type for #1 + #2 + #3 + #4\n-    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n-    if (valueType == null && rhsValue != null) {\n-        // Determining type for #5\n-        valueType = rhsValue.getJSType();\n+    // In the first case, we create a new PrototypeObjectType and set\n+    // its implicit prototype to the type being assigned. This ensures\n+    // that Bar will not get any properties of Foo.prototype, but properties\n+    // later assigned to Bar will get inherited properly.\n+    //\n+    // In the second case, we just use the anonymous object as the prototype.\n+    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n+        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n     }\n-    // Function prototypes are special.\n-    // It's a common JS idiom to do:\n-    // F.prototype = { ... };\n-    // So if F does not have an explicitly declared super type,\n-    // allow F.prototype to be redefined arbitrarily.\n-    if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n-        if (qVar != null) {\n-            // If the programmer has declared that F inherits from Super,\n-            // and they assign F.prototype to an object literal,\n-            // then they are responsible for making sure that the object literal's\n-            // implicit prototype is set up appropriately. We just obey\n-            // the @extends tag.\n-            if (!qVar.isTypeInferred()) {\n-                // If the programmer has declared that F inherits from Super,\n-                // and they assign F.prototype to some arbitrary expression,\n-                // there's not much we can do. We just ignore the expression,\n-                // and hope they've annotated their code in a way to tell us\n-                // what props are going to be on that prototype.\n-                return;\n-            }\n-            if (qVar.getScope() == scope) {\n-                scope.undeclare(qVar);\n-            }\n-        }\n+    if (baseType.isInterface() && !isInterface()) {\n+        // Fill the function with an empty object type\n+        this.instanceType = registry.createAnonymousObjectType(this);\n     }\n-    if (valueType == null) {\n-        if (parent.getType() == Token.EXPR_RESULT) {\n-            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n-        }\n-        return;\n-    }\n-    boolean inferred = true;\n-    if (info != null) {\n-        // Determining declaration for #1 + #3 + #4\n-        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-    }\n-    if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n-    }\n-    if (!inferred) {\n-        ObjectType ownerType = getObjectSlot(ownerName);\n-        if (ownerType != null) {\n-            // Only declare this as an official property if it has not been\n-            // declared yet.\n-            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n-            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n-                // If the property is undeclared or inferred, declare it now.\n-                ownerType.defineDeclaredProperty(propName, valueType, n);\n-            }\n-        }\n-        // If the property is already declared, the error will be\n-        // caught when we try to declare it in the current scope.\n-        defineSlot(n, parent, valueType, inferred);\n-    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n-        // We declare these for delegate proxy method properties.\n-        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n-        if (ownerType != null) {\n-            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n-            String delegateName = codingConvention.getDelegateSuperclassName();\n-            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n-            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n-                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n-            }\n-        }\n-    }\n+    setPrototype((PrototypeObjectType) baseType);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -1,23 +1,25 @@\n-public void setPrototypeBasedOn(ObjectType baseType) {\n-    // This is a bit weird. We need to successfully handle these\n-    // two cases:\n-    // Foo.prototype = new Bar();\n-    // and\n-    // Foo.prototype = {baz: 3};\n-    // In the first case, we do not want new properties to get\n-    // added to Bar. In the second case, we do want new properties\n-    // to get added to the type of the anonymous object.\n-    //\n-    // We handle this by breaking it into two cases:\n-    //\n-    // In the first case, we create a new PrototypeObjectType and set\n-    // its implicit prototype to the type being assigned. This ensures\n-    // that Bar will not get any properties of Foo.prototype, but properties\n-    // later assigned to Bar will get inherited properly.\n-    //\n-    // In the second case, we just use the anonymous object as the prototype.\n-    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n-        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n+public boolean setPrototype(PrototypeObjectType prototype) {\n+    if (prototype == null) {\n+        return false;\n     }\n-    setPrototype((PrototypeObjectType) baseType);\n+    // getInstanceType fails if the function is not a constructor\n+    if (isConstructor() && prototype == getInstanceType()) {\n+        return false;\n+    }\n+    boolean replacedPrototype = prototype != null;\n+    this.prototype = prototype;\n+    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n+    this.prototype.setOwnerFunction(this);\n+    // Disassociating the old prototype makes this easier to debug--\n+    // we don't have to worry about two prototypes running around.\n+    if (isConstructor()) {\n+        FunctionType superClass = getSuperClassConstructor();\n+        if (superClass != null && !superClass.isInterface() && !isInterface()) {\n+            superClass.addSubType(this);\n+        }\n+    }\n+    if (replacedPrototype) {\n+        clearCachedValues();\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = t.getScope().getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == t.getScope()) {\n                t.getScope().undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !t.getScope().isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        PrototypeObjectType prototypeObjectType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n        prototypeObjectType.setImplicitPrototype(baseType);\n        baseType = prototypeObjectType;\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubType(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -1,92 +1,25 @@\n-void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    Node ownerNode = n.getFirstChild();\n-    String ownerName = ownerNode.getQualifiedName();\n-    String qName = n.getQualifiedName();\n-    String propName = n.getLastChild().getString();\n-    Preconditions.checkArgument(qName != null && ownerName != null);\n-    // Precedence of type information on GETPROPs:\n-    // 1) @type annnotation / @enum annotation\n-    // 2) ASSIGN to FUNCTION literal\n-    // 3) @param/@return annotation (with no function literal)\n-    // 4) ASSIGN to something marked @const\n-    // 5) ASSIGN to anything else\n+public void setPrototypeBasedOn(ObjectType baseType) {\n+    // This is a bit weird. We need to successfully handle these\n+    // two cases:\n+    // Foo.prototype = new Bar();\n+    // and\n+    // Foo.prototype = {baz: 3};\n+    // In the first case, we do not want new properties to get\n+    // added to Bar. In the second case, we do want new properties\n+    // to get added to the type of the anonymous object.\n     //\n-    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n-    // the function has jsdoc or has not been declared before.\n+    // We handle this by breaking it into two cases:\n     //\n-    // FUNCTION literals are special because TypedScopeCreator is very smart\n-    // about getting as much type information as possible for them.\n-    // Determining type for #1 + #2 + #3 + #4\n-    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n-    if (valueType == null && rhsValue != null) {\n-        // Determining type for #5\n-        valueType = rhsValue.getJSType();\n+    // In the first case, we create a new PrototypeObjectType and set\n+    // its implicit prototype to the type being assigned. This ensures\n+    // that Bar will not get any properties of Foo.prototype, but properties\n+    // later assigned to Bar will get inherited properly.\n+    //\n+    // In the second case, we just use the anonymous object as the prototype.\n+    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n+        PrototypeObjectType prototypeObjectType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n+        prototypeObjectType.setImplicitPrototype(baseType);\n+        baseType = prototypeObjectType;\n     }\n-    // Function prototypes are special.\n-    // It's a common JS idiom to do:\n-    // F.prototype = { ... };\n-    // So if F does not have an explicitly declared super type,\n-    // allow F.prototype to be redefined arbitrarily.\n-    if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n-        if (qVar != null) {\n-            // If the programmer has declared that F inherits from Super,\n-            // and they assign F.prototype to an object literal,\n-            // then they are responsible for making sure that the object literal's\n-            // implicit prototype is set up appropriately. We just obey\n-            // the @extends tag.\n-            if (!qVar.isTypeInferred()) {\n-                // If the programmer has declared that F inherits from Super,\n-                // and they assign F.prototype to some arbitrary expression,\n-                // there's not much we can do. We just ignore the expression,\n-                // and hope they've annotated their code in a way to tell us\n-                // what props are going to be on that prototype.\n-                return;\n-            }\n-            if (qVar.getScope() == scope) {\n-                scope.undeclare(qVar);\n-            }\n-        }\n-    }\n-    if (valueType == null) {\n-        if (parent.getType() == Token.EXPR_RESULT) {\n-            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n-        }\n-        return;\n-    }\n-    boolean inferred = true;\n-    if (info != null) {\n-        // Determining declaration for #1 + #3 + #4\n-        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-    }\n-    if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n-    }\n-    if (!inferred) {\n-        ObjectType ownerType = getObjectSlot(ownerName);\n-        if (ownerType != null) {\n-            // Only declare this as an official property if it has not been\n-            // declared yet.\n-            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n-            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n-                // If the property is undeclared or inferred, declare it now.\n-                ownerType.defineDeclaredProperty(propName, valueType, n);\n-            }\n-        }\n-        // If the property is already declared, the error will be\n-        // caught when we try to declare it in the current scope.\n-        defineSlot(n, parent, valueType, inferred);\n-    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n-        // We declare these for delegate proxy method properties.\n-        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n-        if (ownerType != null) {\n-            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n-            String delegateName = codingConvention.getDelegateSuperclassName();\n-            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n-            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n-                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n-            }\n-        }\n-    }\n+    setPrototype((PrototypeObjectType) baseType);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -1,23 +1,32 @@\n-public void setPrototypeBasedOn(ObjectType baseType) {\n-    // This is a bit weird. We need to successfully handle these\n-    // two cases:\n-    // Foo.prototype = new Bar();\n-    // and\n-    // Foo.prototype = {baz: 3};\n-    // In the first case, we do not want new properties to get\n-    // added to Bar. In the second case, we do want new properties\n-    // to get added to the type of the anonymous object.\n-    //\n-    // We handle this by breaking it into two cases:\n-    //\n-    // In the first case, we create a new PrototypeObjectType and set\n-    // its implicit prototype to the type being assigned. This ensures\n-    // that Bar will not get any properties of Foo.prototype, but properties\n-    // later assigned to Bar will get inherited properly.\n-    //\n-    // In the second case, we just use the anonymous object as the prototype.\n-    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n-        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n+public boolean setPrototype(PrototypeObjectType prototype) {\n+    if (prototype == null) {\n+        return false;\n     }\n-    setPrototype((PrototypeObjectType) baseType);\n+    // getInstanceType fails if the function is not a constructor\n+    if (isConstructor() && prototype == getInstanceType()) {\n+        return false;\n+    }\n+    boolean replacedPrototype = prototype != null;\n+    this.prototype = prototype;\n+    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n+    this.prototype.setOwnerFunction(this);\n+    // Disassociating the old prototype makes this easier to debug--\n+    // we don't have to worry about two prototypes running around.\n+    if (isConstructor() || isInterface()) {\n+        FunctionType superClass = getSuperClassConstructor();\n+        if (superClass != null) {\n+            superClass.addSubType(this);\n+        }\n+        if (isInterface()) {\n+            for (ObjectType interfaceType : getExtendedInterfaces()) {\n+                if (interfaceType.getConstructor() != null) {\n+                    interfaceType.getConstructor().addSubType(this);\n+                }\n+            }\n+        }\n+    }\n+    if (replacedPrototype) {\n+        clearCachedValues();\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getNameNode().getParent() == parent) {\n                scope.undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (isConstructor() || isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubtype(this);\n        }\n        if (isInterface()) {\n            for (ObjectType interfaceType : getExtendedInterfaces()) {\n                if (interfaceType.getConstructor() != null) {\n                    interfaceType.getConstructor().addSubtype(this);\n                }\n            }\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -1,92 +1,23 @@\n-void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    Node ownerNode = n.getFirstChild();\n-    String ownerName = ownerNode.getQualifiedName();\n-    String qName = n.getQualifiedName();\n-    String propName = n.getLastChild().getString();\n-    Preconditions.checkArgument(qName != null && ownerName != null);\n-    // Precedence of type information on GETPROPs:\n-    // 1) @type annnotation / @enum annotation\n-    // 2) ASSIGN to FUNCTION literal\n-    // 3) @param/@return annotation (with no function literal)\n-    // 4) ASSIGN to something marked @const\n-    // 5) ASSIGN to anything else\n+public void setPrototypeBasedOn(ObjectType baseType) {\n+    // This is a bit weird. We need to successfully handle these\n+    // two cases:\n+    // Foo.prototype = new Bar();\n+    // and\n+    // Foo.prototype = {baz: 3};\n+    // In the first case, we do not want new properties to get\n+    // added to Bar. In the second case, we do want new properties\n+    // to get added to the type of the anonymous object.\n     //\n-    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n-    // the function has jsdoc or has not been declared before.\n+    // We handle this by breaking it into two cases:\n     //\n-    // FUNCTION literals are special because TypedScopeCreator is very smart\n-    // about getting as much type information as possible for them.\n-    // Determining type for #1 + #2 + #3 + #4\n-    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n-    if (valueType == null && rhsValue != null) {\n-        // Determining type for #5\n-        valueType = rhsValue.getJSType();\n+    // In the first case, we create a new PrototypeObjectType and set\n+    // its implicit prototype to the type being assigned. This ensures\n+    // that Bar will not get any properties of Foo.prototype, but properties\n+    // later assigned to Bar will get inherited properly.\n+    //\n+    // In the second case, we just use the anonymous object as the prototype.\n+    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n+        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n     }\n-    // Function prototypes are special.\n-    // It's a common JS idiom to do:\n-    // F.prototype = { ... };\n-    // So if F does not have an explicitly declared super type,\n-    // allow F.prototype to be redefined arbitrarily.\n-    if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n-        if (qVar != null) {\n-            // If the programmer has declared that F inherits from Super,\n-            // and they assign F.prototype to an object literal,\n-            // then they are responsible for making sure that the object literal's\n-            // implicit prototype is set up appropriately. We just obey\n-            // the @extends tag.\n-            if (!qVar.isTypeInferred()) {\n-                // If the programmer has declared that F inherits from Super,\n-                // and they assign F.prototype to some arbitrary expression,\n-                // there's not much we can do. We just ignore the expression,\n-                // and hope they've annotated their code in a way to tell us\n-                // what props are going to be on that prototype.\n-                return;\n-            }\n-            if (qVar.getScope() == scope) {\n-                scope.undeclare(qVar);\n-            }\n-        }\n-    }\n-    if (valueType == null) {\n-        if (parent.getType() == Token.EXPR_RESULT) {\n-            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n-        }\n-        return;\n-    }\n-    boolean inferred = true;\n-    if (info != null) {\n-        // Determining declaration for #1 + #3 + #4\n-        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-    }\n-    if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n-    }\n-    if (!inferred) {\n-        ObjectType ownerType = getObjectSlot(ownerName);\n-        if (ownerType != null) {\n-            // Only declare this as an official property if it has not been\n-            // declared yet.\n-            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n-            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n-                // If the property is undeclared or inferred, declare it now.\n-                ownerType.defineDeclaredProperty(propName, valueType, n);\n-            }\n-        }\n-        // If the property is already declared, the error will be\n-        // caught when we try to declare it in the current scope.\n-        defineSlot(n, parent, valueType, inferred);\n-    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n-        // We declare these for delegate proxy method properties.\n-        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n-        if (ownerType != null) {\n-            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n-            String delegateName = codingConvention.getDelegateSuperclassName();\n-            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n-            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n-                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n-            }\n-        }\n-    }\n+    setPrototype((PrototypeObjectType) baseType);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -1,23 +1,32 @@\n-public void setPrototypeBasedOn(ObjectType baseType) {\n-    // This is a bit weird. We need to successfully handle these\n-    // two cases:\n-    // Foo.prototype = new Bar();\n-    // and\n-    // Foo.prototype = {baz: 3};\n-    // In the first case, we do not want new properties to get\n-    // added to Bar. In the second case, we do want new properties\n-    // to get added to the type of the anonymous object.\n-    //\n-    // We handle this by breaking it into two cases:\n-    //\n-    // In the first case, we create a new PrototypeObjectType and set\n-    // its implicit prototype to the type being assigned. This ensures\n-    // that Bar will not get any properties of Foo.prototype, but properties\n-    // later assigned to Bar will get inherited properly.\n-    //\n-    // In the second case, we just use the anonymous object as the prototype.\n-    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n-        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n+public boolean setPrototype(PrototypeObjectType prototype) {\n+    if (prototype == null) {\n+        return false;\n     }\n-    setPrototype((PrototypeObjectType) baseType);\n+    // getInstanceType fails if the function is not a constructor\n+    if (isConstructor() && prototype == getInstanceType()) {\n+        return false;\n+    }\n+    boolean replacedPrototype = prototype != null;\n+    this.prototype = prototype;\n+    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n+    this.prototype.setOwnerFunction(this);\n+    // Disassociating the old prototype makes this easier to debug--\n+    // we don't have to worry about two prototypes running around.\n+    if (isConstructor() || isInterface()) {\n+        FunctionType superClass = getSuperClassConstructor();\n+        if (superClass != null) {\n+            superClass.addSubtype(this);\n+        }\n+        if (isInterface()) {\n+            for (ObjectType interfaceType : getExtendedInterfaces()) {\n+                if (interfaceType.getConstructor() != null) {\n+                    interfaceType.getConstructor().addSubtype(this);\n+                }\n+            }\n+        }\n+    }\n+    if (replacedPrototype) {\n+        clearCachedValues();\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nvoid maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue, TypedScope scope) {\n    Node ownerNode = n.getFirstChild();\n    String ownerName = ownerNode.getQualifiedName();\n    String qName = n.getQualifiedName();\n    String propName = n.getLastChild().getString();\n    Preconditions.checkArgument(qName != null && ownerName != null);\n    // Precedence of type information on GETPROPs:\n    // 1) @type annnotation / @enum annotation\n    // 2) ASSIGN to FUNCTION literal\n    // 3) @param/@return annotation (with no function literal)\n    // 4) ASSIGN to something marked @const\n    // 5) ASSIGN to anything else\n    //\n    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n    // the function has jsdoc or has not been declared before.\n    //\n    // FUNCTION literals are special because TypedScopeCreator is very smart\n    // about getting as much type information as possible for them.\n    // Determining type for #1 + #2 + #3 + #4\n    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n    }\n    // Function prototypes are special.\n    // It's a common JS idiom to do:\n    // F.prototype = { ... };\n    // So if F does not have an explicitly declared super type,\n    // allow F.prototype to be redefined arbitrarily.\n    if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n            // If the programmer has declared that F inherits from Super,\n            // and they assign F.prototype to an object literal,\n            // then they are responsible for making sure that the object literal's\n            // implicit prototype is set up appropriately. We just obey\n            // the @extends tag.\n            if (!qVar.isTypeInferred()) {\n                // If the programmer has declared that F inherits from Super,\n                // and they assign F.prototype to some arbitrary expression,\n                // there's not much we can do. We just ignore the expression,\n                // and hope they've annotated their code in a way to tell us\n                // what props are going to be on that prototype.\n                return;\n            }\n            if (qVar.getScope() == scope) {\n                scope.undeclare(qVar);\n            }\n        }\n    }\n    if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n        }\n        return;\n    }\n    boolean inferred = true;\n    if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n    }\n    if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n    }\n    if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            // Only declare this as an official property if it has not been\n            // declared yet.\n            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\n## Fixed Function 2\npublic void setPrototypeBasedOn(ObjectType baseType) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType == null || baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType);\n}\n\n## Fixed Function 3\npublic boolean setPrototype(PrototypeObjectType prototype) {\n    if (prototype == null) {\n        return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (!isInterface() && isConstructor() && prototype == getInstanceType()) {\n        return false;\n    }\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n    this.prototype.setOwnerFunction(this);\n    // Disassociating the old prototype makes this easier to debug--\n    // we don't have to worry about two prototypes running around.\n    if (!isInterface()) {\n        FunctionType superClass = getSuperClassConstructor();\n        if (superClass != null) {\n            superClass.addSubType(this);\n        }\n    }\n    if (replacedPrototype) {\n        clearCachedValues();\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n+++ com/google/javascript/jscomp/TypedScopeCreator.javamaybeDeclareQualifiedName\n@@ -1,92 +1,23 @@\n-void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n-    Node ownerNode = n.getFirstChild();\n-    String ownerName = ownerNode.getQualifiedName();\n-    String qName = n.getQualifiedName();\n-    String propName = n.getLastChild().getString();\n-    Preconditions.checkArgument(qName != null && ownerName != null);\n-    // Precedence of type information on GETPROPs:\n-    // 1) @type annnotation / @enum annotation\n-    // 2) ASSIGN to FUNCTION literal\n-    // 3) @param/@return annotation (with no function literal)\n-    // 4) ASSIGN to something marked @const\n-    // 5) ASSIGN to anything else\n+public void setPrototypeBasedOn(ObjectType baseType) {\n+    // This is a bit weird. We need to successfully handle these\n+    // two cases:\n+    // Foo.prototype = new Bar();\n+    // and\n+    // Foo.prototype = {baz: 3};\n+    // In the first case, we do not want new properties to get\n+    // added to Bar. In the second case, we do want new properties\n+    // to get added to the type of the anonymous object.\n     //\n-    // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n-    // the function has jsdoc or has not been declared before.\n+    // We handle this by breaking it into two cases:\n     //\n-    // FUNCTION literals are special because TypedScopeCreator is very smart\n-    // about getting as much type information as possible for them.\n-    // Determining type for #1 + #2 + #3 + #4\n-    JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n-    if (valueType == null && rhsValue != null) {\n-        // Determining type for #5\n-        valueType = rhsValue.getJSType();\n+    // In the first case, we create a new PrototypeObjectType and set\n+    // its implicit prototype to the type being assigned. This ensures\n+    // that Bar will not get any properties of Foo.prototype, but properties\n+    // later assigned to Bar will get inherited properly.\n+    //\n+    // In the second case, we just use the anonymous object as the prototype.\n+    if (baseType == null || baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n+        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n     }\n-    // Function prototypes are special.\n-    // It's a common JS idiom to do:\n-    // F.prototype = { ... };\n-    // So if F does not have an explicitly declared super type,\n-    // allow F.prototype to be redefined arbitrarily.\n-    if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n-        if (qVar != null) {\n-            // If the programmer has declared that F inherits from Super,\n-            // and they assign F.prototype to an object literal,\n-            // then they are responsible for making sure that the object literal's\n-            // implicit prototype is set up appropriately. We just obey\n-            // the @extends tag.\n-            if (!qVar.isTypeInferred()) {\n-                // If the programmer has declared that F inherits from Super,\n-                // and they assign F.prototype to some arbitrary expression,\n-                // there's not much we can do. We just ignore the expression,\n-                // and hope they've annotated their code in a way to tell us\n-                // what props are going to be on that prototype.\n-                return;\n-            }\n-            if (qVar.getScope() == scope) {\n-                scope.undeclare(qVar);\n-            }\n-        }\n-    }\n-    if (valueType == null) {\n-        if (parent.getType() == Token.EXPR_RESULT) {\n-            stubDeclarations.add(new StubDeclaration(n, t.getInput() != null && t.getInput().isExtern(), ownerName));\n-        }\n-        return;\n-    }\n-    boolean inferred = true;\n-    if (info != null) {\n-        // Determining declaration for #1 + #3 + #4\n-        inferred = !(info.hasType() || info.hasEnumParameterType() || (info.isConstant() && valueType != null && !valueType.isUnknownType()) || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-    }\n-    if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null && rhsValue.getType() == Token.FUNCTION && (info != null || !scope.isDeclared(qName, false)));\n-    }\n-    if (!inferred) {\n-        ObjectType ownerType = getObjectSlot(ownerName);\n-        if (ownerType != null) {\n-            // Only declare this as an official property if it has not been\n-            // declared yet.\n-            boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n-            if ((!ownerType.hasOwnProperty(propName) || ownerType.isPropertyTypeInferred(propName)) && ((isExtern && !ownerType.isNativeObjectType()) || !ownerType.isInstanceType())) {\n-                // If the property is undeclared or inferred, declare it now.\n-                ownerType.defineDeclaredProperty(propName, valueType, n);\n-            }\n-        }\n-        // If the property is already declared, the error will be\n-        // caught when we try to declare it in the current scope.\n-        defineSlot(n, parent, valueType, inferred);\n-    } else if (rhsValue != null && rhsValue.getType() == Token.TRUE) {\n-        // We declare these for delegate proxy method properties.\n-        FunctionType ownerType = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n-        if (ownerType != null) {\n-            JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n-            String delegateName = codingConvention.getDelegateSuperclassName();\n-            JSType delegateType = delegateName == null ? null : typeRegistry.getType(delegateName);\n-            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n-                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n-            }\n-        }\n-    }\n+    setPrototype((PrototypeObjectType) baseType);\n }\n--- com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n+++ com/google/javascript/rhino/jstype/FunctionType.javasetPrototypeBasedOn\n@@ -1,23 +1,25 @@\n-public void setPrototypeBasedOn(ObjectType baseType) {\n-    // This is a bit weird. We need to successfully handle these\n-    // two cases:\n-    // Foo.prototype = new Bar();\n-    // and\n-    // Foo.prototype = {baz: 3};\n-    // In the first case, we do not want new properties to get\n-    // added to Bar. In the second case, we do want new properties\n-    // to get added to the type of the anonymous object.\n-    //\n-    // We handle this by breaking it into two cases:\n-    //\n-    // In the first case, we create a new PrototypeObjectType and set\n-    // its implicit prototype to the type being assigned. This ensures\n-    // that Bar will not get any properties of Foo.prototype, but properties\n-    // later assigned to Bar will get inherited properly.\n-    //\n-    // In the second case, we just use the anonymous object as the prototype.\n-    if (baseType.hasReferenceName() || baseType.isUnknownType() || isNativeObjectType() || baseType.isFunctionPrototypeType() || !(baseType instanceof PrototypeObjectType)) {\n-        baseType = new PrototypeObjectType(registry, this.getReferenceName() + \".prototype\", baseType);\n+public boolean setPrototype(PrototypeObjectType prototype) {\n+    if (prototype == null) {\n+        return false;\n     }\n-    setPrototype((PrototypeObjectType) baseType);\n+    // getInstanceType fails if the function is not a constructor\n+    if (!isInterface() && isConstructor() && prototype == getInstanceType()) {\n+        return false;\n+    }\n+    boolean replacedPrototype = prototype != null;\n+    this.prototype = prototype;\n+    this.prototypeSlot = new SimpleSlot(\"prototype\", prototype, true);\n+    this.prototype.setOwnerFunction(this);\n+    // Disassociating the old prototype makes this easier to debug--\n+    // we don't have to worry about two prototypes running around.\n+    if (!isInterface()) {\n+        FunctionType superClass = getSuperClassConstructor();\n+        if (superClass != null) {\n+            superClass.addSubType(this);\n+        }\n+    }\n+    if (replacedPrototype) {\n+        clearCachedValues();\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]