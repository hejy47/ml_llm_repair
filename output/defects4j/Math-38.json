[{"output": "// altmov\n// ----------------------------------------------------------------------------------------\nprivate void prelim(double[] lowerBound, double[] upperBound) {\n    printMethod();\n    final int n = currentBest.getDimension();\n    final int npt = numberOfInterpolationPoints;\n    final int ndim = bMatrix.getRowDimension();\n    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n    final double recip = 1d / rhosq;\n    final int np = n + 1;\n    // Set XBASE to the initial vector of variables, and set the initial\n    // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n    for (int j = 0; j < n; j++) {\n        originShift.setEntry(j, currentBest.getEntry(j));\n        for (int k = 0; k < npt; k++) {\n            interpolationPoints.setEntry(k, j, ZERO);\n        }\n        for (int i = 0; i < ndim; i++) {\n            bMatrix.setEntry(i, j, ZERO);\n        }\n    }\n    for (int i = 0, max = n * np / 2; i < max; i++) {\n        modelSecondDerivativesValues.setEntry(i, ZERO);\n    }\n    for (int k = 0; k < npt; k++) {\n        modelSecondDerivativesParameters.setEntry(k, ZERO);\n        for (int j = 0, max = npt - np; j < max; j++) {\n            zMatrix.setEntry(k, j, ZERO);\n        }\n    }\n\n    int lastInterpolationPointIndex = -1;\n    // Begin the initialization procedure. NF becomes one more than the number\n    // of function values so far. The coordinates of the displacement of the\n    // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n    for (int currentInterpolationPointIndex = 0; currentInterpolationPointIndex < npt; currentInterpolationPointIndex++) {\n        final int nfm = currentInterpolationPointIndex + 1;\n        if (nfm == 1) { // We generate X_1 first.\n            // The trust-region center is X_1.\n            trustRegionCenterInterpolationPointIndex = 0;\n            // Initial step is always the initial trust-region radius.\n            double initialStepSize = initialTrustRegionRadius;\n            // Find the index of the first non-fixed variable.\n            int freeVariableIndex = -1;\n            do {\n                freeVariableIndex++;\n            } while (freeVariableIndex < n && (lowerBound[freeVariableIndex] == upperBound[freeVariableIndex]));\n            if (freeVariableIndex == n) {\n                throw new MoreVariablesThanEquationsException();\n            }\n            // Calculate the initial point X_1.\n            interpolationPoints.setEntry(nfm, freeVariableIndex, initialStepSize);\n        } else { // We generate X_{nfm} for \\geq 2.\n            // Update the last interpolation point to X_{nfm-1}.\n            for (int j = 0; j < n; j++) {\n                interpolationPoints.setEntry(lastInterpolationPointIndex, j, currentBest.getEntry(j));\n            }\n            double objectiveValueAtLastInterpolationPoint = computeObjectiveValue(currentBest.toArray());\n            fAtInterpolationPoints.setEntry(lastInterpolationPointIndex, isMinimize ? objectiveValueAtLastInterpolationPoint : -objectiveValueAtLastInterpolationPoint);\n            double fAtLastInterpolationPoint = fAtInterpolationPoints.getEntry(lastInterpolationPointIndex);\n            // If we have generated fewer points than n+1, we simply generate the\n            // next point according to the fixed pattern.\n            if (nfm <= n + 1) {\n                int j = nfm - 2;\n                int sign = (j % 2 == 0) ? 1 : -1;\n                j /= 2;\n                int currentInterpolationPointIndex0 = currentInterpolationPointIndex - n;\n                final int index1 = trustRegionCenterInterpolationPointIndex;\n                final double deltaX1 = interpolationPoints.getEntry(currentInterpolationPointIndex0, index1);\n                final double x1 = currentBest.getEntry(index1);\n                final double lowerBound1 = lowerBound[index1];\n                final double upperBound1 = upperBound[index1];\n                final double currentPointComponent = x1;\n                final double newPointComponent = Math.min(Math.max(lowerBound1, x1 + sign * deltaX1), upperBound1);\n                final double deltaXDiff = newPointComponent - currentPointComponent;\n                interpolationPoints.setEntry(nfm, index1, deltaXDiff);\n                for (int i = 0; i < j; i++) {\n                    final int indexI = indices[i];\n                    final double deltaXI = coordinateDifference.getEntry(i);\n                    final double xI = currentBest.getEntry(indexI);\n                    final double lowerBoundI = lowerBound[indexI];\n                    final double upperBoundI = upperBound[indexI];\n                    final double currentPointComponentI = xI;\n                    final double newPointComponentI = Math.min(Math.max(lowerBoundI, xI + sign * deltaXI), upperBoundI);\n                    final double deltaXDiffI = newPointComponentI - currentPointComponentI;\n                    interpolationPoints.setEntry(nfm, indexI, deltaXDiffI);\n                }\n            } else {\n                // We generate X_{nfm} using quadratic model.\n                trustRegionCenterInterpolationPointIndex = 0;\n                lastInterpolationPointIndex = currentInterpolationPointIndex - 1;\n                update(bMatrix, zMatrix, modelSecondDerivativesValues, interpolationPoints, fAtInterpolationPoints, trustRegionCenterInterpolationPointIndex, currentInterpolationPointIndex, interpolateEndpoints);\n                for (int j = 0; j < n; j++) {\n                    currentBest.setEntry(j, Math.min(Math.max(lowerBound[j], originShift.getEntry(j) + interpolationPoints.getEntry(currentInterpolationPointIndex, j)), upperBound[j]));\n                    if (interpolationPoints.getEntry(currentInterpolationPointIndex, j) == lowerDifference.getEntry(j)) {\n                        currentBest.setEntry(j, lowerBound[j]);\n                    }\n                    if (interpolationPoints.getEntry(currentInterpolationPointIndex, j) == upperDifference.getEntry(j)) {\n                        currentBest.setEntry(j, upperBound[j]);\n                    }\n                }\n                final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n                final double f = isMinimize ? objectiveValue : -objectiveValue;\n                fAtInterpolationPoints.setEntry(currentInterpolationPointIndex, f);\n                if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n                    trustRegionCenterInterpolationPointIndex = currentInterpolationPointIndex;\n                }\n            }\n        }\n        lastInterpolationPointIndex = currentInterpolationPointIndex;\n    }\n}", "diff": "--- org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java@prelim\n+++ org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java@prelim\n@@ -1,7 +1,6 @@\n // altmov\n // ----------------------------------------------------------------------------------------\n private void prelim(double[] lowerBound, double[] upperBound) {\n-    // XXX\n     printMethod();\n     final int n = currentBest.getDimension();\n     final int npt = numberOfInterpolationPoints;\n@@ -29,134 +28,85 @@\n             zMatrix.setEntry(k, j, ZERO);\n         }\n     }\n+\n+    int lastInterpolationPointIndex = -1;\n     // Begin the initialization procedure. NF becomes one more than the number\n     // of function values so far. The coordinates of the displacement of the\n     // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n-    int ipt = 0;\n-    int jpt = 0;\n-    double fbeg = Double.NaN;\n-    do {\n-        final int nfm = getEvaluations();\n-        final int nfx = nfm - n;\n-        final int nfmm = nfm - 1;\n-        final int nfxm = nfx - 1;\n-        double stepa = 0;\n-        double stepb = 0;\n-        if (nfm <= 2 * n) {\n-            if (nfm >= 1 && nfm <= n) {\n-                stepa = initialTrustRegionRadius;\n-                if (upperDifference.getEntry(nfmm) == ZERO) {\n-                    stepa = -stepa;\n-                    // XXX\n-                    throw new PathIsExploredException();\n+    for (int currentInterpolationPointIndex = 0; currentInterpolationPointIndex < npt; currentInterpolationPointIndex++) {\n+        final int nfm = currentInterpolationPointIndex + 1;\n+        if (nfm == 1) { // We generate X_1 first.\n+            // The trust-region center is X_1.\n+            trustRegionCenterInterpolationPointIndex = 0;\n+            // Initial step is always the initial trust-region radius.\n+            double initialStepSize = initialTrustRegionRadius;\n+            // Find the index of the first non-fixed variable.\n+            int freeVariableIndex = -1;\n+            do {\n+                freeVariableIndex++;\n+            } while (freeVariableIndex < n && (lowerBound[freeVariableIndex] == upperBound[freeVariableIndex]));\n+            if (freeVariableIndex == n) {\n+                throw new MoreVariablesThanEquationsException();\n+            }\n+            // Calculate the initial point X_1.\n+            interpolationPoints.setEntry(nfm, freeVariableIndex, initialStepSize);\n+        } else { // We generate X_{nfm} for \\geq 2.\n+            // Update the last interpolation point to X_{nfm-1}.\n+            for (int j = 0; j < n; j++) {\n+                interpolationPoints.setEntry(lastInterpolationPointIndex, j, currentBest.getEntry(j));\n+            }\n+            double objectiveValueAtLastInterpolationPoint = computeObjectiveValue(currentBest.toArray());\n+            fAtInterpolationPoints.setEntry(lastInterpolationPointIndex, isMinimize ? objectiveValueAtLastInterpolationPoint : -objectiveValueAtLastInterpolationPoint);\n+            double fAtLastInterpolationPoint = fAtInterpolationPoints.getEntry(lastInterpolationPointIndex);\n+            // If we have generated fewer points than n+1, we simply generate the\n+            // next point according to the fixed pattern.\n+            if (nfm <= n + 1) {\n+                int j = nfm - 2;\n+                int sign = (j % 2 == 0) ? 1 : -1;\n+                j /= 2;\n+                int currentInterpolationPointIndex0 = currentInterpolationPointIndex - n;\n+                final int index1 = trustRegionCenterInterpolationPointIndex;\n+                final double deltaX1 = interpolationPoints.getEntry(currentInterpolationPointIndex0, index1);\n+                final double x1 = currentBest.getEntry(index1);\n+                final double lowerBound1 = lowerBound[index1];\n+                final double upperBound1 = upperBound[index1];\n+                final double currentPointComponent = x1;\n+                final double newPointComponent = Math.min(Math.max(lowerBound1, x1 + sign * deltaX1), upperBound1);\n+                final double deltaXDiff = newPointComponent - currentPointComponent;\n+                interpolationPoints.setEntry(nfm, index1, deltaXDiff);\n+                for (int i = 0; i < j; i++) {\n+                    final int indexI = indices[i];\n+                    final double deltaXI = coordinateDifference.getEntry(i);\n+                    final double xI = currentBest.getEntry(indexI);\n+                    final double lowerBoundI = lowerBound[indexI];\n+                    final double upperBoundI = upperBound[indexI];\n+                    final double currentPointComponentI = xI;\n+                    final double newPointComponentI = Math.min(Math.max(lowerBoundI, xI + sign * deltaXI), upperBoundI);\n+                    final double deltaXDiffI = newPointComponentI - currentPointComponentI;\n+                    interpolationPoints.setEntry(nfm, indexI, deltaXDiffI);\n                 }\n-                interpolationPoints.setEntry(nfm, nfmm, stepa);\n-            } else if (nfm > n) {\n-                stepa = interpolationPoints.getEntry(nfx, nfxm);\n-                stepb = -initialTrustRegionRadius;\n-                if (lowerDifference.getEntry(nfxm) == ZERO) {\n-                    stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n-                    // XXX\n-                    throw new PathIsExploredException();\n+            } else {\n+                // We generate X_{nfm} using quadratic model.\n+                trustRegionCenterInterpolationPointIndex = 0;\n+                lastInterpolationPointIndex = currentInterpolationPointIndex - 1;\n+                update(bMatrix, zMatrix, modelSecondDerivativesValues, interpolationPoints, fAtInterpolationPoints, trustRegionCenterInterpolationPointIndex, currentInterpolationPointIndex, interpolateEndpoints);\n+                for (int j = 0; j < n; j++) {\n+                    currentBest.setEntry(j, Math.min(Math.max(lowerBound[j], originShift.getEntry(j) + interpolationPoints.getEntry(currentInterpolationPointIndex, j)), upperBound[j]));\n+                    if (interpolationPoints.getEntry(currentInterpolationPointIndex, j) == lowerDifference.getEntry(j)) {\n+                        currentBest.setEntry(j, lowerBound[j]);\n+                    }\n+                    if (interpolationPoints.getEntry(currentInterpolationPointIndex, j) == upperDifference.getEntry(j)) {\n+                        currentBest.setEntry(j, upperBound[j]);\n+                    }\n                 }\n-                if (upperDifference.getEntry(nfxm) == ZERO) {\n-                    stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n-                    // XXX\n-                    throw new PathIsExploredException();\n+                final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n+                final double f = isMinimize ? objectiveValue : -objectiveValue;\n+                fAtInterpolationPoints.setEntry(currentInterpolationPointIndex, f);\n+                if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n+                    trustRegionCenterInterpolationPointIndex = currentInterpolationPointIndex;\n                 }\n-                interpolationPoints.setEntry(nfm, nfxm, stepb);\n-            }\n-        } else {\n-            final int tmp1 = (nfm - np) / n;\n-            jpt = nfm - tmp1 * n - n;\n-            ipt = jpt + tmp1;\n-            if (ipt > n) {\n-                final int tmp2 = jpt;\n-                jpt = ipt - n;\n-                ipt = tmp2;\n-                // XXX\n-                throw new PathIsExploredException();\n-            }\n-            final int iptMinus1 = ipt;\n-            final int jptMinus1 = jpt;\n-            interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n-            interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n-        }\n-        // Calculate the next value of F. The least function value so far and\n-        // its index are required.\n-        for (int j = 0; j < n; j++) {\n-            currentBest.setEntry(j, Math.min(Math.max(lowerBound[j], originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)), upperBound[j]));\n-            if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n-                currentBest.setEntry(j, lowerBound[j]);\n-            }\n-            if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n-                currentBest.setEntry(j, upperBound[j]);\n             }\n         }\n-        final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n-        final double f = isMinimize ? objectiveValue : -objectiveValue;\n-        // nfm + 1\n-        final int numEval = getEvaluations();\n-        fAtInterpolationPoints.setEntry(nfm, f);\n-        if (numEval == 1) {\n-            fbeg = f;\n-            trustRegionCenterInterpolationPointIndex = 0;\n-        } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n-            trustRegionCenterInterpolationPointIndex = nfm;\n-        }\n-        // Set the nonzero initial elements of BMAT and the quadratic model in the\n-        // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n-        // of the NF-th and (NF-N)-th interpolation points may be switched, in\n-        // order that the function value at the first of them contributes to the\n-        // off-diagonal second derivative terms of the initial quadratic model.\n-        if (numEval <= 2 * n + 1) {\n-            if (numEval >= 2 && numEval <= n + 1) {\n-                gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n-                if (npt < numEval + n) {\n-                    final double oneOverStepA = ONE / stepa;\n-                    bMatrix.setEntry(0, nfmm, -oneOverStepA);\n-                    bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n-                    bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n-                    // XXX\n-                    throw new PathIsExploredException();\n-                }\n-            } else if (numEval >= n + 2) {\n-                final int ih = nfx * (nfx + 1) / 2 - 1;\n-                final double tmp = (f - fbeg) / stepb;\n-                final double diff = stepb - stepa;\n-                modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n-                gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n-                if (stepa * stepb < ZERO) {\n-                    if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n-                        fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n-                        fAtInterpolationPoints.setEntry(nfm - n, f);\n-                        if (trustRegionCenterInterpolationPointIndex == nfm) {\n-                            trustRegionCenterInterpolationPointIndex = nfm - n;\n-                        }\n-                        interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n-                        interpolationPoints.setEntry(nfm, nfxm, stepa);\n-                    }\n-                }\n-                bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n-                bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n-                bMatrix.setEntry(nfm - n, nfxm, -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n-                zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n-                zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n-                // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n-                zMatrix.setEntry(nfm - n, nfxm, -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n-            }\n-            // Set the off-diagonal second derivatives of the Lagrange functions and\n-            // the initial quadratic model.\n-        } else {\n-            zMatrix.setEntry(0, nfxm, recip);\n-            zMatrix.setEntry(nfm, nfxm, recip);\n-            zMatrix.setEntry(ipt, nfxm, -recip);\n-            zMatrix.setEntry(jpt, nfxm, -recip);\n-            final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n-            final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n-            modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n-            // XXX\n-            throw new PathIsExploredException();\n-        }\n-    } while (getEvaluations() < npt);\n+        lastInterpolationPointIndex = currentInterpolationPointIndex;\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]