[{"output": "## Fixed Function 1\n\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    Node fnBody = t.getScopeRoot().getLastChild();\n    if (fnBody != null) {\n        cfa.process(null, fnBody);\n        cfg = cfa.getCfg();\n        reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n        reachingDef.analyze();\n        candidates = Lists.newLinkedList();\n        // Using the forward reaching definition search to find all the inline\n        // candidates\n        new NodeTraversal(compiler, new GatherCandiates()).traverse(fnBody);\n\n        // Compute the backward reaching use. The CFG can be reused.\n        reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n        reachingUses.analyze();\n        for (Candidate c : candidates) {\n            if (c.canInline()) {\n                c.inlineVariable();\n                // If definition c has dependencies, then inlining it may have\n                // introduced new dependencies for our other inlining candidates.\n                //\n                // MustBeReachingVariableDef uses this dependency graph in its\n                // analysis, so some of these candidates may no longer be valid.\n                // We keep track of when the variable dependency graph changed\n                // so that we can back off appropriately.\n                if (!c.defMetadata.depends.isEmpty()) {\n                    inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n                }\n            }\n        }\n    }\n}\n\n\n## Fixed Function 2\n\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode() == null || getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && (!NodeUtil.isExprAssign(def.getParent()) || NodeUtil.isOptChainNullish(def.getLastChild()))) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but, this time, consider all the sub-expressions\n    // to the left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally, we have to make sure that there is only one use\n    // in the program and only one use in the CFG node.\n    // Semantically, inlining twice or more would only increase code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop.\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side-effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (cfg != null &&\n        NodeUtil.isStatementBlock(getDefCfgNode().getParent()) &&\n        getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side-effect check as above but this time the side effect is\n        // elsewhere along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck =\n            new CheckPathsBetweenNodes<>(cfg,\n                                          cfg.getDirectedGraphNode(getDefCfgNode()),\n                                          cfg.getDirectedGraphNode(useCfgNode),\n                                          SIDE_EFFECT_PREDICATE,\n                                          Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                                          false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,40 +1,71 @@\n-@Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+\n+private boolean canInline() {\n+    // Cannot inline a parameter.\n+    if (getDefCfgNode() == null || getDefCfgNode().isFunction()) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // If one of our dependencies has been inlined, then our dependency\n+    // graph is wrong. Re-computing it would take another CFG computation,\n+    // so we just back off for now.\n+    for (Var dependency : defMetadata.depends) {\n+        if (inlinedNewDependencies.contains(dependency)) {\n+            return false;\n         }\n     }\n-}\n+    getDefinition(getDefCfgNode(), null);\n+    getNumUseInUseCfgNode(useCfgNode, null);\n+    // Definition was not found.\n+    if (def == null) {\n+        return false;\n+    }\n+    // Check that the assignment isn't used as a R-Value.\n+    // TODO(user): Certain cases we can still inline.\n+    if (def.isAssign() && (!NodeUtil.isExprAssign(def.getParent()) || NodeUtil.isOptChainNullish(def.getLastChild()))) {\n+        return false;\n+    }\n+    // The right of the definition has side effect:\n+    // Example, for x:\n+    // x = readProp(b), modifyProp(b); print(x);\n+    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n+        return false;\n+    }\n+    // Similar check as the above but, this time, consider all the sub-expressions\n+    // to the left of the use of the variable.\n+    // x = readProp(b); modifyProp(b), print(x);\n+    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n+        return false;\n+    }\n+    // TODO(user): Side-effect is OK sometimes. As long as there are no\n+    // side-effect function down all paths to the use. Once we have all the\n+    // side-effect analysis tool.\n+    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n+        return false;\n+    }\n+    // TODO(user): We could inline all the uses if the expression is short.\n+    // Finally, we have to make sure that there is only one use\n+    // in the program and only one use in the CFG node.\n+    // Semantically, inlining twice or more would only increase code size.\n+    if (numUseWithinUseCfgNode != 1) {\n+        return false;\n+    }\n+    // Make sure that the name is not within a loop.\n+    if (NodeUtil.isWithinLoop(use)) {\n+        return false;\n+    }\n+    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n+    if (uses.size() != 1) {\n+        return false;\n+    }\n+    // We give up inlining stuff with R-Value that has:\n+    // 1) GETPROP, GETELEM,\n+    // 2) anything that creates a new object.\n+    // 3) a direct reference to a catch expression.\n+    // Example:\n+    // var x = a.b.c; j.c = 1; print(x);\n+    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n+    // TODO(user): We could get more accuracy by looking more in-detail\n+    // what j is and what x is trying to into to.\n+    // TODO(johnlenz): rework catch expression handling when we\n+    // have lexical scope support so catch expressions don't\n+    // need to be special cased.\n+    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    // Changed '>=' to '>' in the following line to avoid integer overflow\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE > t.getScope().getVarCount()) {\n        // Compute the forward reaching definition.\n        ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n        // Process the body of the function.\n        Preconditions.checkState(t.getScopeRoot().isFunction());\n        cfa.process(null, t.getScopeRoot().getLastChild());\n        cfg = cfa.getCfg();\n        reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n        reachingDef.analyze();\n        candidates = Lists.newLinkedList();\n        // Using the forward reaching definition search to find all the inline\n        // candidates\n        new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n        // Compute the backward reaching use. The CFG can be reused.\n        reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n        reachingUses.analyze();\n        for (Candidate c : candidates) {\n            if (c.canInline()) {\n                c.inlineVariable();\n                // If definition c has dependencies, then inlining it may\n                // have introduced new dependencies for our other inlining candidates.\n                //\n                // MustBeReachingVariableDef uses this dependency graph in its\n                // analysis, so some of these candidates may no longer be valid.\n                // We keep track of when the variable dependency graph changed so\n                // that we can back off appropriately.\n                if (!c.defMetadata.depends.isEmpty()) {\n                    inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n                }\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency graph is\n    // wrong. Re-computing it would take another CFG computation, so we just\n    // back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions left of\n    // the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail what j is\n    // and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n        @Override\n        public boolean apply(Node input) {\n            switch (input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if they are\n    // just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,40 +1,105 @@\n-@Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+private boolean canInline() {\n+    // Cannot inline a parameter.\n+    if (getDefCfgNode().isFunction()) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // If one of our dependencies has been inlined, then our dependency graph is\n+    // wrong. Re-computing it would take another CFG computation, so we just\n+    // back off for now.\n+    for (Var dependency : defMetadata.depends) {\n+        if (inlinedNewDependencies.contains(dependency)) {\n+            return false;\n         }\n     }\n+    getDefinition(getDefCfgNode(), null);\n+    getNumUseInUseCfgNode(useCfgNode, null);\n+    // Definition was not found.\n+    if (def == null) {\n+        return false;\n+    }\n+    // Check that the assignment isn't used as a R-Value.\n+    // TODO(user): Certain cases we can still inline.\n+    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+        return false;\n+    }\n+    // The right of the definition has side effect:\n+    // Example, for x:\n+    // x = readProp(b), modifyProp(b); print(x);\n+    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n+        return false;\n+    }\n+    // Similar check as the above but this time, all the sub-expressions left of\n+    // the use of the variable.\n+    // x = readProp(b); modifyProp(b), print(x);\n+    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n+        return false;\n+    }\n+    // TODO(user): Side-effect is OK sometimes. As long as there are no\n+    // side-effect function down all paths to the use. Once we have all the\n+    // side-effect analysis tool.\n+    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n+        return false;\n+    }\n+    // TODO(user): We could inline all the uses if the expression is short.\n+    // Finally we have to make sure that there are no more than one use\n+    // in the program and in the CFG node. Even when it is semantically\n+    // correctly inlining twice increases code size.\n+    if (numUseWithinUseCfgNode != 1) {\n+        return false;\n+    }\n+    // Make sure that the name is not within a loop\n+    if (NodeUtil.isWithinLoop(use)) {\n+        return false;\n+    }\n+    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n+    if (uses.size() != 1) {\n+        return false;\n+    }\n+    // We give up inlining stuff with R-Value that has:\n+    // 1) GETPROP, GETELEM,\n+    // 2) anything that creates a new object.\n+    // 3) a direct reference to a catch expression.\n+    // Example:\n+    // var x = a.b.c; j.c = 1; print(x);\n+    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n+    // TODO(user): We could get more accuracy by looking more in-detail what j is\n+    // and what x is trying to into to.\n+    // TODO(johnlenz): rework catch expression handling when we\n+    // have lexical scope support so catch expressions don't\n+    // need to be special cased.\n+    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n+        @Override\n+        public boolean apply(Node input) {\n+            switch (input.getType()) {\n+                case Token.GETELEM:\n+                case Token.GETPROP:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.REGEXP:\n+                case Token.NEW:\n+                    return true;\n+            }\n+            return false;\n+        }\n+    }, new Predicate<Node>() {\n+        @Override\n+        public boolean apply(Node input) {\n+            // Recurse if the node is not a function.\n+            return !input.isFunction();\n+        }\n+    })) {\n+        return false;\n+    }\n+    // We can skip the side effect check along the paths of two nodes if they are\n+    // just next to each other.\n+    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n+        // Similar side effect check as above but this time the side effect is\n+        // else where along the path.\n+        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n+        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n+        if (pathCheck.somePathsSatisfyPredicate()) {\n+            return false;\n+        }\n+    }\n+    return true;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1 (Closure Project)\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    NodeTraversal.traverseEs6(compiler, t.getScopeRoot().getLastChild(), new GatherCandiates());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2 (Closure Project)\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction() || getDefCfgNode().getParent().isParamList()) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    // We allow cases where the assigned variable is part of an array or an object\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        Node rvalue = def.getLastChild();\n        if ((rvalue.isObjectLit() || rvalue.isArrayLit()) && rvalue.hasOneChild()) {\n            Node valueNode = rvalue.getFirstChild();\n            if (valueNode.isOr() || valueNode.isHook()) {\n                Node secondChild = valueNode.getLastChild();\n                if (secondChild.isName()) {\n                    Var var = scope.getVar(secondChild.getString());\n                    if (var != null && !var.isLocal()) {\n                        return false;\n                    }\n                }\n            }\n        } else if (!rvalue.isName()) {\n            return false;\n        } else {\n            Var var = scope.getVar(rvalue.getString());\n            if (var != null && !var.isLocal()) {\n                return false;\n            }\n        }\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                case Token.CALL:\n                    return true;\n                case Token.CAST:\n                    return !compilingEs6OrHigher;\n                case Token.NAME:\n                    if (\"execScript\".equals(input.getString())) {\n                        return true;\n                    }\n                    break;\n            }\n            return false;\n        }\n    }, Predicates.<Node>alwaysTrue())) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // elsewhere along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck =\n                new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg,\n                        cfg.getDirectedGraphNode(getDefCfgNode()),\n                        cfg.getDirectedGraphNode(useCfgNode),\n                        SIDE_EFFECT_PREDICATE,\n                        Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(),\n                        false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n        // Don't even bother. All global variables are likely escaped.\n        return;\n    }\n    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandidates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction() || getDefCfgNode().getParent() == null) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isNameDeclaration(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (!def.getLastChild().isSideEffectFree() || NodeUtil.isCall(def.getLastChild())) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    if (numUseWithinUseCfgNode != 1) {\n        return false;\n    }\n    // Make sure that the name is not within a loop\n    if (NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1 || !uses.iterator().next().isEquivalentTo(use)) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,40 +1,70 @@\n-@Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+private boolean canInline() {\n+    // Cannot inline a parameter.\n+    if (getDefCfgNode().isFunction() || getDefCfgNode().getParent() == null) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // If one of our dependencies has been inlined, then our dependency\n+    // graph is wrong. Re-computing it would take another CFG computation,\n+    // so we just back off for now.\n+    for (Var dependency : defMetadata.depends) {\n+        if (inlinedNewDependencies.contains(dependency)) {\n+            return false;\n         }\n     }\n-}\n+    getDefinition(getDefCfgNode(), null);\n+    getNumUseInUseCfgNode(useCfgNode, null);\n+    // Definition was not found.\n+    if (def == null) {\n+        return false;\n+    }\n+    // Check that the assignment isn't used as a R-Value.\n+    // TODO(user): Certain cases we can still inline.\n+    if (def.isAssign() && !NodeUtil.isNameDeclaration(def.getParent())) {\n+        return false;\n+    }\n+    // The right of the definition has side effect:\n+    // Example, for x:\n+    // x = readProp(b), modifyProp(b); print(x);\n+    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n+        return false;\n+    }\n+    // Similar check as the above but this time, all the sub-expressions\n+    // left of the use of the variable.\n+    // x = readProp(b); modifyProp(b), print(x);\n+    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n+        return false;\n+    }\n+    // TODO(user): Side-effect is OK sometimes. As long as there are no\n+    // side-effect function down all paths to the use. Once we have all the\n+    // side-effect analysis tool.\n+    if (!def.getLastChild().isSideEffectFree() || NodeUtil.isCall(def.getLastChild())) {\n+        return false;\n+    }\n+    // TODO(user): We could inline all the uses if the expression is short.\n+    // Finally we have to make sure that there are no more than one use\n+    // in the program and in the CFG node. Even when it is semantically\n+    // correctly inlining twice increases code size.\n+    if (numUseWithinUseCfgNode != 1) {\n+        return false;\n+    }\n+    // Make sure that the name is not within a loop\n+    if (NodeUtil.isWithinLoop(use)) {\n+        return false;\n+    }\n+    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n+    if (uses.size() != 1 || !uses.iterator().next().isEquivalentTo(use)) {\n+        return false;\n+    }\n+    // We give up inlining stuff with R-Value that has:\n+    // 1) GETPROP, GETELEM,\n+    // 2) anything that creates a new object.\n+    // 3) a direct reference to a catch expression.\n+    // Example:\n+    // var x = a.b.c; j.c = 1; print(x);\n+    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n+    // TODO(user): We could get more accuracy by looking more in-detail\n+    // what j is and what x is trying to into to.\n+    // TODO(johnlenz): rework catch expression handling when we\n+    // have lexical scope support so catch expressions don't\n+    // need to be special cased.\n+    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\npublic void enterScope(NodeTraversal t) {\n    if (t.getScopeRoot().isFunction()) {\n        // Don't process function scopes\n        return;\n    }\n    if (t.inGlobalScope() || LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n        // Skip analyzing if in global scope or if number of variables exceeds maximum\n        return;\n    }\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(t.getScopeRoot().isFunction());\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n    // Using the forward reaching definition search to find all the inline\n    // candidates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n        if (c.canInline()) {\n            c.inlineVariable();\n            // If definition c has dependencies, then inlining it may have\n            // introduced new dependencies for our other inlining candidates.\n            //\n            // MustBeReachingVariableDef uses this dependency graph in its\n            // analysis, so some of these candidates may no longer be valid.\n            // We keep track of when the variable dependency graph changed\n            // so that we can back off appropriately.\n            if (!c.defMetadata.depends.isEmpty()) {\n                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n            }\n        }\n    }\n}\n\n## Fixed Function 2\nprivate boolean canInline() {\n    // Cannot inline a parameter.\n    if (getDefCfgNode().isFunction() || numUseWithinUseCfgNode != 1 || NodeUtil.isWithinLoop(use)) {\n        return false;\n    }\n    // If one of our dependencies has been inlined, then our dependency\n    // graph is wrong. Re-computing it would take another CFG computation,\n    // so we just back off for now.\n    for (Var dependency : defMetadata.depends) {\n        if (inlinedNewDependencies.contains(dependency)) {\n            return false;\n        }\n    }\n    getDefinition(getDefCfgNode(), null);\n    getNumUseInUseCfgNode(useCfgNode, null);\n    // Definition was not found.\n    if (def == null) {\n        return false;\n    }\n    // Check that the assignment isn't used as a R-Value.\n    // TODO(user): Certain cases we can still inline.\n    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n        return false;\n    }\n    // The right of the definition has side effect:\n    // Example, for x:\n    // x = readProp(b), modifyProp(b); print(x);\n    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // Similar check as the above but this time, all the sub-expressions\n    // left of the use of the variable.\n    // x = readProp(b); modifyProp(b), print(x);\n    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n        return false;\n    }\n    // TODO(user): Side-effect is OK sometimes. As long as there are no\n    // side-effect function down all paths to the use. Once we have all the\n    // side-effect analysis tool.\n    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n        return false;\n    }\n    // TODO(user): We could inline all the uses if the expression is short.\n    // Finally we have to make sure that there are no more than one use\n    // in the program and in the CFG node. Even when it is semantically\n    // correctly inlining twice increases code size.\n    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n    if (uses.size() != 1) {\n        return false;\n    }\n    // We give up inlining stuff with R-Value that has:\n    // 1) GETPROP, GETELEM,\n    // 2) anything that creates a new object.\n    // 3) a direct reference to a catch expression.\n    // Example:\n    // var x = a.b.c; j.c = 1; print(x);\n    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n    // TODO(user): We could get more accuracy by looking more in-detail\n    // what j is and what x is trying to into to.\n    // TODO(johnlenz): rework catch expression handling when we\n    // have lexical scope support so catch expressions don't\n    // need to be special cased.\n    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            switch(input.getType()) {\n                case Token.GETELEM:\n                case Token.GETPROP:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.REGEXP:\n                case Token.NEW:\n                    return true;\n            }\n            return false;\n        }\n    }, new Predicate<Node>() {\n\n        @Override\n        public boolean apply(Node input) {\n            // Recurse if the node is not a function.\n            return !input.isFunction();\n        }\n    })) {\n        return false;\n    }\n    // We can skip the side effect check along the paths of two nodes if\n    // they are just next to each other.\n    if (NodeUtil.isStatementBlock(getDefCfgNode().getParent()) && getDefCfgNode().getNext() != useCfgNode) {\n        // Similar side effect check as above but this time the side effect is\n        // else where along the path.\n        // x = readProp(b); while(modifyProp(b)) {}; print(x);\n        CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> pathCheck = new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(cfg, cfg.getDirectedGraphNode(getDefCfgNode()), cfg.getDirectedGraphNode(useCfgNode), SIDE_EFFECT_PREDICATE, Predicates.<DiGraphEdge<Node, ControlFlowGraph.Branch>>alwaysTrue(), false);\n        if (pathCheck.somePathsSatisfyPredicate()) {\n            return false;\n        }\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n+++ com/google/javascript/jscomp/FlowSensitiveInlineVariables.javaenterScope\n@@ -1,40 +1,63 @@\n-@Override\n-public void enterScope(NodeTraversal t) {\n-    if (t.inGlobalScope()) {\n-        // Don't even brother. All global variables are likely escaped.\n-        return;\n+private boolean canInline() {\n+    // Cannot inline a parameter.\n+    if (getDefCfgNode().isFunction() || numUseWithinUseCfgNode != 1 || NodeUtil.isWithinLoop(use)) {\n+        return false;\n     }\n-    if (LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t.getScope().getVarCount()) {\n-        return;\n-    }\n-    // Compute the forward reaching definition.\n-    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n-    // Process the body of the function.\n-    Preconditions.checkState(t.getScopeRoot().isFunction());\n-    cfa.process(null, t.getScopeRoot().getLastChild());\n-    cfg = cfa.getCfg();\n-    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n-    reachingDef.analyze();\n-    candidates = Lists.newLinkedList();\n-    // Using the forward reaching definition search to find all the inline\n-    // candidates\n-    new NodeTraversal(compiler, new GatherCandiates()).traverse(t.getScopeRoot().getLastChild());\n-    // Compute the backward reaching use. The CFG can be reused.\n-    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n-    reachingUses.analyze();\n-    for (Candidate c : candidates) {\n-        if (c.canInline()) {\n-            c.inlineVariable();\n-            // If definition c has dependencies, then inlining it may have\n-            // introduced new dependencies for our other inlining candidates.\n-            //\n-            // MustBeReachingVariableDef uses this dependency graph in its\n-            // analysis, so some of these candidates may no longer be valid.\n-            // We keep track of when the variable dependency graph changed\n-            // so that we can back off appropriately.\n-            if (!c.defMetadata.depends.isEmpty()) {\n-                inlinedNewDependencies.add(t.getScope().getVar(c.varName));\n-            }\n+    // If one of our dependencies has been inlined, then our dependency\n+    // graph is wrong. Re-computing it would take another CFG computation,\n+    // so we just back off for now.\n+    for (Var dependency : defMetadata.depends) {\n+        if (inlinedNewDependencies.contains(dependency)) {\n+            return false;\n         }\n     }\n-}\n+    getDefinition(getDefCfgNode(), null);\n+    getNumUseInUseCfgNode(useCfgNode, null);\n+    // Definition was not found.\n+    if (def == null) {\n+        return false;\n+    }\n+    // Check that the assignment isn't used as a R-Value.\n+    // TODO(user): Certain cases we can still inline.\n+    if (def.isAssign() && !NodeUtil.isExprAssign(def.getParent())) {\n+        return false;\n+    }\n+    // The right of the definition has side effect:\n+    // Example, for x:\n+    // x = readProp(b), modifyProp(b); print(x);\n+    if (checkRightOf(def, getDefCfgNode(), SIDE_EFFECT_PREDICATE)) {\n+        return false;\n+    }\n+    // Similar check as the above but this time, all the sub-expressions\n+    // left of the use of the variable.\n+    // x = readProp(b); modifyProp(b), print(x);\n+    if (checkLeftOf(use, useCfgNode, SIDE_EFFECT_PREDICATE)) {\n+        return false;\n+    }\n+    // TODO(user): Side-effect is OK sometimes. As long as there are no\n+    // side-effect function down all paths to the use. Once we have all the\n+    // side-effect analysis tool.\n+    if (NodeUtil.mayHaveSideEffects(def.getLastChild(), compiler)) {\n+        return false;\n+    }\n+    // TODO(user): We could inline all the uses if the expression is short.\n+    // Finally we have to make sure that there are no more than one use\n+    // in the program and in the CFG node. Even when it is semantically\n+    // correctly inlining twice increases code size.\n+    Collection<Node> uses = reachingUses.getUses(varName, getDefCfgNode());\n+    if (uses.size() != 1) {\n+        return false;\n+    }\n+    // We give up inlining stuff with R-Value that has:\n+    // 1) GETPROP, GETELEM,\n+    // 2) anything that creates a new object.\n+    // 3) a direct reference to a catch expression.\n+    // Example:\n+    // var x = a.b.c; j.c = 1; print(x);\n+    // Inlining print(a.b.c) is not safe consider j and be alias to a.b.\n+    // TODO(user): We could get more accuracy by looking more in-detail\n+    // what j is and what x is trying to into to.\n+    // TODO(johnlenz): rework catch expression handling when we\n+    // have lexical scope support so catch expressions don't\n+    // need to be special cased.\n+    if (NodeUtil.has(def.getLastChild(), new Predicate<Node>() {\n", "finish_reason": "stop", "valid": false, "num": 1}]