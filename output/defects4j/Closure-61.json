[{"output": "static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n    if (callNode.getType() != Token.CALL) {\n        throw new IllegalStateException(\"Expected CALL node, got \" + Token.name(callNode.getType()));\n    }\n    if (callNode.isNoSideEffectsCall()) {\n        return false;\n    }\n    Node nameNode = callNode.getFirstChild();\n    // Built-in functions with no side effects.\n    if (nameNode.getType() == Token.NAME) {\n        String name = nameNode.getString();\n        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n            return false;\n        }\n    } else if (nameNode.getType() == Token.GETPROP) {\n        if (callNode.hasOneChild() && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n            return false;\n        }\n        if (callNode.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) {\n            return false;\n        }\n        // Functions in the \"Math\" namespace have no side effects.\n        if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n            if (nameNode.getFirstChild().getType() == Token.GETPROP && nameNode.getFirstChild().matchesQualifiedName(\"Math.random\")) {\n                return false;\n            } else if (nameNode.getFirstChild().getType() == Token.REGEXP && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                return false;\n            } else if (nameNode.getFirstChild().getType() == Token.STRING && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                Node param = nameNode.getNext();\n                if (param != null && (param.getType() == Token.STRING || param.getType() == Token.REGEXP))\n                    return false;\n            }\n        }\n    }\n    return true;\n}", "diff": "", "finish_reason": "stop", "valid": false, "num": 5}]