[{"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), null, 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EMPTY, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -1,25 +1,56 @@\n-private void traverseFunction(Node n, Node parent) {\n-    Preconditions.checkState(n.getChildCount() == 3);\n-    Preconditions.checkState(n.isFunction());\n-    final Node fnName = n.getFirstChild();\n-    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n-    if (!isFunctionExpression) {\n-        // Functions declarations are in the scope containing the declaration.\n-        traverseBranch(fnName, n);\n+@Override\n+Node processFunctionNode(FunctionNode functionNode) {\n+    Name name = functionNode.getFunctionName();\n+    Boolean isUnnamedFunction = false;\n+    if (name == null) {\n+        int functionType = functionNode.getFunctionType();\n+        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n+            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), null, 0);\n+            // Return the bare minimum to put the AST in a valid state.\n+            return newNode(Token.EMPTY, Node.newNumber(0));\n+        }\n+        name = new Name();\n+        name.setIdentifier(\"\");\n+        isUnnamedFunction = true;\n     }\n-    curNode = n;\n-    pushScope(n);\n-    if (isFunctionExpression) {\n-        // Function expression names are only accessible within the function\n-        // scope.\n-        traverseBranch(fnName, n);\n+    Node node = newNode(Token.FUNCTION);\n+    Node newName = transform(name);\n+    if (isUnnamedFunction) {\n+        // Old Rhino tagged the empty name node with the line number of the\n+        // declaration.\n+        newName.setLineno(functionNode.getLineno());\n+        // TODO(bowdidge) Mark line number of paren correctly.\n+        // Same problem as below - the left paren might not be on the\n+        // same line as the function keyword.\n+        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n+        newName.setCharno(position2charno(lpColumn));\n+        maybeSetLengthFrom(newName, name);\n     }\n-    final Node args = fnName.getNext();\n-    final Node body = args.getNext();\n-    // Args\n-    traverseBranch(args, n);\n-    // Body\n-    Preconditions.checkState(body.getNext() == null && body.isBlock());\n-    traverseBranch(body, n);\n-    popScope();\n+    node.addChildToBack(newName);\n+    Node lp = newNode(Token.PARAM_LIST);\n+    // The left paren's complicated because it's not represented by an\n+    // AstNode, so there's nothing that has the actual line number that it\n+    // appeared on.  We know the paren has to appear on the same line as the\n+    // function name (or else a semicolon will be inserted.)  If there's no\n+    // function name, assume the paren was on the same line as the function.\n+    // TODO(bowdidge): Mark line number of paren correctly.\n+    Name fnName = functionNode.getFunctionName();\n+    if (fnName != null) {\n+        lp.setLineno(fnName.getLineno());\n+    } else {\n+        lp.setLineno(functionNode.getLineno());\n+    }\n+    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n+    lp.setCharno(position2charno(lparenCharno));\n+    for (AstNode param : functionNode.getParams()) {\n+        lp.addChildToBack(transform(param));\n+    }\n+    node.addChildToBack(lp);\n+    Node bodyNode = transform(functionNode.getBody());\n+    // When in ideMode Rhino tries to parse some constructs the compiler\n+    // doesn't support, repair it here. see Rhino's\n+    // Parser#parseFunctionBodyExpr.\n+    parseDirectives(bodyNode);\n+    node.addChildToBack(bodyNode);\n+    return node;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() >= 3 && n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    if (args != null) {\n        traverseBranch(args, n);\n    }\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EMPTY);\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -1,25 +1,56 @@\n-private void traverseFunction(Node n, Node parent) {\n-    Preconditions.checkState(n.getChildCount() == 3);\n-    Preconditions.checkState(n.isFunction());\n-    final Node fnName = n.getFirstChild();\n-    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n-    if (!isFunctionExpression) {\n-        // Functions declarations are in the scope containing the declaration.\n-        traverseBranch(fnName, n);\n+@Override\n+Node processFunctionNode(FunctionNode functionNode) {\n+    Name name = functionNode.getFunctionName();\n+    Boolean isUnnamedFunction = false;\n+    if (name == null) {\n+        int functionType = functionNode.getFunctionType();\n+        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n+            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n+            // Return the bare minimum to put the AST in a valid state.\n+            return newNode(Token.EMPTY);\n+        }\n+        name = new Name();\n+        name.setIdentifier(\"\");\n+        isUnnamedFunction = true;\n     }\n-    curNode = n;\n-    pushScope(n);\n-    if (isFunctionExpression) {\n-        // Function expression names are only accessible within the function\n-        // scope.\n-        traverseBranch(fnName, n);\n+    Node node = newNode(Token.FUNCTION);\n+    Node newName = transform(name);\n+    if (isUnnamedFunction) {\n+        // Old Rhino tagged the empty name node with the line number of the\n+        // declaration.\n+        newName.setLineno(functionNode.getLineno());\n+        // TODO(bowdidge) Mark line number of paren correctly.\n+        // Same problem as below - the left paren might not be on the\n+        // same line as the function keyword.\n+        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n+        newName.setCharno(position2charno(lpColumn));\n+        maybeSetLengthFrom(newName, name);\n     }\n-    final Node args = fnName.getNext();\n-    final Node body = args.getNext();\n-    // Args\n-    traverseBranch(args, n);\n-    // Body\n-    Preconditions.checkState(body.getNext() == null && body.isBlock());\n-    traverseBranch(body, n);\n-    popScope();\n+    node.addChildToBack(newName);\n+    Node lp = newNode(Token.PARAM_LIST);\n+    // The left paren's complicated because it's not represented by an\n+    // AstNode, so there's nothing that has the actual line number that it\n+    // appeared on.  We know the paren has to appear on the same line as the\n+    // function name (or else a semicolon will be inserted.)  If there's no\n+    // function name, assume the paren was on the same line as the function.\n+    // TODO(bowdidge): Mark line number of paren correctly.\n+    Name fnName = functionNode.getFunctionName();\n+    if (fnName != null) {\n+        lp.setLineno(fnName.getLineno());\n+    } else {\n+        lp.setLineno(functionNode.getLineno());\n+    }\n+    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n+    lp.setCharno(position2charno(lparenCharno));\n+    for (AstNode param : functionNode.getParams()) {\n+        lp.addChildToBack(transform(param));\n+    }\n+    node.addChildToBack(lp);\n+    Node bodyNode = transform(functionNode.getBody());\n+    // When in ideMode Rhino tries to parse some constructs the compiler\n+    // doesn't support, repair it here. see Rhino's\n+    // Parser#parseFunctionBodyExpr.\n+    parseDirectives(bodyNode);\n+    node.addChildToBack(bodyNode);\n+    return node;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null && NodeUtil.isFunctionExpression(n));\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    exitScope(n);\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newExpr(newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newFunctionNode(newName(name));\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    Node lp = newParamList();\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -1,25 +1,54 @@\n-private void traverseFunction(Node n, Node parent) {\n-    Preconditions.checkState(n.getChildCount() == 3);\n-    Preconditions.checkState(n.isFunction());\n-    final Node fnName = n.getFirstChild();\n-    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n-    if (!isFunctionExpression) {\n-        // Functions declarations are in the scope containing the declaration.\n-        traverseBranch(fnName, n);\n+@Override\n+Node processFunctionNode(FunctionNode functionNode) {\n+    Name name = functionNode.getFunctionName();\n+    Boolean isUnnamedFunction = false;\n+    if (name == null) {\n+        int functionType = functionNode.getFunctionType();\n+        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n+            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n+            // Return the bare minimum to put the AST in a valid state.\n+            return newExpr(newNumber(0));\n+        }\n+        name = new Name();\n+        name.setIdentifier(\"\");\n+        isUnnamedFunction = true;\n     }\n-    curNode = n;\n-    pushScope(n);\n-    if (isFunctionExpression) {\n-        // Function expression names are only accessible within the function\n-        // scope.\n-        traverseBranch(fnName, n);\n+    Node node = newFunctionNode(newName(name));\n+    if (isUnnamedFunction) {\n+        // Old Rhino tagged the empty name node with the line number of the\n+        // declaration.\n+        newName.setLineno(functionNode.getLineno());\n+        // TODO(bowdidge) Mark line number of paren correctly.\n+        // Same problem as below - the left paren might not be on the\n+        // same line as the function keyword.\n+        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n+        newName.setCharno(position2charno(lpColumn));\n+        maybeSetLengthFrom(newName, name);\n     }\n-    final Node args = fnName.getNext();\n-    final Node body = args.getNext();\n-    // Args\n-    traverseBranch(args, n);\n-    // Body\n-    Preconditions.checkState(body.getNext() == null && body.isBlock());\n-    traverseBranch(body, n);\n-    popScope();\n+    Node lp = newParamList();\n+    // The left paren's complicated because it's not represented by an\n+    // AstNode, so there's nothing that has the actual line number that it\n+    // appeared on.  We know the paren has to appear on the same line as the\n+    // function name (or else a semicolon will be inserted.)  If there's no\n+    // function name, assume the paren was on the same line as the function.\n+    // TODO(bowdidge): Mark line number of paren correctly.\n+    Name fnName = functionNode.getFunctionName();\n+    if (fnName != null) {\n+        lp.setLineno(fnName.getLineno());\n+    } else {\n+        lp.setLineno(functionNode.getLineno());\n+    }\n+    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n+    lp.setCharno(position2charno(lparenCharno));\n+    for (AstNode param : functionNode.getParams()) {\n+        lp.addChildToBack(transform(param));\n+    }\n+    node.addChildToBack(lp);\n+    Node bodyNode = transform(functionNode.getBody());\n+    // When in ideMode Rhino tries to parse some constructs the compiler\n+    // doesn't support, repair it here. see Rhino's\n+    // Parser#parseFunctionBodyExpr.\n+    parseDirectives(bodyNode);\n+    node.addChildToBack(bodyNode);\n+    return node;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        // Fixed below - Pass 'fnName' instead of 'n' to the 'traverseBranch' method\n        traverseBranch(fnName, fnName);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        // Fixed below - Pass 'fnName' instead of 'n' to the 'traverseBranch' method\n        traverseBranch(fnName, fnName);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -1,25 +1,56 @@\n-private void traverseFunction(Node n, Node parent) {\n-    Preconditions.checkState(n.getChildCount() == 3);\n-    Preconditions.checkState(n.isFunction());\n-    final Node fnName = n.getFirstChild();\n-    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n-    if (!isFunctionExpression) {\n-        // Functions declarations are in the scope containing the declaration.\n-        traverseBranch(fnName, n);\n+@Override\n+Node processFunctionNode(FunctionNode functionNode) {\n+    Name name = functionNode.getFunctionName();\n+    Boolean isUnnamedFunction = false;\n+    if (name == null) {\n+        int functionType = functionNode.getFunctionType();\n+        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n+            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n+            // Return the bare minimum to put the AST in a valid state.\n+            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n+        }\n+        name = new Name();\n+        name.setIdentifier(\"\");\n+        isUnnamedFunction = true;\n     }\n-    curNode = n;\n-    pushScope(n);\n-    if (isFunctionExpression) {\n-        // Function expression names are only accessible within the function\n-        // scope.\n-        traverseBranch(fnName, n);\n+    Node node = newNode(Token.FUNCTION);\n+    Node newName = transform(name);\n+    if (isUnnamedFunction) {\n+        // Old Rhino tagged the empty name node with the line number of the\n+        // declaration.\n+        newName.setLineno(functionNode.getLineno());\n+        // TODO(bowdidge) Mark line number of paren correctly.\n+        // Same problem as below - the left paren might not be on the\n+        // same line as the function keyword.\n+        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n+        newName.setCharno(position2charno(lpColumn));\n+        maybeSetLengthFrom(newName, name);\n     }\n-    final Node args = fnName.getNext();\n-    final Node body = args.getNext();\n-    // Args\n-    traverseBranch(args, n);\n-    // Body\n-    Preconditions.checkState(body.getNext() == null && body.isBlock());\n-    traverseBranch(body, n);\n-    popScope();\n+    node.addChildToBack(newName);\n+    Node lp = newNode(Token.PARAM_LIST);\n+    // The left paren's complicated because it's not represented by an\n+    // AstNode, so there's nothing that has the actual line number that it\n+    // appeared on.  We know the paren has to appear on the same line as the\n+    // function name (or else a semicolon will be inserted.)  If there's no\n+    // function name, assume the paren was on the same line as the function.\n+    // TODO(bowdidge): Mark line number of paren correctly.\n+    Name fnName = functionNode.getFunctionName();\n+    if (fnName != null) {\n+        lp.setLineno(fnName.getLineno());\n+    } else {\n+        lp.setLineno(functionNode.getLineno());\n+    }\n+    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n+    lp.setCharno(position2charno(lparenCharno));\n+    for (AstNode param : functionNode.getParams()) {\n+        lp.addChildToBack(transform(param));\n+    }\n+    node.addChildToBack(lp);\n+    Node bodyNode = transform(functionNode.getBody());\n+    // When in ideMode Rhino tries to parse some constructs the compiler\n+    // doesn't support, repair it here. see Rhino's\n+    // Parser#parseFunctionBodyExpr.\n+    parseDirectives(bodyNode);\n+    node.addChildToBack(bodyNode);\n+    return node;\n }\n", "finish_reason": "stop", "valid": false, "num": 2}]