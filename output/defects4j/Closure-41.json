[{"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            boolean paramHandled = false;\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                paramHandled = true;\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            }\n            if (!paramHandled) {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType != null ? parameterType : typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, isOptionalParam, isVarArgs);\n        if (oldParameterType != null) {\n            oldParameterType = oldParameterType.getNext();\n        }\n    }\n    // Copy over any old parameters that aren't in the param list.\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.javainferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.javainferFromOverriddenFunction\n@@ -1,39 +1,55 @@\n-FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n-    if (oldType == null) {\n-        return this;\n+FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n+    if (argsParent == null) {\n+        if (info == null) {\n+            return this;\n+        } else {\n+            return inferParameterTypes(info);\n+        }\n     }\n-    returnType = oldType.getReturnType();\n-    returnTypeInferred = oldType.isReturnTypeInferred();\n-    if (paramsParent == null) {\n-        // Not a function literal.\n-        parametersNode = oldType.getParametersNode();\n-        if (parametersNode == null) {\n-            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n+    // arguments\n+    Node oldParameterType = null;\n+    if (parametersNode != null) {\n+        oldParameterType = parametersNode.getFirstChild();\n+    }\n+    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n+    boolean warnedAboutArgList = false;\n+    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n+    boolean foundTemplateType = false;\n+    boolean isVarArgs = false;\n+    for (Node arg : argsParent.children()) {\n+        String argumentName = arg.getString();\n+        allJsDocParams.remove(argumentName);\n+        // type from JSDocInfo\n+        JSType parameterType = null;\n+        boolean isOptionalParam = isOptionalParameter(arg, info);\n+        isVarArgs = isVarArgsParameter(arg, info);\n+        if (info != null && info.hasParameterType(argumentName)) {\n+            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n+        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n+            parameterType = oldParameterType.getJSType();\n+            isOptionalParam = oldParameterType.isOptionalArg();\n+            isVarArgs = oldParameterType.isVarArgs();\n+        } else {\n+            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n         }\n-    } else {\n-        // We're overriding with a function literal. Apply type information\n-        // to each parameter of the literal.\n-        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n-        Iterator<Node> oldParams = oldType.getParameters().iterator();\n-        boolean warnedAboutArgList = false;\n-        boolean oldParamsListHitOptArgs = false;\n-        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n-            if (oldParams.hasNext()) {\n-                Node oldParam = oldParams.next();\n-                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n-                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n-                // The subclass method might write its var_args as individual\n-                // arguments.\n-                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n-                    newParam.setVarArgs(false);\n-                    newParam.setOptionalArg(true);\n-                }\n-            } else {\n-                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n+            if (foundTemplateType) {\n+                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n             }\n+            foundTemplateType = true;\n         }\n-        // Clone any remaining params that aren't in the function literal.\n-        parametersNode = paramBuilder.build();\n+        warnedAboutArgList |= addParameter(builder, parameterType != null ? parameterType : typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, isOptionalParam, isVarArgs);\n+        if (oldParameterType != null) {\n+            oldParameterType = oldParameterType.getNext();\n+        }\n     }\n+    // Copy over any old parameters that aren't in the param list.\n+    if (templateTypeName != null && !foundTemplateType) {\n+        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n+    }\n+    for (String inexistentName : allJsDocParams) {\n+        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n+    }\n+    parametersNode = builder.build();\n     return this;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                // Add the new parameter to the builder.\n                paramBuilder.addParameter(newParam);\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            paramBuilder.addParameter(newParam);\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n        if (oldParameterType != null) {\n            oldParameterType = oldParameterType.getNext();\n        }\n    }\n    // Copy over any old parameters that aren't in the param list.\n    while (oldParameterType != null) {\n        Node newParam = new Node(Token.EMPTY);\n        newParam.setJSType(oldParameterType.getJSType());\n        newParam.setOptionalArg(oldParameterType.isOptionalArg());\n        newParam.setVarArgs(oldParameterType.isVarArgs());\n        builder.addParameter(newParam);\n        oldParameterType = oldParameterType.getNext();\n    }\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.javainferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.javainferFromOverriddenFunction\n@@ -1,39 +1,63 @@\n-FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n-    if (oldType == null) {\n-        return this;\n+FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n+    if (argsParent == null) {\n+        if (info == null) {\n+            return this;\n+        } else {\n+            return inferParameterTypes(info);\n+        }\n     }\n-    returnType = oldType.getReturnType();\n-    returnTypeInferred = oldType.isReturnTypeInferred();\n-    if (paramsParent == null) {\n-        // Not a function literal.\n-        parametersNode = oldType.getParametersNode();\n-        if (parametersNode == null) {\n-            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n+    // arguments\n+    Node oldParameterType = null;\n+    if (parametersNode != null) {\n+        oldParameterType = parametersNode.getFirstChild();\n+    }\n+    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n+    boolean warnedAboutArgList = false;\n+    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n+    boolean foundTemplateType = false;\n+    boolean isVarArgs = false;\n+    for (Node arg : argsParent.children()) {\n+        String argumentName = arg.getString();\n+        allJsDocParams.remove(argumentName);\n+        // type from JSDocInfo\n+        JSType parameterType = null;\n+        boolean isOptionalParam = isOptionalParameter(arg, info);\n+        isVarArgs = isVarArgsParameter(arg, info);\n+        if (info != null && info.hasParameterType(argumentName)) {\n+            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n+        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n+            parameterType = oldParameterType.getJSType();\n+            isOptionalParam = oldParameterType.isOptionalArg();\n+            isVarArgs = oldParameterType.isVarArgs();\n+        } else {\n+            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n         }\n-    } else {\n-        // We're overriding with a function literal. Apply type information\n-        // to each parameter of the literal.\n-        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n-        Iterator<Node> oldParams = oldType.getParameters().iterator();\n-        boolean warnedAboutArgList = false;\n-        boolean oldParamsListHitOptArgs = false;\n-        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n-            if (oldParams.hasNext()) {\n-                Node oldParam = oldParams.next();\n-                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n-                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n-                // The subclass method might write its var_args as individual\n-                // arguments.\n-                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n-                    newParam.setVarArgs(false);\n-                    newParam.setOptionalArg(true);\n-                }\n-            } else {\n-                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n+            if (foundTemplateType) {\n+                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n             }\n+            foundTemplateType = true;\n         }\n-        // Clone any remaining params that aren't in the function literal.\n-        parametersNode = paramBuilder.build();\n+        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n+        if (oldParameterType != null) {\n+            oldParameterType = oldParameterType.getNext();\n+        }\n     }\n+    // Copy over any old parameters that aren't in the param list.\n+    while (oldParameterType != null) {\n+        Node newParam = new Node(Token.EMPTY);\n+        newParam.setJSType(oldParameterType.getJSType());\n+        newParam.setOptionalArg(oldParameterType.isOptionalArg());\n+        newParam.setVarArgs(oldParameterType.isVarArgs());\n+        builder.addParameter(newParam);\n+        oldParameterType = oldParameterType.getNext();\n+    }\n+    if (templateTypeName != null && !foundTemplateType) {\n+        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n+    }\n+    for (String inexistentName : allJsDocParams) {\n+        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n+    }\n+    parametersNode = builder.build();\n     return this;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                paramBuilder.add(newParam);\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        Node newParam = builder.newParameter(argumentName);\n        newParam.setOptionalArg(isOptionalParam);\n        newParam.setVarArgs(isVarArgs);\n        newParam.setType(parameterType);\n        builder.add(newParam);\n        if (oldParameterType != null) {\n            oldParameterType = oldParameterType.getNext();\n        }\n    }\n    // Copy over any old parameters that aren't in the param list.\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.javainferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.javainferFromOverriddenFunction\n@@ -1,39 +1,59 @@\n-FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n-    if (oldType == null) {\n-        return this;\n+FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n+    if (argsParent == null) {\n+        if (info == null) {\n+            return this;\n+        } else {\n+            return inferParameterTypes(info);\n+        }\n     }\n-    returnType = oldType.getReturnType();\n-    returnTypeInferred = oldType.isReturnTypeInferred();\n-    if (paramsParent == null) {\n-        // Not a function literal.\n-        parametersNode = oldType.getParametersNode();\n-        if (parametersNode == null) {\n-            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n+    // arguments\n+    Node oldParameterType = null;\n+    if (parametersNode != null) {\n+        oldParameterType = parametersNode.getFirstChild();\n+    }\n+    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n+    boolean warnedAboutArgList = false;\n+    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n+    boolean foundTemplateType = false;\n+    boolean isVarArgs = false;\n+    for (Node arg : argsParent.children()) {\n+        String argumentName = arg.getString();\n+        allJsDocParams.remove(argumentName);\n+        // type from JSDocInfo\n+        JSType parameterType = null;\n+        boolean isOptionalParam = isOptionalParameter(arg, info);\n+        isVarArgs = isVarArgsParameter(arg, info);\n+        if (info != null && info.hasParameterType(argumentName)) {\n+            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n+        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n+            parameterType = oldParameterType.getJSType();\n+            isOptionalParam = oldParameterType.isOptionalArg();\n+            isVarArgs = oldParameterType.isVarArgs();\n+        } else {\n+            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n         }\n-    } else {\n-        // We're overriding with a function literal. Apply type information\n-        // to each parameter of the literal.\n-        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n-        Iterator<Node> oldParams = oldType.getParameters().iterator();\n-        boolean warnedAboutArgList = false;\n-        boolean oldParamsListHitOptArgs = false;\n-        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n-            if (oldParams.hasNext()) {\n-                Node oldParam = oldParams.next();\n-                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n-                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n-                // The subclass method might write its var_args as individual\n-                // arguments.\n-                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n-                    newParam.setVarArgs(false);\n-                    newParam.setOptionalArg(true);\n-                }\n-            } else {\n-                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n+            if (foundTemplateType) {\n+                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n             }\n+            foundTemplateType = true;\n         }\n-        // Clone any remaining params that aren't in the function literal.\n-        parametersNode = paramBuilder.build();\n+        Node newParam = builder.newParameter(argumentName);\n+        newParam.setOptionalArg(isOptionalParam);\n+        newParam.setVarArgs(isVarArgs);\n+        newParam.setType(parameterType);\n+        builder.add(newParam);\n+        if (oldParameterType != null) {\n+            oldParameterType = oldParameterType.getNext();\n+        }\n     }\n+    // Copy over any old parameters that aren't in the param list.\n+    if (templateTypeName != null && !foundTemplateType) {\n+        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n+    }\n+    for (String inexistentName : allJsDocParams) {\n+        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n+    }\n+    parametersNode = builder.build();\n     return this;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n                parametersNode.addChildToBack(newParam);\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        while (oldParams.hasNext()) {\n            Node oldParam = oldParams.next();\n            Node newParam = paramBuilder.newParameterFromNode(oldParam);\n            oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n            newParam.setOptionalArg(true);\n            parametersNode.addChildToBack(newParam);\n        }\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n        if (oldParameterType != null) {\n            oldParameterType = oldParameterType.getNext();\n        }\n    }\n    // Copy over any old parameters that aren't in the param list.\n    while (oldParameterType != null) {\n        Node newParam = builder.newParameterFromNode(oldParameterType);\n        if (!newParam.isVarArgs()) {\n            newParam.setOptionalArg(true);\n        }\n        parametersNode.addChildToBack(newParam);\n        oldParameterType = oldParameterType.getNext();\n    }\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.javainferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.javainferFromOverriddenFunction\n@@ -1,39 +1,63 @@\n-FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n-    if (oldType == null) {\n-        return this;\n+FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n+    if (argsParent == null) {\n+        if (info == null) {\n+            return this;\n+        } else {\n+            return inferParameterTypes(info);\n+        }\n     }\n-    returnType = oldType.getReturnType();\n-    returnTypeInferred = oldType.isReturnTypeInferred();\n-    if (paramsParent == null) {\n-        // Not a function literal.\n-        parametersNode = oldType.getParametersNode();\n-        if (parametersNode == null) {\n-            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n+    // arguments\n+    Node oldParameterType = null;\n+    if (parametersNode != null) {\n+        oldParameterType = parametersNode.getFirstChild();\n+    }\n+    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n+    boolean warnedAboutArgList = false;\n+    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n+    boolean foundTemplateType = false;\n+    boolean isVarArgs = false;\n+    for (Node arg : argsParent.children()) {\n+        String argumentName = arg.getString();\n+        allJsDocParams.remove(argumentName);\n+        // type from JSDocInfo\n+        JSType parameterType = null;\n+        boolean isOptionalParam = isOptionalParameter(arg, info);\n+        isVarArgs = isVarArgsParameter(arg, info);\n+        if (info != null && info.hasParameterType(argumentName)) {\n+            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n+        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n+            parameterType = oldParameterType.getJSType();\n+            isOptionalParam = oldParameterType.isOptionalArg();\n+            isVarArgs = oldParameterType.isVarArgs();\n+        } else {\n+            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n         }\n-    } else {\n-        // We're overriding with a function literal. Apply type information\n-        // to each parameter of the literal.\n-        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n-        Iterator<Node> oldParams = oldType.getParameters().iterator();\n-        boolean warnedAboutArgList = false;\n-        boolean oldParamsListHitOptArgs = false;\n-        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n-            if (oldParams.hasNext()) {\n-                Node oldParam = oldParams.next();\n-                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n-                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n-                // The subclass method might write its var_args as individual\n-                // arguments.\n-                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n-                    newParam.setVarArgs(false);\n-                    newParam.setOptionalArg(true);\n-                }\n-            } else {\n-                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n+            if (foundTemplateType) {\n+                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n             }\n+            foundTemplateType = true;\n         }\n-        // Clone any remaining params that aren't in the function literal.\n-        parametersNode = paramBuilder.build();\n+        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n+        if (oldParameterType != null) {\n+            oldParameterType = oldParameterType.getNext();\n+        }\n     }\n+    // Copy over any old parameters that aren't in the param list.\n+    while (oldParameterType != null) {\n+        Node newParam = builder.newParameterFromNode(oldParameterType);\n+        if (!newParam.isVarArgs()) {\n+            newParam.setOptionalArg(true);\n+        }\n+        parametersNode.addChildToBack(newParam);\n+        oldParameterType = oldParameterType.getNext();\n+    }\n+    if (templateTypeName != null && !foundTemplateType) {\n+        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n+    }\n+    for (String inexistentName : allJsDocParams) {\n+        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n+    }\n+    parametersNode = builder.build();\n     return this;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nFunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n        return this;\n    }\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n        // Not a function literal.\n        parametersNode = oldType.getParametersNode();\n        if (parametersNode == null) {\n            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n        }\n    } else {\n        // We're overriding with a function literal. Apply type information\n        // to each parameter of the literal.\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n        Iterator<Node> oldParams = oldType.getParameters().iterator();\n        boolean warnedAboutArgList = false;\n        boolean oldParamsListHitOptArgs = false;\n        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n            if (oldParams.hasNext()) {\n                Node oldParam = oldParams.next();\n                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n                // The subclass method might write its var_args as individual\n                // arguments.\n                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n                    newParam.setVarArgs(false);\n                    newParam.setOptionalArg(true);\n                }\n            } else {\n                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs || currentParam.isVarArgs() || currentParam.isOptionalArg(), currentParam.isVarArgs());\n            }\n        }\n        // Clone any remaining params that aren't in the function literal.\n        parametersNode = paramBuilder.build();\n    }\n    return this;\n}\n\n## Fixed Function 2\nFunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n        if (info == null) {\n            return this;\n        } else {\n            return inferParameterTypes(info);\n        }\n    }\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n        oldParameterType = parametersNode.getFirstChild();\n    }\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    boolean isVarArgs = false;\n    for (Node arg : argsParent.children()) {\n        String argumentName = arg.getString();\n        allJsDocParams.remove(argumentName);\n        // type from JSDocInfo\n        JSType parameterType = null;\n        boolean isOptionalParam = isOptionalParameter(arg, info);\n        isVarArgs = isVarArgsParameter(arg, info);\n        if (info != null && info.hasParameterType(argumentName)) {\n            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n            parameterType = oldParameterType.getJSType();\n            isOptionalParam = oldParameterType.isOptionalArg() || arg.isOptionalArg();\n            isVarArgs = oldParameterType.isVarArgs() || arg.isVarArgs();\n        } else {\n            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n            isOptionalParam = arg.isOptionalArg();\n            isVarArgs = arg.isVarArgs();\n        }\n        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n            if (foundTemplateType) {\n                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n            }\n            foundTemplateType = true;\n        }\n        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n        if (oldParameterType != null) {\n            oldParameterType = oldParameterType.getNext();\n        }\n    }\n    // Copy over any old parameters that aren't in the param list.\n    if (templateTypeName != null && !foundTemplateType) {\n        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    for (String inexistentName : allJsDocParams) {\n        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n    parametersNode = builder.build();\n    return this;\n}", "diff": "--- com/google/javascript/jscomp/FunctionTypeBuilder.javainferFromOverriddenFunction\n+++ com/google/javascript/jscomp/FunctionTypeBuilder.javainferFromOverriddenFunction\n@@ -1,39 +1,57 @@\n-FunctionTypeBuilder inferFromOverriddenFunction(@Nullable FunctionType oldType, @Nullable Node paramsParent) {\n-    if (oldType == null) {\n-        return this;\n+FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent, @Nullable JSDocInfo info) {\n+    if (argsParent == null) {\n+        if (info == null) {\n+            return this;\n+        } else {\n+            return inferParameterTypes(info);\n+        }\n     }\n-    returnType = oldType.getReturnType();\n-    returnTypeInferred = oldType.isReturnTypeInferred();\n-    if (paramsParent == null) {\n-        // Not a function literal.\n-        parametersNode = oldType.getParametersNode();\n-        if (parametersNode == null) {\n-            parametersNode = new FunctionParamBuilder(typeRegistry).build();\n+    // arguments\n+    Node oldParameterType = null;\n+    if (parametersNode != null) {\n+        oldParameterType = parametersNode.getFirstChild();\n+    }\n+    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n+    boolean warnedAboutArgList = false;\n+    Set<String> allJsDocParams = (info == null) ? Sets.<String>newHashSet() : Sets.newHashSet(info.getParameterNames());\n+    boolean foundTemplateType = false;\n+    boolean isVarArgs = false;\n+    for (Node arg : argsParent.children()) {\n+        String argumentName = arg.getString();\n+        allJsDocParams.remove(argumentName);\n+        // type from JSDocInfo\n+        JSType parameterType = null;\n+        boolean isOptionalParam = isOptionalParameter(arg, info);\n+        isVarArgs = isVarArgsParameter(arg, info);\n+        if (info != null && info.hasParameterType(argumentName)) {\n+            parameterType = info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n+        } else if (oldParameterType != null && oldParameterType.getJSType() != null) {\n+            parameterType = oldParameterType.getJSType();\n+            isOptionalParam = oldParameterType.isOptionalArg() || arg.isOptionalArg();\n+            isVarArgs = oldParameterType.isVarArgs() || arg.isVarArgs();\n+        } else {\n+            parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n+            isOptionalParam = arg.isOptionalArg();\n+            isVarArgs = arg.isVarArgs();\n         }\n-    } else {\n-        // We're overriding with a function literal. Apply type information\n-        // to each parameter of the literal.\n-        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(typeRegistry);\n-        Iterator<Node> oldParams = oldType.getParameters().iterator();\n-        boolean warnedAboutArgList = false;\n-        boolean oldParamsListHitOptArgs = false;\n-        for (Node currentParam = paramsParent.getFirstChild(); currentParam != null; currentParam = currentParam.getNext()) {\n-            if (oldParams.hasNext()) {\n-                Node oldParam = oldParams.next();\n-                Node newParam = paramBuilder.newParameterFromNode(oldParam);\n-                oldParamsListHitOptArgs = oldParamsListHitOptArgs || oldParam.isVarArgs() || oldParam.isOptionalArg();\n-                // The subclass method might write its var_args as individual\n-                // arguments.\n-                if (currentParam.getNext() != null && newParam.isVarArgs()) {\n-                    newParam.setVarArgs(false);\n-                    newParam.setOptionalArg(true);\n-                }\n-            } else {\n-                warnedAboutArgList |= addParameter(paramBuilder, typeRegistry.getNativeType(UNKNOWN_TYPE), warnedAboutArgList, codingConvention.isOptionalParameter(currentParam) || oldParamsListHitOptArgs, codingConvention.isVarArgsParameter(currentParam));\n+        if (templateTypeName != null && parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n+            if (foundTemplateType) {\n+                reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n             }\n+            foundTemplateType = true;\n         }\n-        // Clone any remaining params that aren't in the function literal.\n-        parametersNode = paramBuilder.build();\n+        warnedAboutArgList |= addParameter(builder, parameterType, warnedAboutArgList, isOptionalParam, isVarArgs);\n+        if (oldParameterType != null) {\n+            oldParameterType = oldParameterType.getNext();\n+        }\n     }\n+    // Copy over any old parameters that aren't in the param list.\n+    if (templateTypeName != null && !foundTemplateType) {\n+        reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n+    }\n+    for (String inexistentName : allJsDocParams) {\n+        reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n+    }\n+    parametersNode = builder.build();\n     return this;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]