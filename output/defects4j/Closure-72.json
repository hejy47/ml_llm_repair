[{"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new RenamePrivateVariables(idSupplier, \"inline_\", isCallInLoop)));\n    // Make label names unique to this instance.\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            nameNode.setString(newName);\n            compiler.reportCodeChange();\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        Node newChild = node.getFirstChild();\n        parent.replaceChild(node, newChild);\n        if (newChild.getType() == Token.BLOCK) {\n            NodeUtil.tryMergeBlock(newChild);\n        }\n        compiler.reportCodeChange();\n    }\n    // Remove the label from the current stack of labels.\n    namespaceStack.peek().renameMap.remove(name);\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -1,6 +1,6 @@\n private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n     Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n     // Make variable names unique to this instance.\n-    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n+    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new RenamePrivateVariables(idSupplier, \"inline_\", isCallInLoop)));\n     // Make label names unique to this instance.\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -13,8 +13,7 @@\n         }\n     } else {\n         // ... and it is not referenced, just remove it.\n-        Node newChild = node.getLastChild();\n-        node.removeChild(newChild);\n+        Node newChild = node.getFirstChild();\n         parent.replaceChild(node, newChild);\n         if (newChild.getType() == Token.BLOCK) {\n             NodeUtil.tryMergeBlock(newChild);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n    // Make label names unique to this instance.\n    if (fnNode.isFunction()) {\n        Node body = fnNode.getLastChild();\n        LabelNameFinder labelFinder = new LabelNameFinder();\n        NodeTraversal.traverseEs6(compiler, body, labelFinder);\n        Map<String, String> labelMappings = getNewNameMappings(labelFinder.getLabelNames(), idSupplier);\n        NodeTraversal.traverseEs6(compiler, body, new RenameLabels(labelMappings));\n    }\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            nameNode.setString(newName);\n            compiler.reportCodeChange();\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        Node newChild = node.getLastChild().detachFromParent();\n        parent.replaceChild(node, newChild);\n        if (newChild.getType() == Token.BLOCK) {\n            NodeUtil.tryMergeBlock(newChild);\n        }\n        compiler.reportCodeChange();\n    }\n    // Remove the label from the current stack of labels.\n    if (!li.referenced) {\n        namespaceStack.peek().renameMap.remove(name);\n    }\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -3,4 +3,11 @@\n     // Make variable names unique to this instance.\n     NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n     // Make label names unique to this instance.\n+    if (fnNode.isFunction()) {\n+        Node body = fnNode.getLastChild();\n+        LabelNameFinder labelFinder = new LabelNameFinder();\n+        NodeTraversal.traverseEs6(compiler, body, labelFinder);\n+        Map<String, String> labelMappings = getNewNameMappings(labelFinder.getLabelNames(), idSupplier);\n+        NodeTraversal.traverseEs6(compiler, body, new RenameLabels(labelMappings));\n+    }\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -13,8 +13,7 @@\n         }\n     } else {\n         // ... and it is not referenced, just remove it.\n-        Node newChild = node.getLastChild();\n-        node.removeChild(newChild);\n+        Node newChild = node.getLastChild().detachFromParent();\n         parent.replaceChild(node, newChild);\n         if (newChild.getType() == Token.BLOCK) {\n             NodeUtil.tryMergeBlock(newChild);\n@@ -22,5 +21,7 @@\n         compiler.reportCodeChange();\n     }\n     // Remove the label from the current stack of labels.\n-    namespaceStack.peek().renameMap.remove(name);\n+    if (!li.referenced) {\n+        namespaceStack.peek().renameMap.remove(name);\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    MakeDeclaredNamesUnique transformer = new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop));\n    NodeTraversal.traverse(compiler, fnNode, transformer);\n    // Make label names unique to this instance.\n    transformer.makeLabelsUnique();\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            nameNode.setString(newName);\n            compiler.reportCodeChange();\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        Node newChild = node.getLastChild().detachFromParent();\n        parent.replaceChild(node, newChild);\n        if (newChild.getType() == Token.BLOCK) {\n            NodeUtil.tryMergeBlock(newChild);\n        }\n        compiler.reportCodeChange();\n        // Remove the label from the current stack of labels.\n        namespaceStack.peek().renameMap.remove(name);\n    }\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -1,6 +1,8 @@\n private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n     Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n     // Make variable names unique to this instance.\n-    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n+    MakeDeclaredNamesUnique transformer = new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop));\n+    NodeTraversal.traverse(compiler, fnNode, transformer);\n     // Make label names unique to this instance.\n+    transformer.makeLabelsUnique();\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -13,14 +13,13 @@\n         }\n     } else {\n         // ... and it is not referenced, just remove it.\n-        Node newChild = node.getLastChild();\n-        node.removeChild(newChild);\n+        Node newChild = node.getLastChild().detachFromParent();\n         parent.replaceChild(node, newChild);\n         if (newChild.getType() == Token.BLOCK) {\n             NodeUtil.tryMergeBlock(newChild);\n         }\n         compiler.reportCodeChange();\n+        // Remove the label from the current stack of labels.\n+        namespaceStack.peek().renameMap.remove(name);\n     }\n-    // Remove the label from the current stack of labels.\n-    namespaceStack.peek().renameMap.remove(name);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n    // Make label names unique to this instance.\n    new NodeTraversal(compiler, new MakeDeclaredNamesUnique(new UniqueNameGenerator(idSupplier))).traverse(fnNode);\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            Node newLabelNode = IR.label(nameNode.detach()).setName(newName);\n            newLabelNode.addChildToBack(node.getLastChild().detach());\n            parent.replaceChild(node, newLabelNode);\n            compiler.reportCodeChange();\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        Node newChild = node.getLastChild();\n        node.removeChild(newChild);\n        parent.replaceChild(node, newChild);\n        if (newChild.getType() == Token.BLOCK) {\n            NodeUtil.tryMergeBlock(newChild);\n        }\n        compiler.reportCodeChange();\n    }\n    // Remove the label from the current stack of labels.\n    namespaceStack.peek().renameMap.remove(name);\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -3,4 +3,5 @@\n     // Make variable names unique to this instance.\n     NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n     // Make label names unique to this instance.\n+    new NodeTraversal(compiler, new MakeDeclaredNamesUnique(new UniqueNameGenerator(idSupplier))).traverse(fnNode);\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -8,7 +8,9 @@\n         String newName = getNameForId(li.id);\n         if (!name.equals(newName)) {\n             // ... and it is used, give it the short name.\n-            nameNode.setString(newName);\n+            Node newLabelNode = IR.label(nameNode.detach()).setName(newName);\n+            newLabelNode.addChildToBack(node.getLastChild().detach());\n+            parent.replaceChild(node, newLabelNode);\n             compiler.reportCodeChange();\n         }\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    MakeDeclaredNamesUnique makeUnique = new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop));\n    NodeTraversal.traverse(compiler, fnNode, makeUnique);\n    // Make label names unique to this instance.\n    NodeTraversal.traverse(compiler, fnNode, new LabelNameAnnotator());\n    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new RenameLabelsAsUniquePrefix(makeUnique.getDefinitionMap(), \"L\")));\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            // Change the node name and set type to LABEL_NAME\n            nameNode.setString(newName);\n            nameNode.setType(Token.LABEL_NAME);\n            compiler.reportCodeChange();\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        Node jumpTarget = node.getNext();\n        if (jumpTarget == null || jumpTarget.getType() != Token.BLOCK) {\n            // can't remove non-block statement or empty label\n            return;\n        }\n        NodeUtil.tryMergeBlock(jumpTarget);\n        // Replace label node with its sole child.\n        parent.replaceChild(node, jumpTarget);\n        compiler.reportCodeChange();\n    }\n    // Remove the label from the current stack of labels.\n    namespaceStack.peek().renameMap.remove(name);\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -1,6 +1,9 @@\n private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n     Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n     // Make variable names unique to this instance.\n-    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n+    MakeDeclaredNamesUnique makeUnique = new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop));\n+    NodeTraversal.traverse(compiler, fnNode, makeUnique);\n     // Make label names unique to this instance.\n+    NodeTraversal.traverse(compiler, fnNode, new LabelNameAnnotator());\n+    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new RenameLabelsAsUniquePrefix(makeUnique.getDefinitionMap(), \"L\")));\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -8,17 +8,21 @@\n         String newName = getNameForId(li.id);\n         if (!name.equals(newName)) {\n             // ... and it is used, give it the short name.\n+            // Change the node name and set type to LABEL_NAME\n             nameNode.setString(newName);\n+            nameNode.setType(Token.LABEL_NAME);\n             compiler.reportCodeChange();\n         }\n     } else {\n         // ... and it is not referenced, just remove it.\n-        Node newChild = node.getLastChild();\n-        node.removeChild(newChild);\n-        parent.replaceChild(node, newChild);\n-        if (newChild.getType() == Token.BLOCK) {\n-            NodeUtil.tryMergeBlock(newChild);\n+        Node jumpTarget = node.getNext();\n+        if (jumpTarget == null || jumpTarget.getType() != Token.BLOCK) {\n+            // can't remove non-block statement or empty label\n+            return;\n         }\n+        NodeUtil.tryMergeBlock(jumpTarget);\n+        // Replace label node with its sole child.\n+        parent.replaceChild(node, jumpTarget);\n         compiler.reportCodeChange();\n     }\n     // Remove the label from the current stack of labels.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    MakeDeclaredNamesUnique nameUnique = new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop));\n    nameUnique.process(fnNode);\n    // Make label names unique to this instance.\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            NodeLabel label = NodeUtil.newLabel(compiler, newName);\n            parent.replaceChild(node, label);\n            label.addChildToFront(node.getLastChild());\n            compiler.reportCodeChange();\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        node.detach();\n        if (parent.getType() == Token.LABEL) {\n            parent.getParent().replaceChild(parent, node.getLastChild());\n        } else {\n            parent.replaceChild(node, node.getLastChild());\n        }\n        if (node.getLastChild().getType() == Token.BLOCK) {\n            NodeUtil.tryMergeBlock(node.getLastChild());\n        }\n        compiler.reportCodeChange();\n    }\n    // Remove the label from the current stack of labels.\n    namespaceStack.peek().renameMap.remove(name);\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -1,6 +1,7 @@\n private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n     Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n     // Make variable names unique to this instance.\n-    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n+    MakeDeclaredNamesUnique nameUnique = new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop));\n+    nameUnique.process(fnNode);\n     // Make label names unique to this instance.\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -8,16 +8,21 @@\n         String newName = getNameForId(li.id);\n         if (!name.equals(newName)) {\n             // ... and it is used, give it the short name.\n-            nameNode.setString(newName);\n+            NodeLabel label = NodeUtil.newLabel(compiler, newName);\n+            parent.replaceChild(node, label);\n+            label.addChildToFront(node.getLastChild());\n             compiler.reportCodeChange();\n         }\n     } else {\n         // ... and it is not referenced, just remove it.\n-        Node newChild = node.getLastChild();\n-        node.removeChild(newChild);\n-        parent.replaceChild(node, newChild);\n-        if (newChild.getType() == Token.BLOCK) {\n-            NodeUtil.tryMergeBlock(newChild);\n+        node.detach();\n+        if (parent.getType() == Token.LABEL) {\n+            parent.getParent().replaceChild(parent, node.getLastChild());\n+        } else {\n+            parent.replaceChild(node, node.getLastChild());\n+        }\n+        if (node.getLastChild().getType() == Token.BLOCK) {\n+            NodeUtil.tryMergeBlock(node.getLastChild());\n         }\n         compiler.reportCodeChange();\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n    // Make label names unique to this instance.\n    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new LabelNameRenamer(idSupplier)));\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            nameNode.setString(newName);\n            compiler.reportCodeChange();\n            // Update the label info with the new name\n            li.name = newName;\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        Node newChild = node.getLastChild();\n        parent.replaceChild(node, newChild);\n        if (newChild.getType() == Token.BLOCK) {\n            NodeUtil.tryMergeBlock(newChild);\n        }\n        compiler.reportCodeChange();\n        // Remove the label info from the map\n        namespaceStack.peek().renameMap.remove(name);\n    }\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -3,4 +3,5 @@\n     // Make variable names unique to this instance.\n     NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n     // Make label names unique to this instance.\n+    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new LabelNameRenamer(idSupplier)));\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -10,17 +10,18 @@\n             // ... and it is used, give it the short name.\n             nameNode.setString(newName);\n             compiler.reportCodeChange();\n+            // Update the label info with the new name\n+            li.name = newName;\n         }\n     } else {\n         // ... and it is not referenced, just remove it.\n         Node newChild = node.getLastChild();\n-        node.removeChild(newChild);\n         parent.replaceChild(node, newChild);\n         if (newChild.getType() == Token.BLOCK) {\n             NodeUtil.tryMergeBlock(newChild);\n         }\n         compiler.reportCodeChange();\n+        // Remove the label info from the map\n+        namespaceStack.peek().renameMap.remove(name);\n     }\n-    // Remove the label from the current stack of labels.\n-    namespaceStack.peek().renameMap.remove(name);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n    // Make label names unique to this instance.\n    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new LabelRenamer(idSupplier)));\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            nameNode.setString(newName);\n            compiler.reportCodeChange();\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        NodeUtil.removeChild(parent, node);\n        compiler.reportCodeChange();\n    }\n    // Remove the label from the current stack of labels.\n    namespaceStack.peek().renameMap.remove(name);\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -3,4 +3,5 @@\n     // Make variable names unique to this instance.\n     NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n     // Make label names unique to this instance.\n+    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new LabelRenamer(idSupplier)));\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -13,12 +13,7 @@\n         }\n     } else {\n         // ... and it is not referenced, just remove it.\n-        Node newChild = node.getLastChild();\n-        node.removeChild(newChild);\n-        parent.replaceChild(node, newChild);\n-        if (newChild.getType() == Token.BLOCK) {\n-            NodeUtil.tryMergeBlock(newChild);\n-        }\n+        NodeUtil.removeChild(parent, node);\n         compiler.reportCodeChange();\n     }\n     // Remove the label from the current stack of labels.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n    // Make label names unique to this instance.\n    Renamer renamer = new Renamer(idSupplier);\n    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new LabelRenamer(renamer)));\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            Node newLabelNode = IR.labelname(newName);\n            node.replaceChild(nameNode, newLabelNode);\n            compiler.reportCodeChange();\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        Node newChild = node.getLastChild();\n        node.removeChild(newChild);\n        parent.replaceChild(node, newChild);\n        if (newChild.getType() == Token.BLOCK) {\n            NodeUtil.tryMergeBlock(newChild);\n        } else {\n            compiler.reportCodeChange();\n        }\n    }\n    // Remove the label from the current stack of labels.\n    namespaceStack.peek().renameMap.remove(name);\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -3,4 +3,6 @@\n     // Make variable names unique to this instance.\n     NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n     // Make label names unique to this instance.\n+    Renamer renamer = new Renamer(idSupplier);\n+    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new LabelRenamer(renamer)));\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -8,7 +8,8 @@\n         String newName = getNameForId(li.id);\n         if (!name.equals(newName)) {\n             // ... and it is used, give it the short name.\n-            nameNode.setString(newName);\n+            Node newLabelNode = IR.labelname(newName);\n+            node.replaceChild(nameNode, newLabelNode);\n             compiler.reportCodeChange();\n         }\n     } else {\n@@ -18,8 +19,9 @@\n         parent.replaceChild(node, newChild);\n         if (newChild.getType() == Token.BLOCK) {\n             NodeUtil.tryMergeBlock(newChild);\n+        } else {\n+            compiler.reportCodeChange();\n         }\n-        compiler.reportCodeChange();\n     }\n     // Remove the label from the current stack of labels.\n     namespaceStack.peek().renameMap.remove(name);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    IdGenerator idGenerator = new UniqueNameGenerator();\n    // Make variable names unique to this instance.\n    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idGenerator, \"inline_\", isCallInLoop)));\n    // Make label names unique to this instance.\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            Node newLabelNode = IR.label().setName(newName);\n            while (node.hasChildren()) {\n                newLabelNode.addChildToFront(node.removeFirstChild());\n            }\n            parent.replaceChild(node, newLabelNode);\n            node = newLabelNode;\n            compiler.reportCodeChange();\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        Node newChild = node.getLastChild();\n        node.removeChild(newChild);\n        parent.replaceChild(node, newChild);\n        if (newChild.getType() == Token.BLOCK) {\n            NodeUtil.tryMergeBlock(newChild);\n        }\n        compiler.reportCodeChange();\n    }\n    // Remove the label from the current stack of labels.\n    namespaceStack.peek().renameMap.remove(name);\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -1,6 +1,6 @@\n private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n-    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n+    IdGenerator idGenerator = new UniqueNameGenerator();\n     // Make variable names unique to this instance.\n-    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n+    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idGenerator, \"inline_\", isCallInLoop)));\n     // Make label names unique to this instance.\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -8,7 +8,12 @@\n         String newName = getNameForId(li.id);\n         if (!name.equals(newName)) {\n             // ... and it is used, give it the short name.\n-            nameNode.setString(newName);\n+            Node newLabelNode = IR.label().setName(newName);\n+            while (node.hasChildren()) {\n+                newLabelNode.addChildToFront(node.removeFirstChild());\n+            }\n+            parent.replaceChild(node, newLabelNode);\n+            node = newLabelNode;\n             compiler.reportCodeChange();\n         }\n     } else {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    MakeDeclaredNamesUnique makeDeclaredNamesUnique = new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop));\n    makeDeclaredNamesUnique.process(null, fnNode);\n    // Make label names unique to this instance.\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            nameNode.setString(newName);\n            compiler.reportChangeToEnclosingScope(node);\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        Node newChild = node.getLastChild();\n        NodeUtil.removeChild(parent, node);\n        if (newChild.getType() == Token.BLOCK) {\n            NodeUtil.tryMergeBlock(newChild);\n        }\n        compiler.reportChangeToEnclosingScope(parent);\n    }\n    // Remove the label from the current stack of labels.\n    namespaceStack.peek().renameMap.remove(name);\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -1,6 +1,7 @@\n private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n     Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n     // Make variable names unique to this instance.\n-    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n+    MakeDeclaredNamesUnique makeDeclaredNamesUnique = new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop));\n+    makeDeclaredNamesUnique.process(null, fnNode);\n     // Make label names unique to this instance.\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -9,17 +9,16 @@\n         if (!name.equals(newName)) {\n             // ... and it is used, give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n+            compiler.reportChangeToEnclosingScope(node);\n         }\n     } else {\n         // ... and it is not referenced, just remove it.\n         Node newChild = node.getLastChild();\n-        node.removeChild(newChild);\n-        parent.replaceChild(node, newChild);\n+        NodeUtil.removeChild(parent, node);\n         if (newChild.getType() == Token.BLOCK) {\n             NodeUtil.tryMergeBlock(newChild);\n         }\n-        compiler.reportCodeChange();\n+        compiler.reportChangeToEnclosingScope(parent);\n     }\n     // Remove the label from the current stack of labels.\n     namespaceStack.peek().renameMap.remove(name);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    RenameDeclaredVariables uniqueRename = new RenameDeclaredVariables(idSupplier, new SymbolTable(), isCallInLoop);\n    NodeTraversal.traverse(compiler, fnNode, uniqueRename);\n    // Make label names unique to this instance.\n    MakeDeclaredNamesUnique labelRename = new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop));\n    NodeTraversal.traverse(compiler, fnNode, labelRename);\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            Node newNameNode = nameNode.cloneTree();\n            newNameNode.setString(newName);\n            node.replaceChild(nameNode, newNameNode);\n            compiler.reportCodeChange();\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        parent.removeChild(node);\n        if (node.getLastChild().getType() == Token.BLOCK) {\n            NodeUtil.tryMergeBlock(node.getLastChild());\n        }\n        compiler.reportCodeChange();\n    }\n    // Remove the label from the current stack of labels.\n    namespaceStack.peek().renameMap.remove(name);\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -1,6 +1,9 @@\n private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n     Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n     // Make variable names unique to this instance.\n-    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n+    RenameDeclaredVariables uniqueRename = new RenameDeclaredVariables(idSupplier, new SymbolTable(), isCallInLoop);\n+    NodeTraversal.traverse(compiler, fnNode, uniqueRename);\n     // Make label names unique to this instance.\n+    MakeDeclaredNamesUnique labelRename = new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop));\n+    NodeTraversal.traverse(compiler, fnNode, labelRename);\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -8,16 +8,16 @@\n         String newName = getNameForId(li.id);\n         if (!name.equals(newName)) {\n             // ... and it is used, give it the short name.\n-            nameNode.setString(newName);\n+            Node newNameNode = nameNode.cloneTree();\n+            newNameNode.setString(newName);\n+            node.replaceChild(nameNode, newNameNode);\n             compiler.reportCodeChange();\n         }\n     } else {\n         // ... and it is not referenced, just remove it.\n-        Node newChild = node.getLastChild();\n-        node.removeChild(newChild);\n-        parent.replaceChild(node, newChild);\n-        if (newChild.getType() == Token.BLOCK) {\n-            NodeUtil.tryMergeBlock(newChild);\n+        parent.removeChild(node);\n+        if (node.getLastChild().getType() == Token.BLOCK) {\n+            NodeUtil.tryMergeBlock(node.getLastChild());\n         }\n         compiler.reportCodeChange();\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n\n    // Get all declared names in this function.\n    Set<String> declaredNames = new HashSet<>();\n    NodeTraversal.traverse(compiler, fnNode, new NodeTraversal.AbstractPostOrderCallback() {\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n            if (n.isName()) {\n                declaredNames.add(n.getString());\n            }\n        }\n    });\n\n    // Make label names unique to this instance, skipping names that conflict with declared names.\n    NodeTraversal.traverse(compiler, fnNode, new NodeTraversal.Callback() {\n        @Override\n        public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n            return !n.isFunction();\n        }\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n            if (n.isLabel()) {\n                String labelName = n.getFirstChild().getString();\n                LabelInfo li = getLabelInfo(labelName);\n                if (li.referenced) {\n                    String newName = getNameForId(li.id);\n                    if (!labelName.equals(newName) && !declaredNames.contains(newName)) {\n                        n.getFirstChild().setString(newName);\n                        compiler.reportCodeChange();\n                    }\n                } else {\n                    n.detach();\n                    compiler.reportCodeChange();\n                }\n            }\n        }\n    });\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name, unless it conflicts with a declared name.\n            Set<String> declaredNames = new HashSet<>();\n            NodeTraversal.traverse(compiler.getRoot(), new NodeTraversal.Callback() {\n                @Override\n                public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n                    return !n.isFunction();\n                }\n\n                @Override\n                public void visit(NodeTraversal t, Node n, Node parent) {\n                    if (n.isName()) {\n                        declaredNames.add(n.getString());\n                    }\n                }\n            });\n            if (!declaredNames.contains(newName)) {\n                nameNode.setString(newName);\n                compiler.reportCodeChange();\n            }\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        Node newChild = node.getLastChild();\n        node.removeChild(newChild);\n        parent.replaceChild(node, newChild);\n        if (newChild.getType() == Token.BLOCK) {\n            NodeUtil.tryMergeBlock(newChild);\n        }\n        compiler.reportCodeChange();\n    }\n    // Remove the label from the current stack of labels.\n    namespaceStack.peek().renameMap.remove(name);\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -2,5 +2,41 @@\n     Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n     // Make variable names unique to this instance.\n     NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n-    // Make label names unique to this instance.\n+\n+    // Get all declared names in this function.\n+    Set<String> declaredNames = new HashSet<>();\n+    NodeTraversal.traverse(compiler, fnNode, new NodeTraversal.AbstractPostOrderCallback() {\n+        @Override\n+        public void visit(NodeTraversal t, Node n, Node parent) {\n+            if (n.isName()) {\n+                declaredNames.add(n.getString());\n+            }\n+        }\n+    });\n+\n+    // Make label names unique to this instance, skipping names that conflict with declared names.\n+    NodeTraversal.traverse(compiler, fnNode, new NodeTraversal.Callback() {\n+        @Override\n+        public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n+            return !n.isFunction();\n+        }\n+\n+        @Override\n+        public void visit(NodeTraversal t, Node n, Node parent) {\n+            if (n.isLabel()) {\n+                String labelName = n.getFirstChild().getString();\n+                LabelInfo li = getLabelInfo(labelName);\n+                if (li.referenced) {\n+                    String newName = getNameForId(li.id);\n+                    if (!labelName.equals(newName) && !declaredNames.contains(newName)) {\n+                        n.getFirstChild().setString(newName);\n+                        compiler.reportCodeChange();\n+                    }\n+                } else {\n+                    n.detach();\n+                    compiler.reportCodeChange();\n+                }\n+            }\n+        }\n+    });\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -7,9 +7,25 @@\n     if (li.referenced) {\n         String newName = getNameForId(li.id);\n         if (!name.equals(newName)) {\n-            // ... and it is used, give it the short name.\n-            nameNode.setString(newName);\n-            compiler.reportCodeChange();\n+            // ... and it is used, give it the short name, unless it conflicts with a declared name.\n+            Set<String> declaredNames = new HashSet<>();\n+            NodeTraversal.traverse(compiler.getRoot(), new NodeTraversal.Callback() {\n+                @Override\n+                public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n+                    return !n.isFunction();\n+                }\n+\n+                @Override\n+                public void visit(NodeTraversal t, Node n, Node parent) {\n+                    if (n.isName()) {\n+                        declaredNames.add(n.getString());\n+                    }\n+                }\n+            });\n+            if (!declaredNames.contains(newName)) {\n+                nameNode.setString(newName);\n+                compiler.reportCodeChange();\n+            }\n         }\n     } else {\n         // ... and it is not referenced, just remove it.\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    MakeDeclaredNamesUnique renamer1 = new MakeDeclaredNamesUnique(idSupplier);\n    InlineRenamer renamer2 = new InlineRenamer(idSupplier, \"inline_\", isCallInLoop);\n    NodeTraversal.traverse(compiler, fnNode, new NodeTraversal.AbstractPostOrderCallback() {\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n            if (n.isParamList()) {\n                // Do not rename parameters.\n                return;\n            }\n            renamer1.visit(n, parent);\n            renamer2.visit(n, parent);\n        }\n    });\n    // Make label names unique to this instance.\n    new LabelNameAnnotator().process(compiler, fnNode);\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            nameNode.setString(newName);\n            // Recompute the label info, as it depends on label names.\n            computeLabelInfo();\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        NodeUtil.removeChild(parent, node);\n        compiler.reportCodeChange();\n        // Recompute the label info, as it depends on label names.\n        computeLabelInfo();\n    }\n    // Remove the label from the current stack of labels.\n    LabelInfo removed = namespaceStack.peek().labels.remove(name);\n    Preconditions.checkState(removed != null);\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -1,6 +1,19 @@\n private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n     Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n     // Make variable names unique to this instance.\n-    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n+    MakeDeclaredNamesUnique renamer1 = new MakeDeclaredNamesUnique(idSupplier);\n+    InlineRenamer renamer2 = new InlineRenamer(idSupplier, \"inline_\", isCallInLoop);\n+    NodeTraversal.traverse(compiler, fnNode, new NodeTraversal.AbstractPostOrderCallback() {\n+        @Override\n+        public void visit(NodeTraversal t, Node n, Node parent) {\n+            if (n.isParamList()) {\n+                // Do not rename parameters.\n+                return;\n+            }\n+            renamer1.visit(n, parent);\n+            renamer2.visit(n, parent);\n+        }\n+    });\n     // Make label names unique to this instance.\n+    new LabelNameAnnotator().process(compiler, fnNode);\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -9,18 +9,17 @@\n         if (!name.equals(newName)) {\n             // ... and it is used, give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n+            // Recompute the label info, as it depends on label names.\n+            computeLabelInfo();\n         }\n     } else {\n         // ... and it is not referenced, just remove it.\n-        Node newChild = node.getLastChild();\n-        node.removeChild(newChild);\n-        parent.replaceChild(node, newChild);\n-        if (newChild.getType() == Token.BLOCK) {\n-            NodeUtil.tryMergeBlock(newChild);\n-        }\n+        NodeUtil.removeChild(parent, node);\n         compiler.reportCodeChange();\n+        // Recompute the label info, as it depends on label names.\n+        computeLabelInfo();\n     }\n     // Remove the label from the current stack of labels.\n-    namespaceStack.peek().renameMap.remove(name);\n+    LabelInfo removed = namespaceStack.peek().labels.remove(name);\n+    Preconditions.checkState(removed != null);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    MakeDeclaredNamesUnique makeNamesUnique = new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop));\n    makeNamesUnique.process(fnNode);\n    // Make label names unique to this instance.\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            Node newNameNode = IR.string(newName);\n            node.replaceChild(nameNode, newNameNode);\n            compiler.reportCodeChange();\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        Node newChild = node.getLastChild();\n        node.removeChild(nameNode);\n        parent.replaceChild(node, newChild);\n        if (newChild.getType() == Token.BLOCK) {\n            NodeUtil.tryMergeBlock(newChild);\n        }\n        compiler.reportCodeChange();\n    }\n    // Remove the label from the current stack of labels.\n    namespaceStack.peek().renameMap.remove(name);\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -1,6 +1,7 @@\n private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n     Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n     // Make variable names unique to this instance.\n-    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n+    MakeDeclaredNamesUnique makeNamesUnique = new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop));\n+    makeNamesUnique.process(fnNode);\n     // Make label names unique to this instance.\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -8,13 +8,14 @@\n         String newName = getNameForId(li.id);\n         if (!name.equals(newName)) {\n             // ... and it is used, give it the short name.\n-            nameNode.setString(newName);\n+            Node newNameNode = IR.string(newName);\n+            node.replaceChild(nameNode, newNameNode);\n             compiler.reportCodeChange();\n         }\n     } else {\n         // ... and it is not referenced, just remove it.\n         Node newChild = node.getLastChild();\n-        node.removeChild(newChild);\n+        node.removeChild(nameNode);\n         parent.replaceChild(node, newChild);\n         if (newChild.getType() == Token.BLOCK) {\n             NodeUtil.tryMergeBlock(newChild);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n    // Make label names unique to this instance.\n    new NodeTraversal(compiler, new RenameLabels(idSupplier, true)).traverse(fnNode);\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            nameNode.setString(newName);\n            compiler.reportCodeChange();\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        Node newChild = node.getLastChild().detachFromParent();\n        parent.replaceChild(node, newChild);\n        if (newChild.getType() == Token.BLOCK) {\n            NodeUtil.tryMergeBlock(newChild);\n        }\n        compiler.reportCodeChangeToEnclosingScope(parent);\n    }\n    // Remove the label from the current stack of labels.\n    namespaceStack.peek().renameMap.remove(name);\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -3,4 +3,5 @@\n     // Make variable names unique to this instance.\n     NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n     // Make label names unique to this instance.\n+    new NodeTraversal(compiler, new RenameLabels(idSupplier, true)).traverse(fnNode);\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -13,13 +13,12 @@\n         }\n     } else {\n         // ... and it is not referenced, just remove it.\n-        Node newChild = node.getLastChild();\n-        node.removeChild(newChild);\n+        Node newChild = node.getLastChild().detachFromParent();\n         parent.replaceChild(node, newChild);\n         if (newChild.getType() == Token.BLOCK) {\n             NodeUtil.tryMergeBlock(newChild);\n         }\n-        compiler.reportCodeChange();\n+        compiler.reportCodeChangeToEnclosingScope(parent);\n     }\n     // Remove the label from the current stack of labels.\n     namespaceStack.peek().renameMap.remove(name);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop));\n    renamer.process(null, fnNode);\n    // Make label names unique to this instance.\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            nameNode.setString(newName);\n            compiler.reportCodeChange();\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        if (node.hasChildren()) {\n            Node newChild = node.removeFirstChild();\n            parent.replaceChild(node, newChild);\n            if (newChild.getType() == Token.BLOCK) {\n                NodeUtil.tryMergeBlock(newChild);\n            }\n            compiler.reportCodeChange();\n        } else {\n            parent.removeChild(node);\n            compiler.reportCodeChange();\n        }\n    }\n    // Remove the label from the current stack of labels.\n    namespaceStack.peek().renameMap.remove(name);\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -1,6 +1,7 @@\n private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n     Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n     // Make variable names unique to this instance.\n-    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n+    MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop));\n+    renamer.process(null, fnNode);\n     // Make label names unique to this instance.\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -13,13 +13,17 @@\n         }\n     } else {\n         // ... and it is not referenced, just remove it.\n-        Node newChild = node.getLastChild();\n-        node.removeChild(newChild);\n-        parent.replaceChild(node, newChild);\n-        if (newChild.getType() == Token.BLOCK) {\n-            NodeUtil.tryMergeBlock(newChild);\n+        if (node.hasChildren()) {\n+            Node newChild = node.removeFirstChild();\n+            parent.replaceChild(node, newChild);\n+            if (newChild.getType() == Token.BLOCK) {\n+                NodeUtil.tryMergeBlock(newChild);\n+            }\n+            compiler.reportCodeChange();\n+        } else {\n+            parent.removeChild(node);\n+            compiler.reportCodeChange();\n         }\n-        compiler.reportCodeChange();\n     }\n     // Remove the label from the current stack of labels.\n     namespaceStack.peek().renameMap.remove(name);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n    // Make label names unique to this instance.\n    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new LabelRenamer(idSupplier)));\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            nameNode.setString(newName);\n            compiler.reportCodeChange();\n            li.renamed = true; // Flag the label as renamed\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        Node newChild = node.getLastChild();\n        node.removeChild(newChild);\n        parent.replaceChild(node, newChild);\n        if (newChild.getType() == Token.BLOCK) {\n            NodeUtil.tryMergeBlock(newChild);\n        }\n        compiler.reportCodeChange();\n        removeFromLabels(name); // Remove the label from the list of labels\n    }\n    // Remove the label from the current stack of labels, unless it was renamed\n    if (!li.renamed) {\n      namespaceStack.peek().renameMap.remove(name);\n    }\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -3,4 +3,5 @@\n     // Make variable names unique to this instance.\n     NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n     // Make label names unique to this instance.\n+    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new LabelRenamer(idSupplier)));\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -10,6 +10,7 @@\n             // ... and it is used, give it the short name.\n             nameNode.setString(newName);\n             compiler.reportCodeChange();\n+            li.renamed = true; // Flag the label as renamed\n         }\n     } else {\n         // ... and it is not referenced, just remove it.\n@@ -20,7 +21,10 @@\n             NodeUtil.tryMergeBlock(newChild);\n         }\n         compiler.reportCodeChange();\n+        removeFromLabels(name); // Remove the label from the list of labels\n     }\n-    // Remove the label from the current stack of labels.\n-    namespaceStack.peek().renameMap.remove(name);\n+    // Remove the label from the current stack of labels, unless it was renamed\n+    if (!li.renamed) {\n+      namespaceStack.peek().renameMap.remove(name);\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.createUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new RenameVars(idSupplier, new Hashtable<>(), null, isCallInLoop)));\n    // Make label names unique to this instance.\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            nameNode.setString(newName);\n            compiler.reportChangeToEnclosingScope(nameNode);\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        Node newChild = node.getLastChild();\n        node.removeChild(nameNode);\n        parent.replaceChild(node, newChild);\n        if (newChild.getType() == Token.BLOCK) {\n            NodeUtil.tryMergeBlock(newChild);\n        }\n        compiler.reportChangeToEnclosingScope(parent);\n    }\n    // Remove the label from the current stack of labels.\n    namespaceStack.peek().renameMap().remove(name);\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -1,6 +1,6 @@\n private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n-    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n+    Supplier<String> idSupplier = compiler.createUniqueNameIdSupplier();\n     // Make variable names unique to this instance.\n-    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n+    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new RenameVars(idSupplier, new Hashtable<>(), null, isCallInLoop)));\n     // Make label names unique to this instance.\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -9,18 +9,18 @@\n         if (!name.equals(newName)) {\n             // ... and it is used, give it the short name.\n             nameNode.setString(newName);\n-            compiler.reportCodeChange();\n+            compiler.reportChangeToEnclosingScope(nameNode);\n         }\n     } else {\n         // ... and it is not referenced, just remove it.\n         Node newChild = node.getLastChild();\n-        node.removeChild(newChild);\n+        node.removeChild(nameNode);\n         parent.replaceChild(node, newChild);\n         if (newChild.getType() == Token.BLOCK) {\n             NodeUtil.tryMergeBlock(newChild);\n         }\n-        compiler.reportCodeChange();\n+        compiler.reportChangeToEnclosingScope(parent);\n     }\n     // Remove the label from the current stack of labels.\n-    namespaceStack.peek().renameMap.remove(name);\n+    namespaceStack.peek().renameMap().remove(name);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    MakeDeclaredNamesUnique fixFirst = new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop));\n    NodeTraversal.traverse(compiler, fnNode, fixFirst);\n    // Make label names unique to this instance.\n    MakeDeclaredNamesUnique fixSecond = new MakeDeclaredNamesUnique(new LabelRenamer(idSupplier));\n    NodeTraversal.traverse(compiler, fnNode, fixSecond);\n}\n\n## Fixed Function 2\nprivate void visitLabel(Node node, Node parent) {\n    Node nameNode = node.getFirstChild();\n    Preconditions.checkState(nameNode != null);\n    String name = nameNode.getString();\n    LabelInfo li = getLabelInfo(name);\n    // This is a label...\n    if (li.referenced) {\n        String newName = getNameForId(li.id);\n        if (!name.equals(newName)) {\n            // ... and it is used, give it the short name.\n            nameNode.setString(newName);\n            compiler.reportCodeChange();\n        }\n    } else {\n        // ... and it is not referenced, just remove it.\n        Node newChild = node.detachChildren();\n        parent.replaceChild(node, newChild);\n        if (newChild.isBlock()) {\n            NodeUtil.tryMergeBlock(newChild);\n        }\n        compiler.reportCodeChange();\n    }\n    // Remove the label from the current stack of labels.\n    namespaceStack.peek().renameMap.remove(name);\n}", "diff": "--- com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n+++ com/google/javascript/jscomp/FunctionToBlockMutator.javamakeLocalNamesUnique\n@@ -1,6 +1,9 @@\n private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n     Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n     // Make variable names unique to this instance.\n-    NodeTraversal.traverse(compiler, fnNode, new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop)));\n+    MakeDeclaredNamesUnique fixFirst = new MakeDeclaredNamesUnique(new InlineRenamer(idSupplier, \"inline_\", isCallInLoop));\n+    NodeTraversal.traverse(compiler, fnNode, fixFirst);\n     // Make label names unique to this instance.\n+    MakeDeclaredNamesUnique fixSecond = new MakeDeclaredNamesUnique(new LabelRenamer(idSupplier));\n+    NodeTraversal.traverse(compiler, fnNode, fixSecond);\n }\n--- com/google/javascript/jscomp/RenameLabels.javavisitLabel\n+++ com/google/javascript/jscomp/RenameLabels.javavisitLabel\n@@ -13,10 +13,9 @@\n         }\n     } else {\n         // ... and it is not referenced, just remove it.\n-        Node newChild = node.getLastChild();\n-        node.removeChild(newChild);\n+        Node newChild = node.detachChildren();\n         parent.replaceChild(node, newChild);\n-        if (newChild.getType() == Token.BLOCK) {\n+        if (newChild.isBlock()) {\n             NodeUtil.tryMergeBlock(newChild);\n         }\n         compiler.reportCodeChange();\n", "finish_reason": "stop", "valid": false, "num": 1}]