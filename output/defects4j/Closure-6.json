[{"output": "## Fixed Function 1\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType() && ownerType.toObjectType().getOwnerFunction().isInterface()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 2\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!getCurrentScope(t).isTypeInScope(leftType)\n        || !rightType.canAssignTo(leftType)\n        || rightType.equals(VOID_TYPE) && leftType.isConstructor()) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.javaexpectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.javaexpectCanAssignToPropertyOf\n@@ -1,20 +1,11 @@\n-boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n-    // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n+    if (!getCurrentScope(t).isTypeInScope(leftType)\n+        || !rightType.canAssignTo(leftType)\n+        || rightType.equals(VOID_TYPE) && leftType.isConstructor()) {\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n-            // Do not type-check interface methods, because we expect that\n-            // they will have dummy implementations that do not match the type\n-            // annotations.\n-            JSType ownerType = getJSType(owner);\n-            if (ownerType.isFunctionPrototypeType()) {\n-                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n-                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n-                    return true;\n-                }\n-            }\n-            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n+            mismatch(t, n, msg, rightType, leftType);\n         }\n         return false;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) { // Use isSubtypeOf instead of canAssignTo\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 2\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!rightType.isSubtypeOf(leftType)) { // Use isSubtypeOf instead of canAssignTo\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.javaexpectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.javaexpectCanAssignToPropertyOf\n@@ -1,20 +1,9 @@\n-boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n-    // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n+    if (!rightType.isSubtypeOf(leftType)) { // Use isSubtypeOf instead of canAssignTo\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n-            // Do not type-check interface methods, because we expect that\n-            // they will have dummy implementations that do not match the type\n-            // annotations.\n-            JSType ownerType = getJSType(owner);\n-            if (ownerType.isFunctionPrototypeType()) {\n-                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n-                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n-                    return true;\n-                }\n-            }\n-            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n+            mismatch(t, n, msg, rightType, leftType);\n         }\n         return false;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.isSubtypeOf(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 2\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!rightType.isSubtypeOf(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.javaexpectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.javaexpectCanAssignToPropertyOf\n@@ -1,20 +1,9 @@\n-boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n-    // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n+boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n+    if (!rightType.isSubtypeOf(leftType)) {\n         if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n-            // Do not type-check interface methods, because we expect that\n-            // they will have dummy implementations that do not match the type\n-            // annotations.\n-            JSType ownerType = getJSType(owner);\n-            if (ownerType.isFunctionPrototypeType()) {\n-                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n-                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n-                    return true;\n-                }\n-            }\n-            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n+            mismatch(t, n, msg, rightType, leftType);\n         }\n         return false;\n     }\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\nboolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work OK.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            // Do not type-check interface methods, because we expect that\n            // they will have dummy implementations that do not match the type\n            // annotations.\n            JSType ownerType = getJSType(owner);\n            if (ownerType.isFunctionPrototypeType()) {\n                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n                if (ownerFn != null && ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n                    return true;\n                }\n            }\n            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}\n\n## Fixed Function 2\nboolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n    if (!rightType.isUnknownType() && !leftType.isUnknownType()\n            && !rightType.canAssignTo(leftType)) {\n        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor()\n                || rightType.isEnumType())) {\n            registerMismatch(rightType, leftType, null);\n        } else {\n            mismatch(t, n, msg, rightType, leftType);\n        }\n        return false;\n    }\n    return true;\n}", "diff": "--- com/google/javascript/jscomp/TypeValidator.javaexpectCanAssignToPropertyOf\n+++ com/google/javascript/jscomp/TypeValidator.javaexpectCanAssignToPropertyOf\n@@ -1,20 +1,11 @@\n-boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType, JSType leftType, Node owner, String propName) {\n-    // The NoType check is a hack to make typedefs work OK.\n-    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n-        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor() || rightType.isEnumType())) {\n+boolean expectCanAssignTo(NodeTraversal t, Node n, JSType rightType, JSType leftType, String msg) {\n+    if (!rightType.isUnknownType() && !leftType.isUnknownType()\n+            && !rightType.canAssignTo(leftType)) {\n+        if ((leftType.isConstructor() || leftType.isEnumType()) && (rightType.isConstructor()\n+                || rightType.isEnumType())) {\n             registerMismatch(rightType, leftType, null);\n         } else {\n-            // Do not type-check interface methods, because we expect that\n-            // they will have dummy implementations that do not match the type\n-            // annotations.\n-            JSType ownerType = getJSType(owner);\n-            if (ownerType.isFunctionPrototypeType()) {\n-                FunctionType ownerFn = ownerType.toObjectType().getOwnerFunction();\n-                if (ownerFn.isInterface() && rightType.isFunctionType() && leftType.isFunctionType()) {\n-                    return true;\n-                }\n-            }\n-            mismatch(t, n, \"assignment to property \" + propName + \" of \" + getReadableJSTypeName(owner, true), rightType, leftType);\n+            mismatch(t, n, msg, rightType, leftType);\n         }\n         return false;\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}]