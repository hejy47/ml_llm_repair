[{"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, zipEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, zipEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, zipEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, zipEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, zipEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, zipEncoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, Charset encoding) {\n    this.in = in;\n    this.blockSize = blockSize;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, Charset encoding) {\n    this.out = out;\n    switch(format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \" + format);\n    }\n    this.entryFormat = format;\n    this.blockSize = blockSize;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, Charset encoding) throws ArchiveException {\n    this.raw = new TapeInputStream(is);\n    this.hasHitEOF = false;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, int blockSize, int recordSize, Charset encoding) {\n    this.is = is;\n    this.hasHitEOF = false;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.recordSize = recordSize;\n    this.blockSize = blockSize;\n}\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, Charset encoding) {\n    out = new CountingOutputStream(os);\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.assemLen = 0;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordSize = recordSize;\n    this.recordsPerBlock = blockSize / recordSize;\n}\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, Charset encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.limit(0);\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -12,13 +12,13 @@\n         in.reset();\n         if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n             if (entryEncoding != null) {\n-                return new ZipArchiveInputStream(in, entryEncoding);\n+                return new ZipArchiveInputStream(in, zipEncoding);\n             } else {\n                 return new ZipArchiveInputStream(in);\n             }\n         } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n             if (entryEncoding != null) {\n-                return new JarArchiveInputStream(in, entryEncoding);\n+                return new JarArchiveInputStream(in, zipEncoding);\n             } else {\n                 return new JarArchiveInputStream(in);\n             }\n@@ -26,7 +26,7 @@\n             return new ArArchiveInputStream(in);\n         } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n             if (entryEncoding != null) {\n-                return new CpioArchiveInputStream(in, entryEncoding);\n+                return new CpioArchiveInputStream(in, zipEncoding);\n             } else {\n                 return new CpioArchiveInputStream(in);\n             }\n@@ -41,7 +41,7 @@\n         signatureLength = IOUtils.readFully(in, dumpsig);\n         in.reset();\n         if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n-            return new DumpArchiveInputStream(in, entryEncoding);\n+            return new DumpArchiveInputStream(in, zipEncoding);\n         }\n         // Tar needs an even bigger buffer to check the signature; read the first block\n         final byte[] tarheader = new byte[512];\n@@ -49,7 +49,7 @@\n         signatureLength = IOUtils.readFully(in, tarheader);\n         in.reset();\n         if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n-            return new TarArchiveInputStream(in, entryEncoding);\n+            return new TarArchiveInputStream(in, zipEncoding);\n         }\n         // COMPRESS-117 - improve auto-recognition\n         if (signatureLength >= 512) {\n@@ -58,7 +58,7 @@\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n                 if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+                    return new TarArchiveInputStream(in, zipEncoding);\n                 }\n             } catch (Exception e) {\n                 // NOPMD\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry() != null && tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, encoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n    this.in = in;\n    this.blockSize = blockSize;\n    this.zipEncoding = encoding != null ? ZipEncodingHelper.getZipEncoding(encoding) :\n        ZipEncodingHelper.UTF8_ZIP_ENCODING;\n}\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n    this.out = out;\n    switch(format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \" + format);\n    }\n    this.entryFormat = format;\n    this.blockSize = blockSize;\n    this.zipEncoding = encoding != null ? ZipEncodingHelper.getZipEncoding(encoding) :\n        ZipEncodingHelper.UTF8_ZIP_ENCODING;\n}\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n    this.raw = new TapeInputStream(is);\n    this.hasHitEOF = false;\n    this.zipEncoding = encoding != null ? ZipEncodingHelper.getZipEncoding(encoding) :\n        ZipEncodingHelper.UTF8_ZIP_ENCODING;\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n    this.is = is;\n    this.hasHitEOF = false;\n    this.zipEncoding = encoding != null ? ZipEncodingHelper.getZipEncoding(encoding) :\n        ZipEncodingHelper.UTF8_ZIP_ENCODING;\n    this.recordSize = recordSize;\n    this.blockSize = blockSize;\n}\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n    out = new CountingOutputStream(os);\n    this.zipEncoding = encoding != null ? ZipEncodingHelper.getZipEncoding(encoding) :\n        ZipEncodingHelper.UTF8_ZIP_ENCODING;\n    this.assemLen = 0;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordSize = recordSize;\n    this.recordsPerBlock = blockSize / recordSize;\n}\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding = encoding != null ? ZipEncodingHelper.getZipEncoding(encoding) :\n        ZipEncodingHelper.UTF8_ZIP_ENCODING;\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.limit(0);\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -57,7 +57,7 @@\n             try {\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n-                if (tais.getNextTarEntry().isCheckSumOK()) {\n+                if (tais.getNextTarEntry() != null && tais.getNextTarEntry().isCheckSumOK()) {\n                     return new TarArchiveInputStream(in, encoding);\n                 }\n             } catch (Exception e) {\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n@@ -1,5 +1,6 @@\n public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n     this.in = in;\n     this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.zipEncoding = encoding != null ? ZipEncodingHelper.getZipEncoding(encoding) :\n+        ZipEncodingHelper.UTF8_ZIP_ENCODING;\n }\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n@@ -11,5 +11,6 @@\n     }\n     this.entryFormat = format;\n     this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.zipEncoding = encoding != null ? ZipEncodingHelper.getZipEncoding(encoding) :\n+        ZipEncodingHelper.UTF8_ZIP_ENCODING;\n }\n--- org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n+++ org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n@@ -1,7 +1,8 @@\n public DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n     this.raw = new TapeInputStream(is);\n     this.hasHitEOF = false;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.zipEncoding = encoding != null ? ZipEncodingHelper.getZipEncoding(encoding) :\n+        ZipEncodingHelper.UTF8_ZIP_ENCODING;\n     try {\n         // read header, verify it's a dump archive.\n         byte[] headerBytes = raw.readRecord();\n--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n@@ -1,7 +1,8 @@\n public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n     this.is = is;\n     this.hasHitEOF = false;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.zipEncoding = encoding != null ? ZipEncodingHelper.getZipEncoding(encoding) :\n+        ZipEncodingHelper.UTF8_ZIP_ENCODING;\n     this.recordSize = recordSize;\n     this.blockSize = blockSize;\n }\n--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n@@ -1,6 +1,7 @@\n public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n     out = new CountingOutputStream(os);\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.zipEncoding = encoding != null ? ZipEncodingHelper.getZipEncoding(encoding) :\n+        ZipEncodingHelper.UTF8_ZIP_ENCODING;\n     this.assemLen = 0;\n     this.assemBuf = new byte[recordSize];\n     this.recordBuf = new byte[recordSize];\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n@@ -1,5 +1,6 @@\n public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n-    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    zipEncoding = encoding != null ? ZipEncodingHelper.getZipEncoding(encoding) :\n+        ZipEncodingHelper.UTF8_ZIP_ENCODING;\n     this.useUnicodeExtraFields = useUnicodeExtraFields;\n     in = new PushbackInputStream(inputStream, buf.capacity());\n     this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry() != null && tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, entryEncoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, Charset charset) {\n    this.in = in;\n    this.blockSize = blockSize;\n    this.zipEncoding = new ZipEncodingHelper(charset);\n}\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, Charset charset) {\n    this.out = out;\n    switch(format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \" + format);\n    }\n    this.entryFormat = format;\n    this.blockSize = blockSize;\n    this.zipEncoding = new ZipEncodingHelper(charset);\n}\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, Charset charset) throws ArchiveException {\n    this.raw = new TapeInputStream(is);\n    this.hasHitEOF = false;\n    this.zipEncoding = new ZipEncodingHelper(charset);\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, int blockSize, int recordSize, Charset charset) {\n    this.is = is;\n    this.hasHitEOF = false;\n    this.zipEncoding = new ZipEncodingHelper(charset);\n    this.recordSize = recordSize;\n    this.blockSize = blockSize;\n}\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, Charset charset) {\n    out = new CountingOutputStream(os);\n    this.zipEncoding = new ZipEncodingHelper(charset);\n    this.assemLen = 0;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordSize = recordSize;\n    this.recordsPerBlock = blockSize / recordSize;\n}\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, Charset charset, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding = new ZipEncodingHelper(charset);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.limit(0);\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -57,8 +57,8 @@\n             try {\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n-                if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+                if (tais.getNextTarEntry() != null && tais.getNextTarEntry().isCheckSumOK()) {\n+                    return new TarArchiveInputStream(in, entryEncoding);\n                 }\n             } catch (Exception e) {\n                 // NOPMD\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, zipEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, zipEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, zipEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, zipEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, zipEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, zipEncoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n    this.in = in;\n    this.blockSize = blockSize;\n    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n    this.out = out;\n    switch(format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \" + format);\n    }\n    this.entryFormat = format;\n    this.blockSize = blockSize;\n    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n    this.raw = new TapeInputStream(is);\n    this.hasHitEOF = false;\n    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.entryEncoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n    this.is = is;\n    this.hasHitEOF = false;\n    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.recordSize = recordSize;\n    this.blockSize = blockSize;\n}\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n    out = new CountingOutputStream(os);\n    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.assemLen = 0;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordSize = recordSize;\n    this.recordsPerBlock = blockSize / recordSize;\n}\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.limit(0);\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -12,13 +12,13 @@\n         in.reset();\n         if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n             if (entryEncoding != null) {\n-                return new ZipArchiveInputStream(in, entryEncoding);\n+                return new ZipArchiveInputStream(in, zipEncoding);\n             } else {\n                 return new ZipArchiveInputStream(in);\n             }\n         } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n             if (entryEncoding != null) {\n-                return new JarArchiveInputStream(in, entryEncoding);\n+                return new JarArchiveInputStream(in, zipEncoding);\n             } else {\n                 return new JarArchiveInputStream(in);\n             }\n@@ -26,7 +26,7 @@\n             return new ArArchiveInputStream(in);\n         } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n             if (entryEncoding != null) {\n-                return new CpioArchiveInputStream(in, entryEncoding);\n+                return new CpioArchiveInputStream(in, zipEncoding);\n             } else {\n                 return new CpioArchiveInputStream(in);\n             }\n@@ -41,7 +41,7 @@\n         signatureLength = IOUtils.readFully(in, dumpsig);\n         in.reset();\n         if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n-            return new DumpArchiveInputStream(in, entryEncoding);\n+            return new DumpArchiveInputStream(in, zipEncoding);\n         }\n         // Tar needs an even bigger buffer to check the signature; read the first block\n         final byte[] tarheader = new byte[512];\n@@ -49,7 +49,7 @@\n         signatureLength = IOUtils.readFully(in, tarheader);\n         in.reset();\n         if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n-            return new TarArchiveInputStream(in, entryEncoding);\n+            return new TarArchiveInputStream(in, zipEncoding);\n         }\n         // COMPRESS-117 - improve auto-recognition\n         if (signatureLength >= 512) {\n@@ -58,7 +58,7 @@\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n                 if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+                    return new TarArchiveInputStream(in, zipEncoding);\n                 }\n             } catch (Exception e) {\n                 // NOPMD\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n@@ -1,5 +1,5 @@\n public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n     this.in = in;\n     this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n }\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n@@ -11,5 +11,5 @@\n     }\n     this.entryFormat = format;\n     this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n }\n--- org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n+++ org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n@@ -1,7 +1,7 @@\n public DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n     this.raw = new TapeInputStream(is);\n     this.hasHitEOF = false;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     try {\n         // read header, verify it's a dump archive.\n         byte[] headerBytes = raw.readRecord();\n@@ -9,7 +9,7 @@\n             throw new UnrecognizedFormatException();\n         }\n         // get summary information\n-        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n+        summary = new DumpArchiveSummary(headerBytes, this.entryEncoding);\n         // reset buffer with actual block size.\n         raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n         // allocate our read buffer.\n--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n@@ -1,7 +1,7 @@\n public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n     this.is = is;\n     this.hasHitEOF = false;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     this.recordSize = recordSize;\n     this.blockSize = blockSize;\n }\n--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n@@ -1,6 +1,6 @@\n public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n     out = new CountingOutputStream(os);\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     this.assemLen = 0;\n     this.assemBuf = new byte[recordSize];\n     this.recordBuf = new byte[recordSize];\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding, true, true);\n            } else {\n                return new ZipArchiveInputStream(in, true, true);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader), entryEncoding);\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, entryEncoding, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n    this.in = new BufferedInputStream(in, blockSize);\n    this.blockSize = blockSize;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n    this.out = new BufferedOutputStream(out, blockSize);\n    switch(format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \" + format);\n    }\n    this.entryFormat = format;\n    this.blockSize = blockSize;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n    this.raw = new TapeInputStream(is);\n    this.hasHitEOF = false;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n    this.is = new BufferedInputStream(is, blockSize);\n    this.hasHitEOF = false;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.recordSize = recordSize;\n    this.blockSize = blockSize;\n}\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n    out = new CountingOutputStream(new BufferedOutputStream(os, blockSize));\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.assemLen = 0;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordSize = recordSize;\n    this.recordsPerBlock = blockSize / recordSize;\n}\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(new BufferedInputStream(inputStream, ZipArchiveOutputStream.BUFFER_SIZE), buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.limit(0);\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -12,9 +12,9 @@\n         in.reset();\n         if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n             if (entryEncoding != null) {\n-                return new ZipArchiveInputStream(in, entryEncoding);\n+                return new ZipArchiveInputStream(in, entryEncoding, true, true);\n             } else {\n-                return new ZipArchiveInputStream(in);\n+                return new ZipArchiveInputStream(in, true, true);\n             }\n         } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n             if (entryEncoding != null) {\n@@ -49,16 +49,16 @@\n         signatureLength = IOUtils.readFully(in, tarheader);\n         in.reset();\n         if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n-            return new TarArchiveInputStream(in, entryEncoding);\n+            return new TarArchiveInputStream(in, entryEncoding, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n         }\n         // COMPRESS-117 - improve auto-recognition\n         if (signatureLength >= 512) {\n             TarArchiveInputStream tais = null;\n             try {\n-                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n+                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader), entryEncoding);\n                 // COMPRESS-191 - verify the header checksum\n                 if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+                    return new TarArchiveInputStream(in, entryEncoding, TarConstants.DEFAULT_BLKSIZE, TarConstants.DEFAULT_RCDSIZE);\n                 }\n             } catch (Exception e) {\n                 // NOPMD\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n@@ -1,5 +1,5 @@\n public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n-    this.in = in;\n+    this.in = new BufferedInputStream(in, blockSize);\n     this.blockSize = blockSize;\n     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n }\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n@@ -1,5 +1,5 @@\n public CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n-    this.out = out;\n+    this.out = new BufferedOutputStream(out, blockSize);\n     switch(format) {\n         case FORMAT_NEW:\n         case FORMAT_NEW_CRC:\n--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n@@ -1,5 +1,5 @@\n public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n-    this.is = is;\n+    this.is = new BufferedInputStream(is, blockSize);\n     this.hasHitEOF = false;\n     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     this.recordSize = recordSize;\n--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n@@ -1,5 +1,5 @@\n public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n-    out = new CountingOutputStream(os);\n+    out = new CountingOutputStream(new BufferedOutputStream(os, blockSize));\n     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     this.assemLen = 0;\n     this.assemBuf = new byte[recordSize];\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n@@ -1,7 +1,7 @@\n public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n     zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     this.useUnicodeExtraFields = useUnicodeExtraFields;\n-    in = new PushbackInputStream(inputStream, buf.capacity());\n+    in = new PushbackInputStream(new BufferedInputStream(inputStream, ZipArchiveOutputStream.BUFFER_SIZE), buf.capacity());\n     this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n     // haven't read anything so far\n     buf.limit(0);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, entryEncoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n    this.in = in;\n    this.blockSize = blockSize;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n    this.out = out;\n    switch(format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \" + format);\n    }\n    this.entryFormat = format;\n    this.blockSize = blockSize;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n    this.raw = new TapeInputStream(is);\n    this.hasHitEOF = false;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n    this.is = is;\n    this.hasHitEOF = false;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.recordSize = recordSize;\n    this.blockSize = blockSize;\n}\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n    out = new CountingOutputStream(os);\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.assemLen = 0;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordSize = recordSize;\n    this.recordsPerBlock = blockSize / recordSize;\n}\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    buf.limit(0);\n    lengthLimit = -1;\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -58,7 +58,7 @@\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n                 if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+                    return new TarArchiveInputStream(in, entryEncoding);\n                 }\n             } catch (Exception e) {\n                 // NOPMD\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n@@ -3,6 +3,6 @@\n     this.useUnicodeExtraFields = useUnicodeExtraFields;\n     in = new PushbackInputStream(inputStream, buf.capacity());\n     this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n-    // haven't read anything so far\n     buf.limit(0);\n+    lengthLimit = -1;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, entryEncoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    } catch (NullPointerException e) {\n        throw new ArchiveException(e.getMessage(), e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n    this.in = in;\n    this.blockSize = blockSize;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    if (blockSize > 0 && blockSize % RECORD_SIZE != 0) {\n        throw new IllegalArgumentException(\"blockSize must be a multiple of \"\n                + RECORD_SIZE);\n    }\n}\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n    this.out = out;\n    this.blockSize = blockSize;\n    switch(format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \" + format);\n    }\n    this.entryFormat = format;\n    this.blockSize = blockSize;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    if (blockSize > 0 && blockSize % RECORD_SIZE != 0) {\n        throw new IllegalArgumentException(\"blockSize must be a multiple of \"\n                + RECORD_SIZE);\n    }\n}\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n    this.raw = new TapeInputStream(is);\n    this.hasHitEOF = false;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(DUMP_BLOCK_SIZE, summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[DUMP_BLOCK_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n    this.is = is;\n    this.hasHitEOF = false;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.blockSize = blockSize;\n    this.recordSize = recordSize;\n    if (recordSize > blockSize){\n        throw new IllegalArgumentException(\"recordSize cannot be larger than blockSize!\");\n    }\n    recordBuf = new byte[recordSize];\n}\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n    out = new CountingOutputStream(os);\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.assemLen = 0;\n    this.recordSize = recordSize;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.blockSize = blockSize;\n    if (recordSize > blockSize){\n        throw new IllegalArgumentException(\"recordSize cannot be larger than blockSize!\");\n    }\n    recordsPerBlock = blockSize / recordSize;\n}\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.limit(0);\n    if (encoding == null) {\n        throw new IllegalArgumentException(\"Input stream encoding can not be NULL.\");\n    }\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -58,7 +58,7 @@\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n                 if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+                    return new TarArchiveInputStream(in, entryEncoding);\n                 }\n             } catch (Exception e) {\n                 // NOPMD\n@@ -72,6 +72,8 @@\n         }\n     } catch (IOException e) {\n         throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n+    } catch (NullPointerException e) {\n+        throw new ArchiveException(e.getMessage(), e);\n     }\n     throw new ArchiveException(\"No Archiver found for the stream signature\");\n }\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n@@ -2,4 +2,8 @@\n     this.in = in;\n     this.blockSize = blockSize;\n     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    if (blockSize > 0 && blockSize % RECORD_SIZE != 0) {\n+        throw new IllegalArgumentException(\"blockSize must be a multiple of \"\n+                + RECORD_SIZE);\n+    }\n }\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n@@ -1,5 +1,6 @@\n public CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n     this.out = out;\n+    this.blockSize = blockSize;\n     switch(format) {\n         case FORMAT_NEW:\n         case FORMAT_NEW_CRC:\n@@ -12,4 +13,8 @@\n     this.entryFormat = format;\n     this.blockSize = blockSize;\n     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    if (blockSize > 0 && blockSize % RECORD_SIZE != 0) {\n+        throw new IllegalArgumentException(\"blockSize must be a multiple of \"\n+                + RECORD_SIZE);\n+    }\n }\n--- org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n+++ org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n@@ -11,9 +11,9 @@\n         // get summary information\n         summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n         // reset buffer with actual block size.\n-        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n+        raw.resetBlockSize(DUMP_BLOCK_SIZE, summary.isCompressed());\n         // allocate our read buffer.\n-        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n+        blockBuffer = new byte[DUMP_BLOCK_SIZE];\n         // skip past CLRI and BITS segments since we don't handle them yet.\n         readCLRI();\n         readBITS();\n--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n@@ -2,6 +2,10 @@\n     this.is = is;\n     this.hasHitEOF = false;\n     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.blockSize = blockSize;\n     this.recordSize = recordSize;\n-    this.blockSize = blockSize;\n+    if (recordSize > blockSize){\n+        throw new IllegalArgumentException(\"recordSize cannot be larger than blockSize!\");\n+    }\n+    recordBuf = new byte[recordSize];\n }\n--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n@@ -2,8 +2,12 @@\n     out = new CountingOutputStream(os);\n     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     this.assemLen = 0;\n+    this.recordSize = recordSize;\n     this.assemBuf = new byte[recordSize];\n     this.recordBuf = new byte[recordSize];\n-    this.recordSize = recordSize;\n-    this.recordsPerBlock = blockSize / recordSize;\n+    this.blockSize = blockSize;\n+    if (recordSize > blockSize){\n+        throw new IllegalArgumentException(\"recordSize cannot be larger than blockSize!\");\n+    }\n+    recordsPerBlock = blockSize / recordSize;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n@@ -1,8 +1,11 @@\n public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n-    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     this.useUnicodeExtraFields = useUnicodeExtraFields;\n     in = new PushbackInputStream(inputStream, buf.capacity());\n     this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n     // haven't read anything so far\n     buf.limit(0);\n+    if (encoding == null) {\n+        throw new IllegalArgumentException(\"Input stream encoding can not be NULL.\");\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            if (entryEncoding != null) {\n                return new DumpArchiveInputStream(in, entryEncoding);\n            } else {\n                return new DumpArchiveInputStream(in);\n            }\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            if (entryEncoding != null) {\n                return new TarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new TarArchiveInputStream(in);\n            }\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    if (entryEncoding != null) {\n                        return new TarArchiveInputStream(in, entryEncoding);\n                    } else {\n                        return new TarArchiveInputStream(in);\n                    }\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n    this.in = in;\n    this.blockSize = blockSize;\n    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n    this.out = out;\n    switch(format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \" + format);\n    }\n    this.entryFormat = format;\n    this.blockSize = blockSize;\n    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n    this.raw = new TapeInputStream(is);\n    this.hasHitEOF = false;\n    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.entryEncoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n    this.is = is;\n    this.hasHitEOF = false;\n    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.recordSize = recordSize;\n    this.blockSize = blockSize;\n}\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n    out = new CountingOutputStream(os);\n    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.assemLen = 0;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordSize = recordSize;\n    this.recordsPerBlock = blockSize / recordSize;\n}\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.limit(0);\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -41,7 +41,11 @@\n         signatureLength = IOUtils.readFully(in, dumpsig);\n         in.reset();\n         if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n-            return new DumpArchiveInputStream(in, entryEncoding);\n+            if (entryEncoding != null) {\n+                return new DumpArchiveInputStream(in, entryEncoding);\n+            } else {\n+                return new DumpArchiveInputStream(in);\n+            }\n         }\n         // Tar needs an even bigger buffer to check the signature; read the first block\n         final byte[] tarheader = new byte[512];\n@@ -49,7 +53,11 @@\n         signatureLength = IOUtils.readFully(in, tarheader);\n         in.reset();\n         if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n-            return new TarArchiveInputStream(in, entryEncoding);\n+            if (entryEncoding != null) {\n+                return new TarArchiveInputStream(in, entryEncoding);\n+            } else {\n+                return new TarArchiveInputStream(in);\n+            }\n         }\n         // COMPRESS-117 - improve auto-recognition\n         if (signatureLength >= 512) {\n@@ -58,7 +66,11 @@\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n                 if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+                    if (entryEncoding != null) {\n+                        return new TarArchiveInputStream(in, entryEncoding);\n+                    } else {\n+                        return new TarArchiveInputStream(in);\n+                    }\n                 }\n             } catch (Exception e) {\n                 // NOPMD\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n@@ -1,5 +1,5 @@\n public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n     this.in = in;\n     this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n }\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n@@ -11,5 +11,5 @@\n     }\n     this.entryFormat = format;\n     this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n }\n--- org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n+++ org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n@@ -1,7 +1,7 @@\n public DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n     this.raw = new TapeInputStream(is);\n     this.hasHitEOF = false;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     try {\n         // read header, verify it's a dump archive.\n         byte[] headerBytes = raw.readRecord();\n@@ -9,7 +9,7 @@\n             throw new UnrecognizedFormatException();\n         }\n         // get summary information\n-        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n+        summary = new DumpArchiveSummary(headerBytes, this.entryEncoding);\n         // reset buffer with actual block size.\n         raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n         // allocate our read buffer.\n--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n@@ -1,7 +1,7 @@\n public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n     this.is = is;\n     this.hasHitEOF = false;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     this.recordSize = recordSize;\n     this.blockSize = blockSize;\n }\n--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n@@ -1,6 +1,6 @@\n public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n     out = new CountingOutputStream(os);\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     this.assemLen = 0;\n     this.assemBuf = new byte[recordSize];\n     this.recordBuf = new byte[recordSize];\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n@@ -1,5 +1,5 @@\n public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n-    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     this.useUnicodeExtraFields = useUnicodeExtraFields;\n     in = new PushbackInputStream(inputStream, buf.capacity());\n     this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding, allowStoredEntriesWithDataDescriptor);\n            } else {\n                return new ZipArchiveInputStream(in, allowStoredEntriesWithDataDescriptor);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding, allowStoredEntriesWithDataDescriptor);\n            } else {\n                return new JarArchiveInputStream(in, allowStoredEntriesWithDataDescriptor);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, encoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n    this.in = in;\n    this.blockSize = blockSize;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}\n\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n    this.out = out;\n    switch(format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \" + format);\n    }\n    this.entryFormat = format;\n    this.blockSize = blockSize;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}\n\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n    this.raw = new TapeInputStream(is);\n    this.hasHitEOF = false;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n    this.is = is;\n    this.hasHitEOF = false;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.recordSize = recordSize;\n    this.blockSize = blockSize;\n}\n\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n    out = new CountingOutputStream(os);\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.assemLen = 0;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordSize = recordSize;\n    this.recordsPerBlock = blockSize / recordSize;\n}\n\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.limit(0);\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -12,15 +12,15 @@\n         in.reset();\n         if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n             if (entryEncoding != null) {\n-                return new ZipArchiveInputStream(in, entryEncoding);\n+                return new ZipArchiveInputStream(in, entryEncoding, allowStoredEntriesWithDataDescriptor);\n             } else {\n-                return new ZipArchiveInputStream(in);\n+                return new ZipArchiveInputStream(in, allowStoredEntriesWithDataDescriptor);\n             }\n         } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n             if (entryEncoding != null) {\n-                return new JarArchiveInputStream(in, entryEncoding);\n+                return new JarArchiveInputStream(in, entryEncoding, allowStoredEntriesWithDataDescriptor);\n             } else {\n-                return new JarArchiveInputStream(in);\n+                return new JarArchiveInputStream(in, allowStoredEntriesWithDataDescriptor);\n             }\n         } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n             return new ArArchiveInputStream(in);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding, true, allowStoredEntriesWithDataDescriptor);\n            } else {\n                return new ZipArchiveInputStream(in, true, allowStoredEntriesWithDataDescriptor);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader), entryEncoding);\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, entryEncoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n    this.in = in;\n    this.blockSize = blockSize;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.entryEncoding = encoding;\n}\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n    this.out = out;\n    switch(format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \" + format);\n    }\n    this.entryFormat = format;\n    this.blockSize = blockSize;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.entryEncoding = encoding;\n}\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n    this.raw = new TapeInputStream(is);\n    this.hasHitEOF = false;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.entryEncoding = encoding;\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n    this.is = is;\n    this.hasHitEOF = false;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.entryEncoding = encoding;\n    this.recordSize = recordSize;\n    this.blockSize = blockSize;\n}\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n    out = new CountingOutputStream(os);\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.assemLen = 0;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordSize = recordSize;\n    this.recordsPerBlock = blockSize / recordSize;\n    this.entryEncoding = encoding;\n}\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.limit(0);\n    this.entryEncoding = encoding;\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -12,9 +12,9 @@\n         in.reset();\n         if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n             if (entryEncoding != null) {\n-                return new ZipArchiveInputStream(in, entryEncoding);\n+                return new ZipArchiveInputStream(in, entryEncoding, true, allowStoredEntriesWithDataDescriptor);\n             } else {\n-                return new ZipArchiveInputStream(in);\n+                return new ZipArchiveInputStream(in, true, allowStoredEntriesWithDataDescriptor);\n             }\n         } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n             if (entryEncoding != null) {\n@@ -55,10 +55,10 @@\n         if (signatureLength >= 512) {\n             TarArchiveInputStream tais = null;\n             try {\n-                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n+                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader), entryEncoding);\n                 // COMPRESS-191 - verify the header checksum\n                 if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+                    return new TarArchiveInputStream(in, entryEncoding);\n                 }\n             } catch (Exception e) {\n                 // NOPMD\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n@@ -2,4 +2,5 @@\n     this.in = in;\n     this.blockSize = blockSize;\n     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = encoding;\n }\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n@@ -12,4 +12,5 @@\n     this.entryFormat = format;\n     this.blockSize = blockSize;\n     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = encoding;\n }\n--- org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n+++ org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n@@ -2,6 +2,7 @@\n     this.raw = new TapeInputStream(is);\n     this.hasHitEOF = false;\n     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = encoding;\n     try {\n         // read header, verify it's a dump archive.\n         byte[] headerBytes = raw.readRecord();\n--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n@@ -2,6 +2,7 @@\n     this.is = is;\n     this.hasHitEOF = false;\n     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = encoding;\n     this.recordSize = recordSize;\n     this.blockSize = blockSize;\n }\n--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n@@ -6,4 +6,5 @@\n     this.recordBuf = new byte[recordSize];\n     this.recordSize = recordSize;\n     this.recordsPerBlock = blockSize / recordSize;\n+    this.entryEncoding = encoding;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n@@ -5,4 +5,5 @@\n     this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n     // haven't read anything so far\n     buf.limit(0);\n+    this.entryEncoding = encoding;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding, true, allowStoredEntriesWithDataDescriptor);\n            } else {\n                return new ZipArchiveInputStream(in, true, allowStoredEntriesWithDataDescriptor);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, encoding, blockSize, recordSize, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, encoding, blockSize, recordSize, entryEncoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n    this.in = in;\n    this.blockSize = blockSize;\n    this.encoding = encoding;\n}\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n    this.out = out;\n    switch(format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \" + format);\n    }\n    this.entryFormat = format;\n    this.blockSize = blockSize;\n    this.encoding = encoding;\n}\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n    this.raw = new TapeInputStream(is);\n    this.hasHitEOF = false;\n    this.encoding = encoding;\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, String encoding, int blockSize, int recordSize, String entryEncoding) {\n    this.is = is;\n    this.hasHitEOF = false;\n    this.encoding = encoding;\n    this.recordSize = recordSize;\n    this.blockSize = blockSize;\n    this.entryEncoding = entryEncoding;\n}\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding, String entryEncoding) {\n    out = new CountingOutputStream(os);\n    this.encoding = encoding;\n    this.entryEncoding = entryEncoding;\n    this.assemLen = 0;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordSize = recordSize;\n    this.recordsPerBlock = blockSize / recordSize;\n}\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.limit(0);\n    ensureSignatureRead(in);\n    foundFirstEntry = false;\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -12,9 +12,9 @@\n         in.reset();\n         if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n             if (entryEncoding != null) {\n-                return new ZipArchiveInputStream(in, entryEncoding);\n+                return new ZipArchiveInputStream(in, entryEncoding, true, allowStoredEntriesWithDataDescriptor);\n             } else {\n-                return new ZipArchiveInputStream(in);\n+                return new ZipArchiveInputStream(in, true, allowStoredEntriesWithDataDescriptor);\n             }\n         } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n             if (entryEncoding != null) {\n@@ -49,7 +49,7 @@\n         signatureLength = IOUtils.readFully(in, tarheader);\n         in.reset();\n         if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n-            return new TarArchiveInputStream(in, entryEncoding);\n+            return new TarArchiveInputStream(in, encoding, blockSize, recordSize, entryEncoding);\n         }\n         // COMPRESS-117 - improve auto-recognition\n         if (signatureLength >= 512) {\n@@ -58,7 +58,7 @@\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n                 if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+                    return new TarArchiveInputStream(in, encoding, blockSize, recordSize, entryEncoding);\n                 }\n             } catch (Exception e) {\n                 // NOPMD\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n@@ -1,5 +1,5 @@\n public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n     this.in = in;\n     this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.encoding = encoding;\n }\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n@@ -11,5 +11,5 @@\n     }\n     this.entryFormat = format;\n     this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.encoding = encoding;\n }\n--- org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n+++ org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n@@ -1,7 +1,7 @@\n public DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n     this.raw = new TapeInputStream(is);\n     this.hasHitEOF = false;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.encoding = encoding;\n     try {\n         // read header, verify it's a dump archive.\n         byte[] headerBytes = raw.readRecord();\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n@@ -5,4 +5,6 @@\n     this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n     // haven't read anything so far\n     buf.limit(0);\n+    ensureSignatureRead(in);\n+    foundFirstEntry = false;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, entryEncoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n    this.in = in;\n    this.blockSize = blockSize;\n    this.encoding = encoding;\n}\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n    this.out = out;\n    switch(format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \" + format);\n    }\n    this.entryFormat = format;\n    this.blockSize = blockSize;\n    this.encoding = encoding;\n}\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n    this.raw = new TapeInputStream(is);\n    this.hasHitEOF = false;\n    this.encoding = encoding;\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.encoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n    this.is = is;\n    this.hasHitEOF = false;\n    this.blockSize = blockSize;\n    this.recordSize = recordSize;\n    this.encoding = encoding;\n}\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n    out = new CountingOutputStream(os);\n    this.encoding = encoding;\n    this.assemLen = 0;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordSize = recordSize;\n    this.recordsPerBlock = blockSize / recordSize;\n}\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.limit(0);\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -58,7 +58,7 @@\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n                 if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+                    return new TarArchiveInputStream(in, entryEncoding);\n                 }\n             } catch (Exception e) {\n                 // NOPMD\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n@@ -1,5 +1,5 @@\n public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n     this.in = in;\n     this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.encoding = encoding;\n }\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n@@ -11,5 +11,5 @@\n     }\n     this.entryFormat = format;\n     this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.encoding = encoding;\n }\n--- org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n+++ org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n@@ -1,7 +1,7 @@\n public DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n     this.raw = new TapeInputStream(is);\n     this.hasHitEOF = false;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.encoding = encoding;\n     try {\n         // read header, verify it's a dump archive.\n         byte[] headerBytes = raw.readRecord();\n@@ -9,7 +9,7 @@\n             throw new UnrecognizedFormatException();\n         }\n         // get summary information\n-        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n+        summary = new DumpArchiveSummary(headerBytes, this.encoding);\n         // reset buffer with actual block size.\n         raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n         // allocate our read buffer.\n--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n@@ -1,7 +1,7 @@\n public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n     this.is = is;\n     this.hasHitEOF = false;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.blockSize = blockSize;\n     this.recordSize = recordSize;\n-    this.blockSize = blockSize;\n+    this.encoding = encoding;\n }\n--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n@@ -1,6 +1,6 @@\n public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n     out = new CountingOutputStream(os);\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.encoding = encoding;\n     this.assemLen = 0;\n     this.assemBuf = new byte[recordSize];\n     this.recordBuf = new byte[recordSize];\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            if (entryEncoding != null) {\n                return new DumpArchiveInputStream(in, entryEncoding);\n            } else {\n                return new DumpArchiveInputStream(in);\n            }\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            if (entryEncoding != null) {\n                return new TarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new TarArchiveInputStream(in);\n            }\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    if (entryEncoding != null) {\n                        return new TarArchiveInputStream(in, entryEncoding);\n                    } else {\n                        return new TarArchiveInputStream(in);\n                    }\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n    this(in, blockSize, encoding, false);\n}\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n    this(out, format, blockSize, encoding, false);\n}\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n    this.raw = new TapeInputStream(is);\n    this.hasHitEOF = false;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n    this.is = is;\n    this.hasHitEOF = false;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.recordSize = recordSize;\n    this.blockSize = blockSize;\n    this.assemLen = 0;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordsPerBlock = blockSize / recordSize;\n}\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n    out = new CountingOutputStream(os);\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.assemLen = 0;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordSize = recordSize;\n    this.recordsPerBlock = blockSize / recordSize;\n}\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.limit(0);\n    lengthLimit = -1;\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -41,7 +41,11 @@\n         signatureLength = IOUtils.readFully(in, dumpsig);\n         in.reset();\n         if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n-            return new DumpArchiveInputStream(in, entryEncoding);\n+            if (entryEncoding != null) {\n+                return new DumpArchiveInputStream(in, entryEncoding);\n+            } else {\n+                return new DumpArchiveInputStream(in);\n+            }\n         }\n         // Tar needs an even bigger buffer to check the signature; read the first block\n         final byte[] tarheader = new byte[512];\n@@ -49,7 +53,11 @@\n         signatureLength = IOUtils.readFully(in, tarheader);\n         in.reset();\n         if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n-            return new TarArchiveInputStream(in, entryEncoding);\n+            if (entryEncoding != null) {\n+                return new TarArchiveInputStream(in, entryEncoding);\n+            } else {\n+                return new TarArchiveInputStream(in);\n+            }\n         }\n         // COMPRESS-117 - improve auto-recognition\n         if (signatureLength >= 512) {\n@@ -58,7 +66,11 @@\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n                 if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+                    if (entryEncoding != null) {\n+                        return new TarArchiveInputStream(in, entryEncoding);\n+                    } else {\n+                        return new TarArchiveInputStream(in);\n+                    }\n                 }\n             } catch (Exception e) {\n                 // NOPMD\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n@@ -1,5 +1,3 @@\n public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n-    this.in = in;\n-    this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this(in, blockSize, encoding, false);\n }\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n@@ -1,15 +1,3 @@\n public CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n-    this.out = out;\n-    switch(format) {\n-        case FORMAT_NEW:\n-        case FORMAT_NEW_CRC:\n-        case FORMAT_OLD_ASCII:\n-        case FORMAT_OLD_BINARY:\n-            break;\n-        default:\n-            throw new IllegalArgumentException(\"Unknown format: \" + format);\n-    }\n-    this.entryFormat = format;\n-    this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this(out, format, blockSize, encoding, false);\n }\n--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n@@ -4,4 +4,8 @@\n     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     this.recordSize = recordSize;\n     this.blockSize = blockSize;\n+    this.assemLen = 0;\n+    this.assemBuf = new byte[recordSize];\n+    this.recordBuf = new byte[recordSize];\n+    this.recordsPerBlock = blockSize / recordSize;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n@@ -5,4 +5,5 @@\n     this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n     // haven't read anything so far\n     buf.limit(0);\n+    lengthLimit = -1;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader), encoding);\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, encoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n    this.in = in;\n    this.blockSize = blockSize;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n    this.out = out;\n    switch(format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \" + format);\n    }\n    this.entryFormat = format;\n    this.blockSize = blockSize;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n    this.raw = new TapeInputStream(is, encoding);\n    this.hasHitEOF = false;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n    this.is = is;\n    this.hasHitEOF = false;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.recordSize = recordSize;\n    this.blockSize = blockSize;\n}\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n    out = new CountingOutputStream(os);\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.assemLen = 0;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordSize = recordSize;\n    this.recordsPerBlock = blockSize / recordSize;\n}\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.limit(0);\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -55,7 +55,7 @@\n         if (signatureLength >= 512) {\n             TarArchiveInputStream tais = null;\n             try {\n-                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n+                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader), encoding);\n                 // COMPRESS-191 - verify the header checksum\n                 if (tais.getNextTarEntry().isCheckSumOK()) {\n                     return new TarArchiveInputStream(in, encoding);\n--- org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n+++ org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n@@ -1,5 +1,5 @@\n public DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n-    this.raw = new TapeInputStream(is);\n+    this.raw = new TapeInputStream(is, encoding);\n     this.hasHitEOF = false;\n     this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     try {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry() != null && tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, entryEncoding);\n                }\n            } catch (Exception e) {\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n    this.in = in;\n    this.blockSize = blockSize;\n    this.zipEncoding = new ZipEncodingHelper().getZipEncoding(encoding);\n}\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n    this.out = out;\n    switch(format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \" + format);\n    }\n    this.entryFormat = format;\n    this.blockSize = blockSize;\n    this.zipEncoding = new ZipEncodingHelper().getZipEncoding(encoding);\n}\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n    this.raw = new TapeInputStream(is);\n    this.hasHitEOF = false;\n    this.zipEncoding = new ZipEncodingHelper().getZipEncoding(encoding);\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n    this(is, blockSize, encoding);\n    this.recordSize = recordSize;\n}\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n    this(os, blockSize, encoding);\n    this.recordSize = recordSize;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordsPerBlock = blockSize / recordSize;\n}\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    this.zipEncoding = new ZipEncodingHelper().getZipEncoding(encoding);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.limit(0);\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -57,11 +57,10 @@\n             try {\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n-                if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+                if (tais.getNextTarEntry() != null && tais.getNextTarEntry().isCheckSumOK()) {\n+                    return new TarArchiveInputStream(in, entryEncoding);\n                 }\n             } catch (Exception e) {\n-                // NOPMD\n                 // can generate IllegalArgumentException as well\n                 // as IOException\n                 // autodetection, simply not a TAR\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n@@ -1,5 +1,5 @@\n public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n     this.in = in;\n     this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.zipEncoding = new ZipEncodingHelper().getZipEncoding(encoding);\n }\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n@@ -11,5 +11,5 @@\n     }\n     this.entryFormat = format;\n     this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.zipEncoding = new ZipEncodingHelper().getZipEncoding(encoding);\n }\n--- org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n+++ org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n@@ -1,7 +1,7 @@\n public DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n     this.raw = new TapeInputStream(is);\n     this.hasHitEOF = false;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.zipEncoding = new ZipEncodingHelper().getZipEncoding(encoding);\n     try {\n         // read header, verify it's a dump archive.\n         byte[] headerBytes = raw.readRecord();\n--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n@@ -1,7 +1,4 @@\n public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n-    this.is = is;\n-    this.hasHitEOF = false;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this(is, blockSize, encoding);\n     this.recordSize = recordSize;\n-    this.blockSize = blockSize;\n }\n--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n@@ -1,9 +1,7 @@\n public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n-    out = new CountingOutputStream(os);\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n-    this.assemLen = 0;\n+    this(os, blockSize, encoding);\n+    this.recordSize = recordSize;\n     this.assemBuf = new byte[recordSize];\n     this.recordBuf = new byte[recordSize];\n-    this.recordSize = recordSize;\n     this.recordsPerBlock = blockSize / recordSize;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n@@ -1,5 +1,5 @@\n public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n-    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.zipEncoding = new ZipEncodingHelper().getZipEncoding(encoding);\n     this.useUnicodeExtraFields = useUnicodeExtraFields;\n     in = new PushbackInputStream(inputStream, buf.capacity());\n     this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry() != null && tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, encoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n    this.in = in;\n    this.blockSize = blockSize;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n    this.out = out;\n    switch(format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \" + format);\n    }\n    this.entryFormat = format;\n    this.blockSize = blockSize;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n}\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n    this.raw = new TapeInputStream(is);\n    this.hasHitEOF = false;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n    this.is = is;\n    this.hasHitEOF = false;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.recordSize = recordSize;\n    this.blockSize = blockSize;\n}\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n    out = new CountingOutputStream(os);\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.assemLen = 0;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordSize = recordSize;\n    this.recordsPerBlock = blockSize / recordSize;\n}\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.clear();\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -57,7 +57,7 @@\n             try {\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n-                if (tais.getNextTarEntry().isCheckSumOK()) {\n+                if (tais.getNextTarEntry() != null && tais.getNextTarEntry().isCheckSumOK()) {\n                     return new TarArchiveInputStream(in, encoding);\n                 }\n             } catch (Exception e) {\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n@@ -4,5 +4,5 @@\n     in = new PushbackInputStream(inputStream, buf.capacity());\n     this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n     // haven't read anything so far\n-    buf.limit(0);\n+    buf.clear();\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x) {\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x) {\n            return mid;\n        }\n        if (arr[mid] > x) {\n            return binarySearch(arr, l, mid - 1, x);\n        }\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            if (entryEncoding != null) {\n                return new TarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new TarArchiveInputStream(in);\n            }\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, entryEncoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature.\");\n}\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n    this.in = in;\n    this.blockSize = blockSize;\n    if (encoding != null) {\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    } else {\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding((String) null);\n    }\n}\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n    this.out = out;\n    switch (format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \" + format);\n    }\n    this.entryFormat = format;\n    this.blockSize = blockSize;\n    if (encoding != null) {\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    } else {\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding((String) null);\n    }\n}\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n    this.raw = new TapeInputStream(is);\n    this.hasHitEOF = false;\n    if (encoding != null) {\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    } else {\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding((String) null);\n    }\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n    this.is = is;\n    this.hasHitEOF = false;\n    if (encoding != null) {\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    } else {\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding((String) null);\n    }\n    this.recordSize = recordSize;\n    this.blockSize = blockSize;\n}\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n    out = new CountingOutputStream(os);\n    if (encoding != null) {\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    } else {\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding((String) null);\n    }\n    this.assemLen = 0;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordSize = recordSize;\n    this.recordsPerBlock = blockSize / recordSize;\n}\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    if (encoding != null) {\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    } else {\n        this.zipEncoding = ZipEncodingHelper.getZipEncoding((String) null);\n    }\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.limit(0);\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -49,7 +49,11 @@\n         signatureLength = IOUtils.readFully(in, tarheader);\n         in.reset();\n         if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n-            return new TarArchiveInputStream(in, entryEncoding);\n+            if (entryEncoding != null) {\n+                return new TarArchiveInputStream(in, entryEncoding);\n+            } else {\n+                return new TarArchiveInputStream(in);\n+            }\n         }\n         // COMPRESS-117 - improve auto-recognition\n         if (signatureLength >= 512) {\n@@ -58,7 +62,7 @@\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n                 if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+                    return new TarArchiveInputStream(in, entryEncoding);\n                 }\n             } catch (Exception e) {\n                 // NOPMD\n@@ -73,5 +77,5 @@\n     } catch (IOException e) {\n         throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n     }\n-    throw new ArchiveException(\"No Archiver found for the stream signature\");\n+    throw new ArchiveException(\"No Archiver found for the stream signature.\");\n }\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n@@ -1,5 +1,9 @@\n public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n     this.in = in;\n     this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    if (encoding != null) {\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    } else {\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding((String) null);\n+    }\n }\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n@@ -1,6 +1,6 @@\n public CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n     this.out = out;\n-    switch(format) {\n+    switch (format) {\n         case FORMAT_NEW:\n         case FORMAT_NEW_CRC:\n         case FORMAT_OLD_ASCII:\n@@ -11,5 +11,9 @@\n     }\n     this.entryFormat = format;\n     this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    if (encoding != null) {\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    } else {\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding((String) null);\n+    }\n }\n--- org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n+++ org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n@@ -1,7 +1,11 @@\n public DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n     this.raw = new TapeInputStream(is);\n     this.hasHitEOF = false;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    if (encoding != null) {\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    } else {\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding((String) null);\n+    }\n     try {\n         // read header, verify it's a dump archive.\n         byte[] headerBytes = raw.readRecord();\n--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n@@ -1,7 +1,11 @@\n public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n     this.is = is;\n     this.hasHitEOF = false;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    if (encoding != null) {\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    } else {\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding((String) null);\n+    }\n     this.recordSize = recordSize;\n     this.blockSize = blockSize;\n }\n--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n@@ -1,6 +1,10 @@\n public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n     out = new CountingOutputStream(os);\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    if (encoding != null) {\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    } else {\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding((String) null);\n+    }\n     this.assemLen = 0;\n     this.assemBuf = new byte[recordSize];\n     this.recordBuf = new byte[recordSize];\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n@@ -1,5 +1,9 @@\n public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n-    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    if (encoding != null) {\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    } else {\n+        this.zipEncoding = ZipEncodingHelper.getZipEncoding((String) null);\n+    }\n     this.useUnicodeExtraFields = useUnicodeExtraFields;\n     in = new PushbackInputStream(inputStream, buf.capacity());\n     this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, entryEncoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n    this.in = in;\n    this.blockSize = blockSize;\n    this.zipEncoding = encoding;\n}\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n    this.out = out;\n    switch(format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \" + format);\n    }\n    this.entryFormat = format;\n    this.blockSize = blockSize;\n    this.zipEncoding = encoding;\n}\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n    this.raw = new TapeInputStream(is);\n    this.hasHitEOF = false;\n    this.zipEncoding = encoding;\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n    this.is = is;\n    this.hasHitEOF = false;\n    this.zipEncoding = encoding;\n    this.recordSize = recordSize;\n    this.blockSize = blockSize;\n}\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n    out = new CountingOutputStream(os);\n    this.zipEncoding = encoding;\n    this.assemLen = 0;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordSize = recordSize;\n    this.recordsPerBlock = blockSize / recordSize;\n}\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding = encoding;\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.capacity());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.limit(0);\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -58,7 +58,7 @@\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n                 if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+                    return new TarArchiveInputStream(in, entryEncoding);\n                 }\n             } catch (Exception e) {\n                 // NOPMD\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n@@ -1,5 +1,5 @@\n public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n     this.in = in;\n     this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.zipEncoding = encoding;\n }\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n@@ -11,5 +11,5 @@\n     }\n     this.entryFormat = format;\n     this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.zipEncoding = encoding;\n }\n--- org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n+++ org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n@@ -1,7 +1,7 @@\n public DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n     this.raw = new TapeInputStream(is);\n     this.hasHitEOF = false;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.zipEncoding = encoding;\n     try {\n         // read header, verify it's a dump archive.\n         byte[] headerBytes = raw.readRecord();\n--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n@@ -1,7 +1,7 @@\n public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n     this.is = is;\n     this.hasHitEOF = false;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.zipEncoding = encoding;\n     this.recordSize = recordSize;\n     this.blockSize = blockSize;\n }\n--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n@@ -1,6 +1,6 @@\n public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n     out = new CountingOutputStream(os);\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.zipEncoding = encoding;\n     this.assemLen = 0;\n     this.assemBuf = new byte[recordSize];\n     this.recordBuf = new byte[recordSize];\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n@@ -1,5 +1,5 @@\n public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n-    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    zipEncoding = encoding;\n     this.useUnicodeExtraFields = useUnicodeExtraFields;\n     in = new PushbackInputStream(inputStream, buf.capacity());\n     this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n        if (arr[mid] == x)\n            return mid;\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n        return binarySearch(arr, mid + 1, r, x);\n    }\n    return -1;\n}\n\n\n## Fixed Function 2\npublic ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = IOUtils.readFully(in, signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new ZipArchiveInputStream(in, entryEncoding);\n            } else {\n                return new ZipArchiveInputStream(in);\n            }\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new JarArchiveInputStream(in, entryEncoding);\n            } else {\n                return new JarArchiveInputStream(in);\n            }\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            if (entryEncoding != null) {\n                return new CpioArchiveInputStream(in, entryEncoding);\n            } else {\n                return new CpioArchiveInputStream(in);\n            }\n        } else if (ArjArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArjArchiveInputStream(in);\n        } else if (SevenZFile.matches(signature, signatureLength)) {\n            throw new StreamingNotSupportedException(SEVEN_Z);\n        }\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = IOUtils.readFully(in, dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in, entryEncoding);\n        }\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = IOUtils.readFully(in, tarheader);\n        in.reset();\n        if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n            return new TarArchiveInputStream(in, entryEncoding);\n        }\n        // COMPRESS-117 - improve auto-recognition\n        if (signatureLength >= 512) {\n            TarArchiveInputStream tais = null;\n            try {\n                tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                // COMPRESS-191 - verify the header checksum\n                if (tais.getNextTarEntry() != null && tais.getNextTarEntry().isCheckSumOK()) {\n                    return new TarArchiveInputStream(in, entryEncoding);\n                }\n            } catch (Exception e) {\n                // NOPMD\n                // can generate IllegalArgumentException as well\n                // as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            } finally {\n                IOUtils.closeQuietly(tais);\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n\n## Fixed Function 3\npublic CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n    this.in = in;\n    this.blockSize = blockSize;\n    this.entryEncoding = encoding;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(entryEncoding);\n}\n\n## Fixed Function 4\npublic CpioArchiveOutputStream(final OutputStream out, final short format, final int blockSize, final String encoding) {\n    this.out = out;\n    switch(format) {\n        case FORMAT_NEW:\n        case FORMAT_NEW_CRC:\n        case FORMAT_OLD_ASCII:\n        case FORMAT_OLD_BINARY:\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown format: \" + format);\n    }\n    this.entryFormat = format;\n    this.blockSize = blockSize;\n    this.entryEncoding = encoding;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(entryEncoding);\n}\n\n## Fixed Function 5\npublic DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n    this.raw = new TapeInputStream(is);\n    this.hasHitEOF = false;\n    this.entryEncoding = encoding;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(entryEncoding);\n    try {\n        // read header, verify it's a dump archive.\n        byte[] headerBytes = raw.readRecord();\n        if (!DumpArchiveUtil.verify(headerBytes)) {\n            throw new UnrecognizedFormatException();\n        }\n        // get summary information\n        summary = new DumpArchiveSummary(headerBytes, this.zipEncoding);\n        // reset buffer with actual block size.\n        raw.resetBlockSize(summary.getNTRec(), summary.isCompressed());\n        // allocate our read buffer.\n        blockBuffer = new byte[4 * DumpArchiveConstants.TP_SIZE];\n        // skip past CLRI and BITS segments since we don't handle them yet.\n        readCLRI();\n        readBITS();\n    } catch (IOException ex) {\n        throw new ArchiveException(ex.getMessage(), ex);\n    }\n    // put in a dummy record for the root node.\n    Dirent root = new Dirent(2, 2, 4, \".\");\n    names.put(2, root);\n    // use priority based on queue to ensure parent directories are\n    // released first.\n    queue = new PriorityQueue<DumpArchiveEntry>(10, new Comparator<DumpArchiveEntry>() {\n\n        public int compare(DumpArchiveEntry p, DumpArchiveEntry q) {\n            if (p.getOriginalName() == null || q.getOriginalName() == null) {\n                return Integer.MAX_VALUE;\n            }\n            return p.getOriginalName().compareTo(q.getOriginalName());\n        }\n    });\n}\n\n## Fixed Function 6\npublic TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n    this.is = is;\n    this.hasHitEOF = false;\n    this.entryEncoding = encoding;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(entryEncoding);\n    this.recordSize = recordSize;\n    this.blockSize = blockSize;\n}\n\n## Fixed Function 7\npublic TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n    out = new CountingOutputStream(os);\n    this.entryEncoding = encoding;\n    this.zipEncoding = ZipEncodingHelper.getZipEncoding(entryEncoding);\n    this.assemLen = 0;\n    this.assemBuf = new byte[recordSize];\n    this.recordBuf = new byte[recordSize];\n    this.recordSize = recordSize;\n    this.recordsPerBlock = blockSize / recordSize;\n}\n\n## Fixed Function 8\npublic ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n    zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n    this.useUnicodeExtraFields = useUnicodeExtraFields;\n    in = new PushbackInputStream(inputStream, buf.length());\n    this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n    // haven't read anything so far\n    buf.limit(0);\n}", "diff": "--- org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n+++ org/apache/commons/compress/archivers/ArchiveStreamFactory.java@createArchiveInputStream\n@@ -57,8 +57,8 @@\n             try {\n                 tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                 // COMPRESS-191 - verify the header checksum\n-                if (tais.getNextTarEntry().isCheckSumOK()) {\n-                    return new TarArchiveInputStream(in, encoding);\n+                if (tais.getNextTarEntry() != null && tais.getNextTarEntry().isCheckSumOK()) {\n+                    return new TarArchiveInputStream(in, entryEncoding);\n                 }\n             } catch (Exception e) {\n                 // NOPMD\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java@CpioArchiveInputStream\n@@ -1,5 +1,6 @@\n public CpioArchiveInputStream(final InputStream in, int blockSize, String encoding) {\n     this.in = in;\n     this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = encoding;\n+    this.zipEncoding = ZipEncodingHelper.getZipEncoding(entryEncoding);\n }\n--- org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n+++ org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java@CpioArchiveOutputStream\n@@ -11,5 +11,6 @@\n     }\n     this.entryFormat = format;\n     this.blockSize = blockSize;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = encoding;\n+    this.zipEncoding = ZipEncodingHelper.getZipEncoding(entryEncoding);\n }\n--- org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n+++ org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java@DumpArchiveInputStream\n@@ -1,7 +1,8 @@\n public DumpArchiveInputStream(InputStream is, String encoding) throws ArchiveException {\n     this.raw = new TapeInputStream(is);\n     this.hasHitEOF = false;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = encoding;\n+    this.zipEncoding = ZipEncodingHelper.getZipEncoding(entryEncoding);\n     try {\n         // read header, verify it's a dump archive.\n         byte[] headerBytes = raw.readRecord();\n--- org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java@TarArchiveInputStream\n@@ -1,7 +1,8 @@\n public TarArchiveInputStream(InputStream is, int blockSize, int recordSize, String encoding) {\n     this.is = is;\n     this.hasHitEOF = false;\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = encoding;\n+    this.zipEncoding = ZipEncodingHelper.getZipEncoding(entryEncoding);\n     this.recordSize = recordSize;\n     this.blockSize = blockSize;\n }\n--- org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n+++ org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java@TarArchiveOutputStream\n@@ -1,6 +1,7 @@\n public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize, String encoding) {\n     out = new CountingOutputStream(os);\n-    this.zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n+    this.entryEncoding = encoding;\n+    this.zipEncoding = ZipEncodingHelper.getZipEncoding(entryEncoding);\n     this.assemLen = 0;\n     this.assemBuf = new byte[recordSize];\n     this.recordBuf = new byte[recordSize];\n--- org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java@ZipArchiveInputStream\n@@ -1,7 +1,7 @@\n public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields, boolean allowStoredEntriesWithDataDescriptor) {\n     zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n     this.useUnicodeExtraFields = useUnicodeExtraFields;\n-    in = new PushbackInputStream(inputStream, buf.capacity());\n+    in = new PushbackInputStream(inputStream, buf.length());\n     this.allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor;\n     // haven't read anything so far\n     buf.limit(0);\n", "finish_reason": "stop", "valid": false, "num": 1}]