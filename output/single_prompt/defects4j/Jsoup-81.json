[{"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, Charset.forName(charsetName)), bufferSize);\n        if (// creating the buffered reader ignores the input pos, so must skip here\n        bomCharset != null && bomCharset.offset)\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -58,7 +57,7 @@\n     if (doc == null) {\n         if (charsetName == null)\n             charsetName = defaultCharset;\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(input, Charset.forName(charsetName)), bufferSize);\n         if (// creating the buffered reader ignores the input pos, so must skip here\n         bomCharset != null && bomCharset.offset)\n             reader.skip(1);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (// creating the buffered reader ignores the input pos, so must skip here\n        bomCharset != null && bomCharset.offset)\n            reader.skip(bomCharset.offset);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -61,7 +60,7 @@\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n         if (// creating the buffered reader ignores the input pos, so must skip here\n         bomCharset != null && bomCharset.offset)\n-            reader.skip(1);\n+            reader.skip(bomCharset.offset);\n         try {\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n    }\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null) {\n                break;\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration) {\n                decl = (XmlDeclaration) first;\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\")) {\n                    foundCharset = decl.attr(\"encoding\");\n                }\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset) {\n            reader.skip(1);\n        }\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,7 +1,7 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null) {\n         return new Document(baseUri);\n+    }\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n@@ -13,8 +13,9 @@\n     input.reset();\n     // look for BOM - overrides any other header or input\n     BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n-    if (bomCharset != null)\n+    if (bomCharset != null) {\n         charsetName = bomCharset.charset;\n+    }\n     if (charsetName == null) {\n         // determine from meta. safe first parse as UTF-8\n         String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n@@ -24,22 +25,27 @@\n         // if not found, will keep utf-8 as best attempt\n         String foundCharset = null;\n         for (Element meta : metaElements) {\n-            if (meta.hasAttr(\"http-equiv\"))\n+            if (meta.hasAttr(\"http-equiv\")) {\n                 foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-            if (foundCharset == null && meta.hasAttr(\"charset\"))\n+            }\n+            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                 foundCharset = meta.attr(\"charset\");\n-            if (foundCharset != null)\n+            }\n+            if (foundCharset != null) {\n                 break;\n+            }\n         }\n         // look for <?xml encoding='ISO-8859-1'?>\n         if (foundCharset == null && doc.childNodeSize() > 0) {\n             Node first = doc.childNode(0);\n             XmlDeclaration decl = null;\n-            if (first instanceof XmlDeclaration)\n+            if (first instanceof XmlDeclaration) {\n                 decl = (XmlDeclaration) first;\n+            }\n             if (decl != null) {\n-                if (decl.name().equalsIgnoreCase(\"xml\"))\n+                if (decl.name().equalsIgnoreCase(\"xml\")) {\n                     foundCharset = decl.attr(\"encoding\");\n+                }\n             }\n         }\n         foundCharset = validateCharset(foundCharset);\n@@ -56,12 +62,13 @@\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n     }\n     if (doc == null) {\n-        if (charsetName == null)\n+        if (charsetName == null) {\n             charsetName = defaultCharset;\n+        }\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n+        if (bomCharset != null && bomCharset.offset) {\n             reader.skip(1);\n+        }\n         try {\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } \n        else if (!fullyRead) {\n            doc = null;\n        }\n        else {\n            charsetName = defaultCharset;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset)\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            throw e.ioException();\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,7 +1,7 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null) {\n         return new Document(baseUri);\n+    }\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n@@ -48,24 +48,24 @@\n             foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n             charsetName = foundCharset;\n             doc = null;\n-        } else if (!fullyRead) {\n+        } \n+        else if (!fullyRead) {\n             doc = null;\n+        }\n+        else {\n+            charsetName = defaultCharset;\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n     }\n     if (doc == null) {\n-        if (charsetName == null)\n-            charsetName = defaultCharset;\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n+        if (bomCharset != null && bomCharset.offset)\n             reader.skip(1);\n         try {\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n-            // io exception when parsing (not seen before because reading the stream as we go)\n             throw e.ioException();\n         }\n         doc.outputSettings().charset(charsetName);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset)\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.getCause(); // Use getCause() method instead of ioException()\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -59,14 +58,13 @@\n         if (charsetName == null)\n             charsetName = defaultCharset;\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n+        if (bomCharset != null && bomCharset.offset)\n             reader.skip(1);\n         try {\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n             // io exception when parsing (not seen before because reading the stream as we go)\n-            throw e.ioException();\n+            throw e.getCause(); // Use getCause() method instead of ioException()\n         }\n         doc.outputSettings().charset(charsetName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.getCause();\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -59,14 +58,13 @@\n         if (charsetName == null)\n             charsetName = defaultCharset;\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n+        if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n             reader.skip(1);\n         try {\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n             // io exception when parsing (not seen before because reading the stream as we go)\n-            throw e.ioException();\n+            throw e.getCause();\n         }\n         doc.outputSettings().charset(charsetName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n    }\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null) {\n                break;\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration) {\n                decl = (XmlDeclaration) first;\n            }\n            if (decl != null && decl.name().equalsIgnoreCase(\"xml\")) {\n                foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset) {\n            reader.skip(1);\n        }\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,7 +1,7 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null) {\n         return new Document(baseUri);\n+    }\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n@@ -13,8 +13,9 @@\n     input.reset();\n     // look for BOM - overrides any other header or input\n     BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n-    if (bomCharset != null)\n+    if (bomCharset != null) {\n         charsetName = bomCharset.charset;\n+    }\n     if (charsetName == null) {\n         // determine from meta. safe first parse as UTF-8\n         String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n@@ -24,22 +25,25 @@\n         // if not found, will keep utf-8 as best attempt\n         String foundCharset = null;\n         for (Element meta : metaElements) {\n-            if (meta.hasAttr(\"http-equiv\"))\n+            if (meta.hasAttr(\"http-equiv\")) {\n                 foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-            if (foundCharset == null && meta.hasAttr(\"charset\"))\n+            }\n+            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                 foundCharset = meta.attr(\"charset\");\n-            if (foundCharset != null)\n+            }\n+            if (foundCharset != null) {\n                 break;\n+            }\n         }\n         // look for <?xml encoding='ISO-8859-1'?>\n         if (foundCharset == null && doc.childNodeSize() > 0) {\n             Node first = doc.childNode(0);\n             XmlDeclaration decl = null;\n-            if (first instanceof XmlDeclaration)\n+            if (first instanceof XmlDeclaration) {\n                 decl = (XmlDeclaration) first;\n-            if (decl != null) {\n-                if (decl.name().equalsIgnoreCase(\"xml\"))\n-                    foundCharset = decl.attr(\"encoding\");\n+            }\n+            if (decl != null && decl.name().equalsIgnoreCase(\"xml\")) {\n+                foundCharset = decl.attr(\"encoding\");\n             }\n         }\n         foundCharset = validateCharset(foundCharset);\n@@ -56,12 +60,13 @@\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n     }\n     if (doc == null) {\n-        if (charsetName == null)\n+        if (charsetName == null) {\n             charsetName = defaultCharset;\n+        }\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n+        if (bomCharset != null && bomCharset.offset) {\n             reader.skip(1);\n+        }\n         try {\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    int bufferSize = 0;\n    if (input.markSupported()) {\n        if (input.available() == 0)\n            return new Document(baseUri);\n        input.mark(1);\n        if (input.read() == -1)\n            return new Document(baseUri);\n        input.reset();\n        bufferSize = input.available();\n        if (bufferSize > StreamUtil.LARGE_NODE_SIZE) {\n            // if the stream is over largest xml/html node size, cap it.\n            input = StreamUtil.capBuffer(input, StreamUtil.LARGE_NODE_SIZE);\n            bufferSize = StreamUtil.LARGE_NODE_SIZE;\n        }\n    }\n    input = new BufferedInputStream(input, bufferSize);\n    ParseSettings settings = parser.settings();\n    settings = settings != null ? settings : ParseSettings.htmlDefault;\n    Charset charset;\n    boolean fullyRead = false;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        charset = Charset.forName(defaultCharset);\n        ByteBuffer firstBytes = StreamUtil.consumeAsByteBuffer(input);\n        Document doc = parser.parseInput(new CharSequenceReader(firstBytes, charset), baseUri);\n        Element meta = doc.select(\"meta[charset]\").first();\n        if (meta != null) {\n            charset = Charset.forName(meta.attr(\"charset\"));\n        }\n        input.reset();\n        if (input.markSupported()) {\n            input.mark(bufferSize);\n        }\n    } else {\n        charset = Validate.notNull(Charset.forName(charsetName), \"charsetName must not be null\");\n    }\n    if (parser instanceof XmlTreeBuilder) {\n        return ((XmlTreeBuilder) parser).parse(input, charset, baseUri, settings);\n    } else if (parser instanceof HtmlTreeBuilder) {\n        return ((HtmlTreeBuilder) parser).parse(input, charset, baseUri, settings);\n    } else {\n        throw new IllegalStateException(\"Unexpected parser type: \" + parser.getClass().getName());\n    }\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,75 +1,47 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n-    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n-    Document doc = null;\n+    int bufferSize = 0;\n+    if (input.markSupported()) {\n+        if (input.available() == 0)\n+            return new Document(baseUri);\n+        input.mark(1);\n+        if (input.read() == -1)\n+            return new Document(baseUri);\n+        input.reset();\n+        bufferSize = input.available();\n+        if (bufferSize > StreamUtil.LARGE_NODE_SIZE) {\n+            // if the stream is over largest xml/html node size, cap it.\n+            input = StreamUtil.capBuffer(input, StreamUtil.LARGE_NODE_SIZE);\n+            bufferSize = StreamUtil.LARGE_NODE_SIZE;\n+        }\n+    }\n+    input = new BufferedInputStream(input, bufferSize);\n+    ParseSettings settings = parser.settings();\n+    settings = settings != null ? settings : ParseSettings.htmlDefault;\n+    Charset charset;\n     boolean fullyRead = false;\n-    // read the start of the stream and look for a BOM or meta charset\n-    input.mark(bufferSize);\n-    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n-    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n-    fullyRead = input.read() == -1;\n-    input.reset();\n-    // look for BOM - overrides any other header or input\n-    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n-    if (bomCharset != null)\n-        charsetName = bomCharset.charset;\n     if (charsetName == null) {\n         // determine from meta. safe first parse as UTF-8\n-        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n-        doc = parser.parseInput(docData, baseUri);\n-        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n-        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n-        // if not found, will keep utf-8 as best attempt\n-        String foundCharset = null;\n-        for (Element meta : metaElements) {\n-            if (meta.hasAttr(\"http-equiv\"))\n-                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-            if (foundCharset == null && meta.hasAttr(\"charset\"))\n-                foundCharset = meta.attr(\"charset\");\n-            if (foundCharset != null)\n-                break;\n+        charset = Charset.forName(defaultCharset);\n+        ByteBuffer firstBytes = StreamUtil.consumeAsByteBuffer(input);\n+        Document doc = parser.parseInput(new CharSequenceReader(firstBytes, charset), baseUri);\n+        Element meta = doc.select(\"meta[charset]\").first();\n+        if (meta != null) {\n+            charset = Charset.forName(meta.attr(\"charset\"));\n         }\n-        // look for <?xml encoding='ISO-8859-1'?>\n-        if (foundCharset == null && doc.childNodeSize() > 0) {\n-            Node first = doc.childNode(0);\n-            XmlDeclaration decl = null;\n-            if (first instanceof XmlDeclaration)\n-                decl = (XmlDeclaration) first;\n-            if (decl != null) {\n-                if (decl.name().equalsIgnoreCase(\"xml\"))\n-                    foundCharset = decl.attr(\"encoding\");\n-            }\n-        }\n-        foundCharset = validateCharset(foundCharset);\n-        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n-            // need to re-decode. (case insensitive check here to match how validate works)\n-            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n-            charsetName = foundCharset;\n-            doc = null;\n-        } else if (!fullyRead) {\n-            doc = null;\n+        input.reset();\n+        if (input.markSupported()) {\n+            input.mark(bufferSize);\n         }\n     } else {\n-        // specified by content type header (or by user on file load)\n-        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n+        charset = Validate.notNull(Charset.forName(charsetName), \"charsetName must not be null\");\n     }\n-    if (doc == null) {\n-        if (charsetName == null)\n-            charsetName = defaultCharset;\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n-            reader.skip(1);\n-        try {\n-            doc = parser.parseInput(reader, baseUri);\n-        } catch (UncheckedIOException e) {\n-            // io exception when parsing (not seen before because reading the stream as we go)\n-            throw e.ioException();\n-        }\n-        doc.outputSettings().charset(charsetName);\n+    if (parser instanceof XmlTreeBuilder) {\n+        return ((XmlTreeBuilder) parser).parse(input, charset, baseUri, settings);\n+    } else if (parser instanceof HtmlTreeBuilder) {\n+        return ((HtmlTreeBuilder) parser).parse(input, charset, baseUri, settings);\n+    } else {\n+        throw new IllegalStateException(\"Unexpected parser type: \" + parser.getClass().getName());\n     }\n-    input.close();\n-    return doc;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, Charset.forName(charsetName)), bufferSize);\n        if (bomCharset != null && bomCharset.offset)\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            throw e.ioException();\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -58,14 +57,12 @@\n     if (doc == null) {\n         if (charsetName == null)\n             charsetName = defaultCharset;\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(input, Charset.forName(charsetName)), bufferSize);\n+        if (bomCharset != null && bomCharset.offset)\n             reader.skip(1);\n         try {\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n-            // io exception when parsing (not seen before because reading the stream as we go)\n             throw e.ioException();\n         }\n         doc.outputSettings().charset(charsetName);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset();\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset())\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.getCause();\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}\n## Explanation\nThe first buggy function has a problem on line 3 where it'll perform an incorrect calculation when finding the midpoint index for binary search algorithms, as it should be `(l + r) / 2` instead of `l + (r + l) / 2`. The second buggy function has a number of issues on lines 7, 19, and 92. On line 7, the if statement's condition is empty, which will cause an error. On line 19, `bomCharset.charset()` should be called instead of `bomCharset.charset`. Finally, on line 92, e.getCause() should be called instead of e.ioException().", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -14,7 +13,7 @@\n     // look for BOM - overrides any other header or input\n     BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n     if (bomCharset != null)\n-        charsetName = bomCharset.charset;\n+        charsetName = bomCharset.charset();\n     if (charsetName == null) {\n         // determine from meta. safe first parse as UTF-8\n         String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n@@ -59,14 +58,13 @@\n         if (charsetName == null)\n             charsetName = defaultCharset;\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n+        if (bomCharset != null && bomCharset.offset())\n             reader.skip(1);\n         try {\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n             // io exception when parsing (not seen before because reading the stream as we go)\n-            throw e.ioException();\n+            throw e.getCause();\n         }\n         doc.outputSettings().charset(charsetName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    input.mark(bufferSize);\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n     }\n    if (charsetName == null) {\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null) {\n                break;\n            }\n        }\n \n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration) {\n                decl = (XmlDeclaration) first;\n                if (decl.name().equalsIgnoreCase(\"xml\")) {\n                    foundCharset = decl.attr(\"encoding\");\n                }\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset) {\n            reader.skip(1);\n        }\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            throw e.ioException();\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,50 +1,47 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null) {\n         return new Document(baseUri);\n+    }\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n-    // read the start of the stream and look for a BOM or meta charset\n     input.mark(bufferSize);\n-    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n     ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n     fullyRead = input.read() == -1;\n     input.reset();\n-    // look for BOM - overrides any other header or input\n     BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n-    if (bomCharset != null)\n+    if (bomCharset != null) {\n         charsetName = bomCharset.charset;\n+     }\n     if (charsetName == null) {\n-        // determine from meta. safe first parse as UTF-8\n         String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n         doc = parser.parseInput(docData, baseUri);\n-        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n         Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n-        // if not found, will keep utf-8 as best attempt\n         String foundCharset = null;\n         for (Element meta : metaElements) {\n-            if (meta.hasAttr(\"http-equiv\"))\n+            if (meta.hasAttr(\"http-equiv\")) {\n                 foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-            if (foundCharset == null && meta.hasAttr(\"charset\"))\n+            }\n+            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                 foundCharset = meta.attr(\"charset\");\n-            if (foundCharset != null)\n+            }\n+            if (foundCharset != null) {\n                 break;\n+            }\n         }\n-        // look for <?xml encoding='ISO-8859-1'?>\n+ \n         if (foundCharset == null && doc.childNodeSize() > 0) {\n             Node first = doc.childNode(0);\n             XmlDeclaration decl = null;\n-            if (first instanceof XmlDeclaration)\n+            if (first instanceof XmlDeclaration) {\n                 decl = (XmlDeclaration) first;\n-            if (decl != null) {\n-                if (decl.name().equalsIgnoreCase(\"xml\"))\n+                if (decl.name().equalsIgnoreCase(\"xml\")) {\n                     foundCharset = decl.attr(\"encoding\");\n+                }\n             }\n         }\n         foundCharset = validateCharset(foundCharset);\n         if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n-            // need to re-decode. (case insensitive check here to match how validate works)\n             foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n             charsetName = foundCharset;\n             doc = null;\n@@ -52,20 +49,19 @@\n             doc = null;\n         }\n     } else {\n-        // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n     }\n     if (doc == null) {\n-        if (charsetName == null)\n+        if (charsetName == null) {\n             charsetName = defaultCharset;\n+        }\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n+        if (bomCharset != null && bomCharset.offset) {\n             reader.skip(1);\n+        }\n         try {\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n-            // io exception when parsing (not seen before because reading the stream as we go)\n             throw e.ioException();\n         }\n         doc.outputSettings().charset(charsetName);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n    }\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null) {\n                break;\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration) {\n                decl = (XmlDeclaration) first;\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\")) {\n                    foundCharset = decl.attr(\"encoding\");\n                }\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (// creating the buffered reader ignores the input pos, so must skip here\n        bomCharset != null && bomCharset.offset) {\n            reader.skip(1);\n        }\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,7 +1,7 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null) {\n         return new Document(baseUri);\n+    }\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n@@ -13,8 +13,9 @@\n     input.reset();\n     // look for BOM - overrides any other header or input\n     BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n-    if (bomCharset != null)\n+    if (bomCharset != null) {\n         charsetName = bomCharset.charset;\n+    }\n     if (charsetName == null) {\n         // determine from meta. safe first parse as UTF-8\n         String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n@@ -24,22 +25,27 @@\n         // if not found, will keep utf-8 as best attempt\n         String foundCharset = null;\n         for (Element meta : metaElements) {\n-            if (meta.hasAttr(\"http-equiv\"))\n+            if (meta.hasAttr(\"http-equiv\")) {\n                 foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-            if (foundCharset == null && meta.hasAttr(\"charset\"))\n+            }\n+            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                 foundCharset = meta.attr(\"charset\");\n-            if (foundCharset != null)\n+            }\n+            if (foundCharset != null) {\n                 break;\n+            }\n         }\n         // look for <?xml encoding='ISO-8859-1'?>\n         if (foundCharset == null && doc.childNodeSize() > 0) {\n             Node first = doc.childNode(0);\n             XmlDeclaration decl = null;\n-            if (first instanceof XmlDeclaration)\n+            if (first instanceof XmlDeclaration) {\n                 decl = (XmlDeclaration) first;\n+            }\n             if (decl != null) {\n-                if (decl.name().equalsIgnoreCase(\"xml\"))\n+                if (decl.name().equalsIgnoreCase(\"xml\")) {\n                     foundCharset = decl.attr(\"encoding\");\n+                }\n             }\n         }\n         foundCharset = validateCharset(foundCharset);\n@@ -56,12 +62,14 @@\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n     }\n     if (doc == null) {\n-        if (charsetName == null)\n+        if (charsetName == null) {\n             charsetName = defaultCharset;\n+        }\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n         if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n+        bomCharset != null && bomCharset.offset) {\n             reader.skip(1);\n+        }\n         try {\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset && input.markSupported())\n            input.reset();\n        if (// creating the buffered reader ignores the input pos, so must skip here\n        bomCharset != null && bomCharset.offset)\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -59,6 +58,8 @@\n         if (charsetName == null)\n             charsetName = defaultCharset;\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n+        if (bomCharset != null && bomCharset.offset && input.markSupported())\n+            input.reset();\n         if (// creating the buffered reader ignores the input pos, so must skip here\n         bomCharset != null && bomCharset.offset)\n             reader.skip(1);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, bufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset)\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.getCause();\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -8,7 +7,7 @@\n     // read the start of the stream and look for a BOM or meta charset\n     input.mark(bufferSize);\n     // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n-    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n+    ByteBuffer firstBytes = readToByteBuffer(input, bufferSize - 1);\n     fullyRead = input.read() == -1;\n     input.reset();\n     // look for BOM - overrides any other header or input\n@@ -59,14 +58,13 @@\n         if (charsetName == null)\n             charsetName = defaultCharset;\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n+        if (bomCharset != null && bomCharset.offset)\n             reader.skip(1);\n         try {\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n             // io exception when parsing (not seen before because reading the stream as we go)\n-            throw e.ioException();\n+            throw e.getCause();\n         }\n         doc.outputSettings().charset(charsetName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n    }\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null) {\n                break;\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration) {\n                decl = (XmlDeclaration) first;\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\")) {\n                    foundCharset = decl.attr(\"encoding\");\n                }\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        // creating the buffered reader ignores the input pos, so must skip here\n        if (bomCharset != null && bomCharset.offset) {\n            reader.skip(1);\n        }\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,7 +1,7 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null) {\n         return new Document(baseUri);\n+    }\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n@@ -13,8 +13,9 @@\n     input.reset();\n     // look for BOM - overrides any other header or input\n     BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n-    if (bomCharset != null)\n+    if (bomCharset != null) {\n         charsetName = bomCharset.charset;\n+    }\n     if (charsetName == null) {\n         // determine from meta. safe first parse as UTF-8\n         String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n@@ -24,22 +25,27 @@\n         // if not found, will keep utf-8 as best attempt\n         String foundCharset = null;\n         for (Element meta : metaElements) {\n-            if (meta.hasAttr(\"http-equiv\"))\n+            if (meta.hasAttr(\"http-equiv\")) {\n                 foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-            if (foundCharset == null && meta.hasAttr(\"charset\"))\n+            }\n+            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                 foundCharset = meta.attr(\"charset\");\n-            if (foundCharset != null)\n+            }\n+            if (foundCharset != null) {\n                 break;\n+            }\n         }\n         // look for <?xml encoding='ISO-8859-1'?>\n         if (foundCharset == null && doc.childNodeSize() > 0) {\n             Node first = doc.childNode(0);\n             XmlDeclaration decl = null;\n-            if (first instanceof XmlDeclaration)\n+            if (first instanceof XmlDeclaration) {\n                 decl = (XmlDeclaration) first;\n+            }\n             if (decl != null) {\n-                if (decl.name().equalsIgnoreCase(\"xml\"))\n+                if (decl.name().equalsIgnoreCase(\"xml\")) {\n                     foundCharset = decl.attr(\"encoding\");\n+                }\n             }\n         }\n         foundCharset = validateCharset(foundCharset);\n@@ -56,12 +62,14 @@\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n     }\n     if (doc == null) {\n-        if (charsetName == null)\n+        if (charsetName == null) {\n             charsetName = defaultCharset;\n+        }\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n+        // creating the buffered reader ignores the input pos, so must skip here\n+        if (bomCharset != null && bomCharset.offset) {\n             reader.skip(1);\n+        }\n         try {\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (// creating the buffered reader ignores the input pos, so must skip here\n        bomCharset != null && bomCharset.offset)\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.getCause(); // getting the cause of the unchecked exception\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -66,7 +65,7 @@\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n             // io exception when parsing (not seen before because reading the stream as we go)\n-            throw e.ioException();\n+            throw e.getCause(); // getting the cause of the unchecked exception\n         }\n         doc.outputSettings().charset(charsetName);\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset)\n            reader.skip(bomCharset.length);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -59,9 +58,8 @@\n         if (charsetName == null)\n             charsetName = defaultCharset;\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n-            reader.skip(1);\n+        if (bomCharset != null && bomCharset.offset)\n+            reader.skip(bomCharset.length);\n         try {\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset) {\n            int skipped = (int) reader.skip(1);\n            if (skipped != 1) {\n                throw new AssertionError(\"Test should have been guarding against this!\");\n            }\n        }\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -59,9 +58,12 @@\n         if (charsetName == null)\n             charsetName = defaultCharset;\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n-            reader.skip(1);\n+        if (bomCharset != null && bomCharset.offset) {\n+            int skipped = (int) reader.skip(1);\n+            if (skipped != 1) {\n+                throw new AssertionError(\"Test should have been guarding against this!\");\n+            }\n+        }\n         try {\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset && reader.read() != '\\ufeff')\n            reader.reset();\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        doc.outputSettings().charset(charsetName);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -59,9 +58,8 @@\n         if (charsetName == null)\n             charsetName = defaultCharset;\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n-            reader.skip(1);\n+        if (bomCharset != null && bomCharset.offset && reader.read() != '\\ufeff')\n+            reader.reset();\n         try {\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n", "finish_reason": "stop", "valid": false, "num": 1}]