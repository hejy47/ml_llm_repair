[{"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        pushScope(n);  // push scope first\n        traverseBranch(fnName, n);\n        popScope();   // then pop scope\n    } else {\n        pushScope(n); // push scope for expression functions too\n    }\n    curNode = n;\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    if (isFunctionExpression) {\n        popScope(); // pop scope at the end for expression functions\n    }\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    pushScope(lp);  // push scope for function parameters\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    popScope();   // pop scope for function parameters\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -5,10 +5,13 @@\n     boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n     if (!isFunctionExpression) {\n         // Functions declarations are in the scope containing the declaration.\n+        pushScope(n);  // push scope first\n         traverseBranch(fnName, n);\n+        popScope();   // then pop scope\n+    } else {\n+        pushScope(n); // push scope for expression functions too\n     }\n     curNode = n;\n-    pushScope(n);\n     if (isFunctionExpression) {\n         // Function expression names are only accessible within the function\n         // scope.\n@@ -21,5 +24,7 @@\n     // Body\n     Preconditions.checkState(body.getNext() == null && body.isBlock());\n     traverseBranch(body, n);\n-    popScope();\n+    if (isFunctionExpression) {\n+        popScope(); // pop scope at the end for expression functions\n+    }\n }\n--- com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n+++ com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n@@ -42,6 +42,7 @@\n     }\n     int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n     lp.setCharno(position2charno(lparenCharno));\n+    pushScope(lp);  // push scope for function parameters\n     for (AstNode param : functionNode.getParams()) {\n         lp.addChildToBack(transform(param));\n     }\n@@ -52,5 +53,6 @@\n     // Parser#parseFunctionBodyExpr.\n     parseDirectives(bodyNode);\n     node.addChildToBack(bodyNode);\n+    popScope();   // pop scope for function parameters\n     return node;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        pushScope(parent);  // push the parent scope instead\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -12,6 +12,7 @@\n     if (isFunctionExpression) {\n         // Function expression names are only accessible within the function\n         // scope.\n+        pushScope(parent);  // push the parent scope instead\n         traverseBranch(fnName, n);\n     }\n     final Node args = fnName.getNext();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    // Check that n is a function node before checking its child count\n    Preconditions.checkState(n.isFunction());\n    Preconditions.checkState(n.getChildCount() == 3);\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EMPTY);\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -1,6 +1,7 @@\n private void traverseFunction(Node n, Node parent) {\n+    // Check that n is a function node before checking its child count\n+    Preconditions.checkState(n.isFunction());\n     Preconditions.checkState(n.getChildCount() == 3);\n-    Preconditions.checkState(n.isFunction());\n     final Node fnName = n.getFirstChild();\n     boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n     if (!isFunctionExpression) {\n--- com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n+++ com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n@@ -7,7 +7,7 @@\n         if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n             errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n             // Return the bare minimum to put the AST in a valid state.\n-            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n+            return newNode(Token.EMPTY);\n         }\n         name = new Name();\n         name.setIdentifier(\"\");\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        pushScope(fnName);\n        traverseBranch(fnName.getNext(), n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n    if (isFunctionExpression) {\n        popScope();\n    }\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n        lp.setCharno(fnName.getLength() + functionNode.getAbsolutePosition());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n        int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n        lp.setCharno(position2charno(lparenCharno));\n    }\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -12,7 +12,8 @@\n     if (isFunctionExpression) {\n         // Function expression names are only accessible within the function\n         // scope.\n-        traverseBranch(fnName, n);\n+        pushScope(fnName);\n+        traverseBranch(fnName.getNext(), n);\n     }\n     final Node args = fnName.getNext();\n     final Node body = args.getNext();\n@@ -22,4 +23,7 @@\n     Preconditions.checkState(body.getNext() == null && body.isBlock());\n     traverseBranch(body, n);\n     popScope();\n+    if (isFunctionExpression) {\n+        popScope();\n+    }\n }\n--- com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n+++ com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n@@ -37,11 +37,12 @@\n     Name fnName = functionNode.getFunctionName();\n     if (fnName != null) {\n         lp.setLineno(fnName.getLineno());\n+        lp.setCharno(fnName.getLength() + functionNode.getAbsolutePosition());\n     } else {\n         lp.setLineno(functionNode.getLineno());\n+        int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n+        lp.setCharno(position2charno(lparenCharno));\n     }\n-    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n-    lp.setCharno(position2charno(lparenCharno));\n     for (AstNode param : functionNode.getParams()) {\n         lp.addChildToBack(transform(param));\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        pushScope(fnName);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNumber(0);\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = new Node(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2Charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = new Node(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n        lp.setCharno(fnName.getCharno() + fnName.getLength());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n        lp.setCharno(newName.getCharno() + newName.getLength());\n    }\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -12,7 +12,7 @@\n     if (isFunctionExpression) {\n         // Function expression names are only accessible within the function\n         // scope.\n-        traverseBranch(fnName, n);\n+        pushScope(fnName);\n     }\n     final Node args = fnName.getNext();\n     final Node body = args.getNext();\n--- com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n+++ com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n@@ -1,19 +1,19 @@\n @Override\n Node processFunctionNode(FunctionNode functionNode) {\n     Name name = functionNode.getFunctionName();\n-    Boolean isUnnamedFunction = false;\n+    boolean isUnnamedFunction = false;\n     if (name == null) {\n         int functionType = functionNode.getFunctionType();\n         if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n             errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n             // Return the bare minimum to put the AST in a valid state.\n-            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n+            return newNumber(0);\n         }\n         name = new Name();\n         name.setIdentifier(\"\");\n         isUnnamedFunction = true;\n     }\n-    Node node = newNode(Token.FUNCTION);\n+    Node node = new Node(Token.FUNCTION);\n     Node newName = transform(name);\n     if (isUnnamedFunction) {\n         // Old Rhino tagged the empty name node with the line number of the\n@@ -23,11 +23,11 @@\n         // Same problem as below - the left paren might not be on the\n         // same line as the function keyword.\n         int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n-        newName.setCharno(position2charno(lpColumn));\n+        newName.setCharno(position2Charno(lpColumn));\n         maybeSetLengthFrom(newName, name);\n     }\n     node.addChildToBack(newName);\n-    Node lp = newNode(Token.PARAM_LIST);\n+    Node lp = new Node(Token.PARAM_LIST);\n     // The left paren's complicated because it's not represented by an\n     // AstNode, so there's nothing that has the actual line number that it\n     // appeared on.  We know the paren has to appear on the same line as the\n@@ -37,11 +37,11 @@\n     Name fnName = functionNode.getFunctionName();\n     if (fnName != null) {\n         lp.setLineno(fnName.getLineno());\n+        lp.setCharno(fnName.getCharno() + fnName.getLength());\n     } else {\n         lp.setLineno(functionNode.getLineno());\n+        lp.setCharno(newName.getCharno() + newName.getLength());\n     }\n-    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n-    lp.setCharno(position2charno(lparenCharno));\n     for (AstNode param : functionNode.getParams()) {\n         lp.addChildToBack(transform(param));\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(NodeUtil.isFunctionDeclaration(n) || NodeUtil.isFunctionExpression(n));\n    final Node fnName = n.getFirstChild();\n    if (NodeUtil.isFunctionDeclaration(n)) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (NodeUtil.isFunctionExpression(n)) {\n        // Function expression names are only accessible within the function\n        // scope.\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        newName.setLineno(functionNode.getLineno());\n        // Get the character position of the left parenthesis instead of the identifier\n        int lpColumn = functionNode.fn.getToken().getCharPosition() + functionNode.fn.getLength();\n        newName.setCharno(lpColumn);\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    lp.setLineno(functionNode.getLineno());\n    int lparenCharno = -1;\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n        if (lparenCharno == -1) {\n            lparenCharno = param.getPosition() + param.getLength();\n        }\n    }\n    lp.setCharno(lparenCharno);\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode, functionNode.getFunctionType());\n    node.addChildToBack(bodyNode);\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -1,15 +1,14 @@\n private void traverseFunction(Node n, Node parent) {\n     Preconditions.checkState(n.getChildCount() == 3);\n-    Preconditions.checkState(n.isFunction());\n+    Preconditions.checkState(NodeUtil.isFunctionDeclaration(n) || NodeUtil.isFunctionExpression(n));\n     final Node fnName = n.getFirstChild();\n-    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n-    if (!isFunctionExpression) {\n+    if (NodeUtil.isFunctionDeclaration(n)) {\n         // Functions declarations are in the scope containing the declaration.\n         traverseBranch(fnName, n);\n     }\n     curNode = n;\n     pushScope(n);\n-    if (isFunctionExpression) {\n+    if (NodeUtil.isFunctionExpression(n)) {\n         // Function expression names are only accessible within the function\n         // scope.\n         traverseBranch(fnName, n);\n--- com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n+++ com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n@@ -16,41 +16,29 @@\n     Node node = newNode(Token.FUNCTION);\n     Node newName = transform(name);\n     if (isUnnamedFunction) {\n-        // Old Rhino tagged the empty name node with the line number of the\n-        // declaration.\n         newName.setLineno(functionNode.getLineno());\n-        // TODO(bowdidge) Mark line number of paren correctly.\n-        // Same problem as below - the left paren might not be on the\n-        // same line as the function keyword.\n-        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n-        newName.setCharno(position2charno(lpColumn));\n+        // Get the character position of the left parenthesis instead of the identifier\n+        int lpColumn = functionNode.fn.getToken().getCharPosition() + functionNode.fn.getLength();\n+        newName.setCharno(lpColumn);\n         maybeSetLengthFrom(newName, name);\n     }\n     node.addChildToBack(newName);\n     Node lp = newNode(Token.PARAM_LIST);\n-    // The left paren's complicated because it's not represented by an\n-    // AstNode, so there's nothing that has the actual line number that it\n-    // appeared on.  We know the paren has to appear on the same line as the\n-    // function name (or else a semicolon will be inserted.)  If there's no\n-    // function name, assume the paren was on the same line as the function.\n-    // TODO(bowdidge): Mark line number of paren correctly.\n-    Name fnName = functionNode.getFunctionName();\n-    if (fnName != null) {\n-        lp.setLineno(fnName.getLineno());\n-    } else {\n-        lp.setLineno(functionNode.getLineno());\n-    }\n-    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n-    lp.setCharno(position2charno(lparenCharno));\n+    lp.setLineno(functionNode.getLineno());\n+    int lparenCharno = -1;\n     for (AstNode param : functionNode.getParams()) {\n         lp.addChildToBack(transform(param));\n+        if (lparenCharno == -1) {\n+            lparenCharno = param.getPosition() + param.getLength();\n+        }\n     }\n+    lp.setCharno(lparenCharno);\n     node.addChildToBack(lp);\n     Node bodyNode = transform(functionNode.getBody());\n     // When in ideMode Rhino tries to parse some constructs the compiler\n     // doesn't support, repair it here. see Rhino's\n     // Parser#parseFunctionBodyExpr.\n-    parseDirectives(bodyNode);\n+    parseDirectives(bodyNode, functionNode.getFunctionType());\n     node.addChildToBack(bodyNode);\n     return node;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        pushScope(n); // push a new scope for function expression name\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n    if (isFunctionExpression) {\n        // pop the scope for function expression name\n        popScope();\n    }\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n        lp.setCharno(fnName.getCharno()+fnName.getLength()); // set charno after the function name\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -12,6 +12,7 @@\n     if (isFunctionExpression) {\n         // Function expression names are only accessible within the function\n         // scope.\n+        pushScope(n); // push a new scope for function expression name\n         traverseBranch(fnName, n);\n     }\n     final Node args = fnName.getNext();\n@@ -22,4 +23,8 @@\n     Preconditions.checkState(body.getNext() == null && body.isBlock());\n     traverseBranch(body, n);\n     popScope();\n+    if (isFunctionExpression) {\n+        // pop the scope for function expression name\n+        popScope();\n+    }\n }\n--- com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n+++ com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n@@ -37,11 +37,10 @@\n     Name fnName = functionNode.getFunctionName();\n     if (fnName != null) {\n         lp.setLineno(fnName.getLineno());\n+        lp.setCharno(fnName.getCharno()+fnName.getLength()); // set charno after the function name\n     } else {\n         lp.setLineno(functionNode.getLineno());\n     }\n-    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n-    lp.setCharno(position2charno(lparenCharno));\n     for (AstNode param : functionNode.getParams()) {\n         lp.addChildToBack(transform(param));\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        rewriteChildren(n);\n        traverseBranch(fnName.getFirstChild(), n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    rewriteChildren(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -12,7 +12,8 @@\n     if (isFunctionExpression) {\n         // Function expression names are only accessible within the function\n         // scope.\n-        traverseBranch(fnName, n);\n+        rewriteChildren(n);\n+        traverseBranch(fnName.getFirstChild(), n);\n     }\n     final Node args = fnName.getNext();\n     final Node body = args.getNext();\n--- com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n+++ com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n@@ -51,6 +51,7 @@\n     // doesn't support, repair it here. see Rhino's\n     // Parser#parseFunctionBodyExpr.\n     parseDirectives(bodyNode);\n+    rewriteChildren(bodyNode);\n     node.addChildToBack(bodyNode);\n     return node;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.hasChildren());\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        traverseBranch(fnName);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    if (args.hasChildren()) {\n        traverseBranch(args);\n    }\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    if (body.hasChildren()){\n        traverseBranch(body);\n    }\n    popScope();\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null || isBlankName(name)) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EMPTY, functionNode.getLineno());\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    int parentLineno = functionNode.getLineno();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n        parentLineno = fnName.getLineno();\n    } else {\n        lp.setLineno(parentLineno);\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    node.setLineno(parentLineno);\n    return node;\n}\n\n# Helper Function\n\nprivate boolean isBlankName(Name name) {\n    return name.getIdentifier() == null || name.getIdentifier().trim().isEmpty();\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -1,25 +1,30 @@\n private void traverseFunction(Node n, Node parent) {\n+    Preconditions.checkState(n.hasChildren());\n     Preconditions.checkState(n.getChildCount() == 3);\n     Preconditions.checkState(n.isFunction());\n     final Node fnName = n.getFirstChild();\n     boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n     if (!isFunctionExpression) {\n         // Functions declarations are in the scope containing the declaration.\n-        traverseBranch(fnName, n);\n+        traverseBranch(fnName);\n     }\n     curNode = n;\n     pushScope(n);\n     if (isFunctionExpression) {\n         // Function expression names are only accessible within the function\n         // scope.\n-        traverseBranch(fnName, n);\n+        traverseBranch(fnName);\n     }\n     final Node args = fnName.getNext();\n     final Node body = args.getNext();\n     // Args\n-    traverseBranch(args, n);\n+    if (args.hasChildren()) {\n+        traverseBranch(args);\n+    }\n     // Body\n     Preconditions.checkState(body.getNext() == null && body.isBlock());\n-    traverseBranch(body, n);\n+    if (body.hasChildren()){\n+        traverseBranch(body);\n+    }\n     popScope();\n }\n--- com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n+++ com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n@@ -2,12 +2,12 @@\n Node processFunctionNode(FunctionNode functionNode) {\n     Name name = functionNode.getFunctionName();\n     Boolean isUnnamedFunction = false;\n-    if (name == null) {\n+    if (name == null || isBlankName(name)) {\n         int functionType = functionNode.getFunctionType();\n         if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n             errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n             // Return the bare minimum to put the AST in a valid state.\n-            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n+            return newNode(Token.EMPTY, functionNode.getLineno());\n         }\n         name = new Name();\n         name.setIdentifier(\"\");\n@@ -35,10 +35,12 @@\n     // function name, assume the paren was on the same line as the function.\n     // TODO(bowdidge): Mark line number of paren correctly.\n     Name fnName = functionNode.getFunctionName();\n+    int parentLineno = functionNode.getLineno();\n     if (fnName != null) {\n         lp.setLineno(fnName.getLineno());\n+        parentLineno = fnName.getLineno();\n     } else {\n-        lp.setLineno(functionNode.getLineno());\n+        lp.setLineno(parentLineno);\n     }\n     int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n     lp.setCharno(position2charno(lparenCharno));\n@@ -52,5 +54,6 @@\n     // Parser#parseFunctionBodyExpr.\n     parseDirectives(bodyNode);\n     node.addChildToBack(bodyNode);\n+    node.setLineno(parentLineno);\n     return node;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        pushScope(fnName);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    if (isFunctionExpression) {\n        popScope();\n    }\n    popScope();\n}\n\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    pushScope(functionNode);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    popScope();\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -12,7 +12,7 @@\n     if (isFunctionExpression) {\n         // Function expression names are only accessible within the function\n         // scope.\n-        traverseBranch(fnName, n);\n+        pushScope(fnName);\n     }\n     final Node args = fnName.getNext();\n     final Node body = args.getNext();\n@@ -21,5 +21,8 @@\n     // Body\n     Preconditions.checkState(body.getNext() == null && body.isBlock());\n     traverseBranch(body, n);\n+    if (isFunctionExpression) {\n+        popScope();\n+    }\n     popScope();\n }\n--- com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n+++ com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n@@ -46,11 +46,13 @@\n         lp.addChildToBack(transform(param));\n     }\n     node.addChildToBack(lp);\n+    pushScope(functionNode);\n     Node bodyNode = transform(functionNode.getBody());\n     // When in ideMode Rhino tries to parse some constructs the compiler\n     // doesn't support, repair it here. see Rhino's\n     // Parser#parseFunctionBodyExpr.\n     parseDirectives(bodyNode);\n     node.addChildToBack(bodyNode);\n+    popScope();\n     return node;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        pushScope(fnName); // fix\n        traverseBranch(fnName.getNext(), n); // fix\n        popScope(); // fix\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}\n\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n        // add name to current scope fix\n        addToScope(name, newName, Scope.NamedSymbolKind.FUNCTION_DECLARATION); // fix\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -12,7 +12,9 @@\n     if (isFunctionExpression) {\n         // Function expression names are only accessible within the function\n         // scope.\n-        traverseBranch(fnName, n);\n+        pushScope(fnName); // fix\n+        traverseBranch(fnName.getNext(), n); // fix\n+        popScope(); // fix\n     }\n     final Node args = fnName.getNext();\n     final Node body = args.getNext();\n--- com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n+++ com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n@@ -25,6 +25,8 @@\n         int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n         newName.setCharno(position2charno(lpColumn));\n         maybeSetLengthFrom(newName, name);\n+        // add name to current scope fix\n+        addToScope(name, newName, Scope.NamedSymbolKind.FUNCTION_DECLARATION); // fix\n     }\n     node.addChildToBack(newName);\n     Node lp = newNode(Token.PARAM_LIST);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    pushScope(n);\n    curNode = n; // Moved this line to after pushScope(n) to avoid scope issues\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // Mark line number of left paren correctly.\n        int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n        newName.setCharno(position2charno(lparenCharno));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.) Mark the line\n    // number of the left paren correctly.\n    lp.setLineno(functionNode.getLpNode().getLineno());\n    lp.setCharno(functionNode.getLp()+functionNode.getLpNode().getCharno());\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -7,8 +7,8 @@\n         // Functions declarations are in the scope containing the declaration.\n         traverseBranch(fnName, n);\n     }\n-    curNode = n;\n     pushScope(n);\n+    curNode = n; // Moved this line to after pushScope(n) to avoid scope issues\n     if (isFunctionExpression) {\n         // Function expression names are only accessible within the function\n         // scope.\n--- com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n+++ com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n@@ -19,11 +19,9 @@\n         // Old Rhino tagged the empty name node with the line number of the\n         // declaration.\n         newName.setLineno(functionNode.getLineno());\n-        // TODO(bowdidge) Mark line number of paren correctly.\n-        // Same problem as below - the left paren might not be on the\n-        // same line as the function keyword.\n-        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n-        newName.setCharno(position2charno(lpColumn));\n+        // Mark line number of left paren correctly.\n+        int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n+        newName.setCharno(position2charno(lparenCharno));\n         maybeSetLengthFrom(newName, name);\n     }\n     node.addChildToBack(newName);\n@@ -31,17 +29,10 @@\n     // The left paren's complicated because it's not represented by an\n     // AstNode, so there's nothing that has the actual line number that it\n     // appeared on.  We know the paren has to appear on the same line as the\n-    // function name (or else a semicolon will be inserted.)  If there's no\n-    // function name, assume the paren was on the same line as the function.\n-    // TODO(bowdidge): Mark line number of paren correctly.\n-    Name fnName = functionNode.getFunctionName();\n-    if (fnName != null) {\n-        lp.setLineno(fnName.getLineno());\n-    } else {\n-        lp.setLineno(functionNode.getLineno());\n-    }\n-    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n-    lp.setCharno(position2charno(lparenCharno));\n+    // function name (or else a semicolon will be inserted.) Mark the line\n+    // number of the left paren correctly.\n+    lp.setLineno(functionNode.getLpNode().getLineno());\n+    lp.setCharno(functionNode.getLp()+functionNode.getLpNode().getCharno());\n     for (AstNode param : functionNode.getParams()) {\n         lp.addChildToBack(transform(param));\n     }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        // FIXED - Need to push new scope for function expression too\n        pushScope(fnName);\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    if (isFunctionExpression) {\n        // FIXED - Need to pop the newly pushed scope for function expression\n        popScope();\n    }\n    popScope();\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    if (isUnnamedFunction) {\n        // FIXED - When a function is unnamed, we need to wrap it inside an expression statement.\n        Node exprResult = new Node(Token.EXPR_RESULT);\n        exprResult.addChildToBack(node);\n        return exprResult;\n    } else {\n        return node;\n    }\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -12,6 +12,8 @@\n     if (isFunctionExpression) {\n         // Function expression names are only accessible within the function\n         // scope.\n+        // FIXED - Need to push new scope for function expression too\n+        pushScope(fnName);\n         traverseBranch(fnName, n);\n     }\n     final Node args = fnName.getNext();\n@@ -21,5 +23,9 @@\n     // Body\n     Preconditions.checkState(body.getNext() == null && body.isBlock());\n     traverseBranch(body, n);\n+    if (isFunctionExpression) {\n+        // FIXED - Need to pop the newly pushed scope for function expression\n+        popScope();\n+    }\n     popScope();\n }\n--- com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n+++ com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n@@ -52,5 +52,12 @@\n     // Parser#parseFunctionBodyExpr.\n     parseDirectives(bodyNode);\n     node.addChildToBack(bodyNode);\n-    return node;\n+    if (isUnnamedFunction) {\n+        // FIXED - When a function is unnamed, we need to wrap it inside an expression statement.\n+        Node exprResult = new Node(Token.EXPR_RESULT);\n+        exprResult.addChildToBack(node);\n+        return exprResult;\n+    } else {\n+        return node;\n+    }\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", functionNode.getLineno(), \"\");\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n+++ com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n@@ -5,7 +5,7 @@\n     if (name == null) {\n         int functionType = functionNode.getFunctionType();\n         if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n-            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n+            errorReporter.error(\"unnamed function statement\", functionNode.getLineno(), \"\");\n             // Return the bare minimum to put the AST in a valid state.\n             return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n         }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        pushScope(n);\n        traverseBranch(fnName, n);\n    } else {\n        pushScope(n);\n    }\n    curNode = n;\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            // Update: changed null argument to zero as it needs to be initialized\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -5,10 +5,12 @@\n     boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n     if (!isFunctionExpression) {\n         // Functions declarations are in the scope containing the declaration.\n+        pushScope(n);\n         traverseBranch(fnName, n);\n+    } else {\n+        pushScope(n);\n     }\n     curNode = n;\n-    pushScope(n);\n     if (isFunctionExpression) {\n         // Function expression names are only accessible within the function\n         // scope.\n--- com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n+++ com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n@@ -7,6 +7,7 @@\n         if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n             errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n             // Return the bare minimum to put the AST in a valid state.\n+            // Update: changed null argument to zero as it needs to be initialized\n             return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n         }\n         name = new Name();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        pushScope(fnName); // <-- added to create a new scope for function expression names\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    if (isFunctionExpression) {\n        popScope(); // <-- added to pop the function expression scope\n    }\n    popScope();\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    if (isUnnamedFunction && newName.getLastChild() instanceof Symbol && !((Symbol) newName.getLastChild()).getName().isEmpty()) {\n        popScope(); // <-- added to pop the function expression scope if it was created\n    }\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -12,6 +12,7 @@\n     if (isFunctionExpression) {\n         // Function expression names are only accessible within the function\n         // scope.\n+        pushScope(fnName); // <-- added to create a new scope for function expression names\n         traverseBranch(fnName, n);\n     }\n     final Node args = fnName.getNext();\n@@ -21,5 +22,8 @@\n     // Body\n     Preconditions.checkState(body.getNext() == null && body.isBlock());\n     traverseBranch(body, n);\n+    if (isFunctionExpression) {\n+        popScope(); // <-- added to pop the function expression scope\n+    }\n     popScope();\n }\n--- com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n+++ com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n@@ -52,5 +52,8 @@\n     // Parser#parseFunctionBodyExpr.\n     parseDirectives(bodyNode);\n     node.addChildToBack(bodyNode);\n+    if (isUnnamedFunction && newName.getLastChild() instanceof Symbol && !((Symbol) newName.getLastChild()).getName().isEmpty()) {\n+        popScope(); // <-- added to pop the function expression scope if it was created\n+    }\n     return node;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        pushScope(fnName);\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    if (isFunctionExpression) {\n        popScope();\n    }\n    popScope();\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    node.setLength(functionNode.getLength());\n    node.setSourceName(functionNode.getSourceName());\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -12,6 +12,7 @@\n     if (isFunctionExpression) {\n         // Function expression names are only accessible within the function\n         // scope.\n+        pushScope(fnName);\n         traverseBranch(fnName, n);\n     }\n     final Node args = fnName.getNext();\n@@ -21,5 +22,8 @@\n     // Body\n     Preconditions.checkState(body.getNext() == null && body.isBlock());\n     traverseBranch(body, n);\n+    if (isFunctionExpression) {\n+        popScope();\n+    }\n     popScope();\n }\n--- com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n+++ com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n@@ -52,5 +52,7 @@\n     // Parser#parseFunctionBodyExpr.\n     parseDirectives(bodyNode);\n     node.addChildToBack(bodyNode);\n+    node.setLength(functionNode.getLength());\n+    node.setSourceName(functionNode.getSourceName());\n     return node;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        pushScope(fnName);\n        traverseBranch(fnName.getNext(), n);\n        popScope();\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n        // Add name to function node\n        functionNode.setName(name);\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -12,7 +12,9 @@\n     if (isFunctionExpression) {\n         // Function expression names are only accessible within the function\n         // scope.\n-        traverseBranch(fnName, n);\n+        pushScope(fnName);\n+        traverseBranch(fnName.getNext(), n);\n+        popScope();\n     }\n     final Node args = fnName.getNext();\n     final Node body = args.getNext();\n--- com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n+++ com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n@@ -12,6 +12,8 @@\n         name = new Name();\n         name.setIdentifier(\"\");\n         isUnnamedFunction = true;\n+        // Add name to function node\n+        functionNode.setName(name);\n     }\n     Node node = newNode(Token.FUNCTION);\n     Node newName = transform(name);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (isFunctionExpression && fnName.isName()) {\n        // Function expression names are only accessible within the function\n        // scope.\n        traverseBranch(fnName, n);\n    }\n    curNode = n;\n    pushScope(n);\n    if (fnName.isQualifiedName()) {\n        // Functions declarations are in the scope containing the declaration.\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EMPTY, functionNode.getLineno());\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -3,15 +3,15 @@\n     Preconditions.checkState(n.isFunction());\n     final Node fnName = n.getFirstChild();\n     boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n-    if (!isFunctionExpression) {\n-        // Functions declarations are in the scope containing the declaration.\n+    if (isFunctionExpression && fnName.isName()) {\n+        // Function expression names are only accessible within the function\n+        // scope.\n         traverseBranch(fnName, n);\n     }\n     curNode = n;\n     pushScope(n);\n-    if (isFunctionExpression) {\n-        // Function expression names are only accessible within the function\n-        // scope.\n+    if (fnName.isQualifiedName()) {\n+        // Functions declarations are in the scope containing the declaration.\n         traverseBranch(fnName, n);\n     }\n     final Node args = fnName.getNext();\n--- com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n+++ com/google/javascript/jscomp/parsing/IRFactory.javaprocessFunctionNode\n@@ -7,7 +7,7 @@\n         if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n             errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n             // Return the bare minimum to put the AST in a valid state.\n-            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n+            return newNode(Token.EMPTY, functionNode.getLineno());\n         }\n         name = new Name();\n         name.setIdentifier(\"\");\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.isFunction());\n    final Node fnName = n.getFirstChild();\n    boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n    if (!isFunctionExpression) {\n        // Functions declarations are in the scope containing the declaration.\n        pushScope(n); // moved pushScope call here\n        traverseBranch(fnName, n);\n    } else {\n        curNode = n; // moved curNode assignment here\n        pushScope(n);\n    }\n    if (isFunctionExpression) {\n        // Function expression names are only accessible within the function\n        // scope.\n        traverseBranch(fnName, n);\n    }\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n    // Args\n    traverseBranch(args, n);\n    // Body\n    Preconditions.checkState(body.getNext() == null && body.isBlock());\n    traverseBranch(body, n);\n    popScope();\n}\n\n## Fixed Function 2\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    Boolean isUnnamedFunction = false;\n    if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n            errorReporter.error(\"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0);\n            // Return the bare minimum to put the AST in a valid state.\n            return newNode(Token.EXPR_RESULT, Node.newNumber(0));\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n    }\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n    if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n    }\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.PARAM_LIST);\n    // The left paren's complicated because it's not represented by an\n    // AstNode, so there's nothing that has the actual line number that it\n    // appeared on.  We know the paren has to appear on the same line as the\n    // function name (or else a semicolon will be inserted.)  If there's no\n    // function name, assume the paren was on the same line as the function.\n    // TODO(bowdidge): Mark line number of paren correctly.\n    Name fnName = functionNode.getFunctionName();\n    if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n    } else {\n        lp.setLineno(functionNode.getLineno());\n    }\n    int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n    lp.setCharno(position2charno(lparenCharno));\n    for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n    }\n    node.addChildToBack(lp);\n    Node bodyNode = transform(functionNode.getBody());\n    // When in ideMode Rhino tries to parse some constructs the compiler\n    // doesn't support, repair it here. see Rhino's\n    // Parser#parseFunctionBodyExpr.\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n    return node;\n}", "diff": "--- com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n+++ com/google/javascript/jscomp/NodeTraversal.javatraverseFunction\n@@ -5,10 +5,12 @@\n     boolean isFunctionExpression = (parent != null) && NodeUtil.isFunctionExpression(n);\n     if (!isFunctionExpression) {\n         // Functions declarations are in the scope containing the declaration.\n+        pushScope(n); // moved pushScope call here\n         traverseBranch(fnName, n);\n+    } else {\n+        curNode = n; // moved curNode assignment here\n+        pushScope(n);\n     }\n-    curNode = n;\n-    pushScope(n);\n     if (isFunctionExpression) {\n         // Function expression names are only accessible within the function\n         // scope.\n", "finish_reason": "stop", "valid": false, "num": 1}]