[{"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n    // Should we check that there is a sub-class relationship?\n    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n    // TODO: fix in 2.8\n    if (subclass.isAssignableFrom(_class)) {\n        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n    }\n    // Otherwise, stitch together the hierarchy. First, super-class\n    // if not found, try a super-interface\n    // should not get here but...\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -8,8 +8,11 @@\n     // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n     //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n     // TODO: fix in 2.8\n+    if (subclass.isAssignableFrom(_class)) {\n         return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n+    }\n     // Otherwise, stitch together the hierarchy. First, super-class\n     // if not found, try a super-interface\n     // should not get here but...\n+    return null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n    // Check if subclass is assignable from _class\n    if (subclass.isAssignableFrom(_class)) {\n        return new SimpleType(subclass, _bindings,\n                              this, _superInterfaces,\n                              _valueHandler, _typeHandler,\n                              _asStatic);\n    }\n    // Otherwise, stitch together the hierarchy.\n    // First, check the super-class\n    if (_class.isAssignableFrom(subclass)) {\n        return fromClass(subclass, _bindings, null);\n    }\n    // Then try a super-interface\n    for (JavaType intr : _superInterfaces) {\n        if (intr.getRawClass() == subclass) {\n            return intr;\n        }\n        if (subclass.isAssignableFrom(intr.getRawClass())) {\n            return intr.narrow(subclass);\n        }\n    }\n    throw new IllegalArgumentException(\"Class \" + subclass.getName() +\n                                           \" not subtype of \" + _class.getName());\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -4,12 +4,27 @@\n     if (_class == subclass) {\n         return this;\n     }\n-    // Should we check that there is a sub-class relationship?\n-    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n-    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n-    // TODO: fix in 2.8\n-        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n-    // Otherwise, stitch together the hierarchy. First, super-class\n-    // if not found, try a super-interface\n-    // should not get here but...\n+    // Check if subclass is assignable from _class\n+    if (subclass.isAssignableFrom(_class)) {\n+        return new SimpleType(subclass, _bindings,\n+                              this, _superInterfaces,\n+                              _valueHandler, _typeHandler,\n+                              _asStatic);\n+    }\n+    // Otherwise, stitch together the hierarchy.\n+    // First, check the super-class\n+    if (_class.isAssignableFrom(subclass)) {\n+        return fromClass(subclass, _bindings, null);\n+    }\n+    // Then try a super-interface\n+    for (JavaType intr : _superInterfaces) {\n+        if (intr.getRawClass() == subclass) {\n+            return intr;\n+        }\n+        if (subclass.isAssignableFrom(intr.getRawClass())) {\n+            return intr.narrow(subclass);\n+        }\n+    }\n+    throw new IllegalArgumentException(\"Class \" + subclass.getName() +\n+                                           \" not subtype of \" + _class.getName());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n    // Check that there is a sub-class relationship\n    if (!subclass.isAssignableFrom(_class)) {\n        throw new IllegalArgumentException(\"Class \" + subclass.getName() + \" is not a subclass of \" + _class.getName());\n    }\n    return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -4,12 +4,9 @@\n     if (_class == subclass) {\n         return this;\n     }\n-    // Should we check that there is a sub-class relationship?\n-    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n-    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n-    // TODO: fix in 2.8\n-        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n-    // Otherwise, stitch together the hierarchy. First, super-class\n-    // if not found, try a super-interface\n-    // should not get here but...\n+    // Check that there is a sub-class relationship\n+    if (!subclass.isAssignableFrom(_class)) {\n+        throw new IllegalArgumentException(\"Class \" + subclass.getName() + \" is not a subclass of \" + _class.getName());\n+    }\n+    return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n    if (_bindings == null || _bindings.isEmpty()) {\n        // if no bindings, can NOT be more specific.\n        return new SimpleType(subclass);\n    }\n    JavaType newType = _bindings.getBoundType(subclass);\n    if (newType == null) {\n        newType = _mapType(subclass, TypeBindings.create(_class, subclass), null);\n    }\n    return newType;\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -4,12 +4,13 @@\n     if (_class == subclass) {\n         return this;\n     }\n-    // Should we check that there is a sub-class relationship?\n-    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n-    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n-    // TODO: fix in 2.8\n-        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n-    // Otherwise, stitch together the hierarchy. First, super-class\n-    // if not found, try a super-interface\n-    // should not get here but...\n+    if (_bindings == null || _bindings.isEmpty()) {\n+        // if no bindings, can NOT be more specific.\n+        return new SimpleType(subclass);\n+    }\n+    JavaType newType = _bindings.getBoundType(subclass);\n+    if (newType == null) {\n+        newType = _mapType(subclass, TypeBindings.create(_class, subclass), null);\n+    }\n+    return newType;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n    // Ignore any non-subclasses\n    if (!subclass.isAssignableFrom(_class)) {\n        return null;\n    }\n    // Should we check that there is a sub-class relationship?\n    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n    // TODO: fix in 2.8\n    return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n    // Otherwise, stitch together the hierarchy. First, super-class\n    // if not found, try a super-interface\n    // should not get here but...\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -4,11 +4,15 @@\n     if (_class == subclass) {\n         return this;\n     }\n+    // Ignore any non-subclasses\n+    if (!subclass.isAssignableFrom(_class)) {\n+        return null;\n+    }\n     // Should we check that there is a sub-class relationship?\n     // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n     //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n     // TODO: fix in 2.8\n-        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n+    return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n     // Otherwise, stitch together the hierarchy. First, super-class\n     // if not found, try a super-interface\n     // should not get here but...\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n    // Check if subclass is a sub-class of this class\n    if (subclass.isAssignableFrom(_class)) {\n        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n    }\n    // Otherwise, stitch together the hierarchy. First, super-class\n    // if not found, try a super-interface\n    // should not get here but...\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -4,11 +4,10 @@\n     if (_class == subclass) {\n         return this;\n     }\n-    // Should we check that there is a sub-class relationship?\n-    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n-    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n-    // TODO: fix in 2.8\n+    // Check if subclass is a sub-class of this class\n+    if (subclass.isAssignableFrom(_class)) {\n         return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n+    }\n     // Otherwise, stitch together the hierarchy. First, super-class\n     // if not found, try a super-interface\n     // should not get here but...\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    } else if (_bindings == null) {\n        // no points to combining bindings, so:\n        return new SimpleType(subclass, TypeBindings.emptyBindings(), _superClass, _superInterfaces,\n                _valueHandler, _typeHandler, _asStatic);\n    } else {\n        TypeBindings childBindings = TypeBindings.create(subclass, this);\n        return new SimpleType(subclass, childBindings, _superClass, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -3,13 +3,12 @@\n protected JavaType _narrow(Class<?> subclass) {\n     if (_class == subclass) {\n         return this;\n+    } else if (_bindings == null) {\n+        // no points to combining bindings, so:\n+        return new SimpleType(subclass, TypeBindings.emptyBindings(), _superClass, _superInterfaces,\n+                _valueHandler, _typeHandler, _asStatic);\n+    } else {\n+        TypeBindings childBindings = TypeBindings.create(subclass, this);\n+        return new SimpleType(subclass, childBindings, _superClass, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n     }\n-    // Should we check that there is a sub-class relationship?\n-    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n-    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n-    // TODO: fix in 2.8\n-        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n-    // Otherwise, stitch together the hierarchy. First, super-class\n-    // if not found, try a super-interface\n-    // should not get here but...\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n    if (subclass.isAssignableFrom(_class)) {\n        // Ensure that the new type has the same parameterization\n        JavaType newType = _gptContext.findSubtype(subclass);\n        // If there is no subtype found, create a simple type\n        if (newType == null) {\n            newType = new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n        }\n        return newType;\n    }\n    // Otherwise, stitch together the hierarchy. First, super-class\n    // if not found, try a super-interface\n    // should not get here but...\n    return super._narrow(subclass);\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -4,12 +4,17 @@\n     if (_class == subclass) {\n         return this;\n     }\n-    // Should we check that there is a sub-class relationship?\n-    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n-    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n-    // TODO: fix in 2.8\n-        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n+    if (subclass.isAssignableFrom(_class)) {\n+        // Ensure that the new type has the same parameterization\n+        JavaType newType = _gptContext.findSubtype(subclass);\n+        // If there is no subtype found, create a simple type\n+        if (newType == null) {\n+            newType = new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n+        }\n+        return newType;\n+    }\n     // Otherwise, stitch together the hierarchy. First, super-class\n     // if not found, try a super-interface\n     // should not get here but...\n+    return super._narrow(subclass);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n    // Check if subclass is assignable from _class\n    if (subclass.isAssignableFrom(_class)) {\n        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n    }\n    // Otherwise, stitch together the hierarchy. First, super-class\n    // if not found, try a super-interface\n    // should not get here but...\n    return new SimpleType(subclass, TypeBindings.emptyBindings(), null, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -4,12 +4,12 @@\n     if (_class == subclass) {\n         return this;\n     }\n-    // Should we check that there is a sub-class relationship?\n-    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n-    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n-    // TODO: fix in 2.8\n+    // Check if subclass is assignable from _class\n+    if (subclass.isAssignableFrom(_class)) {\n         return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n+    }\n     // Otherwise, stitch together the hierarchy. First, super-class\n     // if not found, try a super-interface\n     // should not get here but...\n+    return new SimpleType(subclass, TypeBindings.emptyBindings(), null, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n    // Check that there is a sub-class relationship\n    if (!subclass.isAssignableFrom(_class)) {\n        return null;\n    }\n    return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n    // Otherwise, stitch together the hierarchy. First, super-class\n    // if not found, try a super-interface\n    // should not get here but...\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -4,11 +4,11 @@\n     if (_class == subclass) {\n         return this;\n     }\n-    // Should we check that there is a sub-class relationship?\n-    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n-    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n-    // TODO: fix in 2.8\n-        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n+    // Check that there is a sub-class relationship\n+    if (!subclass.isAssignableFrom(_class)) {\n+        return null;\n+    }\n+    return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n     // Otherwise, stitch together the hierarchy. First, super-class\n     // if not found, try a super-interface\n     // should not get here but...\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n    // Check for sub-class relationship\n    if (!subclass.isAssignableFrom(_class)) {\n        throw new IllegalArgumentException(\"Class \" + subclass.getName() + \" is not a subclass of \" + _class.getName());\n    }\n    // Stitch together the hierarchy. First, super-class\n    // if not found, try a super-interface\n    JavaType superClass = null;\n    if (_class.getSuperclass() != null && !_class.getSuperclass().equals(Object.class)) {\n        superClass = _fromClass(_class.getSuperclass(), _bindings);\n    }\n    if (superClass == null) {\n        for (Class<?> intf : _class.getInterfaces()) {\n            JavaType type = _fromClass(intf, _bindings);\n            if (type.getSuperClass() != null && type.getSuperClass().equals(subclass)) {\n                return type;\n            }\n        }\n        // should not get here but...\n    } else if (superClass.getRawClass().equals(subclass)) {\n        return superClass;\n    } else if (superClass.isTypeOrSubTypeOf(subclass)) {\n        return superClass.narrowBy(subclass);\n    }\n    return new SimpleType(subclass, _bindings, superClass, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -4,12 +4,28 @@\n     if (_class == subclass) {\n         return this;\n     }\n-    // Should we check that there is a sub-class relationship?\n-    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n-    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n-    // TODO: fix in 2.8\n-        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n-    // Otherwise, stitch together the hierarchy. First, super-class\n+    // Check for sub-class relationship\n+    if (!subclass.isAssignableFrom(_class)) {\n+        throw new IllegalArgumentException(\"Class \" + subclass.getName() + \" is not a subclass of \" + _class.getName());\n+    }\n+    // Stitch together the hierarchy. First, super-class\n     // if not found, try a super-interface\n-    // should not get here but...\n+    JavaType superClass = null;\n+    if (_class.getSuperclass() != null && !_class.getSuperclass().equals(Object.class)) {\n+        superClass = _fromClass(_class.getSuperclass(), _bindings);\n+    }\n+    if (superClass == null) {\n+        for (Class<?> intf : _class.getInterfaces()) {\n+            JavaType type = _fromClass(intf, _bindings);\n+            if (type.getSuperClass() != null && type.getSuperClass().equals(subclass)) {\n+                return type;\n+            }\n+        }\n+        // should not get here but...\n+    } else if (superClass.getRawClass().equals(subclass)) {\n+        return superClass;\n+    } else if (superClass.isTypeOrSubTypeOf(subclass)) {\n+        return superClass.narrowBy(subclass);\n+    }\n+    return new SimpleType(subclass, _bindings, superClass, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n    \n    // Check if the subclass is a derived class of this class\n    if (_class.isAssignableFrom(subclass)) {\n        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n    }\n    \n    // Otherwise, stitch together the hierarchy. First, super-class\n    // if not found, try a super-interface\n    // should not get here but...\n    return new SimpleType(subclass, TypeBindings.emptyBindings(), null, _superClass, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -4,12 +4,14 @@\n     if (_class == subclass) {\n         return this;\n     }\n-    // Should we check that there is a sub-class relationship?\n-    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n-    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n-    // TODO: fix in 2.8\n+    \n+    // Check if the subclass is a derived class of this class\n+    if (_class.isAssignableFrom(subclass)) {\n         return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n+    }\n+    \n     // Otherwise, stitch together the hierarchy. First, super-class\n     // if not found, try a super-interface\n     // should not get here but...\n+    return new SimpleType(subclass, TypeBindings.emptyBindings(), null, _superClass, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n    // Check if the subclass is a subtype of the current class\n    if (subclass.isAssignableFrom(_class)) {\n        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n    }\n    // Otherwise, stitch together the hierarchy. First, super-class\n    // if not found, try a super-interface\n    // should not get here but...\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -4,11 +4,10 @@\n     if (_class == subclass) {\n         return this;\n     }\n-    // Should we check that there is a sub-class relationship?\n-    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n-    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n-    // TODO: fix in 2.8\n+    // Check if the subclass is a subtype of the current class\n+    if (subclass.isAssignableFrom(_class)) {\n         return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n+    }\n     // Otherwise, stitch together the hierarchy. First, super-class\n     // if not found, try a super-interface\n     // should not get here but...\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n    // Check for sub-class relationship\n    if (!subclass.isAssignableFrom(_class)) {\n        throw new IllegalArgumentException(\"Class \" + subclass.getName() + \" is not a subclass of \" + _class.getName());\n    }\n    // Stitch together the hierarchy. First, super-class\n    JavaType superClass = _fromClass(((Class)subclass.getSuperclass()), _bindings);\n    if (superClass == null) {\n        // If not found, try a super-interface\n        Type[] superInterfaces = subclass.getGenericInterfaces();\n        for (Type superInterface : superInterfaces) {\n            JavaType jti = _fromType(superInterface, _bindings);\n            if (jti != null) {\n                return jti;\n            }\n        }\n        // should not get here but...\n        throw new IllegalArgumentException(\"Internal error: Class \" + subclass.getName() + \" neither has a superclass, nor implements any interfaces.\");\n    }\n    return superClass;\n}\n\n##Fixed Function 2\n@JsonSerialize(using = ClassSerializer.class)\npublic static final class C implements A {\n    public String getValue() { return \"C\"; }\n}\n\n@JsonSerializer\npublic static class ClassSerializer extends JsonSerializer<Class<?>> {    \n    @Override\n    public void serialize(Class<?> value, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n        gen.writeString(value.getName());\n    }\n}\n\npublic static void main(String[] args) throws IOException {\n    ObjectMapper mapper = new ObjectMapper();\n    A c = new C();\n    String json = mapper.writeValueAsString(c);\n    System.out.println(json);\n}\n\n##Fixed Function 3\npublic void test() throws IOException {\n    String invalidJson = \"{ \\\"name\\\" : \\\"John\\\", age: 30 }\";\n    ClassWithRequiredProperties obj = new ObjectMapper().readerFor(ClassWithRequiredProperties.class)\n            .with(DeserializationFeature.FAIL_ON_MISSING_CREATOR_PROPERTIES)\n            .readValue(invalidJson);\n    System.out.println(obj.getName());\n}\n\n@JsonCreator\npublic static ClassWithRequiredProperties create(@JsonProperty(\"name\") String name) {\n    return new ClassWithRequiredProperties(name);\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -4,12 +4,23 @@\n     if (_class == subclass) {\n         return this;\n     }\n-    // Should we check that there is a sub-class relationship?\n-    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n-    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n-    // TODO: fix in 2.8\n-        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n-    // Otherwise, stitch together the hierarchy. First, super-class\n-    // if not found, try a super-interface\n-    // should not get here but...\n+    // Check for sub-class relationship\n+    if (!subclass.isAssignableFrom(_class)) {\n+        throw new IllegalArgumentException(\"Class \" + subclass.getName() + \" is not a subclass of \" + _class.getName());\n+    }\n+    // Stitch together the hierarchy. First, super-class\n+    JavaType superClass = _fromClass(((Class)subclass.getSuperclass()), _bindings);\n+    if (superClass == null) {\n+        // If not found, try a super-interface\n+        Type[] superInterfaces = subclass.getGenericInterfaces();\n+        for (Type superInterface : superInterfaces) {\n+            JavaType jti = _fromType(superInterface, _bindings);\n+            if (jti != null) {\n+                return jti;\n+            }\n+        }\n+        // should not get here but...\n+        throw new IllegalArgumentException(\"Internal error: Class \" + subclass.getName() + \" neither has a superclass, nor implements any interfaces.\");\n+    }\n+    return superClass;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n\n    // Check for sub-class relationship using isAssignableFrom\n    if (subclass.isAssignableFrom(_class)) {\n        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n    }\n\n    // Otherwise, stitch together the hierarchy. First, super-class\n    // if not found, try a super-interface\n    // should not get here but...\n    return null;\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -4,12 +4,14 @@\n     if (_class == subclass) {\n         return this;\n     }\n-    // Should we check that there is a sub-class relationship?\n-    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n-    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n-    // TODO: fix in 2.8\n+\n+    // Check for sub-class relationship using isAssignableFrom\n+    if (subclass.isAssignableFrom(_class)) {\n         return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n+    }\n+\n     // Otherwise, stitch together the hierarchy. First, super-class\n     // if not found, try a super-interface\n     // should not get here but...\n+    return null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n    if (_class.isAssignableFrom(subclass)) {\n        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n    }\n    // Otherwise, stitch together the hierarchy. First, super-class\n    JavaType st = null;\n    if (_class.isInterface()) {\n        for (JavaType intf : _superInterfaces) {\n            if (intf.getRawClass().isAssignableFrom(subclass)) {\n                if (st != null) {\n                    throw new IllegalArgumentException(\"More than one super-type match for class \" + subclass.getName() + \": \" + st + \", \" + intf);\n                }\n                st = intf.narrow(subclass);\n            }\n        }\n    }\n    if (st == null) {\n        if (_superClass != null && _superClass.isAssignableFrom(subclass)) {\n            st = _superClass.narrow(subclass);\n        }\n    }\n    if (st == null) {\n        throw new IllegalArgumentException(\"Class \" + subclass.getName() + \" not subtype of \" + toString());\n    }\n    return st;\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -4,12 +4,28 @@\n     if (_class == subclass) {\n         return this;\n     }\n-    // Should we check that there is a sub-class relationship?\n-    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n-    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n-    // TODO: fix in 2.8\n-        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n+    if (_class.isAssignableFrom(subclass)) {\n+        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n+    }\n     // Otherwise, stitch together the hierarchy. First, super-class\n-    // if not found, try a super-interface\n-    // should not get here but...\n+    JavaType st = null;\n+    if (_class.isInterface()) {\n+        for (JavaType intf : _superInterfaces) {\n+            if (intf.getRawClass().isAssignableFrom(subclass)) {\n+                if (st != null) {\n+                    throw new IllegalArgumentException(\"More than one super-type match for class \" + subclass.getName() + \": \" + st + \", \" + intf);\n+                }\n+                st = intf.narrow(subclass);\n+            }\n+        }\n+    }\n+    if (st == null) {\n+        if (_superClass != null && _superClass.isAssignableFrom(subclass)) {\n+            st = _superClass.narrow(subclass);\n+        }\n+    }\n+    if (st == null) {\n+        throw new IllegalArgumentException(\"Class \" + subclass.getName() + \" not subtype of \" + toString());\n+    }\n+    return st;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n    // Check if subclass is actually a subclass of this class\n    if (_class.isAssignableFrom(subclass)) {\n        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n    }\n    // Otherwise, stitch together the hierarchy. First, super-class\n    // if not found, try a super-interface\n    // should not get here but...\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -4,11 +4,10 @@\n     if (_class == subclass) {\n         return this;\n     }\n-    // Should we check that there is a sub-class relationship?\n-    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n-    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n-    // TODO: fix in 2.8\n+    // Check if subclass is actually a subclass of this class\n+    if (_class.isAssignableFrom(subclass)) {\n         return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n+    }\n     // Otherwise, stitch together the hierarchy. First, super-class\n     // if not found, try a super-interface\n     // should not get here but...\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n    /* Check sub-class relationship.\n     * Prior implementation had an issue where it did not account for placeholder\n     * values.\u201d\n     */\n    if (_class.isAssignableFrom(subclass)) {\n        JavaType type;\n        if (_bindings.isEmpty()) {\n            type = new SimpleType(subclass);\n        } else {\n            type = new SimpleType(subclass, _bindings);\n        }\n        return type;\n    }\n    // Otherwise, stitch together the hierarchy. First, super-class\n    // if not found, try a super-interface\n    // should not get here but...\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -4,11 +4,19 @@\n     if (_class == subclass) {\n         return this;\n     }\n-    // Should we check that there is a sub-class relationship?\n-    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n-    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n-    // TODO: fix in 2.8\n-        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n+    /* Check sub-class relationship.\n+     * Prior implementation had an issue where it did not account for placeholder\n+     * values.\u201d\n+     */\n+    if (_class.isAssignableFrom(subclass)) {\n+        JavaType type;\n+        if (_bindings.isEmpty()) {\n+            type = new SimpleType(subclass);\n+        } else {\n+            type = new SimpleType(subclass, _bindings);\n+        }\n+        return type;\n+    }\n     // Otherwise, stitch together the hierarchy. First, super-class\n     // if not found, try a super-interface\n     // should not get here but...\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n    if (_bindings == null || _bindings.isEmpty()) { // added this condition to check if there are no type bindings\n        return new SimpleType(subclass, null, _valueHandler, _typeHandler, _asStatic);\n    }\n    return new SimpleType(subclass, _bindings, _valueHandler, _typeHandler, _asStatic);\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -4,12 +4,8 @@\n     if (_class == subclass) {\n         return this;\n     }\n-    // Should we check that there is a sub-class relationship?\n-    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n-    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n-    // TODO: fix in 2.8\n-        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n-    // Otherwise, stitch together the hierarchy. First, super-class\n-    // if not found, try a super-interface\n-    // should not get here but...\n+    if (_bindings == null || _bindings.isEmpty()) { // added this condition to check if there are no type bindings\n+        return new SimpleType(subclass, null, _valueHandler, _typeHandler, _asStatic);\n+    }\n+    return new SimpleType(subclass, _bindings, _valueHandler, _typeHandler, _asStatic);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@Override\n@Deprecated\nprotected JavaType _narrow(Class<?> subclass) {\n    if (_class == subclass) {\n        return this;\n    }\n    // Check that subclass is a subtype of this class\n    if (!subclass.isAssignableFrom(_class)) {\n        throw new IllegalArgumentException(\"Class \" + subclass.getName() + \" is not a subtype of \" + _class.getName());\n    }\n\n    // Stitch together the hierarchy. First, super-class if not found, try a super-interface\n    JavaType type = _narrow(subclass.getSuperclass());\n    if (type == null) {\n        for (Class<?> interfaceClass : subclass.getInterfaces()) {\n            type = _narrow(interfaceClass);\n            if (type != null) {\n                break;\n            }\n        }\n    }\n    // If still not found, create a new SimpleType\n    if (type == null) {\n        type = new SimpleType(subclass, _bindings, null, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n    }\n    return type;\n}", "diff": "--- com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n+++ com/fasterxml/jackson/databind/type/SimpleType.java@_narrow\n@@ -4,12 +4,24 @@\n     if (_class == subclass) {\n         return this;\n     }\n-    // Should we check that there is a sub-class relationship?\n-    // 15-Jan-2016, tatu: Almost yes, but there are some complications with\n-    //    placeholder values (`Void`, `NoClass`), so can not quite do yet.\n-    // TODO: fix in 2.8\n-        return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n-    // Otherwise, stitch together the hierarchy. First, super-class\n-    // if not found, try a super-interface\n-    // should not get here but...\n+    // Check that subclass is a subtype of this class\n+    if (!subclass.isAssignableFrom(_class)) {\n+        throw new IllegalArgumentException(\"Class \" + subclass.getName() + \" is not a subtype of \" + _class.getName());\n+    }\n+\n+    // Stitch together the hierarchy. First, super-class if not found, try a super-interface\n+    JavaType type = _narrow(subclass.getSuperclass());\n+    if (type == null) {\n+        for (Class<?> interfaceClass : subclass.getInterfaces()) {\n+            type = _narrow(interfaceClass);\n+            if (type != null) {\n+                break;\n+            }\n+        }\n+    }\n+    // If still not found, create a new SimpleType\n+    if (type == null) {\n+        type = new SimpleType(subclass, _bindings, null, _superInterfaces, _valueHandler, _typeHandler, _asStatic);\n+    }\n+    return type;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]