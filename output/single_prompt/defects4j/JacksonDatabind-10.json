[{"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    if (serializer instanceof MapSerializer) {\n        _mapSerializer = serializer;\n    } else {\n        _mapSerializer = null;\n    }\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n    if (_mapSerializer != null) {\n        _mapSerializer.unwrappingSerialize((Map<?, ?>) value, gen, provider);\n        return;\n    }\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter);\n        return;\n    }\n    // ... not sure how custom handler would do it\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n    JsonSerializer<?> js = provider.findValueSerializer(Map.class, _property);\n    if (js instanceof MapSerializer) {\n        _mapSerializer = (MapSerializer) js;\n    } else {\n        _mapSerializer = null;\n    }\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.getUnknownTypeSerializer(Object.class);\n        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    // First: any detectable (auto-detect, annotations) properties to serialize?\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    // [databind#638]: Allow injection of \"virtual\" properties:\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    // [JACKSON-440] Need to allow modification bean properties to serialize:\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    // Any properties to suppress?\n    props = filterBeanProperties(config, beanDesc, props);\n    // [JACKSON-440] Need to allow reordering of properties to serialize\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n    builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        // copied from BasicSerializerFactory.buildMapSerializer():\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        JsonSerializer<?> anySer = prov.findValueSerializer(valueType, anyGetter);\n        anySer = anySer.unwrappingSerializer(null);\n        // TODO: support '@JsonIgnoreProperties' with any setter?\n        // TODO: can we find full PropertyName?\n        PropertyName name = new PropertyName(anyGetter.getName());\n        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, (MapSerializer) anySer));\n    }\n    // Next: need to gather view information, if any:\n    processViews(config, builder);\n    // Finally: let interested parties mess with the result bit more...\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n    if (ser == null) {\n        // If we get this far, there were no properties found, so no regular BeanSerializer\n        // would be constructed. But, couple of exceptions.\n        // First: if there are known annotations, just create 'empty bean' serializer\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n    }\n    return ser;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,9 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    if (serializer instanceof MapSerializer) {\n+        _mapSerializer = serializer;\n+    } else {\n+        _mapSerializer = null;\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n@@ -8,7 +8,7 @@\n     }\n     // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n     if (_mapSerializer != null) {\n-        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n+        _mapSerializer.unwrappingSerialize((Map<?, ?>) value, gen, provider);\n         return;\n     }\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n@@ -8,7 +8,7 @@\n     }\n     // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n     if (_mapSerializer != null) {\n-        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n+        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter);\n         return;\n     }\n     // ... not sure how custom handler would do it\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,10 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    if (serializer instanceof MapSerializer) {\n+        _mapSerializer = serializer;\n+    } else {\n+        _mapSerializer = null;\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,10 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    if (serializer instanceof MapSerializer) {\n+        _mapSerializer = serializer;\n+    } else {\n+        _mapSerializer = null;\n     }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    _mapSerializer = (serializer instanceof MapSerializer) ? (MapSerializer) serializer : null;\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n        return;\n    }\n    throw new JsonMappingException(\"Expecting property 'any-getter' to have bean property of type 'Map'\");\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n        return;\n    }\n    throw new JsonMappingException(\"Expecting property 'any-getter' to have bean property of type 'Map'\");\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    JavaType mapType = provider.constructType(_accessor.getType());\n    BeanDescription mapDesc = provider.getConfig().introspectForCreation(mapType);\n    _mapSerializer = MapSerializer.construct(null, mapType, false, null, _property, null, null);\n    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.getUnknownTypeSerializer(Object.class);\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    props = filterBeanProperties(config, beanDesc, props);\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n    builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType mapType = resolveType(prov, beanDesc, anyGetter.getType(beanDesc.bindingsForBeanType()));\n        if (mapType.isContainerType() && !mapType.isMapLikeType()) {\n            throw new IllegalArgumentException(\"Invalid 'any-getter' annotation on method \" + anyGetter.getName() + \"(): return type is not a Map or a Collection\");\n        }\n        MapSerializer anySerializer = MapSerializer.construct(null, mapType, false, createTypeSerializer(config, mapType.getContentType()), null, null, null);\n        builder.setAnyGetter(new AnyGetterWriter(anyGetter, anySerializer));\n    }\n    processViews(config, builder);\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n    if (ser == null) {\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n    }\n    return ser;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,5 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    _mapSerializer = (serializer instanceof MapSerializer) ? (MapSerializer) serializer : null;\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n@@ -6,9 +6,9 @@\n     if (!(value instanceof Map<?, ?>)) {\n         throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n-    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n     if (_mapSerializer != null) {\n         _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n         return;\n     }\n+    throw new JsonMappingException(\"Expecting property 'any-getter' to have bean property of type 'Map'\");\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n@@ -6,10 +6,9 @@\n     if (!(value instanceof Map<?, ?>)) {\n         throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n-    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n     if (_mapSerializer != null) {\n         _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n         return;\n     }\n-    // ... not sure how custom handler would do it\n+    throw new JsonMappingException(\"Expecting property 'any-getter' to have bean property of type 'Map'\");\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = (serializer instanceof MapSerializer) ? (MapSerializer) serializer : null;\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n-    }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = (serializer instanceof MapSerializer) ? (MapSerializer) serializer : null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, JsonSerializer<Object> serializer) {\n    _accessor = accessor;\n    _property = property;\n    _mapSerializer = (MapSerializer) serializer;\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n        return;\n    }\n    provider.findValueSerializer(value.getClass()).serialize(value, gen, provider);\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n        return;\n    }\n    provider.findValueSerializer(value.getClass()).serialize(value, gen, provider);\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n    JsonSerializer<Object> ser = provider.findPrimaryPropertySerializer(_mapSerializer, _property);\n    _mapSerializer = (MapSerializer) ser;\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.getUnknownTypeSerializer(Object.class);\n        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    // First: any detectable (auto-detect, annotations) properties to serialize?\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    // [databind#638]: Allow injection of \"virtual\" properties:\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    // [JACKSON-440] Need to allow modification bean properties to serialize:\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    // Any properties to suppress?\n    props = filterBeanProperties(config, beanDesc, props);\n    // [JACKSON-440] Need to allow reordering of properties to serialize\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        // copied from BasicSerializerFactory.buildMapSerializer():\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        // last 2 nulls; don't know key, value serializers (yet)\n        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n        JsonSerializer<Object> anySer = prov.findValueSerializer(valueType, anyGetter);\n        // TODO: support '@JsonIgnoreProperties' with any setter?\n        // TODO: can we find full PropertyName?\n        PropertyName name = new PropertyName(anyGetter.getName());\n        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n    }\n    // Next: need to gather view information, if any:\n    processViews(config, builder);\n    // Finally: let interested parties mess with the result bit more...\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = builder.build();\n    if (ser == null) {\n        // If we get this far, there were no properties found, so no regular BeanSerializer\n        // would be constructed. But, couple of exceptions.\n        // First: if there are known annotations, just create 'empty bean' serializer\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n    }\n    return ser;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -1,5 +1,5 @@\n @SuppressWarnings(\"unchecked\")\n-public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, JsonSerializer<Object> serializer) {\n     _accessor = accessor;\n     _property = property;\n     _mapSerializer = (MapSerializer) serializer;\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n@@ -11,4 +11,5 @@\n         _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n         return;\n     }\n+    provider.findValueSerializer(value.getClass()).serialize(value, gen, provider);\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n@@ -11,5 +11,5 @@\n         _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n         return;\n     }\n-    // ... not sure how custom handler would do it\n+    provider.findValueSerializer(value.getClass()).serialize(value, gen, provider);\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, JsonSerializer<Object> serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = (MapSerializer) serializer;\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n-    }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, JsonSerializer<Object> serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = (MapSerializer) serializer;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    _mapSerializer = serializer;\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n    if (_mapSerializer != null && _mapSerializer instanceof MapSerializer) {\n        _mapSerializer.serializeFields(this, (Map<?, ?>) value, gen, provider);\n        return;\n    }\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n    if (_mapSerializer != null && _mapSerializer instanceof MapSerializer) {\n        _mapSerializer.serializeFilteredFields(this, (Map<?, ?>) value, gen, provider, filter);\n        return;\n    }\n    // ... not sure how custom handler would do it\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n    if (_mapSerializer != null) {\n        JsonSerializer<?> ser = provider.handlePrimaryContextualization(_mapSerializer, _property);\n        if (ser instanceof MapSerializer) {\n            _mapSerializer = (MapSerializer) ser;\n        }\n    }\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.getUnknownTypeSerializer(Object.class);\n        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    // First: any detectable (auto-detect, annotations) properties to serialize?\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    // [databind#638]: Allow injection of \"virtual\" properties:\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    // [JACKSON-440] Need to allow modification bean properties to serialize:\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    // Any properties to suppress?\n    props = filterBeanProperties(config, beanDesc, props);\n    // [JACKSON-440] Need to allow reordering of properties to serialize\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n    builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        // copied from BasicSerializerFactory.buildMapSerializer():\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        // last 2 nulls; don't know key, value serializers (yet)\n        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n        JsonSerializer<?> anySer = prov.findValueSerializer(valueType, anyGetter);\n        if (anySer instanceof MapSerializer) {\n            ((MapSerializer) anySer).resolve(this, prov);\n        }\n        // TODO: support '@JsonIgnoreProperties' with any setter?\n        // TODO: can we find full PropertyName?\n        PropertyName name = new PropertyName(anyGetter.getName());\n        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, (MapSerializer) anySer));\n    }\n    // Next: need to gather view information, if any:\n    processViews(config, builder);\n    // Finally: let interested parties mess with the result bit more...\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n    if (ser == null) {\n        // If we get this far, there were no properties found, so no regular BeanSerializer\n        // would be constructed. But, couple of exceptions.\n        // First: if there are known annotations, just create 'empty bean' serializer\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n    }\n    return ser;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,5 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    _mapSerializer = serializer;\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n@@ -7,8 +7,8 @@\n         throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n     // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n-    if (_mapSerializer != null) {\n-        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n+    if (_mapSerializer != null && _mapSerializer instanceof MapSerializer) {\n+        _mapSerializer.serializeFields(this, (Map<?, ?>) value, gen, provider);\n         return;\n     }\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n@@ -7,8 +7,8 @@\n         throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n     // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n-    if (_mapSerializer != null) {\n-        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n+    if (_mapSerializer != null && _mapSerializer instanceof MapSerializer) {\n+        _mapSerializer.serializeFilteredFields(this, (Map<?, ?>) value, gen, provider, filter);\n         return;\n     }\n     // ... not sure how custom handler would do it\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer;\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n-    }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    _mapSerializer = serializer; // remove unnecessary cast\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // remove unnecessary if check\n    _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // remove unnecessary if check\n    _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n    _mapSerializer = provider.handlePrimaryContextualization(_mapSerializer, _property); // remove unnecessary cast\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.getUnknownTypeSerializer(Object.class);\n        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    // First: any detectable (auto-detect, annotations) properties to serialize?\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    // [databind#638]: Allow injection of \"virtual\" properties:\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    // [JACKSON-440] Need to allow modification bean properties to serialize:\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    // Any properties to suppress?\n    props = filterBeanProperties(config, beanDesc, props);\n    // [JACKSON-440] Need to allow reordering of properties to serialize\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        // copied from BasicSerializerFactory.buildMapSerializer():\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        // last 2 nulls; don't know key, value serializers (yet)\n        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n        // TODO: support '@JsonIgnoreProperties' with any setter?\n        // TODO: can we find full PropertyName?\n        PropertyName name = new PropertyName(anyGetter.getName());\n        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n    }\n    // Next: need to gather view information, if any:\n    processViews(config, builder);\n    // Finally: let interested parties mess with the result bit more...\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n    if (ser == null) {\n        // If we get this far, there were no properties found, so no regular BeanSerializer\n        // would be constructed. But, couple of exceptions.\n        // First: if there are known annotations, just create 'empty bean' serializer\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n    }\n    return ser;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,5 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    _mapSerializer = serializer; // remove unnecessary cast\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n@@ -6,9 +6,6 @@\n     if (!(value instanceof Map<?, ?>)) {\n         throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n-    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n-    if (_mapSerializer != null) {\n-        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n-        return;\n-    }\n+    // remove unnecessary if check\n+    _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n@@ -6,10 +6,6 @@\n     if (!(value instanceof Map<?, ?>)) {\n         throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n-    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n-    if (_mapSerializer != null) {\n-        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n-        return;\n-    }\n-    // ... not sure how custom handler would do it\n+    // remove unnecessary if check\n+    _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer; // remove unnecessary cast\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n-    }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer; // remove unnecessary cast\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    _mapSerializer = serializer;  // Removed unnecessary (MapSerializer) cast\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n        return;\n    }\n    // Fix: If _mapSerializer is null, attempt to create a new MapSerializer instance and use it\n    _mapSerializer = new MapSerializer(null, null, null, null, null, null, null);\n    _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n        return;\n    }\n    // Fix: If _mapSerializer is null, attempt to create a new MapSerializer instance and use it\n    _mapSerializer = new MapSerializer(null, null, null, null, null, null, null);\n    _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    // Fix: Cast _mapSerializer to Map<Object, Object> instead of MapSerializer\n    _mapSerializer = (Map<Object, Object>) provider.handlePrimaryContextualization(_mapSerializer, _property);\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.getUnknownTypeSerializer(Object.class);\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    props = filterBeanProperties(config, beanDesc, props);\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n    builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n        PropertyName name = new PropertyName(anyGetter.getName());\n        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n    }\n    processViews(config, builder);\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n    if (ser == null) {\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n        // Fix: If we still can't create a serializer, return default serializer\n        return prov.findValueSerializer(beanDesc.getType(), null);\n    }\n    return ser;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,5 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    _mapSerializer = serializer;  // Removed unnecessary (MapSerializer) cast\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n@@ -6,9 +6,11 @@\n     if (!(value instanceof Map<?, ?>)) {\n         throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n-    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n     if (_mapSerializer != null) {\n         _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n         return;\n     }\n+    // Fix: If _mapSerializer is null, attempt to create a new MapSerializer instance and use it\n+    _mapSerializer = new MapSerializer(null, null, null, null, null, null, null);\n+    _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n@@ -6,10 +6,11 @@\n     if (!(value instanceof Map<?, ?>)) {\n         throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n-    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n     if (_mapSerializer != null) {\n         _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n         return;\n     }\n-    // ... not sure how custom handler would do it\n+    // Fix: If _mapSerializer is null, attempt to create a new MapSerializer instance and use it\n+    _mapSerializer = new MapSerializer(null, null, null, null, null, null, null);\n+    _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer;  // Removed unnecessary (MapSerializer) cast\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n-    }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer;  // Removed unnecessary (MapSerializer) cast\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    _mapSerializer = serializer;\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw JsonMappingException.from(gen, \"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n        return;\n    }\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw JsonMappingException.from(gen, \"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n        return;\n    }\n    // ... not sure how custom handler would do it\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n    JsonSerializer<?> ser = provider.handlePrimaryContextualization(_mapSerializer, _property);\n    if (ser instanceof MapSerializer) {\n        _mapSerializer = (MapSerializer) ser;\n    }\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.findValueSerializer(Object.class);\n        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    // First: any detectable (auto-detect, annotations) properties to serialize?\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    // [databind#638]: Allow injection of \"virtual\" properties:\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    // [JACKSON-440] Need to allow modification bean properties to serialize:\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    // Any properties to suppress?\n    props = filterBeanProperties(config, beanDesc, props);\n    // [JACKSON-440] Need to allow reordering of properties to serialize\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n    builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        // copied from BasicSerializerFactory.buildMapSerializer():\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        // last 2 nulls; don't know key, value serializers (yet)\n        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n        // TODO: support '@JsonIgnoreProperties' with any setter?\n        // TODO: can we find full PropertyName?\n        PropertyName name = new PropertyName(anyGetter.getName());\n        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n    }\n    // Next: need to gather view information, if any:\n    processViews(config, builder);\n    // Finally: let interested parties mess with the result bit more...\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n    if (ser == null) {\n        // If we get this far, there were no properties found, so no regular BeanSerializer\n        // would be constructed. But, couple of exceptions.\n        // First: if there are known annotations, just create 'empty bean' serializer\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n    }\n    return ser;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,5 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    _mapSerializer = serializer;\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n@@ -4,7 +4,7 @@\n         return;\n     }\n     if (!(value instanceof Map<?, ?>)) {\n-        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n+        throw JsonMappingException.from(gen, \"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n     // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n     if (_mapSerializer != null) {\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n@@ -4,7 +4,7 @@\n         return;\n     }\n     if (!(value instanceof Map<?, ?>)) {\n-        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n+        throw JsonMappingException.from(gen, \"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n     // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n     if (_mapSerializer != null) {\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer;\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n-    }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    _mapSerializer = serializer; // remove unnecessary casting\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n        return;\n    }\n    // FIXED: if _mapSerializer is null, create it on-the-fly\n    MapSerializer mapSerializer = (MapSerializer) provider.findValueSerializer(value.getClass());\n    mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n        return;\n    }\n    // FIXED: if _mapSerializer is null, create it on-the-fly\n    MapSerializer mapSerializer = (MapSerializer) provider.findValueSerializer(value.getClass());\n    mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n    // FIXED: avoid unnecessary cast\n    _mapSerializer = provider.handlePrimaryContextualization(_mapSerializer, _property);\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.getUnknownTypeSerializer(Object.class);\n        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    // First: any detectable (auto-detect, annotations) properties to serialize?\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    // [databind#638]: Allow injection of \"virtual\" properties:\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    // [JACKSON-440] Need to allow modification bean properties to serialize:\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    // Any properties to suppress?\n    props = filterBeanProperties(config, beanDesc, props);\n    // [JACKSON-440] Need to allow reordering of properties to serialize\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        // copied from BasicSerializerFactory.buildMapSerializer():\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        // last 2 nulls; don't know key, value serializers (yet)\n        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n        // FIXED: create MapSerializer on-the-fly, rather than relying on _mapSerializer field\n        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n        // TODO: support '@JsonIgnoreProperties' with any setter?\n        // TODO: can we find full PropertyName?\n        PropertyName name = new PropertyName(anyGetter.getName());\n        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n    }\n    // Next: need to gather view information, if any:\n    processViews(config, builder);\n    // Finally: let interested parties mess with the result bit more...\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n    if (ser == null) {\n        // If we get this far, there were no properties found, so no regular BeanSerializer\n        // would be constructed. But, couple of exceptions.\n        // First: if there are known annotations, just create 'empty bean' serializer\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n    }\n    return ser;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,5 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    _mapSerializer = serializer; // remove unnecessary casting\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n@@ -11,4 +11,7 @@\n         _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n         return;\n     }\n+    // FIXED: if _mapSerializer is null, create it on-the-fly\n+    MapSerializer mapSerializer = (MapSerializer) provider.findValueSerializer(value.getClass());\n+    mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n@@ -11,5 +11,7 @@\n         _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n         return;\n     }\n-    // ... not sure how custom handler would do it\n+    // FIXED: if _mapSerializer is null, create it on-the-fly\n+    MapSerializer mapSerializer = (MapSerializer) provider.findValueSerializer(value.getClass());\n+    mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer; // remove unnecessary casting\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n-    }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer; // remove unnecessary casting\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    if (serializer != null) {\n        _mapSerializer = (MapSerializer) serializer;\n    }\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n    }\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n    }\n    // ... not sure how custom handler would do it\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    if (_mapSerializer != null) {\n        _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n    }\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.getUnknownTypeSerializer(Object.class);\n        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    // First: any detectable (auto-detect, annotations) properties to serialize?\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    // [databind#638]: Allow injection of \"virtual\" properties:\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    // [JACKSON-440] Need to allow modification bean properties to serialize:\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    // Any properties to suppress?\n    props = filterBeanProperties(config, beanDesc, props);\n    // [JACKSON-440] Need to allow reordering of properties to serialize\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n    builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        // copied from BasicSerializerFactory.buildMapSerializer():\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        // last 2 nulls; don't know key, value serializers (yet)\n        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n        // TODO: support '@JsonIgnoreProperties' with any setter?\n        // TODO: can we find full PropertyName?\n        PropertyName name = new PropertyName(anyGetter.getName());\n        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n    }\n    // Next: need to gather view information, if any:\n    processViews(config, builder);\n    // Finally: let interested parties mess with the result bit more...\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n    if (ser == null) {\n        // If we get this far, there were no properties found, so no regular BeanSerializer\n        // would be constructed. But, couple of exceptions.\n        // First: if there are known annotations, just create 'empty bean' serializer\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n        // Second: better give a warning if this happens, to avoid\n        // ticket #360\n        if (!props.isEmpty()) {\n            /* 27-Jan-2012, tatu: But only warn if we are (most likely) producing JSON.\n             *   In other modes it's bit too easy to hit this with non-JSON output. For now,\n             *   I will assume that if \"JsonGenerator\" is listed as provider, it is JSON\n             *   (possibly wrongly -- may need to revise in future)\n             */\n            if (prov != null && prov.getGenerator() != null) {\n                if (prov.getGenerator().getClass().getName().contains(\"jackson\")) {\n                    // 22-May-2015, tatu: as per [databind#743], use logging to warn as well\n                    String msg = \"JSON\";\n                    if (prov != null) {\n                        msg = String.format(\"JSON (via %s)\", prov.getGenerator().getClass().getName());\n                    }\n                    LoggerFactory.getLogger(beanDesc.getBeanClass()).warn(\"Empty %s BeanSerializer for %s\", msg, beanDesc.getBeanClass());\n                }\n            }\n        }\n    }\n    return ser;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,7 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    if (serializer != null) {\n+        _mapSerializer = (MapSerializer) serializer;\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n@@ -9,6 +9,5 @@\n     // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n     if (_mapSerializer != null) {\n         _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n-        return;\n     }\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n@@ -9,7 +9,6 @@\n     // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n     if (_mapSerializer != null) {\n         _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n-        return;\n     }\n     // ... not sure how custom handler would do it\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,8 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    if (serializer != null) {\n+        _mapSerializer = (MapSerializer) serializer;\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,8 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    if (serializer != null) {\n+        _mapSerializer = (MapSerializer) serializer;\n     }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    _mapSerializer = serializer; // No need to cast to MapSerializer, serializer is already of type MapSerializer\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n        return;\n    }\n    // Use default MapSerializer if none is defined\n    MapSerializer defaultMapSerializer = (MapSerializer) provider.findValueSerializer(Map.class);\n    defaultMapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n        return;\n    }\n    // Use default MapSerializer if none is defined\n    MapSerializer defaultMapSerializer = (MapSerializer) provider.findValueSerializer(Map.class);\n    defaultMapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n    // No need to cast to MapSerializer, handlePrimaryContextualization() already returns a MapSerializer\n    _mapSerializer = provider.handlePrimaryContextualization(_mapSerializer, _property);\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.getUnknownTypeSerializer(Object.class);\n        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    // First: any detectable (auto-detect, annotations) properties to serialize?\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    // [databind#638]: Allow injection of \"virtual\" properties:\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    // [JACKSON-440] Need to allow modification bean properties to serialize:\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    // Any properties to suppress?\n    props = filterBeanProperties(config, beanDesc, props);\n    // [JACKSON-440] Need to allow reordering of properties to serialize\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n    builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        // copied from BasicSerializerFactory.buildMapSerializer():\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        // last 2 nulls; don't know key, value serializers (yet)\n        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n        JsonSerializer<?> mapValueSerializer = null;\n        JsonSerializer<?> mapKeySerializer = null;\n        if (_factoryConfig.hasKeySerializers()) {\n            mapKeySerializer = _factoryConfig.keySerializers().findSerializer(config, valueType, null);\n        }\n        if (mapKeySerializer == null) {\n            mapKeySerializer = valueType.getValueHandler();\n        }\n        if (_factoryConfig.hasSerializers()) {\n            mapValueSerializer = _factoryConfig.serializers().findSerializer(config, valueType, null);\n        }\n        if (mapValueSerializer == null) {\n            mapValueSerializer = prov.findValueSerializer(valueType, _property);\n        }\n        MapSerializer anySer = MapSerializer.construct((Set<String>) null, valueType, staticTyping, typeSer, mapKeySerializer, valueType.getValueHandler(), mapValueSerializer);\n        // TODO: support '@JsonIgnoreProperties' with any setter?\n        // TODO: can we find full PropertyName?\n        PropertyName name = new PropertyName(anyGetter.getName());\n        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n    }\n    // Next: need to gather view information, if any:\n    processViews(config, builder);\n    // Finally: let interested parties mess with the result bit more...\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n    if (ser == null) {\n        // If we get this far, there were no properties found, so no regular BeanSerializer\n        // would be constructed. But, couple of exceptions.\n        // First: if there are known annotations, just create 'empty bean' serializer\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n    }\n    return ser;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,5 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    _mapSerializer = serializer; // No need to cast to MapSerializer, serializer is already of type MapSerializer\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n@@ -11,4 +11,7 @@\n         _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n         return;\n     }\n+    // Use default MapSerializer if none is defined\n+    MapSerializer defaultMapSerializer = (MapSerializer) provider.findValueSerializer(Map.class);\n+    defaultMapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n@@ -11,5 +11,7 @@\n         _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n         return;\n     }\n-    // ... not sure how custom handler would do it\n+    // Use default MapSerializer if none is defined\n+    MapSerializer defaultMapSerializer = (MapSerializer) provider.findValueSerializer(Map.class);\n+    defaultMapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer; // No need to cast to MapSerializer, serializer is already of type MapSerializer\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n-    }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer; // No need to cast to MapSerializer, serializer is already of type MapSerializer\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    if (serializer instanceof MapSerializer) { // add this check to avoid ClassCastException\n        _mapSerializer = (MapSerializer) serializer; // cast only if serializer is an instance of MapSerializer\n    }\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n        return;\n    } else {\n        Map<Object, Object> filteredMap = new HashMap<>();\n        for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {\n            if (_property.getFilterId() != null) {\n                provider.findPropertyFilter(_property.getFilterId(), bean).serializeAsField(bean, gen, provider, entry.getKey(), entry.getValue());\n            } else {\n                gen.writeFieldName(entry.getKey().toString());\n                provider.defaultSerializeValue(entry.getValue(), gen);\n            }\n        }\n    }\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n        return;\n    } else {\n        Map<Object, Object> filteredMap = new HashMap<>();\n        for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {\n            if (filter.include(_property, entry.getKey(), entry.getValue())) {\n                filteredMap.put(entry.getKey(), entry.getValue());\n            }\n        }\n        provider.defaultSerializeValue(filteredMap, gen);\n    }\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    JsonSerializer<Object> ser = provider.handlePrimaryContextualization(_mapSerializer, _property);\n    if (ser instanceof MapSerializer) { // add this check to avoid ClassCastException\n        _mapSerializer = (MapSerializer) ser; // cast only if ser is an instance of MapSerializer\n    }\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.getUnknownTypeSerializer(Object.class);\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    props = filterBeanProperties(config, beanDesc, props);\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n    builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n        PropertyName name = new PropertyName(anyGetter.getName());\n        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n    }\n    processViews(config, builder);\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n    if (ser == null) {\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n    }\n    if (ser instanceof BeanSerializer) { // add this check to avoid ClassCastException\n        addSerializerProperties((BeanSerializer) ser); // call the method to add 'properties' serializer\n    }\n    return ser;\n}\n\n// Additional Fixed Function\nprotected void addSerializerProperties(BeanSerializer serializer) {\n    JsonSerializer<Object> serializerProperties = new JsonSerializer<Object>() {\n        @Override\n        public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n            gen.writeStartObject();\n            gen.writeStringField(\"property_name\", \"property_value\");\n            gen.writeEndObject();\n        }\n    };\n    Map<String, JsonSerializer<Object>> properties = serializer.getProperties();\n    if (properties != null) { // check if properties is null to avoid NullPointerException\n        properties.put(\"serializer_properties\", serializerProperties);\n    }\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,7 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    if (serializer instanceof MapSerializer) { // add this check to avoid ClassCastException\n+        _mapSerializer = (MapSerializer) serializer; // cast only if serializer is an instance of MapSerializer\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n@@ -6,9 +6,18 @@\n     if (!(value instanceof Map<?, ?>)) {\n         throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n-    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n     if (_mapSerializer != null) {\n         _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n         return;\n+    } else {\n+        Map<Object, Object> filteredMap = new HashMap<>();\n+        for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {\n+            if (_property.getFilterId() != null) {\n+                provider.findPropertyFilter(_property.getFilterId(), bean).serializeAsField(bean, gen, provider, entry.getKey(), entry.getValue());\n+            } else {\n+                gen.writeFieldName(entry.getKey().toString());\n+                provider.defaultSerializeValue(entry.getValue(), gen);\n+            }\n+        }\n     }\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n@@ -6,10 +6,16 @@\n     if (!(value instanceof Map<?, ?>)) {\n         throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n-    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n     if (_mapSerializer != null) {\n         _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n         return;\n+    } else {\n+        Map<Object, Object> filteredMap = new HashMap<>();\n+        for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {\n+            if (filter.include(_property, entry.getKey(), entry.getValue())) {\n+                filteredMap.put(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        provider.defaultSerializeValue(filteredMap, gen);\n     }\n-    // ... not sure how custom handler would do it\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,8 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    if (serializer instanceof MapSerializer) { // add this check to avoid ClassCastException\n+        _mapSerializer = (MapSerializer) serializer; // cast only if serializer is an instance of MapSerializer\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,8 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    if (serializer instanceof MapSerializer) { // add this check to avoid ClassCastException\n+        _mapSerializer = (MapSerializer) serializer; // cast only if serializer is an instance of MapSerializer\n     }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    _mapSerializer = serializer instanceof MapSerializer ? (MapSerializer) serializer : null;\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n        return;\n    } else {\n        JsonSerializer<Object> ser = provider.findValueSerializer(value.getClass(), _property);\n        ser.serialize(value, gen, provider);\n    }\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n        return;\n    } else {\n        JsonSerializer<Object> ser = provider.findValueSerializer(value.getClass(), _property);\n        ser.serialize(value, gen, provider);\n    }\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n    JsonSerializer<?> ser = provider.handlePrimaryContextualization(_mapSerializer, _property);\n    if (ser instanceof MapSerializer) {\n        _mapSerializer = (MapSerializer) ser;\n    } else {\n        _mapSerializer = null;\n    }\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.getUnknownTypeSerializer(Object.class);\n        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    // First: any detectable (auto-detect, annotations) properties to serialize?\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    // [databind#638]: Allow injection of \"virtual\" properties:\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    // [JACKSON-440] Need to allow modification bean properties to serialize:\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    // Any properties to suppress?\n    props = filterBeanProperties(config, beanDesc, props);\n    // [JACKSON-440] Need to allow reordering of properties to serialize\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        // copied from BasicSerializerFactory.buildMapSerializer():\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        // last 2 nulls; don't know key, value serializers (yet)\n        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n        // TODO: support '@JsonIgnoreProperties' with any setter?\n        // TODO: can we find full PropertyName?\n        PropertyName name = new PropertyName(anyGetter.getName());\n        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n        if (_mapSerializer != null) {\n            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, _mapSerializer));\n        } else {\n            builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n        }\n    }\n    // Next: need to gather view information, if any:\n    processViews(config, builder);\n    // Finally: let interested parties mess with the result bit more...\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n    if (ser == null) {\n        // If we get this far, there were no properties found, so no regular BeanSerializer\n        // would be constructed. But, couple of exceptions.\n        // First: if there are known annotations, just create 'empty bean' serializer\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n    }\n    return ser;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,5 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    _mapSerializer = serializer instanceof MapSerializer ? (MapSerializer) serializer : null;\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n@@ -10,5 +10,8 @@\n     if (_mapSerializer != null) {\n         _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n         return;\n+    } else {\n+        JsonSerializer<Object> ser = provider.findValueSerializer(value.getClass(), _property);\n+        ser.serialize(value, gen, provider);\n     }\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n@@ -10,6 +10,8 @@\n     if (_mapSerializer != null) {\n         _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n         return;\n+    } else {\n+        JsonSerializer<Object> ser = provider.findValueSerializer(value.getClass(), _property);\n+        ser.serialize(value, gen, provider);\n     }\n-    // ... not sure how custom handler would do it\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer instanceof MapSerializer ? (MapSerializer) serializer : null;\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n-    }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer instanceof MapSerializer ? (MapSerializer) serializer : null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    _mapSerializer = serializer; //remove cast to MapSerializer \n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n        return;\n    }\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n        return;\n    }\n    // ... not sure how custom handler would do it\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n    if(_mapSerializer == null) return; //return if null\n    _mapSerializer = provider.handlePrimaryContextualization(_mapSerializer, _property);\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.getUnknownTypeSerializer(Object.class);\n        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    // First: any detectable (auto-detect, annotations) properties to serialize?\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    // [databind#638]: Allow injection of \"virtual\" properties:\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    // [JACKSON-440] Need to allow modification bean properties to serialize:\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    // Any properties to suppress?\n    props = filterBeanProperties(config, beanDesc, props);\n    // [JACKSON-440] Need to allow reordering of properties to serialize\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        // copied from BasicSerializerFactory.buildMapSerializer():\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        // last 2 nulls; don't know key, value serializers (yet)\n        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n        // TODO: support '@JsonIgnoreProperties' with any setter?\n        // TODO: can we find full PropertyName?\n        PropertyName name = new PropertyName(anyGetter.getName());\n        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n    }\n    // Next: need to gather view information, if any:\n    processViews(config, builder);\n    // Finally: let interested parties mess with the result bit more...\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n    if (ser == null) {\n        // If we get this far, there were no properties found, so no regular BeanSerializer\n        // would be constructed. But, couple of exceptions.\n        // First: if there are known annotations, just create 'empty bean' serializer\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n    }\n    return ser;\n}\n\nNote: It is highly recommended to consult the official repository of JacksonDatabind or the official documentation to obtain the latest Fixed Functions.", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,5 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    _mapSerializer = serializer; //remove cast to MapSerializer \n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer; //remove cast to MapSerializer \n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n-    }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer; //remove cast to MapSerializer \n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    _mapSerializer = serializer; // removed unnecessary casting\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n        return;\n    } else {\n        throw new JsonMappingException(\"No serializer found for Map property \" + _property.getName() + \" in class \" + bean.getClass().getName());\n    } // added error handling for missing serializer\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n        return;\n    } else {\n        throw new JsonMappingException(\"No serializer found for Map property \" + _property.getName() + \" in class \" + bean.getClass().getName());\n    } // added error handling for missing serializer\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    if (_mapSerializer == null) { // added null check\n        return;\n    }\n    _mapSerializer = provider.handlePrimaryContextualization(_mapSerializer, _property);\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.getUnknownTypeSerializer(Object.class);\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    props = filterBeanProperties(config, beanDesc, props);\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n    builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n        PropertyName name = new PropertyName(anyGetter.getName());\n        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n    } else {\n        builder.setAnyGetter(null); // added to remove any getter if none is found\n    }\n    processViews(config, builder);\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n    if (ser == null) {\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n    }\n    return ser;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,5 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    _mapSerializer = serializer; // removed unnecessary casting\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n@@ -6,9 +6,10 @@\n     if (!(value instanceof Map<?, ?>)) {\n         throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n-    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n     if (_mapSerializer != null) {\n         _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n         return;\n-    }\n+    } else {\n+        throw new JsonMappingException(\"No serializer found for Map property \" + _property.getName() + \" in class \" + bean.getClass().getName());\n+    } // added error handling for missing serializer\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n@@ -6,10 +6,10 @@\n     if (!(value instanceof Map<?, ?>)) {\n         throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n-    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n     if (_mapSerializer != null) {\n         _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n         return;\n-    }\n-    // ... not sure how custom handler would do it\n+    } else {\n+        throw new JsonMappingException(\"No serializer found for Map property \" + _property.getName() + \" in class \" + bean.getClass().getName());\n+    } // added error handling for missing serializer\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer; // removed unnecessary casting\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n-    }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer; // removed unnecessary casting\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    _mapSerializer = serializer; // remove unnecessary casting\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n        return;\n    } else {\n        Map<?, ?> valueMap = (Map<?, ?>) value;\n        gen.writeStartObject();\n        for (Map.Entry<?, ?> entry : valueMap.entrySet()) {\n            gen.writeFieldName(String.valueOf(entry.getKey()));\n            provider.defaultSerializeValue(entry.getValue(), gen);\n        }\n        gen.writeEndObject();\n        return;\n    }\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n        return;\n    } else {\n        Map<?, ?> valueMap = (Map<?, ?>) value;\n        PropertyFilter mapFilter = new MapPropertyFilter(filter);\n        gen.writeStartObject();\n        for (Map.Entry<?, ?> entry : valueMap.entrySet()) {\n            if (mapFilter.include(entry, gen, provider) == FilterResult.INCLUDE_PROPERTY) {\n                gen.writeFieldName(String.valueOf(entry.getKey()));\n                provider.defaultSerializeValue(entry.getValue(), gen);\n            }\n        }\n        gen.writeEndObject();\n        return;\n    }\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    _mapSerializer = provider.handlePrimaryContextualization(_mapSerializer, _property);\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.findNullValueSerializer(beanDesc.getBeanProperty());\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    props = filterBeanProperties(config, beanDesc, props);\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n    builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        Map<Object, Object> filterMap = null;\n        if (valueType.isMapLikeType()) {\n            filterMap = new HashMap<Object, Object>();\n            builder.setAnyGetter(new AnyGetterWriter(new BeanProperty.Std(PropertyName.construct(anyGetter.getName()), valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL), anyGetter, null));\n        } else {\n            MapSerializer anyMapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n            filterMap = anyMapSer.getFilterId() == null ? new HashMap<Object, Object>() : null;\n            builder.setAnyGetter(new AnyGetterWriter(new BeanProperty.Std(PropertyName.construct(anyGetter.getName()), valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL), anyGetter, anyMapSer));\n        }\n        if (filterMap != null) {\n            provider.getFilterProvider().findPropertyFilter(beanDesc.getClassInfo(), filterMap, anyGetter);\n        }\n    }\n    processViews(config, builder);\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<?> ser = builder.build();\n    if (ser == null) {\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n    }\n    return (JsonSerializer<Object>) ser;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,5 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    _mapSerializer = serializer; // remove unnecessary casting\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n@@ -6,9 +6,17 @@\n     if (!(value instanceof Map<?, ?>)) {\n         throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n-    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n     if (_mapSerializer != null) {\n         _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n         return;\n+    } else {\n+        Map<?, ?> valueMap = (Map<?, ?>) value;\n+        gen.writeStartObject();\n+        for (Map.Entry<?, ?> entry : valueMap.entrySet()) {\n+            gen.writeFieldName(String.valueOf(entry.getKey()));\n+            provider.defaultSerializeValue(entry.getValue(), gen);\n+        }\n+        gen.writeEndObject();\n+        return;\n     }\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n@@ -6,10 +6,20 @@\n     if (!(value instanceof Map<?, ?>)) {\n         throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n-    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n     if (_mapSerializer != null) {\n         _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n         return;\n+    } else {\n+        Map<?, ?> valueMap = (Map<?, ?>) value;\n+        PropertyFilter mapFilter = new MapPropertyFilter(filter);\n+        gen.writeStartObject();\n+        for (Map.Entry<?, ?> entry : valueMap.entrySet()) {\n+            if (mapFilter.include(entry, gen, provider) == FilterResult.INCLUDE_PROPERTY) {\n+                gen.writeFieldName(String.valueOf(entry.getKey()));\n+                provider.defaultSerializeValue(entry.getValue(), gen);\n+            }\n+        }\n+        gen.writeEndObject();\n+        return;\n     }\n-    // ... not sure how custom handler would do it\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer; // remove unnecessary casting\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n-    }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer; // remove unnecessary casting\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    _mapSerializer = serializer; // removed cast to MapSerializer\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n        return;\n    }\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n        return;\n    }\n    // ... not sure how custom handler would do it\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n    _mapSerializer = provider.handlePrimaryContextualization(_mapSerializer, _property); // removed cast to MapSerializer\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.getUnknownTypeSerializer(Object.class);\n        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    // First: any detectable (auto-detect, annotations) properties to serialize?\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    // [databind#638]: Allow injection of \"virtual\" properties:\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    // [JACKSON-440] Need to allow modification bean properties to serialize:\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    // Any properties to suppress?\n    props = filterBeanProperties(config, beanDesc, props);\n    // [JACKSON-440] Need to allow reordering of properties to serialize\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        // copied from BasicSerializerFactory.buildMapSerializer():\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        // last 2 nulls; don't know key, value serializers (yet)\n        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n        JsonSerializer<?> ser = provider.findValueSerializer(valueType, anyGetter); // changed to use provider to find serializer\n        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, ser, null); // passed ser to MapSerializer\n        // TODO: support '@JsonIgnoreProperties' with any setter?\n        // TODO: can we find full PropertyName?\n        PropertyName name = new PropertyName(anyGetter.getName());\n        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n    }\n    // Next: need to gather view information, if any:\n    processViews(config, builder);\n    // Finally: let interested parties mess with the result bit more...\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n    if (ser == null) {\n        // If we get this far, there were no properties found, so no regular BeanSerializer\n        // would be constructed. But, couple of exceptions.\n        // First: if there are known annotations, just create 'empty bean' serializer\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n    }\n    return ser;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,5 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    _mapSerializer = serializer; // removed cast to MapSerializer\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer; // removed cast to MapSerializer\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n-    }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer; // removed cast to MapSerializer\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    if(serializer instanceof MapSerializer) {\n        _mapSerializer = (MapSerializer) serializer;\n    } else {\n        _mapSerializer = null;\n    }\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n        return;\n    } else {\n        JsonSerializer<Object> ser = provider.findValueSerializer(value.getClass(), _property);\n        ser.serialize(value, gen, provider);\n        return;\n    }\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n        return;\n    } else {\n        JsonSerializer<Object> ser = provider.findValueSerializer(value.getClass(), _property);\n        if (ser instanceof PropertyFilter) {\n            ((PropertyFilter) ser).serializeAsField(bean, gen, provider, filter);\n        } else {\n            ser.serialize(value, gen, provider);\n        }\n        return;\n    }\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n    if (_mapSerializer != null) {\n        _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n    }\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.getUnknownTypeSerializer(Object.class);\n        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    // First: any detectable (auto-detect, annotations) properties to serialize?\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    // [databind#638]: Allow injection of \"virtual\" properties:\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    // [JACKSON-440] Need to allow modification bean properties to serialize:\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    // Any properties to suppress?\n    props = filterBeanProperties(config, beanDesc, props);\n    // [JACKSON-440] Need to allow reordering of properties to serialize\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n    builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        // copied from BasicSerializerFactory.buildMapSerializer():\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        // last 2 nulls; don't know key, value serializers (yet)\n        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n        // TODO: support '@JsonIgnoreProperties' with any setter?\n        // TODO: can we find full PropertyName?\n        PropertyName name = new PropertyName(anyGetter.getName());\n        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n    }\n    // Next: need to gather view information, if any:\n    processViews(config, builder);\n    // Finally: let interested parties mess with the result bit more...\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n    if (ser == null) {\n        // If we get this far, there were no properties found, so no regular BeanSerializer\n        // would be constructed. But, couple of exceptions.\n        // First: if there are known annotations, just create 'empty bean' serializer\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n        // and second, for non-structured types (primitives, wrappers), let's just use basic\n        // serializer that does handle name, inclusion etc:\n        if (BeanUtil.isStdJdkCollection(beanDesc.getBeanClass())\n                || BeanUtil.isStdJdkMapOrItsSubclass(beanDesc.getBeanClass())) {\n            return buildContainerSerializer(prov, beanDesc);\n        }\n    }\n    return ser;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,9 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    if(serializer instanceof MapSerializer) {\n+        _mapSerializer = (MapSerializer) serializer;\n+    } else {\n+        _mapSerializer = null;\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n@@ -10,5 +10,9 @@\n     if (_mapSerializer != null) {\n         _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n         return;\n+    } else {\n+        JsonSerializer<Object> ser = provider.findValueSerializer(value.getClass(), _property);\n+        ser.serialize(value, gen, provider);\n+        return;\n     }\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n@@ -10,6 +10,13 @@\n     if (_mapSerializer != null) {\n         _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n         return;\n+    } else {\n+        JsonSerializer<Object> ser = provider.findValueSerializer(value.getClass(), _property);\n+        if (ser instanceof PropertyFilter) {\n+            ((PropertyFilter) ser).serializeAsField(bean, gen, provider, filter);\n+        } else {\n+            ser.serialize(value, gen, provider);\n+        }\n+        return;\n     }\n-    // ... not sure how custom handler would do it\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,10 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    if(serializer instanceof MapSerializer) {\n+        _mapSerializer = (MapSerializer) serializer;\n+    } else {\n+        _mapSerializer = null;\n+    }\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,10 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    if(serializer instanceof MapSerializer) {\n+        _mapSerializer = (MapSerializer) serializer;\n+    } else {\n+        _mapSerializer = null;\n     }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    _mapSerializer = serializer; // Removed unnecessary cast\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map)) { // Removed unnecessary generic type specification\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFields((Map) value, gen, provider); // Removed unnecessary generic type specification\n        return;\n    }\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map)) { // Removed unnecessary generic type specification\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFilteredFields((Map) value, gen, provider, filter, null); // Removed unnecessary generic type specification\n        return;\n    }\n    // ... not sure how custom handler would do it\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n    _mapSerializer = provider.handlePrimaryContextualization(_mapSerializer, _property); // Removed unnecessary cast\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.getUnknownTypeSerializer(Object.class);\n        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    // First: any detectable (auto-detect, annotations) properties to serialize?\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<>();\n    }\n    // [databind#638]: Allow injection of \"virtual\" properties:\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    // [JACKSON-440] Need to allow modification bean properties to serialize:\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    // Any properties to suppress?\n    props = filterBeanProperties(config, beanDesc, props);\n    // [JACKSON-440] Need to allow reordering of properties to serialize\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n    builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        // copied from BasicSerializerFactory.buildMapSerializer():\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        // last 2 nulls; don't know key, value serializers (yet)\n        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n        // TODO: support '@JsonIgnoreProperties' with any setter?\n        // TODO: can we find full PropertyName?\n        PropertyName name = new PropertyName(anyGetter.getName());\n        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n    }\n    // Next: need to gather view information, if any:\n    processViews(config, builder);\n    // Finally: let interested parties mess with the result bit more...\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n    if (ser == null) {\n        // If we get this far, there were no properties found, so no regular BeanSerializer\n        // would be constructed. But, couple of exceptions.\n        // First: if there are known annotations, just create 'empty bean' serializer\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n    }\n    return ser;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,5 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    _mapSerializer = serializer; // Removed unnecessary cast\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n@@ -3,12 +3,12 @@\n     if (value == null) {\n         return;\n     }\n-    if (!(value instanceof Map<?, ?>)) {\n+    if (!(value instanceof Map)) { // Removed unnecessary generic type specification\n         throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n     // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n     if (_mapSerializer != null) {\n-        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n+        _mapSerializer.serializeFields((Map) value, gen, provider); // Removed unnecessary generic type specification\n         return;\n     }\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n@@ -3,12 +3,12 @@\n     if (value == null) {\n         return;\n     }\n-    if (!(value instanceof Map<?, ?>)) {\n+    if (!(value instanceof Map)) { // Removed unnecessary generic type specification\n         throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n     // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n     if (_mapSerializer != null) {\n-        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n+        _mapSerializer.serializeFilteredFields((Map) value, gen, provider, filter, null); // Removed unnecessary generic type specification\n         return;\n     }\n     // ... not sure how custom handler would do it\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer; // Removed unnecessary cast\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n-    }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer; // Removed unnecessary cast\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    _mapSerializer = serializer;\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n        return;\n    }\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n    if (_mapSerializer != null) {\n        // use serializer's filterId if there is one, otherwise use bean property's filterId\n        Object filterId = (_mapSerializer.getFilterId() == null) ? _property.getFilterId() : _mapSerializer.getFilterId();\n        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, filterId);\n        return;\n    }\n    // ... not sure how custom handler would do it\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n    if (beanDesc.getBeanClass() == Object.class) {\n        return prov.getUnknownTypeSerializer(Object.class);\n        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n    // First: any detectable (auto-detect, annotations) properties to serialize?\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    // [databind#638]: Allow injection of \"virtual\" properties:\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    // [JACKSON-440] Need to allow modification bean properties to serialize:\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    // Any properties to suppress?\n    props = filterBeanProperties(config, beanDesc, props);\n    // [JACKSON-440] Need to allow reordering of properties to serialize\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        // copied from BasicSerializerFactory.buildMapSerializer():\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        JsonSerializer<?> anySer; \n        // last 2 nulls; don't know key, value serializers (yet)\n        if (_factoryConfig.hasSerializerModifiers()) {\n            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                anySer = mod.modifySerializer(config, anyGetter, null, _mapSerializer);\n            }\n        }\n        anySer = (_mapSerializer == null) ? MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null) :\n                _mapSerializer.createContextual(config, anyGetter);\n        // TODO: support '@JsonIgnoreProperties' with any setter?\n        // TODO: can we find full PropertyName?\n        PropertyName name = new PropertyName(anyGetter.getName());\n        BeanProperty StdanyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n        builder.setAnyGetter(new AnyGetterWriter(StdanyProp, anyGetter, anySer));\n    }\n    // Next: need to gather view information, if any:\n    processViews(config, builder);\n    // Finally: let interested parties mess with the result bit more...\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n    if (ser == null) {\n        // If we get this far, there were no properties found, so no regular BeanSerializer\n        // would be constructed. But, couple of exceptions.\n        // First: if there are known annotations, just create 'empty bean' serializer\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n    }\n    return ser;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,5 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    _mapSerializer = serializer;\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n@@ -8,7 +8,9 @@\n     }\n     // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n     if (_mapSerializer != null) {\n-        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n+        // use serializer's filterId if there is one, otherwise use bean property's filterId\n+        Object filterId = (_mapSerializer.getFilterId() == null) ? _property.getFilterId() : _mapSerializer.getFilterId();\n+        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, filterId);\n         return;\n     }\n     // ... not sure how custom handler would do it\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer;\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n-    }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\n@SuppressWarnings(\"unchecked\")\npublic AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n    _accessor = accessor;\n    _property = property;\n    _mapSerializer = serializer; // remove unnecessary casting\n}\n\n## Fixed Function 2\npublic void getAndSerialize(Object bean, JsonGenerator gen, SerializerProvider provider) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n        return;\n    } else {\n        // add handling for _dynamicSerializers not being null\n        Map<Object, Object> dynamicValues = (Map<Object, Object>) value;\n        JsonSerializer<Object> valueSerializer = null;\n        TypeSerializer typeSerializer = null;\n        PropertySerializerMap serializers = provider.getSerializers();\n        for (Entry<Object, Object> entry : dynamicValues.entrySet()) {\n            Object dynamicKey = entry.getKey();\n            if (dynamicKey == null) {\n                provider.findNullKeySerializer(_mapSerializer).serialize(null, gen, provider);\n            } else {\n                // First: find key serializer\n                JsonSerializer<Object> keySerializer = (JsonSerializer<Object>) provider.findKeySerializer(dynamicKey.getClass(), _property);\n                // type info from property, supersedes (if any) global defaults\n                if (keySerializer instanceof ResolvableSerializer) {\n                    ((ResolvableSerializer) keySerializer).resolve(provider);\n                }\n                // then value serializer\n                Object dynamicValue = entry.getValue();\n                if (dynamicValue == null) {\n                    provider.getDefaultNullValueSerializer().serialize(null, gen, provider);\n                    continue;\n                }\n                Class<?> cls = dynamicValue.getClass();\n                valueSerializer = (JsonSerializer<Object>) serializers.serializerFor(cls);\n                if (valueSerializer == null) {\n                    if (_valueType.hasGenericTypes()) {\n                        valueSerializer = _findAndAddDynamicProvider(provider, _valueType.forRawClass(cls));\n                    } else {\n                        valueSerializer = _findAndAddDynamicProvider(provider, cls);\n                    }\n                    serializers = provider.getSerializers();\n                }\n                if (valueSerializer instanceof ResolvableSerializer) {\n                    ((ResolvableSerializer) valueSerializer).resolve(provider);\n                }\n                // Then the rest\n                JsonSerializer<Object> ser = null;\n                if (_valueTypeSerializer != null) {\n                    typeSerializer = _valueTypeSerializer;\n                }\n                ser = valueSerializer;\n                ser.serialize(dynamicValue, gen, provider);\n            }\n        }\n        return;\n    }\n}\n\n## Fixed Function 3\npublic void getAndFilter(Object bean, JsonGenerator gen, SerializerProvider provider, PropertyFilter filter) throws Exception {\n    Object value = _accessor.getValue(bean);\n    if (value == null) {\n        return;\n    }\n    if (!(value instanceof Map<?, ?>)) {\n        throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n    }\n    if (_mapSerializer != null) {\n        _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n        return;\n    } else {\n        Map<Object, Object> filteredValues = (Map<Object, Object>) value;\n        JsonSerializer<Object> valueSerializer = null;\n        TypeSerializer typeSerializer = null;\n        PropertySerializerMap serializers = provider.getSerializers();\n        for (Entry<Object, Object> entry : filteredValues.entrySet()) {\n            Object filterKey = entry.getKey();\n            Object dynamicValue = entry.getValue();\n            // First: find key serializer\n            JsonSerializer<Object> keySerializer = (JsonSerializer<Object>) provider.findKeySerializer(filterKey.getClass(), _property);\n            // type info from property, supersedes (if any) global defaults\n            if (keySerializer instanceof ResolvableSerializer) {\n                ((ResolvableSerializer) keySerializer).resolve(provider);\n            }\n            // Then value; unless skipped\n            if (dynamicValue == null) {\n                provider.getDefaultNullValueSerializer().serialize(null, gen, provider);\n                continue;\n            }\n            Class<?> cls = dynamicValue.getClass();\n            valueSerializer = (JsonSerializer<Object>) serializers.serializerFor(cls);\n            if (valueSerializer == null) {\n                if (_valueType.hasGenericTypes()) {\n                    valueSerializer = _findAndAddDynamicProvider(provider, _valueType.forRawClass(cls));\n                } else {\n                    valueSerializer = _findAndAddDynamicProvider(provider, cls);\n                }\n                serializers = provider.getSerializers();\n            }\n            if (valueSerializer instanceof ResolvableSerializer) {\n                ((ResolvableSerializer) valueSerializer).resolve(provider);\n            }\n            // Then the rest\n            JsonSerializer<Object> ser = null;\n            if (_valueTypeSerializer != null) {\n                typeSerializer = _valueTypeSerializer;\n            }\n            if (provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)) {\n                ser = valueSerializer;\n            } else {\n                if (dynamicValue != null) {\n                    ser = valueSerializer;\n                }\n            }\n            if (ser != null) {\n                if (typeSerializer != null) {\n                    ser.serializeWithType(dynamicValue, gen, provider, typeSerializer);\n                } else {\n                    ser.serialize(dynamicValue, gen, provider);\n                }\n            }\n        }\n        return;\n    }\n}\n\n## Fixed Function 4\n@SuppressWarnings(\"unchecked\")\npublic void resolve(SerializerProvider provider) throws JsonMappingException {\n    JsonSerializer<Object> ser = provider.handlePrimaryContextualization(_mapSerializer, _property);\n    // if returned serializer more specialized one, use it instead\n    if (ser != _mapSerializer && ser != null) {\n        _mapSerializer = (MapSerializer) ser;\n    }\n}\n\n## Fixed Function 5\n@SuppressWarnings(\"unchecked\")\nprotected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n    if (beanDesc.getBeanClass() == Object.class) {\n        // Use unknown type serializer instead of throwing exception\n        return prov.getUnknownTypeSerializer(Object.class);\n    }\n    final SerializationConfig config = prov.getConfig();\n    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n    builder.setConfig(config);\n\n    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n    if (props == null) {\n        props = new ArrayList<BeanPropertyWriter>();\n    }\n    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.changeProperties(config, beanDesc, props);\n        }\n    }\n    props = filterBeanProperties(config, beanDesc, props);\n\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            props = mod.orderProperties(config, beanDesc, props);\n        }\n    }\n    builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n    builder.setProperties(props);\n    builder.setFilterId(findFilterId(config, beanDesc));\n    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n    if (anyGetter != null) {\n        if (config.canOverrideAccessModifiers()) {\n            anyGetter.fixAccess();\n        }\n        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n        // copied from BasicSerializerFactory.buildMapSerializer():\n        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n        JavaType valueType = type.getContentType();\n        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n        PropertyName name = new PropertyName(anyGetter.getName());\n        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n    }\n    processViews(config, builder);\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            builder = mod.updateBuilder(config, beanDesc, builder);\n        }\n    }\n    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n    if (ser == null) {\n        if (beanDesc.hasKnownClassAnnotations()) {\n            return builder.createDummy();\n        }\n    }\n    if (_factoryConfig.hasSerializerModifiers()) {\n        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n            ser = mod.modifySerializer(config, beanDesc, ser);\n        }\n    }\n    return ser;\n}", "diff": "--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@AnyGetterWriter\n@@ -2,5 +2,5 @@\n public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n     _accessor = accessor;\n     _property = property;\n-    _mapSerializer = (MapSerializer) serializer;\n+    _mapSerializer = serializer; // remove unnecessary casting\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndSerialize\n@@ -6,9 +6,54 @@\n     if (!(value instanceof Map<?, ?>)) {\n         throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n-    // 23-Feb-2015, tatu: Nasty, but has to do (for now)\n     if (_mapSerializer != null) {\n         _mapSerializer.serializeFields((Map<?, ?>) value, gen, provider);\n         return;\n+    } else {\n+        // add handling for _dynamicSerializers not being null\n+        Map<Object, Object> dynamicValues = (Map<Object, Object>) value;\n+        JsonSerializer<Object> valueSerializer = null;\n+        TypeSerializer typeSerializer = null;\n+        PropertySerializerMap serializers = provider.getSerializers();\n+        for (Entry<Object, Object> entry : dynamicValues.entrySet()) {\n+            Object dynamicKey = entry.getKey();\n+            if (dynamicKey == null) {\n+                provider.findNullKeySerializer(_mapSerializer).serialize(null, gen, provider);\n+            } else {\n+                // First: find key serializer\n+                JsonSerializer<Object> keySerializer = (JsonSerializer<Object>) provider.findKeySerializer(dynamicKey.getClass(), _property);\n+                // type info from property, supersedes (if any) global defaults\n+                if (keySerializer instanceof ResolvableSerializer) {\n+                    ((ResolvableSerializer) keySerializer).resolve(provider);\n+                }\n+                // then value serializer\n+                Object dynamicValue = entry.getValue();\n+                if (dynamicValue == null) {\n+                    provider.getDefaultNullValueSerializer().serialize(null, gen, provider);\n+                    continue;\n+                }\n+                Class<?> cls = dynamicValue.getClass();\n+                valueSerializer = (JsonSerializer<Object>) serializers.serializerFor(cls);\n+                if (valueSerializer == null) {\n+                    if (_valueType.hasGenericTypes()) {\n+                        valueSerializer = _findAndAddDynamicProvider(provider, _valueType.forRawClass(cls));\n+                    } else {\n+                        valueSerializer = _findAndAddDynamicProvider(provider, cls);\n+                    }\n+                    serializers = provider.getSerializers();\n+                }\n+                if (valueSerializer instanceof ResolvableSerializer) {\n+                    ((ResolvableSerializer) valueSerializer).resolve(provider);\n+                }\n+                // Then the rest\n+                JsonSerializer<Object> ser = null;\n+                if (_valueTypeSerializer != null) {\n+                    typeSerializer = _valueTypeSerializer;\n+                }\n+                ser = valueSerializer;\n+                ser.serialize(dynamicValue, gen, provider);\n+            }\n+        }\n+        return;\n     }\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@getAndFilter\n@@ -6,10 +6,61 @@\n     if (!(value instanceof Map<?, ?>)) {\n         throw new JsonMappingException(\"Value returned by 'any-getter' (\" + _accessor.getName() + \"()) not java.util.Map but \" + value.getClass().getName());\n     }\n-    // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n     if (_mapSerializer != null) {\n         _mapSerializer.serializeFilteredFields((Map<?, ?>) value, gen, provider, filter, null);\n         return;\n+    } else {\n+        Map<Object, Object> filteredValues = (Map<Object, Object>) value;\n+        JsonSerializer<Object> valueSerializer = null;\n+        TypeSerializer typeSerializer = null;\n+        PropertySerializerMap serializers = provider.getSerializers();\n+        for (Entry<Object, Object> entry : filteredValues.entrySet()) {\n+            Object filterKey = entry.getKey();\n+            Object dynamicValue = entry.getValue();\n+            // First: find key serializer\n+            JsonSerializer<Object> keySerializer = (JsonSerializer<Object>) provider.findKeySerializer(filterKey.getClass(), _property);\n+            // type info from property, supersedes (if any) global defaults\n+            if (keySerializer instanceof ResolvableSerializer) {\n+                ((ResolvableSerializer) keySerializer).resolve(provider);\n+            }\n+            // Then value; unless skipped\n+            if (dynamicValue == null) {\n+                provider.getDefaultNullValueSerializer().serialize(null, gen, provider);\n+                continue;\n+            }\n+            Class<?> cls = dynamicValue.getClass();\n+            valueSerializer = (JsonSerializer<Object>) serializers.serializerFor(cls);\n+            if (valueSerializer == null) {\n+                if (_valueType.hasGenericTypes()) {\n+                    valueSerializer = _findAndAddDynamicProvider(provider, _valueType.forRawClass(cls));\n+                } else {\n+                    valueSerializer = _findAndAddDynamicProvider(provider, cls);\n+                }\n+                serializers = provider.getSerializers();\n+            }\n+            if (valueSerializer instanceof ResolvableSerializer) {\n+                ((ResolvableSerializer) valueSerializer).resolve(provider);\n+            }\n+            // Then the rest\n+            JsonSerializer<Object> ser = null;\n+            if (_valueTypeSerializer != null) {\n+                typeSerializer = _valueTypeSerializer;\n+            }\n+            if (provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)) {\n+                ser = valueSerializer;\n+            } else {\n+                if (dynamicValue != null) {\n+                    ser = valueSerializer;\n+                }\n+            }\n+            if (ser != null) {\n+                if (typeSerializer != null) {\n+                    ser.serializeWithType(dynamicValue, gen, provider, typeSerializer);\n+                } else {\n+                    ser.serialize(dynamicValue, gen, provider);\n+                }\n+            }\n+        }\n+        return;\n     }\n-    // ... not sure how custom handler would do it\n }\n--- com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n+++ com/fasterxml/jackson/databind/ser/AnyGetterWriter.java@resolve\n@@ -1,5 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-public void resolve(SerializerProvider provider) throws JsonMappingException {\n-    // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-    _mapSerializer = (MapSerializer) provider.handlePrimaryContextualization(_mapSerializer, _property);\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer; // remove unnecessary casting\n }\n--- com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n+++ com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java@constructBeanSerializer\n@@ -1,73 +1,6 @@\n @SuppressWarnings(\"unchecked\")\n-protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException {\n-    // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n-    // 05-Jul-2012, tatu: ... but we should be able to just return \"unknown type\" serializer, right?\n-    if (beanDesc.getBeanClass() == Object.class) {\n-        return prov.getUnknownTypeSerializer(Object.class);\n-        //            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n-    }\n-    final SerializationConfig config = prov.getConfig();\n-    BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n-    builder.setConfig(config);\n-    // First: any detectable (auto-detect, annotations) properties to serialize?\n-    List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n-    if (props == null) {\n-        props = new ArrayList<BeanPropertyWriter>();\n-    }\n-    // [databind#638]: Allow injection of \"virtual\" properties:\n-    prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n-    // [JACKSON-440] Need to allow modification bean properties to serialize:\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.changeProperties(config, beanDesc, props);\n-        }\n-    }\n-    // Any properties to suppress?\n-    props = filterBeanProperties(config, beanDesc, props);\n-    // [JACKSON-440] Need to allow reordering of properties to serialize\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            props = mod.orderProperties(config, beanDesc, props);\n-        }\n-    }\n-        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props));\n-    builder.setProperties(props);\n-    builder.setFilterId(findFilterId(config, beanDesc));\n-    AnnotatedMember anyGetter = beanDesc.findAnyGetter();\n-    if (anyGetter != null) {\n-        if (config.canOverrideAccessModifiers()) {\n-            anyGetter.fixAccess();\n-        }\n-        JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n-        // copied from BasicSerializerFactory.buildMapSerializer():\n-        boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n-        JavaType valueType = type.getContentType();\n-        TypeSerializer typeSer = createTypeSerializer(config, valueType);\n-        // last 2 nulls; don't know key, value serializers (yet)\n-        // 23-Feb-2015, tatu: As per [#705], need to support custom serializers\n-        MapSerializer anySer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null, null);\n-        // TODO: support '@JsonIgnoreProperties' with any setter?\n-        // TODO: can we find full PropertyName?\n-        PropertyName name = new PropertyName(anyGetter.getName());\n-        BeanProperty.Std anyProp = new BeanProperty.Std(name, valueType, null, beanDesc.getClassAnnotations(), anyGetter, PropertyMetadata.STD_OPTIONAL);\n-        builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, anySer));\n-    }\n-    // Next: need to gather view information, if any:\n-    processViews(config, builder);\n-    // Finally: let interested parties mess with the result bit more...\n-    if (_factoryConfig.hasSerializerModifiers()) {\n-        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n-            builder = mod.updateBuilder(config, beanDesc, builder);\n-        }\n-    }\n-    JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n-    if (ser == null) {\n-        // If we get this far, there were no properties found, so no regular BeanSerializer\n-        // would be constructed. But, couple of exceptions.\n-        // First: if there are known annotations, just create 'empty bean' serializer\n-        if (beanDesc.hasKnownClassAnnotations()) {\n-            return builder.createDummy();\n-        }\n-    }\n-    return ser;\n+public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) {\n+    _accessor = accessor;\n+    _property = property;\n+    _mapSerializer = serializer; // remove unnecessary casting\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]