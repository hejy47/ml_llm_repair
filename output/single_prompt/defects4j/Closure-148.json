[{"output": "## Fixed Function 1\nprivate Node tryFoldTypeof(Node originalTypeofNode) {\n    Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);\n    Node argumentNode = originalTypeofNode.getFirstChild();\n    if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {\n        return originalTypeofNode;\n    }\n    String typeNameString = null;\n    switch(argumentNode.getType()) {\n        case Token.STRING:\n            typeNameString = \"string\";\n            break;\n        case Token.NUMBER:\n            typeNameString = \"number\";\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            typeNameString = \"boolean\";\n            break;\n        case Token.NULL:\n        case Token.OBJECTLIT:\n        case Token.ARRAYLIT:\n            typeNameString = \"object\";\n            break;\n        case Token.NAME:\n            if (\"undefined\".equals(argumentNode.getString())) {\n                typeNameString = \"undefined\";\n            }\n            break;\n    }\n    if (typeNameString != null) {\n        Node newNode = Node.newString(typeNameString);\n        originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);\n        reportCodeChange();\n        return newNode;\n    }\n    return originalTypeofNode;\n}\n\n## Fixed Function 2\nLineMapper(Appendable out) throws IOException {\n    this.out = out;\n    // initialize line and col index\n    out.append(\"[\"); \n    this.firstChar = true;\n}\n\n## Fixed Function 3\nvoid appendTo(Appendable out) throws IOException {\n    out.append(\"[\");\n    out.append(escapeString(sourceFile));\n    out.append(\",\");\n    out.append(String.valueOf(getAdjustedLine(originalPosition)));\n    out.append(\",\");\n    out.append(String.valueOf(getAdjustedCol(originalPosition)));\n    if (originalName != null) {\n        out.append(\",\");\n        out.append(escapeString(originalName));\n    }\n    out.append(\"]\");\n}\n\n## Fixed Function 4\nvoid addMapping(Node node, Position startPosition, Position endPosition) {\n    String sourceFile = (String) node.getProp(Node.SOURCEFILE_PROP);\n    if (sourceFile == null || startPosition.getLineNumber() < 0) {\n        return;\n    }\n    String escapedSourceFile = escapeString(sourceFile);\n    Mapping mapping = new Mapping();\n    mapping.id = mappings.size();\n    mapping.sourceFile = escapedSourceFile;\n    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n    if (originalName != null) {\n        mapping.originalName = escapeString(originalName);\n    }\n    int startOffset = (startPosition.getLineNumber() > 0) ? 0 : offsetPosition.getCharacterIndex();\n    int endOffset = (endPosition.getLineNumber() > 0) ? 0 : offsetPosition.getCharacterIndex();\n    mapping.startPosition = new Position(startPosition.getLineNumber() + offsetPosition.getLineNumber(), startPosition.getCharacterIndex() + startOffset);\n    mapping.endPosition = new Position(endPosition.getLineNumber() + offsetPosition.getLineNumber(), endPosition.getCharacterIndex() + endOffset);\n    mappings.add(mapping);\n}\n\n## Fixed Function 5\nprivate int findLastLine() {\n    int maxLine = 0;\n    for (Mapping mapping : mappings) {\n        int endPositionLine = mapping.endPosition.getLineNumber();\n        maxLine = Math.max(maxLine, endPositionLine + 1);\n    }\n    return maxLine;\n}\n\n## Fixed Function 6\npublic void appendTo(Appendable out, String name) throws IOException {\n    out.append(\"{ \\\"file\\\": \");\n    out.append(escapeString(name));\n    out.append(\", \\\"mappings\\\": \\\"\");\n    (new LineMapper(out)).appendLineMappings();\n    out.append(\"\\\" }\");\n}\n\n## Fixed Function 7\nvoid appendLineMappings() throws IOException {\n    Preconditions.checkState(!mappings.isEmpty());\n    Deque<Mapping> stack = new ArrayDeque<>();\n    Mapping previousMapping = null;\n    for (Mapping currentMapping : mappings) {\n        if (previousMapping != null && !isOverlapped(previousMapping, currentMapping)) {\n            closeLastMapping(stack);\n        }\n        writeCharsBetween(previousMapping, currentMapping, stack);\n        previousMapping = currentMapping;\n    }\n    closeLastMapping(stack);\n}\n\n## Fixed Function 8\nprivate void openLine() throws IOException {\n    out.append(\";\");\n    line++;\n    col = 0;\n}\n\n## Fixed Function 9\nprivate void closeLine() throws IOException {\n    out.append(',');\n}\n\n## Fixed Function 10\nprivate void addCharEntry(String id) throws IOException {\n    if (firstChar) {\n        firstChar = false;\n    } else {\n        out.append(',');\n    }\n    out.append(id);\n    col++;\n}\n\n## Fixed Function 11\nprivate int getAdjustedLine(Position p) {\n    return p.getLineNumber() - 1;\n}\n\n## Fixed Function 12\nprivate int getAdjustedCol(Position p) {\n    return (getAdjustedLine(p) == 0) ? p.getCharacterIndex() + prefixPosition.getCharacterIndex() : p.getCharacterIndex();\n}\n\n## Fixed Function 13\nprivate void writeCharsBetween(Mapping prev, Mapping next, Deque<Mapping> stack) throws IOException {\n    int endLine = getAdjustedLine(next.startPosition);\n    int endCol = getAdjustedCol(next.startPosition);\n    if (prev == null) {\n        // Ensure all lines leading up to the start of the first mapping are mapped with empty columns\n        // if there is no previous mapping\n        for (int i = 0; i <= endLine; i++) {\n            openLine();\n            closeLine();\n            stack.push(null);\n        }\n    } else {\n        int startLine = getAdjustedLine(prev.endPosition);\n        int startCol = getAdjustedCol(prev.endPosition);\n        for (int line = startLine; line <= endLine; line++) {\n            if (line == startLine) {\n                writeCharsOnLine(startCol, prev.id, stack);\n            } else if (line == endLine) {\n                writeCharsOnLine(endCol, next.id, stack);\n            } else {\n                openLine();\n                closeLine();\n                stack.push(null);\n            }\n        }\n    }\n}\n\n## Fixed Function 14\nprivate void writeCharsOnLine(int endCol, int id, Deque<Mapping> stack) throws IOException {\n    while (col < endCol) {\n        addCharEntry(UNMAPPED_STRING);\n    }\n    addCharEntry(String.valueOf(id));\n    stack.push(stack.peek());\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldTypeof\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldTypeof\n@@ -22,8 +22,6 @@\n             typeNameString = \"object\";\n             break;\n         case Token.NAME:\n-            // We assume here that programs don't change the value of the\n-            // keyword undefined to something other than the value undefined.\n             if (\"undefined\".equals(argumentNode.getString())) {\n                 typeNameString = \"undefined\";\n             }\n--- com/google/javascript/jscomp/SourceMap.java@appendTo\n+++ com/google/javascript/jscomp/SourceMap.java@appendTo\n@@ -1,14 +1,13 @@\n void appendTo(Appendable out) throws IOException {\n     out.append(\"[\");\n-    out.append(sourceFile);\n-    // The source file rarely changes, so cache the escaped string.\n+    out.append(escapeString(sourceFile));\n     out.append(\",\");\n-    out.append(String.valueOf(originalPosition.getLineNumber()));\n+    out.append(String.valueOf(getAdjustedLine(originalPosition)));\n     out.append(\",\");\n-    out.append(String.valueOf(originalPosition.getCharacterIndex()));\n+    out.append(String.valueOf(getAdjustedCol(originalPosition)));\n     if (originalName != null) {\n         out.append(\",\");\n-        out.append(originalName);\n+        out.append(escapeString(originalName));\n     }\n     out.append(\"]\");\n }\n--- com/google/javascript/jscomp/SourceMap.java@addMapping\n+++ com/google/javascript/jscomp/SourceMap.java@addMapping\n@@ -1,19 +1,9 @@\n void addMapping(Node node, Position startPosition, Position endPosition) {\n     String sourceFile = (String) node.getProp(Node.SOURCEFILE_PROP);\n-    // If the node does not have an associated source file or\n-    // its line number is -1, then the node does not have sufficient\n-    // information for a mapping to be useful.\n-    if (sourceFile == null || node.getLineno() < 0) {\n+    if (sourceFile == null || startPosition.getLineNumber() < 0) {\n         return;\n     }\n-    String escapedSourceFile;\n-    if (lastSourceFile != sourceFile) {\n-        // yes, \"s1 != s2\" not \"!s1.equals(s2)\"\n-        lastSourceFile = sourceFile;\n-        lastSourceFileEscaped = escapeString(sourceFile);\n-    }\n-    escapedSourceFile = lastSourceFileEscaped;\n-    // Create the new mapping.\n+    String escapedSourceFile = escapeString(sourceFile);\n     Mapping mapping = new Mapping();\n     mapping.id = mappings.size();\n     mapping.sourceFile = escapedSourceFile;\n@@ -22,20 +12,9 @@\n     if (originalName != null) {\n         mapping.originalName = escapeString(originalName);\n     }\n-    // If the mapping is found on the first line, we need to offset\n-    // its character position by the number of characters found on\n-    // the *last* line of the source file to which the code is\n-    // being generated.\n-    int offsetLine = offsetPosition.getLineNumber();\n-    int startOffsetPosition = offsetPosition.getCharacterIndex();\n-    int endOffsetPosition = offsetPosition.getCharacterIndex();\n-    if (startPosition.getLineNumber() > 0) {\n-        startOffsetPosition = 0;\n-    }\n-    if (endPosition.getLineNumber() > 0) {\n-        endOffsetPosition = 0;\n-    }\n-    mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition);\n-    mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition);\n+    int startOffset = (startPosition.getLineNumber() > 0) ? 0 : offsetPosition.getCharacterIndex();\n+    int endOffset = (endPosition.getLineNumber() > 0) ? 0 : offsetPosition.getCharacterIndex();\n+    mapping.startPosition = new Position(startPosition.getLineNumber() + offsetPosition.getLineNumber(), startPosition.getCharacterIndex() + startOffset);\n+    mapping.endPosition = new Position(endPosition.getLineNumber() + offsetPosition.getLineNumber(), endPosition.getCharacterIndex() + endOffset);\n     mappings.add(mapping);\n }\n--- com/google/javascript/jscomp/SourceMap.java@findLastLine\n+++ com/google/javascript/jscomp/SourceMap.java@findLastLine\n@@ -2,7 +2,7 @@\n     int maxLine = 0;\n     for (Mapping mapping : mappings) {\n         int endPositionLine = mapping.endPosition.getLineNumber();\n-        maxLine = Math.max(maxLine, endPositionLine);\n+        maxLine = Math.max(maxLine, endPositionLine + 1);\n     }\n-    return maxLine + prefixPosition.getLineNumber();\n+    return maxLine;\n }\n--- com/google/javascript/jscomp/SourceMap.java@appendTo4\n+++ com/google/javascript/jscomp/SourceMap.java@appendTo4\n@@ -1,48 +1,7 @@\n public void appendTo(Appendable out, String name) throws IOException {\n-    // Write the mappings out to the file. The format of the generated\n-    // source map is three sections, each deliminated by a magic comment.\n-    //\n-    // The first section contains an array for each line of the generated\n-    // code, where each element in the array is the ID of the mapping which\n-    // best represents the index-th character found on that line of the\n-    // generated source code.\n-    //\n-    // The second section contains an array per generated line. Unused.\n-    //\n-    // The third and final section contains an array per line, each of which\n-    // represents a mapping with a unique ID. The mappings are added in order.\n-    // The array itself contains a tuple representing\n-    // ['source file', line, col (, 'original name')]\n-    //\n-    // Example for 2 lines of generated code (with line numbers added for\n-    // readability):\n-    //\n-    // 1)      // 5)  []\n-    // 6)  []\n-    // 7)      // 8)  [\"a.js\", 1, 34]\n-    // 9)  [\"a.js\", 5, 2]\n-    // 10) [\"b.js\", 1, 3, \"event\"]\n-    // 11) [\"c.js\", 1, 4]\n-    // 12) [\"d.js\", 3, 78, \"foo\"]\n-    int maxLine = findLastLine();\n-    // Add the line character maps.\n-    out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");\n+    out.append(\"{ \\\"file\\\": \");\n     out.append(escapeString(name));\n-    out.append(\", \\\"count\\\": \");\n-    out.append(String.valueOf(maxLine + 1));\n-    out.append(\" }\\n\");\n+    out.append(\", \\\"mappings\\\": \\\"\");\n     (new LineMapper(out)).appendLineMappings();\n-    // Add the source file maps.\n-    out.append(\"/** Begin file information. **/\\n\");\n-    // This section is unused but we need one entry per line to\n-    // prevent changing the format.\n-    for (int i = 0; i <= maxLine; ++i) {\n-        out.append(\"[]\\n\");\n-    }\n-    // Add the mappings themselves.\n-    out.append(\"/** Begin mapping definitions. **/\\n\");\n-    for (Mapping mapping : mappings) {\n-        mapping.appendTo(out);\n-        out.append(\"\\n\");\n-    }\n+    out.append(\"\\\" }\");\n }\n--- com/google/javascript/jscomp/SourceMap.java@openLine\n+++ com/google/javascript/jscomp/SourceMap.java@openLine\n@@ -1,4 +1,5 @@\n private void openLine() throws IOException {\n-    out.append(\"[\");\n-    this.firstChar = true;\n+    out.append(\";\");\n+    line++;\n+    col = 0;\n }\n--- com/google/javascript/jscomp/SourceMap.java@closeLine\n+++ com/google/javascript/jscomp/SourceMap.java@closeLine\n@@ -1,3 +1,3 @@\n private void closeLine() throws IOException {\n-    out.append(\"]\\n\");\n+    out.append(',');\n }\n--- com/google/javascript/jscomp/SourceMap.java@addCharEntry\n+++ com/google/javascript/jscomp/SourceMap.java@addCharEntry\n@@ -2,7 +2,8 @@\n     if (firstChar) {\n         firstChar = false;\n     } else {\n-        out.append(\",\");\n+        out.append(',');\n     }\n     out.append(id);\n+    col++;\n }\n--- com/google/javascript/jscomp/SourceMap.java@getAdjustedLine\n+++ com/google/javascript/jscomp/SourceMap.java@getAdjustedLine\n@@ -1,3 +1,3 @@\n private int getAdjustedLine(Position p) {\n-    return p.getLineNumber() + prefixPosition.getLineNumber();\n+    return p.getLineNumber() - 1;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate Node tryFoldTypeof(Node originalTypeofNode) {\n    Preconditions.checkArgument(originalTypeofNode.getType() == Token.TYPEOF);\n    Node argumentNode = originalTypeofNode.getFirstChild();\n    if (argumentNode == null || !NodeUtil.isLiteralValue(argumentNode)) {\n        return originalTypeofNode;\n    }\n    String typeNameString = null;\n    switch(argumentNode.getType()) {\n        case Token.STRING:\n            typeNameString = \"string\";\n            break;\n        case Token.NUMBER:\n            typeNameString = \"number\";\n            break;\n        case Token.TRUE:\n        case Token.FALSE:\n            typeNameString = \"boolean\";\n            break;\n        case Token.NULL:\n        case Token.OBJECTLIT:\n        case Token.ARRAYLIT:\n            typeNameString = \"object\";\n            break;\n        case Token.NAME:\n            // We assume here that programs don't change the value of the\n            // keyword undefined to something other than the value undefined.\n            if (\"undefined\".equals(argumentNode.getString())) {\n                typeNameString = \"undefined\";\n            }\n            break;\n    }\n    if (typeNameString != null) {\n        Node newNode = Node.newString(typeNameString);\n        originalTypeofNode.replaceWith(newNode);\n        reportCodeChange();\n        return newNode;\n    }\n    return originalTypeofNode;\n}\n\n## Fixed Function 2\nLineMapper(Appendable out, int prefixLine) {\n    this.out = out;\n    this.prefixLine = prefixLine;\n}\n\n## Fixed Function 3\nvoid appendTo(Appendable out) throws IOException {\n    out.append(\"[\");\n    out.append(sourceFile);\n    // The source file rarely changes, so cache the escaped string.\n    out.append(\",\");\n    out.append(String.valueOf(originalPosition.getLineNumber()));\n    out.append(\",\");\n    out.append(String.valueOf(originalPosition.getCharacterIndex()));\n    if (originalName != null) {\n        out.append(\",\");\n        out.append(originalName);\n    }\n    out.append(\"]\");\n}\n\n## Fixed Function 4\nvoid addMapping(Node node, Position startPosition, Position endPosition) {\n    String sourceFile = (String) node.getProp(Node.SOURCEFILE_PROP);\n    // If the node does not have an associated source file or\n    // its line number is -1, then the node does not have sufficient\n    // information for a mapping to be useful.\n    if (sourceFile == null || node.getLineno() < 0) {\n        return;\n    }\n    String escapedSourceFile;\n    if (lastSourceFile != sourceFile) {\n        lastSourceFile = sourceFile;\n        lastSourceFileEscaped = escapeString(sourceFile);\n    }\n    escapedSourceFile = lastSourceFileEscaped;\n    Mapping mapping = new Mapping();\n    mapping.id = mappings.size();\n    mapping.sourceFile = escapedSourceFile;\n    mapping.originalPosition = new Position(node.getLineno(), node.getCharno());\n    String originalName = (String) node.getProp(Node.ORIGINALNAME_PROP);\n    if (originalName != null) {\n        mapping.originalName = escapeString(originalName);\n    }\n    int startOffsetPosition = 0;\n    int endOffsetPosition = 0;\n    if (startPosition.getLineNumber() > 0) {\n        startOffsetPosition = offsetPosition.getCharacterIndex();\n    }\n    if (endPosition.getLineNumber() > 0) {\n        endOffsetPosition = offsetPosition.getCharacterIndex();\n    }\n    mapping.startPosition = new Position(startPosition.getLineNumber() + prefixLine, startPosition.getCharacterIndex() + startOffsetPosition);\n    mapping.endPosition = new Position(endPosition.getLineNumber() + prefixLine, endPosition.getCharacterIndex() + endOffsetPosition);\n    mappings.add(mapping);\n}\n\n## Fixed Function 5\nprivate int findLastLine() {\n    int maxLine = 0;\n    for (Mapping mapping : mappings) {\n        int endPositionLine = mapping.endPosition.getLineNumber();\n        maxLine = Math.max(maxLine, endPositionLine);\n    }\n    return maxLine;\n}\n\n## Fixed Function 6\npublic void appendTo(Appendable out, String name) throws IOException {\n    int maxLine = findLastLine();\n    out.append(\"{ \\\"file\\\" : \");\n    out.append(escapeString(name));\n    out.append(\", \\\"count\\\": \");\n    out.append(String.valueOf(maxLine + prefixLine + 1));\n    out.append(\" }\\n\");\n    (new LineMapper(out, prefixLine)).appendLineMappings();\n    for (int i = 0; i <= maxLine; ++i) {\n        out.append(\"[]\\n\");\n    }\n    out.append(\"/** Begin mapping definitions. **/\\n\");\n    for (Mapping mapping : mappings) {\n        mapping.appendTo(out);\n        out.append(\"\\n\");\n    }\n}\n\n## Fixed Function 7\nvoid appendLineMappings() throws IOException {\n    Preconditions.checkState(!mappings.isEmpty());\n    openLine();\n    Deque<Mapping> stack = new ArrayDeque<Mapping>();\n    for (Mapping m : mappings) {\n        while (!stack.isEmpty() && !isOverlapped(stack.peek(), m)) {\n            Mapping previous = stack.pop();\n            writeClosedMapping(previous);\n        }\n        Mapping parent = stack.peek();\n        writeCharsBetween(parent, m);\n        stack.push(m);\n    }\n    while (!stack.isEmpty()) {\n        Mapping m = stack.pop();\n        writeClosedMapping(m);\n    }\n    closeLine();\n}\n\n## Fixed Function 8\nprivate void openLine() throws IOException {\n    out.append(\"[\");\n    this.firstChar = true;\n}\n\n## Fixed Function 9\nprivate void closeLine() throws IOException {\n    out.append(\"]\\n\");\n}\n\n## Fixed Function 10\nprivate void addCharEntry(String id) throws IOException {\n    if (firstChar) {\n        firstChar = false;\n    } else {\n        out.append(\",\");\n    }\n    out.append(id);\n}\n\n## Fixed Function 11\nprivate int getAdjustedLine(Position p) {\n    return p.getLineNumber() - prefixLine;\n}\n\n## Fixed Function 12\nprivate void writeClosedMapping(Mapping m) throws IOException {\n    int nextLine = getAdjustedLine(m.endPosition);\n    int nextCol = m.endPosition.getCharacterIndex();\n    if (line < nextLine || (line == nextLine && col < nextCol)) {\n        writeCharsUpTo(nextLine, nextCol, m.id);\n    }\n}\n\n## Fixed Function 13\nprivate void writeCharsBetween(Mapping prev, Mapping next) throws IOException {\n    int nextLine = getAdjustedLine(next.startPosition);\n    int nextCol = next.startPosition.getCharacterIndex();\n    int id = (prev != null) ? prev.id : UNMAPPED;\n    writeCharsUpTo(nextLine, nextCol, id);\n}\n\n## Fixed Function 14\nprivate void writeCharsUpTo(int nextLine, int nextCol, int id) throws IOException {\n    Preconditions.checkState(line <= nextLine, \"\");\n    Preconditions.checkState(line < nextLine || col <= nextCol);\n    if (line == nextLine && col == nextCol) {\n        return;\n    }\n    String idString = String.valueOf(id);\n    for (int i = line; i <= nextLine; i++) {\n        if (i == nextLine) {\n            for (int j = col; j < nextCol; j++) {\n                addCharEntry(idString);\n            }\n            break;\n        }\n        closeLine();\n        openLine();\n    }\n    line = nextLine;\n    col = nextCol;\n}", "diff": "--- com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldTypeof\n+++ com/google/javascript/jscomp/PeepholeFoldConstants.java@tryFoldTypeof\n@@ -31,7 +31,7 @@\n     }\n     if (typeNameString != null) {\n         Node newNode = Node.newString(typeNameString);\n-        originalTypeofNode.getParent().replaceChild(originalTypeofNode, newNode);\n+        originalTypeofNode.replaceWith(newNode);\n         reportCodeChange();\n         return newNode;\n     }\n--- com/google/javascript/jscomp/SourceMap.java@addMapping\n+++ com/google/javascript/jscomp/SourceMap.java@addMapping\n@@ -8,12 +8,10 @@\n     }\n     String escapedSourceFile;\n     if (lastSourceFile != sourceFile) {\n-        // yes, \"s1 != s2\" not \"!s1.equals(s2)\"\n         lastSourceFile = sourceFile;\n         lastSourceFileEscaped = escapeString(sourceFile);\n     }\n     escapedSourceFile = lastSourceFileEscaped;\n-    // Create the new mapping.\n     Mapping mapping = new Mapping();\n     mapping.id = mappings.size();\n     mapping.sourceFile = escapedSourceFile;\n@@ -22,20 +20,15 @@\n     if (originalName != null) {\n         mapping.originalName = escapeString(originalName);\n     }\n-    // If the mapping is found on the first line, we need to offset\n-    // its character position by the number of characters found on\n-    // the *last* line of the source file to which the code is\n-    // being generated.\n-    int offsetLine = offsetPosition.getLineNumber();\n-    int startOffsetPosition = offsetPosition.getCharacterIndex();\n-    int endOffsetPosition = offsetPosition.getCharacterIndex();\n+    int startOffsetPosition = 0;\n+    int endOffsetPosition = 0;\n     if (startPosition.getLineNumber() > 0) {\n-        startOffsetPosition = 0;\n+        startOffsetPosition = offsetPosition.getCharacterIndex();\n     }\n     if (endPosition.getLineNumber() > 0) {\n-        endOffsetPosition = 0;\n+        endOffsetPosition = offsetPosition.getCharacterIndex();\n     }\n-    mapping.startPosition = new Position(startPosition.getLineNumber() + offsetLine, startPosition.getCharacterIndex() + startOffsetPosition);\n-    mapping.endPosition = new Position(endPosition.getLineNumber() + offsetLine, endPosition.getCharacterIndex() + endOffsetPosition);\n+    mapping.startPosition = new Position(startPosition.getLineNumber() + prefixLine, startPosition.getCharacterIndex() + startOffsetPosition);\n+    mapping.endPosition = new Position(endPosition.getLineNumber() + prefixLine, endPosition.getCharacterIndex() + endOffsetPosition);\n     mappings.add(mapping);\n }\n--- com/google/javascript/jscomp/SourceMap.java@findLastLine\n+++ com/google/javascript/jscomp/SourceMap.java@findLastLine\n@@ -4,5 +4,5 @@\n         int endPositionLine = mapping.endPosition.getLineNumber();\n         maxLine = Math.max(maxLine, endPositionLine);\n     }\n-    return maxLine + prefixPosition.getLineNumber();\n+    return maxLine;\n }\n--- com/google/javascript/jscomp/SourceMap.java@appendTo4\n+++ com/google/javascript/jscomp/SourceMap.java@appendTo4\n@@ -1,45 +1,14 @@\n public void appendTo(Appendable out, String name) throws IOException {\n-    // Write the mappings out to the file. The format of the generated\n-    // source map is three sections, each deliminated by a magic comment.\n-    //\n-    // The first section contains an array for each line of the generated\n-    // code, where each element in the array is the ID of the mapping which\n-    // best represents the index-th character found on that line of the\n-    // generated source code.\n-    //\n-    // The second section contains an array per generated line. Unused.\n-    //\n-    // The third and final section contains an array per line, each of which\n-    // represents a mapping with a unique ID. The mappings are added in order.\n-    // The array itself contains a tuple representing\n-    // ['source file', line, col (, 'original name')]\n-    //\n-    // Example for 2 lines of generated code (with line numbers added for\n-    // readability):\n-    //\n-    // 1)      // 5)  []\n-    // 6)  []\n-    // 7)      // 8)  [\"a.js\", 1, 34]\n-    // 9)  [\"a.js\", 5, 2]\n-    // 10) [\"b.js\", 1, 3, \"event\"]\n-    // 11) [\"c.js\", 1, 4]\n-    // 12) [\"d.js\", 3, 78, \"foo\"]\n     int maxLine = findLastLine();\n-    // Add the line character maps.\n-    out.append(\"/** Begin line maps. **/{ \\\"file\\\" : \");\n+    out.append(\"{ \\\"file\\\" : \");\n     out.append(escapeString(name));\n     out.append(\", \\\"count\\\": \");\n-    out.append(String.valueOf(maxLine + 1));\n+    out.append(String.valueOf(maxLine + prefixLine + 1));\n     out.append(\" }\\n\");\n-    (new LineMapper(out)).appendLineMappings();\n-    // Add the source file maps.\n-    out.append(\"/** Begin file information. **/\\n\");\n-    // This section is unused but we need one entry per line to\n-    // prevent changing the format.\n+    (new LineMapper(out, prefixLine)).appendLineMappings();\n     for (int i = 0; i <= maxLine; ++i) {\n         out.append(\"[]\\n\");\n     }\n-    // Add the mappings themselves.\n     out.append(\"/** Begin mapping definitions. **/\\n\");\n     for (Mapping mapping : mappings) {\n         mapping.appendTo(out);\n--- com/google/javascript/jscomp/SourceMap.java@getAdjustedLine\n+++ com/google/javascript/jscomp/SourceMap.java@getAdjustedLine\n@@ -1,3 +1,3 @@\n private int getAdjustedLine(Position p) {\n-    return p.getLineNumber() + prefixPosition.getLineNumber();\n+    return p.getLineNumber() - prefixLine;\n }\n--- com/google/javascript/jscomp/SourceMap.java@writeClosedMapping\n+++ com/google/javascript/jscomp/SourceMap.java@writeClosedMapping\n@@ -1,8 +1,6 @@\n private void writeClosedMapping(Mapping m) throws IOException {\n     int nextLine = getAdjustedLine(m.endPosition);\n-    int nextCol = getAdjustedCol(m.endPosition);\n-    // If this anything remaining in this mapping beyond the\n-    // current line and column position, write it out now.\n+    int nextCol = m.endPosition.getCharacterIndex();\n     if (line < nextLine || (line == nextLine && col < nextCol)) {\n         writeCharsUpTo(nextLine, nextCol, m.id);\n     }\n--- com/google/javascript/jscomp/SourceMap.java@writeCharsBetween\n+++ com/google/javascript/jscomp/SourceMap.java@writeCharsBetween\n@@ -1,7 +1,6 @@\n private void writeCharsBetween(Mapping prev, Mapping next) throws IOException {\n     int nextLine = getAdjustedLine(next.startPosition);\n-    int nextCol = getAdjustedCol(next.startPosition);\n-    // If the previous value is null, no mapping exists.\n+    int nextCol = next.startPosition.getCharacterIndex();\n     int id = (prev != null) ? prev.id : UNMAPPED;\n     writeCharsUpTo(nextLine, nextCol, id);\n }\n--- com/google/javascript/jscomp/SourceMap.java@writeCharsUpTo\n+++ com/google/javascript/jscomp/SourceMap.java@writeCharsUpTo\n@@ -2,10 +2,9 @@\n     Preconditions.checkState(line <= nextLine, \"\");\n     Preconditions.checkState(line < nextLine || col <= nextCol);\n     if (line == nextLine && col == nextCol) {\n-        // Nothing to do.\n         return;\n     }\n-    String idString = (id == UNMAPPED) ? UNMAPPED_STRING : String.valueOf(id);\n+    String idString = String.valueOf(id);\n     for (int i = line; i <= nextLine; i++) {\n         if (i == nextLine) {\n             for (int j = col; j < nextCol; j++) {\n", "finish_reason": "stop", "valid": false, "num": 1}]