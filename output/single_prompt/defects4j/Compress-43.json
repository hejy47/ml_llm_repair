[{"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(ze)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (ze.getMethod() != DEFLATED || channel != null) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    }\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zip64) {\n        return ZIP64_MIN_VERSION;\n    }\n    if (usedDataDescriptor) {\n        return DATA_DESCRIPTOR_MIN_VERSION;\n    }\n    return versionNeededToExtractMethod(zipMethod, zip64);\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return zipMethod == DEFLATED && channel == null && !hasZip64Extra(entry.entry);\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -36,7 +36,7 @@\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n+    if (hasZip64Extra(ze)) {\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n@@ -5,5 +5,5 @@\n     if (usedDataDescriptor) {\n         return DATA_DESCRIPTOR_MIN_VERSION;\n     }\n-    return versionNeededToExtractMethod(zipMethod);\n+    return versionNeededToExtractMethod(zipMethod, zip64);\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,3 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return zipMethod == DEFLATED && channel == null && !hasZip64Extra(entry.entry);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    if (usesDataDescriptor(ze.getMethod())) {\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET + WORD;\n    } else {\n        entry.localDataStart = localHeaderStart + localHeader.length;\n    }\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (dataDescriptor) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (dataDescriptor) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (ze.getMethod() != DEFLATED || channel != null) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (hasZip64Extra(ze)) {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    }\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zip64) {\n        return ZIP64_MIN_VERSION;\n    }\n    if (usedDataDescriptor) {\n        if (channel == null) {\n            return DATA_DESCRIPTOR_MIN_VERSION;\n        } else {\n            return zipMethod == BZIP2ED || zipMethod == LZMAED ? ZIP64_MIN_VERSION : DATA_DESCRIPTOR_MIN_VERSION;\n        }\n    }\n    return versionNeededToExtractMethod(zipMethod);\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return (zipMethod == STORED || zipMethod == DEFLATED && channel == null);\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n@@ -8,7 +8,11 @@\n     final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n     metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n     // At crc offset\n-    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n+    if (usesDataDescriptor(ze.getMethod())) {\n+        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET + WORD;\n+    } else {\n+        entry.localDataStart = localHeaderStart + localHeader.length;\n+    }\n     writeCounted(localHeader);\n     entry.dataStart = streamCompressor.getTotalBytesWritten();\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -27,9 +27,7 @@\n     putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n     ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n     // CRC\n-    if (phased) {\n-        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n+    if (dataDescriptor) {\n         System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n     } else {\n         putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n@@ -42,15 +40,11 @@\n         // stream is seekable\n         ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n         ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (phased) {\n-        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n-        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n+    } else if (dataDescriptor) {\n         System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n         System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n     } else {\n-        // Stored\n-        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n+        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n         putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n     }\n     // file name length\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n@@ -4,11 +4,11 @@\n     }\n     writeCounted(DD_SIG);\n     writeCounted(ZipLong.getBytes(ze.getCrc()));\n-    if (!hasZip64Extra(ze)) {\n+    if (hasZip64Extra(ze)) {\n+        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n+        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n+    } else {\n         writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n         writeCounted(ZipLong.getBytes(ze.getSize()));\n-    } else {\n-        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n-        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n     }\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n@@ -3,7 +3,11 @@\n         return ZIP64_MIN_VERSION;\n     }\n     if (usedDataDescriptor) {\n-        return DATA_DESCRIPTOR_MIN_VERSION;\n+        if (channel == null) {\n+            return DATA_DESCRIPTOR_MIN_VERSION;\n+        } else {\n+            return zipMethod == BZIP2ED || zipMethod == LZMAED ? ZIP64_MIN_VERSION : DATA_DESCRIPTOR_MIN_VERSION;\n+        }\n     }\n     return versionNeededToExtractMethod(zipMethod);\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,3 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return (zipMethod == STORED || zipMethod == DEFLATED && channel == null);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // Set the local data start for phased compression.\n    if (phased) {\n        ze.localDataStart = localHeaderStart + localHeader.length;\n    }\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(ze)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (usesDataDescriptor(ze.getMethod())) {\n        writeCounted(DD_SIG);\n        writeCounted(ZipLong.getBytes(ze.getCrc()));\n        if (hasZip64Extra(ze)) {\n            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n        } else {\n            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipLong.getBytes(ze.getSize()));\n        }\n    }\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zip64) {\n        return ZIP64_MIN_VERSION;\n    } else if (usedDataDescriptor) {\n        return DATA_DESCRIPTOR_MIN_VERSION;\n    } else {\n        return versionNeededToExtractMethod(zipMethod);\n    }\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return (zipMethod == STORED) ||\n           (zipMethod == DEFLATED && channel == null &&\n               !ZipArchiveOutputStream.this.useZip64ForExtraFields &&\n               !ZipArchiveOutputStream.this.allowStoredEntriesWithDataDescriptor);\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n@@ -7,8 +7,10 @@\n     final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n     final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n     metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n-    // At crc offset\n-    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n+    // Set the local data start for phased compression.\n+    if (phased) {\n+        ze.localDataStart = localHeaderStart + localHeader.length;\n+    }\n     writeCounted(localHeader);\n     entry.dataStart = streamCompressor.getTotalBytesWritten();\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -36,7 +36,7 @@\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n+    if (hasZip64Extra(ze)) {\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n@@ -1,14 +1,13 @@\n protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n-    if (ze.getMethod() != DEFLATED || channel != null) {\n-        return;\n-    }\n-    writeCounted(DD_SIG);\n-    writeCounted(ZipLong.getBytes(ze.getCrc()));\n-    if (!hasZip64Extra(ze)) {\n-        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n-        writeCounted(ZipLong.getBytes(ze.getSize()));\n-    } else {\n-        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n-        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n+    if (usesDataDescriptor(ze.getMethod())) {\n+        writeCounted(DD_SIG);\n+        writeCounted(ZipLong.getBytes(ze.getCrc()));\n+        if (hasZip64Extra(ze)) {\n+            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n+            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n+        } else {\n+            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n+            writeCounted(ZipLong.getBytes(ze.getSize()));\n+        }\n     }\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n@@ -1,9 +1,9 @@\n private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n     if (zip64) {\n         return ZIP64_MIN_VERSION;\n+    } else if (usedDataDescriptor) {\n+        return DATA_DESCRIPTOR_MIN_VERSION;\n+    } else {\n+        return versionNeededToExtractMethod(zipMethod);\n     }\n-    if (usedDataDescriptor) {\n-        return DATA_DESCRIPTOR_MIN_VERSION;\n-    }\n-    return versionNeededToExtractMethod(zipMethod);\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,6 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return (zipMethod == STORED) ||\n+           (zipMethod == DEFLATED && channel == null &&\n+               !ZipArchiveOutputStream.this.useZip64ForExtraFields &&\n+               !ZipArchiveOutputStream.this.allowStoredEntriesWithDataDescriptor);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    if (phased) {\n        entry.dataStart = streamCompressor.getTotalBytesWritten();\n    }\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (channel != null) {\n        throw new UnsupportedOperationException(\"Writing of data descriptors in ZIP files with channels not supported\");\n    }\n    if (ze.getMethod() != DEFLATED) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    }\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zipMethod == ZipMethod.AES.getZipMethod()) {\n        return AES_VERSION;\n    }\n    if (zip64) {\n        return ZIP64_MIN_VERSION;\n    }\n    if (usedDataDescriptor) {\n        return DATA_DESCRIPTOR_MIN_VERSION;\n    }\n    return versionNeededToExtractMethod(zipMethod);\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return zipMethod == DEFLATED && (entry != null ? entry.usesZip64() : channel == null);\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n@@ -10,5 +10,7 @@\n     // At crc offset\n     entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n     writeCounted(localHeader);\n-    entry.dataStart = streamCompressor.getTotalBytesWritten();\n+    if (phased) {\n+        entry.dataStart = streamCompressor.getTotalBytesWritten();\n+    }\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n@@ -1,5 +1,8 @@\n protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n-    if (ze.getMethod() != DEFLATED || channel != null) {\n+    if (channel != null) {\n+        throw new UnsupportedOperationException(\"Writing of data descriptors in ZIP files with channels not supported\");\n+    }\n+    if (ze.getMethod() != DEFLATED) {\n         return;\n     }\n     writeCounted(DD_SIG);\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n@@ -1,4 +1,7 @@\n private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n+    if (zipMethod == ZipMethod.AES.getZipMethod()) {\n+        return AES_VERSION;\n+    }\n     if (zip64) {\n         return ZIP64_MIN_VERSION;\n     }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,3 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return zipMethod == DEFLATED && (entry != null ? entry.usesZip64() : channel == null);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    // Fix: add local header size to start\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET + WORD;\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    // Fix: add space for GPB (2 bytes)\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length + WORD;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET + WORD);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET + WORD, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET + WORD);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET + WORD);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET + WORD);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET + WORD);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET + WORD);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET + WORD, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET + WORD, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET + WORD);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET + WORD);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET + WORD, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen + WORD, extra.length);\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (ze.getMethod() != DEFLATED || channel != null) {\n        return;\n    }\n    // Fix: add DD size\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    }\n    // Fix: update entry position\n    entry.localDataStart += DD_SIG.length + (hasZip64Extra(ze) ? ZipEightByteInteger.getBytes(ze.getCompressedSize()).length + ZipEightByteInteger.getBytes(ze.getSize()).length : ZipLong.getBytes(ze.getCompressedSize()).length + ZipLong.getBytes(ze.getCrc()).length);\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zip64) {\n        return ZIP64_MIN_VERSION;\n    }\n    if (usedDataDescriptor) {\n        return DATA_DESCRIPTOR_MIN_VERSION;\n    }\n    // Fix: add check for zipMethod == STORED\n    if (zipMethod == STORED) {\n        return STORED_MIN_VERSION;\n    }\n    return versionNeededToExtractMethod(zipMethod);\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    // Fix: add check for zipMethod == STORED\n    return zipMethod == DEFLATED && channel == null || zipMethod == STORED;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n@@ -8,7 +8,8 @@\n     final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n     metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n     // At crc offset\n-    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n+    // Fix: add local header size to start\n+    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET + WORD;\n     writeCounted(localHeader);\n     entry.dataStart = streamCompressor.getTotalBytesWritten();\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -14,7 +14,8 @@\n     }\n     final byte[] extra = ze.getLocalFileDataExtra();\n     final int nameLen = name.limit() - name.position();\n-    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n+    // Fix: add space for GPB (2 bytes)\n+    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length + WORD;\n     final byte[] buf = new byte[len];\n     System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n     //store method in local variable to prevent multiple method calls\n@@ -28,11 +29,11 @@\n     ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n     // CRC\n     if (phased) {\n-        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n+        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET + WORD);\n     } else if (zipMethod == DEFLATED || channel != null) {\n-        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n+        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET + WORD, WORD);\n     } else {\n-        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n+        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET + WORD);\n     }\n     // compressed length\n     // uncompressed length\n@@ -40,26 +41,26 @@\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n-        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n-        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n+        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET + WORD);\n+        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET + WORD);\n     } else if (phased) {\n-        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n-        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n+        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET + WORD);\n+        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET + WORD);\n     } else if (zipMethod == DEFLATED || channel != null) {\n-        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n-        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n+        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET + WORD, WORD);\n+        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET + WORD, WORD);\n     } else {\n         // Stored\n-        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n-        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n+        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET + WORD);\n+        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET + WORD);\n     }\n     // file name length\n     putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n     // extra field length\n     putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n     // file name\n-    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n+    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET + WORD, nameLen);\n     // extra fields\n-    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n+    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen + WORD, extra.length);\n     return buf;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n@@ -2,6 +2,7 @@\n     if (ze.getMethod() != DEFLATED || channel != null) {\n         return;\n     }\n+    // Fix: add DD size\n     writeCounted(DD_SIG);\n     writeCounted(ZipLong.getBytes(ze.getCrc()));\n     if (!hasZip64Extra(ze)) {\n@@ -11,4 +12,6 @@\n         writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n         writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n     }\n+    // Fix: update entry position\n+    entry.localDataStart += DD_SIG.length + (hasZip64Extra(ze) ? ZipEightByteInteger.getBytes(ze.getCompressedSize()).length + ZipEightByteInteger.getBytes(ze.getSize()).length : ZipLong.getBytes(ze.getCompressedSize()).length + ZipLong.getBytes(ze.getCrc()).length);\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n@@ -5,5 +5,9 @@\n     if (usedDataDescriptor) {\n         return DATA_DESCRIPTOR_MIN_VERSION;\n     }\n+    // Fix: add check for zipMethod == STORED\n+    if (zipMethod == STORED) {\n+        return STORED_MIN_VERSION;\n+    }\n     return versionNeededToExtractMethod(zipMethod);\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,4 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    // Fix: add check for zipMethod == STORED\n+    return zipMethod == DEFLATED && channel == null || zipMethod == STORED;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    if (!usesDataDescriptor(ze.getMethod())) {\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    }\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (!dataDescriptor) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (!dataDescriptor) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (ze.getMethod() != DEFLATED || channel != null || usesDataDescriptor(ze.getMethod())) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    }\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zip64) {\n        return ZIP64_MIN_VERSION;\n    }\n    if (usedDataDescriptor) {\n        return DATA_DESCRIPTOR_MIN_VERSION;\n    }\n    return versionNeededToExtractMethod(zipMethod);\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return zipMethod == STORED && channel == null;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n@@ -8,7 +8,9 @@\n     final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n     metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n     // At crc offset\n-    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n+    if (!usesDataDescriptor(ze.getMethod())) {\n+        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n+    }\n     writeCounted(localHeader);\n     entry.dataStart = streamCompressor.getTotalBytesWritten();\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -29,10 +29,10 @@\n     // CRC\n     if (phased) {\n         putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n+    } else if (!dataDescriptor) {\n+        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n+    } else {\n         System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n-    } else {\n-        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n     }\n     // compressed length\n     // uncompressed length\n@@ -45,13 +45,12 @@\n     } else if (phased) {\n         putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n         putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n+    } else if (!dataDescriptor) {\n+        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n+        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n+    } else {\n         System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n         System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n-    } else {\n-        // Stored\n-        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n-        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n     }\n     // file name length\n     putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n@@ -1,5 +1,5 @@\n protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n-    if (ze.getMethod() != DEFLATED || channel != null) {\n+    if (ze.getMethod() != DEFLATED || channel != null || usesDataDescriptor(ze.getMethod())) {\n         return;\n     }\n     writeCounted(DD_SIG);\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,3 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return zipMethod == STORED && channel == null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    ze.setDataStartPosition(localHeaderStart + LFH_CRC_OFFSET);\n    writeCounted(localHeader);\n    ze.setDataStartPosition(streamCompressor.getTotalBytesWritten());\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(ze)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (ze.getMethod() != DEFLATED || channel != null || ze.getCompressedSize() < 0 || ze.getSize() < 0) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n    writeCounted(ZipLong.getBytes(ze.getSize()));\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zipMethod == STORED || !usedDataDescriptor) {\n        return 10;\n    }\n    if (zip64) {\n        return ZIP64_MIN_VERSION;\n    }\n    return DATA_DESCRIPTOR_MIN_VERSION;\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return zipMethod == STORED || zipMethod == DEFLATED && (channel == null || !channel.isOpen());\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n@@ -8,7 +8,7 @@\n     final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n     metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n     // At crc offset\n-    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n+    ze.setDataStartPosition(localHeaderStart + LFH_CRC_OFFSET);\n     writeCounted(localHeader);\n-    entry.dataStart = streamCompressor.getTotalBytesWritten();\n+    ze.setDataStartPosition(streamCompressor.getTotalBytesWritten());\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -36,7 +36,7 @@\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n+    if (hasZip64Extra(ze)) {\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n@@ -1,14 +1,9 @@\n protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n-    if (ze.getMethod() != DEFLATED || channel != null) {\n+    if (ze.getMethod() != DEFLATED || channel != null || ze.getCompressedSize() < 0 || ze.getSize() < 0) {\n         return;\n     }\n     writeCounted(DD_SIG);\n     writeCounted(ZipLong.getBytes(ze.getCrc()));\n-    if (!hasZip64Extra(ze)) {\n-        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n-        writeCounted(ZipLong.getBytes(ze.getSize()));\n-    } else {\n-        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n-        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n-    }\n+    writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n+    writeCounted(ZipLong.getBytes(ze.getSize()));\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n@@ -1,9 +1,9 @@\n private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n+    if (zipMethod == STORED || !usedDataDescriptor) {\n+        return 10;\n+    }\n     if (zip64) {\n         return ZIP64_MIN_VERSION;\n     }\n-    if (usedDataDescriptor) {\n-        return DATA_DESCRIPTOR_MIN_VERSION;\n-    }\n-    return versionNeededToExtractMethod(zipMethod);\n+    return DATA_DESCRIPTOR_MIN_VERSION;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,3 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return zipMethod == STORED || zipMethod == DEFLATED && (channel == null || !channel.isOpen());\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    ze.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    ze.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(ze)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (ze.getMethod() != DEFLATED || channel != null || !usesDataDescriptor(ze.getMethod())) { // Check for Data Descriptor\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    }\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    int result = versionNeededToExtractMethod(zipMethod);\n    if (usedDataDescriptor) { // Check for Data Descriptor\n        result = Math.max(result, DATA_DESCRIPTOR_MIN_VERSION);\n    }\n    if (zip64) {\n        result = Math.max(result, ZIP64_MIN_VERSION);\n    }\n    return result;\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return zipMethod == DEFLATED || zipMethod == STORED && channel == null;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n@@ -8,7 +8,7 @@\n     final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n     metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n     // At crc offset\n-    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n+    ze.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n     writeCounted(localHeader);\n-    entry.dataStart = streamCompressor.getTotalBytesWritten();\n+    ze.dataStart = streamCompressor.getTotalBytesWritten();\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -36,7 +36,7 @@\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n+    if (hasZip64Extra(ze)) {\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n@@ -1,5 +1,5 @@\n protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n-    if (ze.getMethod() != DEFLATED || channel != null) {\n+    if (ze.getMethod() != DEFLATED || channel != null || !usesDataDescriptor(ze.getMethod())) { // Check for Data Descriptor\n         return;\n     }\n     writeCounted(DD_SIG);\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n@@ -1,9 +1,10 @@\n private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n+    int result = versionNeededToExtractMethod(zipMethod);\n+    if (usedDataDescriptor) { // Check for Data Descriptor\n+        result = Math.max(result, DATA_DESCRIPTOR_MIN_VERSION);\n+    }\n     if (zip64) {\n-        return ZIP64_MIN_VERSION;\n+        result = Math.max(result, ZIP64_MIN_VERSION);\n     }\n-    if (usedDataDescriptor) {\n-        return DATA_DESCRIPTOR_MIN_VERSION;\n-    }\n-    return versionNeededToExtractMethod(zipMethod);\n+    return result;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,3 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return zipMethod == DEFLATED || zipMethod == STORED && channel == null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // store versionMadeBy appropriately\n    putShort(ze.getPlatform() << 8 | (version & 0xff), buf, LFH_VERSION_MADE_BY_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || isEntryEncrypted(ze)) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(ze) || ze.getSize() >= ZIP64_MAGIC_SHORT || ze.getCompressedSize() >= ZIP64_MAGIC_SHORT || ze.getLocalFileDataExtra().length > 0) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        if (dataDescriptor) {\n            putLong(DATA_DESCRIPTOR_MIN_VERSION, buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET);\n        }\n    } else if (zipMethod == DEFLATED || isEntryEncrypted(ze)) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        if (dataDescriptor) {\n            putLong(DATA_DESCRIPTOR_MIN_VERSION, buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET);\n        }\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        if (dataDescriptor) {\n            putLong(DATA_DESCRIPTOR_MIN_VERSION, buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET);\n        }\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (!usesDataDescriptor(ze.getMethod())) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (hasZip64Extra(ze)) {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    }\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    int version = versionNeededToExtractMethod(zipMethod);\n    if (zip64 || usedDataDescriptor) {\n        version = Math.max(version, DATA_DESCRIPTOR_MIN_VERSION);\n    }\n    return version;\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return zipMethod == DEFLATED || (!isSeekable() && isZip64Mode() && zipMethod == STORED);\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -20,38 +20,49 @@\n     //store method in local variable to prevent multiple method calls\n     final int zipMethod = ze.getMethod();\n     final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n-    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n     generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n+    // store versionMadeBy appropriately\n+    putShort(ze.getPlatform() << 8 | (version & 0xff), buf, LFH_VERSION_MADE_BY_OFFSET);\n     // compression method\n     putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n     ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n     // CRC\n     if (phased) {\n         putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n+    } else if (zipMethod == DEFLATED || isEntryEncrypted(ze)) {\n         System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n     } else {\n         putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n+    if (hasZip64Extra(ze) || ze.getSize() >= ZIP64_MAGIC_SHORT || ze.getCompressedSize() >= ZIP64_MAGIC_SHORT || ze.getLocalFileDataExtra().length > 0) {\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n         ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n         ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n+        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET);\n     } else if (phased) {\n         putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n         putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n+        if (dataDescriptor) {\n+            putLong(DATA_DESCRIPTOR_MIN_VERSION, buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET);\n+        }\n+    } else if (zipMethod == DEFLATED || isEntryEncrypted(ze)) {\n         System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n         System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n+        if (dataDescriptor) {\n+            putLong(DATA_DESCRIPTOR_MIN_VERSION, buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET);\n+        }\n     } else {\n         // Stored\n         putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n         putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n+        if (dataDescriptor) {\n+            putLong(DATA_DESCRIPTOR_MIN_VERSION, buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET);\n+        }\n     }\n     // file name length\n     putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n@@ -1,14 +1,14 @@\n protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n-    if (ze.getMethod() != DEFLATED || channel != null) {\n+    if (!usesDataDescriptor(ze.getMethod())) {\n         return;\n     }\n     writeCounted(DD_SIG);\n     writeCounted(ZipLong.getBytes(ze.getCrc()));\n-    if (!hasZip64Extra(ze)) {\n+    if (hasZip64Extra(ze)) {\n+        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n+        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n+    } else {\n         writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n         writeCounted(ZipLong.getBytes(ze.getSize()));\n-    } else {\n-        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n-        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n     }\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n@@ -1,9 +1,7 @@\n private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n-    if (zip64) {\n-        return ZIP64_MIN_VERSION;\n+    int version = versionNeededToExtractMethod(zipMethod);\n+    if (zip64 || usedDataDescriptor) {\n+        version = Math.max(version, DATA_DESCRIPTOR_MIN_VERSION);\n     }\n-    if (usedDataDescriptor) {\n-        return DATA_DESCRIPTOR_MIN_VERSION;\n-    }\n-    return versionNeededToExtractMethod(zipMethod);\n+    return version;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,3 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return zipMethod == DEFLATED || (!isSeekable() && isZip64Mode() && zipMethod == STORED);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (!usesDataDescriptor(ze.getMethod())) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    }\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zip64) {\n        return ZIP64_MIN_VERSION;\n    }\n    if (usedDataDescriptor) {\n        return DATA_DESCRIPTOR_MIN_VERSION;\n    }\n    return versionNeededToExtractMethod(zipMethod);\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return (zipMethod == STORED || zipMethod == DEFLATED) && channel == null;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -20,11 +20,11 @@\n     //store method in local variable to prevent multiple method calls\n     final int zipMethod = ze.getMethod();\n     final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n-    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n     generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n     // compression method\n     putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n+    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n     // CRC\n     if (phased) {\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n@@ -1,5 +1,5 @@\n protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n-    if (ze.getMethod() != DEFLATED || channel != null) {\n+    if (!usesDataDescriptor(ze.getMethod())) {\n         return;\n     }\n     writeCounted(DD_SIG);\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,3 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return (zipMethod == STORED || zipMethod == DEFLATED) && channel == null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    EntryMetaData metadata = new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod()));\n    metaData.put(ze.getRawName(), metadata);\n    // At crc offset\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(ze)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (!usesDataDescriptor(ze.getMethod())) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (hasZip64Extra(ze)) {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    }\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zip64) {\n        return ZIP64_MIN_VERSION;\n    }\n    if (usedDataDescriptor && zipMethod == DEFLATED) {\n        return DATA_DESCRIPTOR_MIN_VERSION;\n    }\n    return versionNeededToExtractMethod(zipMethod);\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return zipMethod == STORED && channel == null || zipMethod == DEFLATED;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n@@ -6,7 +6,8 @@\n     }\n     final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n     final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n-    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n+    EntryMetaData metadata = new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod()));\n+    metaData.put(ze.getRawName(), metadata);\n     // At crc offset\n     entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n     writeCounted(localHeader);\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -36,7 +36,7 @@\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n+    if (hasZip64Extra(ze)) {\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n@@ -1,14 +1,14 @@\n protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n-    if (ze.getMethod() != DEFLATED || channel != null) {\n+    if (!usesDataDescriptor(ze.getMethod())) {\n         return;\n     }\n     writeCounted(DD_SIG);\n     writeCounted(ZipLong.getBytes(ze.getCrc()));\n-    if (!hasZip64Extra(ze)) {\n+    if (hasZip64Extra(ze)) {\n+        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n+        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n+    } else {\n         writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n         writeCounted(ZipLong.getBytes(ze.getSize()));\n-    } else {\n-        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n-        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n     }\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n@@ -2,7 +2,7 @@\n     if (zip64) {\n         return ZIP64_MIN_VERSION;\n     }\n-    if (usedDataDescriptor) {\n+    if (usedDataDescriptor && zipMethod == DEFLATED) {\n         return DATA_DESCRIPTOR_MIN_VERSION;\n     }\n     return versionNeededToExtractMethod(zipMethod);\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,3 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return zipMethod == STORED && channel == null || zipMethod == DEFLATED;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    ze.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    ze.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || streamCompressor != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(ze)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || streamCompressor != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (ze.getMethod() != DEFLATED || streamCompressor != null) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    }\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zip64) {\n        return ZIP64_MIN_VERSION;\n    }\n    if (usedDataDescriptor) {\n        return DATA_DESCRIPTOR_MIN_VERSION;\n    }\n    return versionNeededToExtractMethod(zipMethod) & 0xff;\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return zipMethod == DEFLATED && streamCompressor == null;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n@@ -8,7 +8,7 @@\n     final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n     metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n     // At crc offset\n-    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n+    ze.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n     writeCounted(localHeader);\n-    entry.dataStart = streamCompressor.getTotalBytesWritten();\n+    ze.dataStart = streamCompressor.getTotalBytesWritten();\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -29,14 +29,14 @@\n     // CRC\n     if (phased) {\n         putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n+    } else if (zipMethod == DEFLATED || streamCompressor != null) {\n         System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n     } else {\n         putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n+    if (hasZip64Extra(ze)) {\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n@@ -45,7 +45,7 @@\n     } else if (phased) {\n         putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n         putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n+    } else if (zipMethod == DEFLATED || streamCompressor != null) {\n         System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n         System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n     } else {\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n@@ -1,5 +1,5 @@\n protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n-    if (ze.getMethod() != DEFLATED || channel != null) {\n+    if (ze.getMethod() != DEFLATED || streamCompressor != null) {\n         return;\n     }\n     writeCounted(DD_SIG);\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n@@ -5,5 +5,5 @@\n     if (usedDataDescriptor) {\n         return DATA_DESCRIPTOR_MIN_VERSION;\n     }\n-    return versionNeededToExtractMethod(zipMethod);\n+    return versionNeededToExtractMethod(zipMethod) & 0xff;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,3 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return zipMethod == DEFLATED && streamCompressor == null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    ze.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    ze.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(ze)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (ze.getMethod() != DEFLATED || channel != null) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    }\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zip64) {\n        return ZIP64_MIN_VERSION;\n    }\n    if (usedDataDescriptor && zipMethod == DEFLATED && channel == null) {\n        return DATA_DESCRIPTOR_MIN_VERSION;\n    }\n    return versionNeededToExtractMethod(zipMethod);\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return zipMethod == DEFLATED && channel == null && !hasZip64Extra(entry.entry);\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n@@ -8,7 +8,7 @@\n     final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n     metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n     // At crc offset\n-    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n+    ze.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n     writeCounted(localHeader);\n-    entry.dataStart = streamCompressor.getTotalBytesWritten();\n+    ze.dataStart = streamCompressor.getTotalBytesWritten();\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -36,7 +36,7 @@\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n+    if (hasZip64Extra(ze)) {\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n@@ -2,7 +2,7 @@\n     if (zip64) {\n         return ZIP64_MIN_VERSION;\n     }\n-    if (usedDataDescriptor) {\n+    if (usedDataDescriptor && zipMethod == DEFLATED && channel == null) {\n         return DATA_DESCRIPTOR_MIN_VERSION;\n     }\n     return versionNeededToExtractMethod(zipMethod);\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,3 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return zipMethod == DEFLATED && channel == null && !hasZip64Extra(entry.entry);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (ze.getMethod() != DEFLATED || channel != null || ze.getSize() < 0 || ze.getCompressedSize() < 0 || ze.getCrc() < 0) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    }\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zip64) {\n        if (usedDataDescriptor) {\n            return DATA_DESCRIPTOR_MIN_VERSION_ZIP64;\n        }\n        return ZIP64_MIN_VERSION;\n    }\n    if (usedDataDescriptor) {\n        return DATA_DESCRIPTOR_MIN_VERSION;\n    }\n    return versionNeededToExtractMethod(zipMethod);\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return zipMethod == DEFLATED && (channel == null || !ChannelEntry.class.isAssignableFrom(entry.getClass()));\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -20,9 +20,9 @@\n     //store method in local variable to prevent multiple method calls\n     final int zipMethod = ze.getMethod();\n     final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n-    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n     generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n+    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     // compression method\n     putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n     ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n@@ -1,5 +1,5 @@\n protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n-    if (ze.getMethod() != DEFLATED || channel != null) {\n+    if (ze.getMethod() != DEFLATED || channel != null || ze.getSize() < 0 || ze.getCompressedSize() < 0 || ze.getCrc() < 0) {\n         return;\n     }\n     writeCounted(DD_SIG);\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n@@ -1,5 +1,8 @@\n private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n     if (zip64) {\n+        if (usedDataDescriptor) {\n+            return DATA_DESCRIPTOR_MIN_VERSION_ZIP64;\n+        }\n         return ZIP64_MIN_VERSION;\n     }\n     if (usedDataDescriptor) {\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,3 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return zipMethod == DEFLATED && (channel == null || !ChannelEntry.class.isAssignableFrom(entry.getClass()));\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(ze)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipEightByteInteger.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipEightByteInteger.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (ze.getMethod() != DEFLATED || channel != null) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    }\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zip64) {\n        return ZIP64_MIN_VERSION;\n    }\n    if (usedDataDescriptor) {\n        return DATA_DESCRIPTOR_MIN_VERSION;\n    }\n    return versionNeededToExtractMethod(zipMethod);\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return zipMethod == DEFLATED && channel == null && !(entry.methodRequiresZip64() && entry.getCompressedSize() >= ZIP64_MAGIC;);\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -36,12 +36,12 @@\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n+    if (hasZip64Extra(ze)) {\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n-        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n-        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n+        ZipEightByteInteger.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n+        ZipEightByteInteger.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n     } else if (phased) {\n         putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n         putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,3 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return zipMethod == DEFLATED && channel == null && !(entry.methodRequiresZip64() && entry.getCompressedSize() >= ZIP64_MAGIC;);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    if (!usesDataDescriptor(ze.getMethod())) {\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET + WORD;\n    } else {\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    }\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len + WORD];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (dataDescriptor) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        if (dataDescriptor) {\n            System.arraycopy(LZERO, 0, buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET, WORD);\n        } else {\n            putInt(DATA_DESCRIPTOR_MIN_VERSION, buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET);\n        }\n    } else if (zipMethod == DEFLATED || channel != null || dataDescriptor) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n        putInt(DATA_DESCRIPTOR_MIN_VERSION, buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n        if (dataDescriptor) {\n            System.arraycopy(LZERO, 0, buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET, WORD);\n        } else {\n            putInt(DATA_DESCRIPTOR_MIN_VERSION, buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET);\n        }\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    // initialize data descriptor length to 0\n    if (usesDataDescriptor(zipMethod) && !hasZip64Extra(ze) && !phased) {\n        putInt(DATA_DESCRIPTOR_MIN_VERSION, buf, len);\n    }\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (!usesDataDescriptor(ze.getMethod()) || channel != null) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    }\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zip64 || usedDataDescriptor) {\n        return ZIP64_MIN_VERSION;\n    }\n    return versionNeededToExtractMethod(zipMethod);\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return zipMethod == DEFLATED && channel == null && !hasZip64Extra(entry.entry);\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n@@ -8,7 +8,11 @@\n     final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n     metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n     // At crc offset\n-    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n+    if (!usesDataDescriptor(ze.getMethod())) {\n+        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET + WORD;\n+    } else {\n+        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n+    }\n     writeCounted(localHeader);\n     entry.dataStart = streamCompressor.getTotalBytesWritten();\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -15,7 +15,7 @@\n     final byte[] extra = ze.getLocalFileDataExtra();\n     final int nameLen = name.limit() - name.position();\n     final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n-    final byte[] buf = new byte[len];\n+    final byte[] buf = new byte[len + WORD];\n     System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n     //store method in local variable to prevent multiple method calls\n     final int zipMethod = ze.getMethod();\n@@ -29,7 +29,7 @@\n     // CRC\n     if (phased) {\n         putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n+    } else if (dataDescriptor) {\n         System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n     } else {\n         putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n@@ -42,16 +42,28 @@\n         // stream is seekable\n         ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n         ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n+        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET);\n     } else if (phased) {\n         putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n         putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n+        if (dataDescriptor) {\n+            System.arraycopy(LZERO, 0, buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET, WORD);\n+        } else {\n+            putInt(DATA_DESCRIPTOR_MIN_VERSION, buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET);\n+        }\n+    } else if (zipMethod == DEFLATED || channel != null || dataDescriptor) {\n         System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n         System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n+        putInt(DATA_DESCRIPTOR_MIN_VERSION, buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET);\n     } else {\n         // Stored\n         putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n         putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n+        if (dataDescriptor) {\n+            System.arraycopy(LZERO, 0, buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET, WORD);\n+        } else {\n+            putInt(DATA_DESCRIPTOR_MIN_VERSION, buf, LFH_DATA_DESCRIPTOR_LENGTH_OFFSET);\n+        }\n     }\n     // file name length\n     putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n@@ -61,5 +73,9 @@\n     System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n     // extra fields\n     System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n+    // initialize data descriptor length to 0\n+    if (usesDataDescriptor(zipMethod) && !hasZip64Extra(ze) && !phased) {\n+        putInt(DATA_DESCRIPTOR_MIN_VERSION, buf, len);\n+    }\n     return buf;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n@@ -1,5 +1,5 @@\n protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n-    if (ze.getMethod() != DEFLATED || channel != null) {\n+    if (!usesDataDescriptor(ze.getMethod()) || channel != null) {\n         return;\n     }\n     writeCounted(DD_SIG);\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n@@ -1,9 +1,6 @@\n private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n-    if (zip64) {\n+    if (zip64 || usedDataDescriptor) {\n         return ZIP64_MIN_VERSION;\n-    }\n-    if (usedDataDescriptor) {\n-        return DATA_DESCRIPTOR_MIN_VERSION;\n     }\n     return versionNeededToExtractMethod(zipMethod);\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,3 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return zipMethod == DEFLATED && channel == null && !hasZip64Extra(entry.entry);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    ze.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    ze.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.remaining();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.position(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (ze.getMethod() != DEFLATED || channel != null) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize().getLong()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize().getLong()));\n    }\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zip64) {\n        return ZIP64_MIN_VERSION;\n    }\n    if (usedDataDescriptor) {\n        return DATA_DESCRIPTOR_MIN_VERSION;\n    }\n    return versionNeededToExtractMethod(zipMethod);\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return zipMethod == STORED && channel == null;\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n@@ -8,7 +8,7 @@\n     final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n     metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n     // At crc offset\n-    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n+    ze.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n     writeCounted(localHeader);\n-    entry.dataStart = streamCompressor.getTotalBytesWritten();\n+    ze.dataStart = streamCompressor.getTotalBytesWritten();\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -13,7 +13,7 @@\n         ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n     }\n     final byte[] extra = ze.getLocalFileDataExtra();\n-    final int nameLen = name.limit() - name.position();\n+    final int nameLen = name.remaining();\n     final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n     final byte[] buf = new byte[len];\n     System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n@@ -58,7 +58,7 @@\n     // extra field length\n     putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n     // file name\n-    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n+    System.arraycopy(name.array(), name.position(), buf, LFH_FILENAME_OFFSET, nameLen);\n     // extra fields\n     System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n     return buf;\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n@@ -8,7 +8,7 @@\n         writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n         writeCounted(ZipLong.getBytes(ze.getSize()));\n     } else {\n-        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n-        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n+        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize().getLong()));\n+        writeCounted(ZipEightByteInteger.getBytes(ze.getSize().getLong()));\n     }\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,3 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return zipMethod == STORED && channel == null;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    if (!usesDataDescriptor(ze.getMethod())) {\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    } else {\n        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET + WORD;\n    }\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    boolean hasZip64Extra = hasZip64Extra(entry.entry);\n    int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    int extraStartOffset = len;\n\n    if (hasZip64Extra) {\n        len += ZipEightByteInteger.getEntrySize();\n    }\n    final byte[] buf = new byte[len];\n\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra, dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (!phased && (dataDescriptor || ze.getCrc() == ZIP64_MAGIC)) {\n        System.arraycopy(ZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra) {\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else {\n        putLong(dataDescriptor && phased ? ZIP64_MAGIC : ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(dataDescriptor && phased ? ZIP64_MAGIC : ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length + (hasZip64Extra ? ZipEightByteInteger.getEntrySize() : 0), buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    extraStartOffset += nameLen;\n\n    if (hasZip64Extra) {\n        ZipEightByteInteger compressedSize = new ZipEightByteInteger(ze.getCompressedSize());\n        System.arraycopy(ZipEightByteInteger.getHeaderId().getBytes(), 0, buf, extraStartOffset, ZipShort.getSize());\n        extraStartOffset += ZipShort.getSize();\n        System.arraycopy(ZipEightByteInteger.getSize().getBytes(), 0, buf, extraStartOffset, ZipShort.getSize());\n        extraStartOffset += ZipShort.getSize();\n        System.arraycopy(compressedSize.getBytes(), 0, buf, extraStartOffset, ZipEightByteInteger.getSize());\n        extraStartOffset += ZipEightByteInteger.getSize();\n\n        ZipEightByteInteger size = new ZipEightByteInteger(ze.getSize());\n        System.arraycopy(ZipEightByteInteger.getHeaderId().getBytes(), 0, buf, extraStartOffset, ZipShort.getSize());\n        extraStartOffset += ZipShort.getSize();\n        System.arraycopy(ZipEightByteInteger.getSize().getBytes(), 0, buf, extraStartOffset, ZipShort.getSize());\n        extraStartOffset += ZipShort.getSize();\n        System.arraycopy(size.getBytes(), 0, buf, extraStartOffset, ZipEightByteInteger.getSize());\n    }\n\n    return buf;\n}\n\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (usesDataDescriptor(ze.getMethod())) {\n        writeCounted(DD_SIG);\n        writeCounted(ZipLong.getBytes(ze.getCrc()));\n        if (hasZip64Extra(entry.entry)) {\n            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n        } else {\n            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n            writeCounted(ZipLong.getBytes(ze.getSize()));\n        }\n    }\n}\n\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zip64) {\n        return ZIP64_MIN_VERSION;\n    }\n    if (usedDataDescriptor) {\n        return Math.max(DATA_DESCRIPTOR_MIN_VERSION, ZIP64_MIN_VERSION);\n    }\n    return versionNeededToExtractMethod(zipMethod);\n}\n\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return zipMethod == DEFLATED && channel == null && !hasZip64Extra(entry.entry);\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeLocalFileHeader\n@@ -8,7 +8,11 @@\n     final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n     metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n     // At crc offset\n-    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n+    if (!usesDataDescriptor(ze.getMethod())) {\n+        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n+    } else {\n+        entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET + WORD;\n+    }\n     writeCounted(localHeader);\n     entry.dataStart = streamCompressor.getTotalBytesWritten();\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -14,52 +14,66 @@\n     }\n     final byte[] extra = ze.getLocalFileDataExtra();\n     final int nameLen = name.limit() - name.position();\n-    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n+    boolean hasZip64Extra = hasZip64Extra(entry.entry);\n+    int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n+    int extraStartOffset = len;\n+\n+    if (hasZip64Extra) {\n+        len += ZipEightByteInteger.getEntrySize();\n+    }\n     final byte[] buf = new byte[len];\n+\n     System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n     //store method in local variable to prevent multiple method calls\n     final int zipMethod = ze.getMethod();\n     final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n-    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n+    putShort(versionNeededToExtract(zipMethod, hasZip64Extra, dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n     final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n     generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n     // compression method\n     putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n     ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n     // CRC\n-    if (phased) {\n-        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n-        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n+    if (!phased && (dataDescriptor || ze.getCrc() == ZIP64_MAGIC)) {\n+        System.arraycopy(ZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n     } else {\n         putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n-        // point to ZIP64 extended information extra field for\n-        // sizes, may get rewritten once sizes are known if\n-        // stream is seekable\n+    if (hasZip64Extra) {\n         ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n         ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (phased) {\n-        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n-        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n-    } else if (zipMethod == DEFLATED || channel != null) {\n-        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n-        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n     } else {\n-        // Stored\n-        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n-        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n+        putLong(dataDescriptor && phased ? ZIP64_MAGIC : ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n+        putLong(dataDescriptor && phased ? ZIP64_MAGIC : ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n     }\n     // file name length\n     putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n     // extra field length\n-    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n+    putShort(extra.length + (hasZip64Extra ? ZipEightByteInteger.getEntrySize() : 0), buf, LFH_EXTRA_LENGTH_OFFSET);\n     // file name\n     System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n     // extra fields\n     System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n+    extraStartOffset += nameLen;\n+\n+    if (hasZip64Extra) {\n+        ZipEightByteInteger compressedSize = new ZipEightByteInteger(ze.getCompressedSize());\n+        System.arraycopy(ZipEightByteInteger.getHeaderId().getBytes(), 0, buf, extraStartOffset, ZipShort.getSize());\n+        extraStartOffset += ZipShort.getSize();\n+        System.arraycopy(ZipEightByteInteger.getSize().getBytes(), 0, buf, extraStartOffset, ZipShort.getSize());\n+        extraStartOffset += ZipShort.getSize();\n+        System.arraycopy(compressedSize.getBytes(), 0, buf, extraStartOffset, ZipEightByteInteger.getSize());\n+        extraStartOffset += ZipEightByteInteger.getSize();\n+\n+        ZipEightByteInteger size = new ZipEightByteInteger(ze.getSize());\n+        System.arraycopy(ZipEightByteInteger.getHeaderId().getBytes(), 0, buf, extraStartOffset, ZipShort.getSize());\n+        extraStartOffset += ZipShort.getSize();\n+        System.arraycopy(ZipEightByteInteger.getSize().getBytes(), 0, buf, extraStartOffset, ZipShort.getSize());\n+        extraStartOffset += ZipShort.getSize();\n+        System.arraycopy(size.getBytes(), 0, buf, extraStartOffset, ZipEightByteInteger.getSize());\n+    }\n+\n     return buf;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@writeDataDescriptor\n@@ -1,14 +1,13 @@\n protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n-    if (ze.getMethod() != DEFLATED || channel != null) {\n-        return;\n-    }\n-    writeCounted(DD_SIG);\n-    writeCounted(ZipLong.getBytes(ze.getCrc()));\n-    if (!hasZip64Extra(ze)) {\n-        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n-        writeCounted(ZipLong.getBytes(ze.getSize()));\n-    } else {\n-        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n-        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n+    if (usesDataDescriptor(ze.getMethod())) {\n+        writeCounted(DD_SIG);\n+        writeCounted(ZipLong.getBytes(ze.getCrc()));\n+        if (hasZip64Extra(entry.entry)) {\n+            writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n+            writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n+        } else {\n+            writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n+            writeCounted(ZipLong.getBytes(ze.getSize()));\n+        }\n     }\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n@@ -3,7 +3,7 @@\n         return ZIP64_MIN_VERSION;\n     }\n     if (usedDataDescriptor) {\n-        return DATA_DESCRIPTOR_MIN_VERSION;\n+        return Math.max(DATA_DESCRIPTOR_MIN_VERSION, ZIP64_MIN_VERSION);\n     }\n     return versionNeededToExtractMethod(zipMethod);\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,3 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return zipMethod == DEFLATED && channel == null && !hasZip64Extra(entry.entry);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(entry.entry)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (ze.getMethod() != DEFLATED || channel != null) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    }\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zip64) {\n        return ZIP64_MIN_VERSION;\n    }\n    if (usedDataDescriptor) {\n        return DATA_DESCRIPTOR_MIN_VERSION;\n    }\n    return versionNeededToExtractMethod(zipMethod);\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return zipMethod == DEFLATED && (channel == null || streamCompressor.def.getCRC() == null);\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,3 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return zipMethod == DEFLATED && (channel == null || streamCompressor.def.getCRC() == null);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nprivate void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\n    final boolean encodable = zipEncoding.canEncode(ze.getName());\n    final ByteBuffer name = getName(ze);\n    if (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\n        addUnicodeExtraFields(ze, encodable, name);\n    }\n    final long localHeaderStart = streamCompressor.getTotalBytesWritten();\n    final byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\n    metaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\n    // At crc offset\n    entry.localDataStart = localHeaderStart + LFH_CRC_OFFSET;\n    writeCounted(localHeader);\n    entry.dataStart = streamCompressor.getTotalBytesWritten();\n}\n\n## Fixed Function 2\nprivate byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable, final boolean phased, long archiveOffset) throws IOException {\n    ResourceAlignmentExtraField oldAlignmentEx = (ResourceAlignmentExtraField) ze.getExtraField(ResourceAlignmentExtraField.ID);\n    if (oldAlignmentEx != null) {\n        ze.removeExtraField(ResourceAlignmentExtraField.ID);\n    }\n    int alignment = ze.getAlignment();\n    if (alignment <= 0 && oldAlignmentEx != null) {\n        alignment = oldAlignmentEx.getAlignment();\n    }\n    if (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\n        int oldLength = LFH_FILENAME_OFFSET + name.limit() - name.position() + ze.getLocalFileDataExtra().length;\n        int padding = (int) ((-archiveOffset - oldLength - ZipExtraField.EXTRAFIELD_HEADER_SIZE - ResourceAlignmentExtraField.BASE_SIZE) & (alignment - 1));\n        ze.addExtraField(new ResourceAlignmentExtraField(alignment, oldAlignmentEx != null && oldAlignmentEx.allowMethodChange(), padding));\n    }\n    final byte[] extra = ze.getLocalFileDataExtra();\n    final int nameLen = name.limit() - name.position();\n    final int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\n    final byte[] buf = new byte[len];\n    System.arraycopy(LFH_SIG, 0, buf, LFH_SIG_OFFSET, WORD);\n    //store method in local variable to prevent multiple method calls\n    final int zipMethod = ze.getMethod();\n    final boolean dataDescriptor = usesDataDescriptor(zipMethod);\n    putShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\n    final GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\n    generalPurposeBit.encode(buf, LFH_GPB_OFFSET);\n    // compression method\n    putShort(zipMethod, buf, LFH_METHOD_OFFSET);\n    ZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\n    // CRC\n    if (phased) {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\n    } else {\n        putLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n    }\n    // compressed length\n    // uncompressed length\n    if (hasZip64Extra(ze)) {\n        // point to ZIP64 extended information extra field for\n        // sizes, may get rewritten once sizes are known if\n        // stream is seekable\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_COMPRESSED_SIZE_OFFSET);\n        ZipLong.ZIP64_MAGIC.putLong(buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (phased) {\n        putLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    } else if (zipMethod == DEFLATED || channel != null) {\n        System.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\n        System.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\n    } else {\n        // Stored\n        putLong(ze.getSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\n        putLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n    }\n    // file name length\n    putShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\n    // extra field length\n    putShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\n    // file name\n    System.arraycopy(name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\n    // extra fields\n    System.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\n    return buf;\n}\n\n## Fixed Function 3\nprotected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\n    if (ze.getMethod() != DEFLATED || channel != null) {\n        return;\n    }\n    writeCounted(DD_SIG);\n    writeCounted(ZipLong.getBytes(ze.getCrc()));\n    if (!hasZip64Extra(ze)) {\n        writeCounted(ZipLong.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipLong.getBytes(ze.getSize()));\n    } else {\n        writeCounted(ZipEightByteInteger.getBytes(ze.getCompressedSize()));\n        writeCounted(ZipEightByteInteger.getBytes(ze.getSize()));\n    }\n}\n\n## Fixed Function 4\nprivate int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n    if (zip64) {\n        return ZIP64_MIN_VERSION;\n    }\n    if (usedDataDescriptor) {\n        return DATA_DESCRIPTOR_MIN_VERSION;\n    }\n    return versionNeededToExtractMethod(zipMethod) & ZIP_VERSION_MASK;\n}\n\n## Fixed Function 5\nprivate boolean usesDataDescriptor(final int zipMethod) {\n    return zipMethod == DEFLATED && channel == null && !hasZip64Extra(entry.entry);\n}", "diff": "--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@createLocalFileHeader\n@@ -36,7 +36,7 @@\n     }\n     // compressed length\n     // uncompressed length\n-    if (hasZip64Extra(entry.entry)) {\n+    if (hasZip64Extra(ze)) {\n         // point to ZIP64 extended information extra field for\n         // sizes, may get rewritten once sizes are known if\n         // stream is seekable\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@versionNeededToExtract\n@@ -5,5 +5,5 @@\n     if (usedDataDescriptor) {\n         return DATA_DESCRIPTOR_MIN_VERSION;\n     }\n-    return versionNeededToExtractMethod(zipMethod);\n+    return versionNeededToExtractMethod(zipMethod) & ZIP_VERSION_MASK;\n }\n--- org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n+++ org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java@usesDataDescriptor\n@@ -1,3 +1,3 @@\n private boolean usesDataDescriptor(final int zipMethod) {\n-    return zipMethod == DEFLATED && channel == null;\n+    return zipMethod == DEFLATED && channel == null && !hasZip64Extra(entry.entry);\n }\n", "finish_reason": "stop", "valid": false, "num": 1}]