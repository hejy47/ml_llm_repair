[{"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration())\n                    decl = comment.asXmlDeclaration();\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName));\n        // creating the buffered reader ignores the input pos, so must skip here if there was a BOM\n        if (bomCharset != null && bomCharset.offset)\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        // some charsets can read but not encode; switch to an encodable charset and update the meta el\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -63,9 +62,9 @@\n     if (doc == null) {\n         if (charsetName == null)\n             charsetName = defaultCharset;\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName));\n+        // creating the buffered reader ignores the input pos, so must skip here if there was a BOM\n+        if (bomCharset != null && bomCharset.offset)\n             reader.skip(1);\n         try {\n             doc = parser.parseInput(reader, baseUri);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n    }\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null) {\n                break;\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration) {\n                decl = (XmlDeclaration) first;\n            } else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration()) {\n                    decl = comment.asXmlDeclaration();\n                }\n            }\n            if (decl != null && decl.name().equalsIgnoreCase(\"xml\")) {\n                foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize)) {\n            if (bomCharset != null && bomCharset.offset) {\n                reader.skip(1);\n            }\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.ioException();\n            }\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        // some charsets can read but not encode; switch to an encodable charset and update the meta el\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,7 +1,7 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null) {\n         return new Document(baseUri);\n+    }\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n@@ -13,8 +13,9 @@\n     input.reset();\n     // look for BOM - overrides any other header or input\n     BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n-    if (bomCharset != null)\n+    if (bomCharset != null) {\n         charsetName = bomCharset.charset;\n+    }\n     if (charsetName == null) {\n         // determine from meta. safe first parse as UTF-8\n         String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n@@ -24,27 +25,30 @@\n         // if not found, will keep utf-8 as best attempt\n         String foundCharset = null;\n         for (Element meta : metaElements) {\n-            if (meta.hasAttr(\"http-equiv\"))\n+            if (meta.hasAttr(\"http-equiv\")) {\n                 foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-            if (foundCharset == null && meta.hasAttr(\"charset\"))\n+            }\n+            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                 foundCharset = meta.attr(\"charset\");\n-            if (foundCharset != null)\n+            }\n+            if (foundCharset != null) {\n                 break;\n+            }\n         }\n         // look for <?xml encoding='ISO-8859-1'?>\n         if (foundCharset == null && doc.childNodeSize() > 0) {\n             Node first = doc.childNode(0);\n             XmlDeclaration decl = null;\n-            if (first instanceof XmlDeclaration)\n+            if (first instanceof XmlDeclaration) {\n                 decl = (XmlDeclaration) first;\n-            else if (first instanceof Comment) {\n+            } else if (first instanceof Comment) {\n                 Comment comment = (Comment) first;\n-                if (comment.isXmlDeclaration())\n+                if (comment.isXmlDeclaration()) {\n                     decl = comment.asXmlDeclaration();\n+                }\n             }\n-            if (decl != null) {\n-                if (decl.name().equalsIgnoreCase(\"xml\"))\n-                    foundCharset = decl.attr(\"encoding\");\n+            if (decl != null && decl.name().equalsIgnoreCase(\"xml\")) {\n+                foundCharset = decl.attr(\"encoding\");\n             }\n         }\n         foundCharset = validateCharset(foundCharset);\n@@ -61,17 +65,19 @@\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n     }\n     if (doc == null) {\n-        if (charsetName == null)\n+        if (charsetName == null) {\n             charsetName = defaultCharset;\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n-            reader.skip(1);\n-        try {\n-            doc = parser.parseInput(reader, baseUri);\n-        } catch (UncheckedIOException e) {\n-            // io exception when parsing (not seen before because reading the stream as we go)\n-            throw e.ioException();\n+        }\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize)) {\n+            if (bomCharset != null && bomCharset.offset) {\n+                reader.skip(1);\n+            }\n+            try {\n+                doc = parser.parseInput(reader, baseUri);\n+            } catch (UncheckedIOException e) {\n+                // io exception when parsing (not seen before because reading the stream as we go)\n+                throw e.ioException();\n+            }\n         }\n         Charset charset = Charset.forName(charsetName);\n         doc.outputSettings().charset(charset);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration())\n                    decl = comment.asXmlDeclaration();\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n            input.reset(); // added to fix issue where stream can't be fully read\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (// creating the buffered reader ignores the input pos, so must skip here\n        bomCharset != null && bomCharset.offset)\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        // some charsets can read but not encode; switch to an encodable charset and update the meta el\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -55,6 +54,7 @@\n             doc = null;\n         } else if (!fullyRead) {\n             doc = null;\n+            input.reset(); // added to fix issue where stream can't be fully read\n         }\n     } else {\n         // specified by content type header (or by user on file load)\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration())\n                    decl = comment.asXmlDeclaration();\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (// creating the buffered reader ignores the input pos, so must skip here\n        bomCharset != null && bomCharset.offset)\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.getCause();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        // some charsets can read but not encode; switch to an encodable charset and update the meta el\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -71,7 +70,7 @@\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n             // io exception when parsing (not seen before because reading the stream as we go)\n-            throw e.ioException();\n+            throw e.getCause();\n         }\n         Charset charset = Charset.forName(charsetName);\n         doc.outputSettings().charset(charset);\n", "finish_reason": "stop", "valid": false, "num": 5}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    input.mark(bufferSize);\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    // read() returns -1 on eof\n    int readResult = input.read();\n    fullyRead = (readResult == -1);\n    input.reset();\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n    }\n    if (charsetName == null) {\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null) {\n                break;\n            }\n        }\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration) {\n                decl = (XmlDeclaration) first;\n            } else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration()) {\n                    decl = comment.asXmlDeclaration();\n                }\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\")) {\n                    foundCharset = decl.attr(\"encoding\");\n                }\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n        // Use try-with-resources to auto-close reader\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize)) {\n            if (bomCharset != null && bomCharset.offset) {\n                reader.skip(1);\n            }\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,55 +1,55 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null) {\n         return new Document(baseUri);\n+    }\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n-    // read the start of the stream and look for a BOM or meta charset\n     input.mark(bufferSize);\n-    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n     ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n-    fullyRead = input.read() == -1;\n+    // read() returns -1 on eof\n+    int readResult = input.read();\n+    fullyRead = (readResult == -1);\n     input.reset();\n-    // look for BOM - overrides any other header or input\n     BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n-    if (bomCharset != null)\n+    if (bomCharset != null) {\n         charsetName = bomCharset.charset;\n+    }\n     if (charsetName == null) {\n-        // determine from meta. safe first parse as UTF-8\n         String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n         doc = parser.parseInput(docData, baseUri);\n-        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n         Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n-        // if not found, will keep utf-8 as best attempt\n         String foundCharset = null;\n         for (Element meta : metaElements) {\n-            if (meta.hasAttr(\"http-equiv\"))\n+            if (meta.hasAttr(\"http-equiv\")) {\n                 foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-            if (foundCharset == null && meta.hasAttr(\"charset\"))\n+            }\n+            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                 foundCharset = meta.attr(\"charset\");\n-            if (foundCharset != null)\n+            }\n+            if (foundCharset != null) {\n                 break;\n+            }\n         }\n-        // look for <?xml encoding='ISO-8859-1'?>\n         if (foundCharset == null && doc.childNodeSize() > 0) {\n             Node first = doc.childNode(0);\n             XmlDeclaration decl = null;\n-            if (first instanceof XmlDeclaration)\n+            if (first instanceof XmlDeclaration) {\n                 decl = (XmlDeclaration) first;\n-            else if (first instanceof Comment) {\n+            } else if (first instanceof Comment) {\n                 Comment comment = (Comment) first;\n-                if (comment.isXmlDeclaration())\n+                if (comment.isXmlDeclaration()) {\n                     decl = comment.asXmlDeclaration();\n+                }\n             }\n             if (decl != null) {\n-                if (decl.name().equalsIgnoreCase(\"xml\"))\n+                if (decl.name().equalsIgnoreCase(\"xml\")) {\n                     foundCharset = decl.attr(\"encoding\");\n+                }\n             }\n         }\n         foundCharset = validateCharset(foundCharset);\n         if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n-            // need to re-decode. (case insensitive check here to match how validate works)\n             foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n             charsetName = foundCharset;\n             doc = null;\n@@ -57,25 +57,23 @@\n             doc = null;\n         }\n     } else {\n-        // specified by content type header (or by user on file load)\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n     }\n     if (doc == null) {\n-        if (charsetName == null)\n+        if (charsetName == null) {\n             charsetName = defaultCharset;\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n-            reader.skip(1);\n-        try {\n+        }\n+        // Use try-with-resources to auto-close reader\n+        try (BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize)) {\n+            if (bomCharset != null && bomCharset.offset) {\n+                reader.skip(1);\n+            }\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n-            // io exception when parsing (not seen before because reading the stream as we go)\n             throw e.ioException();\n         }\n         Charset charset = Charset.forName(charsetName);\n         doc.outputSettings().charset(charset);\n-        // some charsets can read but not encode; switch to an encodable charset and update the meta el\n     }\n     input.close();\n     return doc;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration())\n                    decl = comment.asXmlDeclaration();\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (// creating the buffered reader ignores the input pos, so must skip here\n        bomCharset != null && bomCharset.offset)\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.getCause(); /* Changed ioException() to getCause() */\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        // some charsets can read but not encode; switch to an encodable charset and update the meta el\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -71,7 +70,7 @@\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n             // io exception when parsing (not seen before because reading the stream as we go)\n-            throw e.ioException();\n+            throw e.getCause(); /* Changed ioException() to getCause() */\n         }\n         Charset charset = Charset.forName(charsetName);\n         doc.outputSettings().charset(charset);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration())\n                    decl = comment.asXmlDeclaration();\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        Reader reader = new InputStreamReader(input, charsetName);\n        if (bomCharset != null && bomCharset.offset) {\n            // skip BOM bytes\n            reader = new SkipBomInputStreamReader(input, bomCharset.charset);\n        }\n        BufferedReader bufferedReader = new BufferedReader(reader, bufferSize);\n        try {\n            doc = parser.parseInput(bufferedReader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        // some charsets can read but not encode; switch to an encodable charset and update the meta el\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -63,12 +62,14 @@\n     if (doc == null) {\n         if (charsetName == null)\n             charsetName = defaultCharset;\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n-            reader.skip(1);\n+        Reader reader = new InputStreamReader(input, charsetName);\n+        if (bomCharset != null && bomCharset.offset) {\n+            // skip BOM bytes\n+            reader = new SkipBomInputStreamReader(input, bomCharset.charset);\n+        }\n+        BufferedReader bufferedReader = new BufferedReader(reader, bufferSize);\n         try {\n-            doc = parser.parseInput(reader, baseUri);\n+            doc = parser.parseInput(bufferedReader, baseUri);\n         } catch (UncheckedIOException e) {\n             // io exception when parsing (not seen before because reading the stream as we go)\n             throw e.ioException();\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n    }\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null) {\n                break;\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration) {\n                decl = (XmlDeclaration) first;\n            } else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration()) {\n                    decl = comment.asXmlDeclaration();\n                }\n            }\n            if (decl != null && decl.name().equalsIgnoreCase(\"xml\")) {\n                foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (// creating the buffered reader ignores the input pos, so must skip here\n            bomCharset != null && bomCharset.offset) {\n            reader.skip(1);\n        }\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        // some charsets can read but not encode; switch to an encodable charset and update the meta el\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,7 +1,7 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null) {\n         return new Document(baseUri);\n+    }\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n@@ -13,8 +13,9 @@\n     input.reset();\n     // look for BOM - overrides any other header or input\n     BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n-    if (bomCharset != null)\n+    if (bomCharset != null) {\n         charsetName = bomCharset.charset;\n+    }\n     if (charsetName == null) {\n         // determine from meta. safe first parse as UTF-8\n         String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n@@ -24,27 +25,30 @@\n         // if not found, will keep utf-8 as best attempt\n         String foundCharset = null;\n         for (Element meta : metaElements) {\n-            if (meta.hasAttr(\"http-equiv\"))\n+            if (meta.hasAttr(\"http-equiv\")) {\n                 foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-            if (foundCharset == null && meta.hasAttr(\"charset\"))\n+            }\n+            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                 foundCharset = meta.attr(\"charset\");\n-            if (foundCharset != null)\n+            }\n+            if (foundCharset != null) {\n                 break;\n+            }\n         }\n         // look for <?xml encoding='ISO-8859-1'?>\n         if (foundCharset == null && doc.childNodeSize() > 0) {\n             Node first = doc.childNode(0);\n             XmlDeclaration decl = null;\n-            if (first instanceof XmlDeclaration)\n+            if (first instanceof XmlDeclaration) {\n                 decl = (XmlDeclaration) first;\n-            else if (first instanceof Comment) {\n+            } else if (first instanceof Comment) {\n                 Comment comment = (Comment) first;\n-                if (comment.isXmlDeclaration())\n+                if (comment.isXmlDeclaration()) {\n                     decl = comment.asXmlDeclaration();\n+                }\n             }\n-            if (decl != null) {\n-                if (decl.name().equalsIgnoreCase(\"xml\"))\n-                    foundCharset = decl.attr(\"encoding\");\n+            if (decl != null && decl.name().equalsIgnoreCase(\"xml\")) {\n+                foundCharset = decl.attr(\"encoding\");\n             }\n         }\n         foundCharset = validateCharset(foundCharset);\n@@ -65,8 +69,9 @@\n             charsetName = defaultCharset;\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n         if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n+            bomCharset != null && bomCharset.offset) {\n             reader.skip(1);\n+        }\n         try {\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    byte[] firstBytes = new byte[firstReadBufferSize - 1];\n    int offset = 0;\n    int read = 0;\n    while (read >= 0 && offset < firstReadBufferSize - 1) {\n        read = input.read(firstBytes, offset, firstReadBufferSize - 1 - offset);\n        if (read > 0)\n            offset += read;\n    }\n    ByteBuffer firstByteBuffer = ByteBuffer.wrap(firstBytes, 0, offset);\n    fullyRead = read == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstByteBuffer);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        byte[] docDataBytes = new byte[offset];\n        System.arraycopy(firstBytes, 0, docDataBytes, 0, offset);\n        String docData = Charset.forName(defaultCharset).decode(ByteBuffer.wrap(docDataBytes)).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration())\n                    decl = comment.asXmlDeclaration();\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (// creating the buffered reader ignores the input pos, so must skip here\n        bomCharset != null && bomCharset.offset)\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        // some charsets can read but not encode; switch to an encodable charset and update the meta el\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -8,16 +7,26 @@\n     // read the start of the stream and look for a BOM or meta charset\n     input.mark(bufferSize);\n     // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n-    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n-    fullyRead = input.read() == -1;\n+    byte[] firstBytes = new byte[firstReadBufferSize - 1];\n+    int offset = 0;\n+    int read = 0;\n+    while (read >= 0 && offset < firstReadBufferSize - 1) {\n+        read = input.read(firstBytes, offset, firstReadBufferSize - 1 - offset);\n+        if (read > 0)\n+            offset += read;\n+    }\n+    ByteBuffer firstByteBuffer = ByteBuffer.wrap(firstBytes, 0, offset);\n+    fullyRead = read == -1;\n     input.reset();\n     // look for BOM - overrides any other header or input\n-    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n+    BomCharset bomCharset = detectCharsetFromBom(firstByteBuffer);\n     if (bomCharset != null)\n         charsetName = bomCharset.charset;\n     if (charsetName == null) {\n         // determine from meta. safe first parse as UTF-8\n-        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n+        byte[] docDataBytes = new byte[offset];\n+        System.arraycopy(firstBytes, 0, docDataBytes, 0, offset);\n+        String docData = Charset.forName(defaultCharset).decode(ByteBuffer.wrap(docDataBytes)).toString();\n         doc = parser.parseInput(docData, baseUri);\n         // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n         Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        // return an empty document instead of null\n        return new Document(baseUri);\n    }\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n    }\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\")) {\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            }\n            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                foundCharset = meta.attr(\"charset\");\n            }\n            if (foundCharset != null) {\n                break;\n            }\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration) {\n                decl = (XmlDeclaration) first;\n            } else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration()) {\n                    decl = comment.asXmlDeclaration();\n                }\n            }\n            if (decl != null && decl.name().equalsIgnoreCase(\"xml\")) {\n                foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null) {\n            charsetName = defaultCharset;\n        }\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset) {\n            reader.skip(1);\n        }\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        // Set the charset for the output settings first before encoding the document\n        doc.outputSettings().charset(charset);\n        // some charsets can read but not encode; switch to an encodable charset and update the meta el\n        doc.updateMetaCharsetElement(charset);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,7 +1,8 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null) {\n+        // return an empty document instead of null\n         return new Document(baseUri);\n+    }\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n@@ -13,8 +14,9 @@\n     input.reset();\n     // look for BOM - overrides any other header or input\n     BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n-    if (bomCharset != null)\n+    if (bomCharset != null) {\n         charsetName = bomCharset.charset;\n+    }\n     if (charsetName == null) {\n         // determine from meta. safe first parse as UTF-8\n         String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n@@ -24,27 +26,30 @@\n         // if not found, will keep utf-8 as best attempt\n         String foundCharset = null;\n         for (Element meta : metaElements) {\n-            if (meta.hasAttr(\"http-equiv\"))\n+            if (meta.hasAttr(\"http-equiv\")) {\n                 foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-            if (foundCharset == null && meta.hasAttr(\"charset\"))\n+            }\n+            if (foundCharset == null && meta.hasAttr(\"charset\")) {\n                 foundCharset = meta.attr(\"charset\");\n-            if (foundCharset != null)\n+            }\n+            if (foundCharset != null) {\n                 break;\n+            }\n         }\n         // look for <?xml encoding='ISO-8859-1'?>\n         if (foundCharset == null && doc.childNodeSize() > 0) {\n             Node first = doc.childNode(0);\n             XmlDeclaration decl = null;\n-            if (first instanceof XmlDeclaration)\n+            if (first instanceof XmlDeclaration) {\n                 decl = (XmlDeclaration) first;\n-            else if (first instanceof Comment) {\n+            } else if (first instanceof Comment) {\n                 Comment comment = (Comment) first;\n-                if (comment.isXmlDeclaration())\n+                if (comment.isXmlDeclaration()) {\n                     decl = comment.asXmlDeclaration();\n+                }\n             }\n-            if (decl != null) {\n-                if (decl.name().equalsIgnoreCase(\"xml\"))\n-                    foundCharset = decl.attr(\"encoding\");\n+            if (decl != null && decl.name().equalsIgnoreCase(\"xml\")) {\n+                foundCharset = decl.attr(\"encoding\");\n             }\n         }\n         foundCharset = validateCharset(foundCharset);\n@@ -61,12 +66,13 @@\n         Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n     }\n     if (doc == null) {\n-        if (charsetName == null)\n+        if (charsetName == null) {\n             charsetName = defaultCharset;\n+        }\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n+        if (bomCharset != null && bomCharset.offset) {\n             reader.skip(1);\n+        }\n         try {\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n@@ -74,8 +80,10 @@\n             throw e.ioException();\n         }\n         Charset charset = Charset.forName(charsetName);\n+        // Set the charset for the output settings first before encoding the document\n         doc.outputSettings().charset(charset);\n         // some charsets can read but not encode; switch to an encodable charset and update the meta el\n+        doc.updateMetaCharsetElement(charset);\n     }\n     input.close();\n     return doc;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    int bufferSize = Parser.settings.getMaxBufferedBytes();\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, Math.min(bufferSize, firstReadBufferSize) - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(Parser.settings.getDefaultCharset()).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration())\n                    decl = comment.asXmlDeclaration();\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(Parser.settings.getDefaultCharset())) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = Parser.settings.getDefaultCharset();\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (// creating the buffered reader ignores the input pos, so must skip here\n        bomCharset != null && bomCharset.offset)\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        // some charsets can read but not encode; switch to an encodable charset and update the meta el\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,14 +1,14 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n+    int bufferSize = Parser.settings.getMaxBufferedBytes();\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n     // read the start of the stream and look for a BOM or meta charset\n     input.mark(bufferSize);\n     // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n-    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n+    ByteBuffer firstBytes = readToByteBuffer(input, Math.min(bufferSize, firstReadBufferSize) - 1);\n     fullyRead = input.read() == -1;\n     input.reset();\n     // look for BOM - overrides any other header or input\n@@ -17,7 +17,7 @@\n         charsetName = bomCharset.charset;\n     if (charsetName == null) {\n         // determine from meta. safe first parse as UTF-8\n-        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n+        String docData = Charset.forName(Parser.settings.getDefaultCharset()).decode(firstBytes).toString();\n         doc = parser.parseInput(docData, baseUri);\n         // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n         Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n@@ -48,7 +48,7 @@\n             }\n         }\n         foundCharset = validateCharset(foundCharset);\n-        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n+        if (foundCharset != null && !foundCharset.equalsIgnoreCase(Parser.settings.getDefaultCharset())) {\n             // need to re-decode. (case insensitive check here to match how validate works)\n             foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n             charsetName = foundCharset;\n@@ -62,7 +62,7 @@\n     }\n     if (doc == null) {\n         if (charsetName == null)\n-            charsetName = defaultCharset;\n+            charsetName = Parser.settings.getDefaultCharset();\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n         if (// creating the buffered reader ignores the input pos, so must skip here\n         bomCharset != null && bomCharset.offset)\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration())\n                    decl = comment.asXmlDeclaration();\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset)\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            throw e.getCause(); // throw the original IO exception, if any\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -64,18 +63,15 @@\n         if (charsetName == null)\n             charsetName = defaultCharset;\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n+        if (bomCharset != null && bomCharset.offset)\n             reader.skip(1);\n         try {\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n-            // io exception when parsing (not seen before because reading the stream as we go)\n-            throw e.ioException();\n+            throw e.getCause(); // throw the original IO exception, if any\n         }\n         Charset charset = Charset.forName(charsetName);\n         doc.outputSettings().charset(charset);\n-        // some charsets can read but not encode; switch to an encodable charset and update the meta el\n     }\n     input.close();\n     return doc;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n        // check if the stream offset needs to be adjusted\n        if (bomCharset.offset) {\n            input.skip(1);\n        }\n        // reset after adjusting offset\n        input.reset();\n        // read the start of the stream again to ignore the BOM\n        firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n        fullyRead = input.read() == -1;\n    }\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration())\n                    decl = comment.asXmlDeclaration();\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName));\n        if (bomCharset != null && bomCharset.offset)\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        // some charsets can read but not encode; switch to an encodable charset and update the meta el\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -13,8 +12,18 @@\n     input.reset();\n     // look for BOM - overrides any other header or input\n     BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n-    if (bomCharset != null)\n+    if (bomCharset != null) {\n         charsetName = bomCharset.charset;\n+        // check if the stream offset needs to be adjusted\n+        if (bomCharset.offset) {\n+            input.skip(1);\n+        }\n+        // reset after adjusting offset\n+        input.reset();\n+        // read the start of the stream again to ignore the BOM\n+        firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n+        fullyRead = input.read() == -1;\n+    }\n     if (charsetName == null) {\n         // determine from meta. safe first parse as UTF-8\n         String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n@@ -63,9 +72,8 @@\n     if (doc == null) {\n         if (charsetName == null)\n             charsetName = defaultCharset;\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName));\n+        if (bomCharset != null && bomCharset.offset)\n             reader.skip(1);\n         try {\n             doc = parser.parseInput(reader, baseUri);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    // wrap input stream with ConstrainableInputStream to prevent IOException caused by reading over large http response\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration())\n                    decl = comment.asXmlDeclaration();\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (// creating the buffered reader ignores the input pos, so must skip here\n        bomCharset != null && bomCharset.offset)\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.getCause();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        // some charsets can read but not encode; switch to an encodable charset and update the meta el\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,7 +1,7 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n+    // wrap input stream with ConstrainableInputStream to prevent IOException caused by reading over large http response\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n@@ -71,7 +71,7 @@\n             doc = parser.parseInput(reader, baseUri);\n         } catch (UncheckedIOException e) {\n             // io exception when parsing (not seen before because reading the stream as we go)\n-            throw e.ioException();\n+            throw e.getCause();\n         }\n         Charset charset = Charset.forName(charsetName);\n         doc.outputSettings().charset(charset);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        return new Document(baseUri);\n    }\n\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    JavaNetHttpURLConnection.BOMCharset bomCharset = JavaNetHttpURLConnection.detectCharsetFromBom(input);\n    if (charsetName == null && bomCharset != null) {\n        charsetName = bomCharset.charset();\n    }\n    input.reset();\n    if (charsetName == null) {\n        charsetName = defaultCharset;\n    }\n\n    // determine from meta. safe first parse as UTF-8\n    String docData = Streams.readToEnd(new InputStreamReader(input, Charset.forName(charsetName)));\n    doc = parser.parseInput(docData, baseUri);\n    // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n    Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n    // if not found, will keep utf-8 as best attempt\n    String foundCharset = null;\n    for (Element meta : metaElements) {\n        if (meta.hasAttr(\"http-equiv\"))\n            foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n        if (foundCharset == null && meta.hasAttr(\"charset\"))\n            foundCharset = meta.attr(\"charset\");\n        if (foundCharset != null)\n            break;\n    }\n    // look for <?xml encoding='ISO-8859-1'?>\n    if (foundCharset == null && doc.childNodeSize() > 0) {\n        Node first = doc.childNode(0);\n        XmlDeclaration decl = null;\n        if (first instanceof XmlDeclaration)\n            decl = (XmlDeclaration) first;\n        else if (first instanceof Comment) {\n            Comment comment = (Comment) first;\n            if (comment.isXmlDeclaration())\n                decl = comment.asXmlDeclaration();\n        }\n        if (decl != null) {\n            if (decl.name().equalsIgnoreCase(\"xml\"))\n                foundCharset = decl.attr(\"encoding\");\n        }\n    }\n    foundCharset = validateCharset(foundCharset);\n    if (foundCharset != null && !foundCharset.equalsIgnoreCase(charsetName)) {\n        // need to re-decode. (case insensitive check here to match how validate works)\n        foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n        charsetName = foundCharset;\n        doc = null;\n        InputStreamReader reinput = new InputStreamReader(new ByteArrayInputStream(docData.getBytes()), foundCharset);\n        doc = parser.parseInput(reinput, baseUri);\n    }\n\n    Charset charset = Charset.forName(charsetName);\n    doc.outputSettings().charset(charset);\n\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,82 +1,66 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null) {\n         return new Document(baseUri);\n+    }\n+\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n     boolean fullyRead = false;\n+\n     // read the start of the stream and look for a BOM or meta charset\n     input.mark(bufferSize);\n-    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n-    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n-    fullyRead = input.read() == -1;\n+    JavaNetHttpURLConnection.BOMCharset bomCharset = JavaNetHttpURLConnection.detectCharsetFromBom(input);\n+    if (charsetName == null && bomCharset != null) {\n+        charsetName = bomCharset.charset();\n+    }\n     input.reset();\n-    // look for BOM - overrides any other header or input\n-    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n-    if (bomCharset != null)\n-        charsetName = bomCharset.charset;\n     if (charsetName == null) {\n-        // determine from meta. safe first parse as UTF-8\n-        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n-        doc = parser.parseInput(docData, baseUri);\n-        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n-        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n-        // if not found, will keep utf-8 as best attempt\n-        String foundCharset = null;\n-        for (Element meta : metaElements) {\n-            if (meta.hasAttr(\"http-equiv\"))\n-                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-            if (foundCharset == null && meta.hasAttr(\"charset\"))\n-                foundCharset = meta.attr(\"charset\");\n-            if (foundCharset != null)\n-                break;\n+        charsetName = defaultCharset;\n+    }\n+\n+    // determine from meta. safe first parse as UTF-8\n+    String docData = Streams.readToEnd(new InputStreamReader(input, Charset.forName(charsetName)));\n+    doc = parser.parseInput(docData, baseUri);\n+    // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n+    Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n+    // if not found, will keep utf-8 as best attempt\n+    String foundCharset = null;\n+    for (Element meta : metaElements) {\n+        if (meta.hasAttr(\"http-equiv\"))\n+            foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n+        if (foundCharset == null && meta.hasAttr(\"charset\"))\n+            foundCharset = meta.attr(\"charset\");\n+        if (foundCharset != null)\n+            break;\n+    }\n+    // look for <?xml encoding='ISO-8859-1'?>\n+    if (foundCharset == null && doc.childNodeSize() > 0) {\n+        Node first = doc.childNode(0);\n+        XmlDeclaration decl = null;\n+        if (first instanceof XmlDeclaration)\n+            decl = (XmlDeclaration) first;\n+        else if (first instanceof Comment) {\n+            Comment comment = (Comment) first;\n+            if (comment.isXmlDeclaration())\n+                decl = comment.asXmlDeclaration();\n         }\n-        // look for <?xml encoding='ISO-8859-1'?>\n-        if (foundCharset == null && doc.childNodeSize() > 0) {\n-            Node first = doc.childNode(0);\n-            XmlDeclaration decl = null;\n-            if (first instanceof XmlDeclaration)\n-                decl = (XmlDeclaration) first;\n-            else if (first instanceof Comment) {\n-                Comment comment = (Comment) first;\n-                if (comment.isXmlDeclaration())\n-                    decl = comment.asXmlDeclaration();\n-            }\n-            if (decl != null) {\n-                if (decl.name().equalsIgnoreCase(\"xml\"))\n-                    foundCharset = decl.attr(\"encoding\");\n-            }\n+        if (decl != null) {\n+            if (decl.name().equalsIgnoreCase(\"xml\"))\n+                foundCharset = decl.attr(\"encoding\");\n         }\n-        foundCharset = validateCharset(foundCharset);\n-        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n-            // need to re-decode. (case insensitive check here to match how validate works)\n-            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n-            charsetName = foundCharset;\n-            doc = null;\n-        } else if (!fullyRead) {\n-            doc = null;\n-        }\n-    } else {\n-        // specified by content type header (or by user on file load)\n-        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n     }\n-    if (doc == null) {\n-        if (charsetName == null)\n-            charsetName = defaultCharset;\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n-            reader.skip(1);\n-        try {\n-            doc = parser.parseInput(reader, baseUri);\n-        } catch (UncheckedIOException e) {\n-            // io exception when parsing (not seen before because reading the stream as we go)\n-            throw e.ioException();\n-        }\n-        Charset charset = Charset.forName(charsetName);\n-        doc.outputSettings().charset(charset);\n-        // some charsets can read but not encode; switch to an encodable charset and update the meta el\n+    foundCharset = validateCharset(foundCharset);\n+    if (foundCharset != null && !foundCharset.equalsIgnoreCase(charsetName)) {\n+        // need to re-decode. (case insensitive check here to match how validate works)\n+        foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n+        charsetName = foundCharset;\n+        doc = null;\n+        InputStreamReader reinput = new InputStreamReader(new ByteArrayInputStream(docData.getBytes()), foundCharset);\n+        doc = parser.parseInput(reinput, baseUri);\n     }\n-    input.close();\n+\n+    Charset charset = Charset.forName(charsetName);\n+    doc.outputSettings().charset(charset);\n+\n     return doc;\n }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "## Fixed Function 1\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null)\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n    Document doc = null;\n    boolean fullyRead = false;\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);\n    fullyRead = input.read() == -1;\n    input.reset();\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n    if (charsetName == null) {\n        // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        // if not found, will keep utf-8 as best attempt\n        String foundCharset = null;\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration())\n                    decl = comment.asXmlDeclaration();\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) {\n            // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else {\n        // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        // wrap the input stream with a buffered reader\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset)\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        // some charsets can read but not encode; switch to an encodable charset and update the meta el\n    }\n    input.close();\n    return doc;\n}", "diff": "--- org/jsoup/helper/DataUtil.java@parseInputStream\n+++ org/jsoup/helper/DataUtil.java@parseInputStream\n@@ -1,6 +1,5 @@\n static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n-    if (// empty body\n-    input == null)\n+    if (input == null)\n         return new Document(baseUri);\n     input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n     Document doc = null;\n@@ -63,9 +62,9 @@\n     if (doc == null) {\n         if (charsetName == null)\n             charsetName = defaultCharset;\n+        // wrap the input stream with a buffered reader\n         BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-        if (// creating the buffered reader ignores the input pos, so must skip here\n-        bomCharset != null && bomCharset.offset)\n+        if (bomCharset != null && bomCharset.offset)\n             reader.skip(1);\n         try {\n             doc = parser.parseInput(reader, baseUri);\n", "finish_reason": "stop", "valid": false, "num": 1}]