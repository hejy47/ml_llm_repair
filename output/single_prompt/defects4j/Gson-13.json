[{"output": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    // Negative to accommodate Long.MIN_VALUE more easily.\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n    charactersOfNumber: for (; true; i++) {\n        if (p + i == l) {\n            if (i == buffer.length) {\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    if (last == NUMBER_CHAR_SIGN && value == 0) {\n                        return PEEKED_NONE;\n                    }\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        // Leading '0' prefix is not allowed (since it could be octal).\n                        return PEEKED_NONE;\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER / 10 ||\n                            (value == MIN_INCOMPLETE_INTEGER / 10 && newValue < (MIN_INCOMPLETE_INTEGER % 10));\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -61,6 +61,9 @@\n                     return PEEKED_NONE;\n                 }\n                 if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n+                    if (last == NUMBER_CHAR_SIGN && value == 0) {\n+                        return PEEKED_NONE;\n+                    }\n                     value = -(c - '0');\n                     last = NUMBER_CHAR_DIGIT;\n                 } else if (last == NUMBER_CHAR_DIGIT) {\n@@ -69,7 +72,8 @@\n                         return PEEKED_NONE;\n                     }\n                     long newValue = value * 10 - (c - '0');\n-                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n+                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER / 10 ||\n+                            (value == MIN_INCOMPLETE_INTEGER / 10 && newValue < (MIN_INCOMPLETE_INTEGER % 10));\n                     value = newValue;\n                 } else if (last == NUMBER_CHAR_DECIMAL) {\n                     last = NUMBER_CHAR_FRACTION_DIGIT;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    // Negative to accommodate Long.MIN_VALUE more easily.\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n    charactersOfNumber: for (; true; i++) {\n        if (p + i == l) {\n            if (i == buffer.length) {\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_EXP_E) { // allow dot after exponent\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        // Leading '0' prefix is not allowed (since it could be octal).\n                        return PEEKED_NONE;\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if ((last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT)\n            && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -48,7 +48,7 @@\n                 }\n                 return PEEKED_NONE;\n             case '.':\n-                if (last == NUMBER_CHAR_DIGIT) {\n+                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_EXP_E) { // allow dot after exponent\n                     last = NUMBER_CHAR_DECIMAL;\n                     continue;\n                 }\n@@ -79,7 +79,8 @@\n         }\n     }\n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+    if ((last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT)\n+            && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n         peekedLong = negative ? value : -value;\n         pos += i;\n         return peeked = PEEKED_LONG;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private int peekNumber() throws IOException {\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n    charactersOfNumber: for (; true; i++) {\n        if (p + i == l) {\n            if (i == buffer.length) {\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE || last == NUMBER_CHAR_EXP_E) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_NONE) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN) {\n                    last = NUMBER_CHAR_DIGIT;\n                    value = -(c - '0');\n                } else if (last == NUMBER_CHAR_NONE) {\n                    last = NUMBER_CHAR_DIGIT;\n                    value = c - '0';\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                } else {\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                }\n        }\n    }\n\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -1,9 +1,7 @@\n private int peekNumber() throws IOException {\n-    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n     char[] buffer = this.buffer;\n     int p = pos;\n     int l = limit;\n-    // Negative to accommodate Long.MIN_VALUE more easily.\n     long value = 0;\n     boolean negative = false;\n     boolean fitsInLong = true;\n@@ -25,12 +23,9 @@\n         char c = buffer[p + i];\n         switch(c) {\n             case '-':\n-                if (last == NUMBER_CHAR_NONE) {\n+                if (last == NUMBER_CHAR_NONE || last == NUMBER_CHAR_EXP_E) {\n                     negative = true;\n                     last = NUMBER_CHAR_SIGN;\n-                    continue;\n-                } else if (last == NUMBER_CHAR_EXP_E) {\n-                    last = NUMBER_CHAR_EXP_SIGN;\n                     continue;\n                 }\n                 return PEEKED_NONE;\n@@ -48,7 +43,7 @@\n                 }\n                 return PEEKED_NONE;\n             case '.':\n-                if (last == NUMBER_CHAR_DIGIT) {\n+                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_NONE) {\n                     last = NUMBER_CHAR_DECIMAL;\n                     continue;\n                 }\n@@ -60,25 +55,24 @@\n                     }\n                     return PEEKED_NONE;\n                 }\n-                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n+                if (last == NUMBER_CHAR_SIGN) {\n+                    last = NUMBER_CHAR_DIGIT;\n                     value = -(c - '0');\n+                } else if (last == NUMBER_CHAR_NONE) {\n                     last = NUMBER_CHAR_DIGIT;\n-                } else if (last == NUMBER_CHAR_DIGIT) {\n-                    if (value == 0) {\n-                        // Leading '0' prefix is not allowed (since it could be octal).\n-                        return PEEKED_NONE;\n-                    }\n-                    long newValue = value * 10 - (c - '0');\n-                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n-                    value = newValue;\n+                    value = c - '0';\n                 } else if (last == NUMBER_CHAR_DECIMAL) {\n                     last = NUMBER_CHAR_FRACTION_DIGIT;\n                 } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                     last = NUMBER_CHAR_EXP_DIGIT;\n+                } else {\n+                    long newValue = value * 10 - (c - '0');\n+                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n+                    value = newValue;\n                 }\n         }\n     }\n-    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n+\n     if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n         peekedLong = negative ? value : -value;\n         pos += i;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    // Negative to accommodate Long.MIN_VALUE more easily.\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n    charactersOfNumber: for (; true; i++) {\n        if (p + i == l) {\n            if (i == buffer.length) {\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_SIGN) { // fix: allow '-' sign before decimal point\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        // Leading '0' prefix is not allowed (since it could be octal).\n                        return PEEKED_NONE;\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -48,7 +48,7 @@\n                 }\n                 return PEEKED_NONE;\n             case '.':\n-                if (last == NUMBER_CHAR_DIGIT) {\n+                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_SIGN) { // fix: allow '-' sign before decimal point\n                     last = NUMBER_CHAR_DECIMAL;\n                     continue;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private int peekNumber() throws IOException {\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n\n    charactersOfNumber: for (; true; i++) {\n        if (p + i == l) {\n            if (i == buffer.length) {\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN) {\n                    last = NUMBER_CHAR_DIGIT;\n                    value = -(c - '0');\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                } else {\n                    return PEEKED_NONE;\n                }\n        }\n    }\n\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -1,19 +1,16 @@\n private int peekNumber() throws IOException {\n-    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n     char[] buffer = this.buffer;\n     int p = pos;\n     int l = limit;\n-    // Negative to accommodate Long.MIN_VALUE more easily.\n     long value = 0;\n     boolean negative = false;\n     boolean fitsInLong = true;\n     int last = NUMBER_CHAR_NONE;\n     int i = 0;\n+\n     charactersOfNumber: for (; true; i++) {\n         if (p + i == l) {\n             if (i == buffer.length) {\n-                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n-                // and let the application handle this as an unquoted literal.\n                 return PEEKED_NONE;\n             }\n             if (!fillBuffer(i + 1)) {\n@@ -60,14 +57,10 @@\n                     }\n                     return PEEKED_NONE;\n                 }\n-                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n+                if (last == NUMBER_CHAR_SIGN) {\n+                    last = NUMBER_CHAR_DIGIT;\n                     value = -(c - '0');\n-                    last = NUMBER_CHAR_DIGIT;\n                 } else if (last == NUMBER_CHAR_DIGIT) {\n-                    if (value == 0) {\n-                        // Leading '0' prefix is not allowed (since it could be octal).\n-                        return PEEKED_NONE;\n-                    }\n                     long newValue = value * 10 - (c - '0');\n                     fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                     value = newValue;\n@@ -75,10 +68,12 @@\n                     last = NUMBER_CHAR_FRACTION_DIGIT;\n                 } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                     last = NUMBER_CHAR_EXP_DIGIT;\n+                } else {\n+                    return PEEKED_NONE;\n                 }\n         }\n     }\n-    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n+\n     if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n         peekedLong = negative ? value : -value;\n         pos += i;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    // Negative to accommodate Long.MIN_VALUE more easily.\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n    charactersOfNumber: for (; true; i++) {\n        if (p + i == l) {\n            if (i == buffer.length) {\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_NONE) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        // Leading '0' prefix is not allowed (since it could be octal).\n                        return PEEKED_NONE;\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -48,7 +48,7 @@\n                 }\n                 return PEEKED_NONE;\n             case '.':\n-                if (last == NUMBER_CHAR_DIGIT) {\n+                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_NONE) {\n                     last = NUMBER_CHAR_DECIMAL;\n                     continue;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    // Negative to accommodate Long.MIN_VALUE more easily.\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n    charactersOfNumber: for (; true; i++) {\n        if (p + i >= l) {\n            if (i + 1 >= buffer.length) {\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        // Leading '0' prefix is not allowed (since it could be octal).\n                        return PEEKED_NONE;\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER / 10\n                            || (value == MIN_INCOMPLETE_INTEGER / 10 && newValue < MIN_INCOMPLETE_INTEGER % 10);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -10,8 +10,8 @@\n     int last = NUMBER_CHAR_NONE;\n     int i = 0;\n     charactersOfNumber: for (; true; i++) {\n-        if (p + i == l) {\n-            if (i == buffer.length) {\n+        if (p + i >= l) {\n+            if (i + 1 >= buffer.length) {\n                 // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                 // and let the application handle this as an unquoted literal.\n                 return PEEKED_NONE;\n@@ -69,7 +69,8 @@\n                         return PEEKED_NONE;\n                     }\n                     long newValue = value * 10 - (c - '0');\n-                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n+                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER / 10\n+                            || (value == MIN_INCOMPLETE_INTEGER / 10 && newValue < MIN_INCOMPLETE_INTEGER % 10);\n                     value = newValue;\n                 } else if (last == NUMBER_CHAR_DECIMAL) {\n                     last = NUMBER_CHAR_FRACTION_DIGIT;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    // Negative to accommodate Long.MIN_VALUE more easily.\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n    charactersOfNumber: for (; true; i++) {\n        if (p + i == l) {\n            if (i == buffer.length) {\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    if (c == '0' && i + 1 < l && buffer[p + i + 1] >= '0' && buffer[p + i + 1] <= '9') {\n                        // leading '0' prefix is not allowed (since it could be octal); fix by returning NONE\n                        return PEEKED_NONE;\n                    }\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        // Leading '0' prefix is not allowed (since it could be octal).\n                        if (c == '0') {\n                            // fix by returning NONE\n                            return PEEKED_NONE;\n                        }\n                        // Fix by setting last to NUMBER_CHAR_NONE and continuing the loop\n                        last = NUMBER_CHAR_NONE;\n                        continue;\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -61,12 +61,22 @@\n                     return PEEKED_NONE;\n                 }\n                 if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n+                    if (c == '0' && i + 1 < l && buffer[p + i + 1] >= '0' && buffer[p + i + 1] <= '9') {\n+                        // leading '0' prefix is not allowed (since it could be octal); fix by returning NONE\n+                        return PEEKED_NONE;\n+                    }\n                     value = -(c - '0');\n                     last = NUMBER_CHAR_DIGIT;\n                 } else if (last == NUMBER_CHAR_DIGIT) {\n                     if (value == 0) {\n                         // Leading '0' prefix is not allowed (since it could be octal).\n-                        return PEEKED_NONE;\n+                        if (c == '0') {\n+                            // fix by returning NONE\n+                            return PEEKED_NONE;\n+                        }\n+                        // Fix by setting last to NUMBER_CHAR_NONE and continuing the loop\n+                        last = NUMBER_CHAR_NONE;\n+                        continue;\n                     }\n                     long newValue = value * 10 - (c - '0');\n                     fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    // Negative to accommodate Long.MIN_VALUE more easily.\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n    charactersOfNumber: for (; true; i++) {\n        if (p + i == l) {\n            if (i + 1 >= buffer.length && i < INDENT.length()) {\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        // Leading '0' prefix is not allowed (since it could be octal).\n                        return PEEKED_NONE;\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -11,9 +11,7 @@\n     int i = 0;\n     charactersOfNumber: for (; true; i++) {\n         if (p + i == l) {\n-            if (i == buffer.length) {\n-                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n-                // and let the application handle this as an unquoted literal.\n+            if (i + 1 >= buffer.length && i < INDENT.length()) {\n                 return PEEKED_NONE;\n             }\n             if (!fillBuffer(i + 1)) {\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    // Negative to accommodate Long.MIN_VALUE more easily.\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n    charactersOfNumber: for (; true; i++) {\n        if (p + i >= l) {\n            if (i >= buffer.length) {\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        // Leading '0' prefix is not allowed (since it could be octal).\n                        return PEEKED_NONE;\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -10,8 +10,8 @@\n     int last = NUMBER_CHAR_NONE;\n     int i = 0;\n     charactersOfNumber: for (; true; i++) {\n-        if (p + i == l) {\n-            if (i == buffer.length) {\n+        if (p + i >= l) {\n+            if (i >= buffer.length) {\n                 // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                 // and let the application handle this as an unquoted literal.\n                 return PEEKED_NONE;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    // Negative to accommodate Long.MIN_VALUE more easily.\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n    charactersOfNumber: for (; true; i++) {\n        if (p + i >= l) {\n            if (i + 1 >= buffer.length) {\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_NONE) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        // Leading '0' prefix is not allowed (since it could be octal).\n                        return PEEKED_NONE;\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -10,8 +10,8 @@\n     int last = NUMBER_CHAR_NONE;\n     int i = 0;\n     charactersOfNumber: for (; true; i++) {\n-        if (p + i == l) {\n-            if (i == buffer.length) {\n+        if (p + i >= l) {\n+            if (i + 1 >= buffer.length) {\n                 // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                 // and let the application handle this as an unquoted literal.\n                 return PEEKED_NONE;\n@@ -48,7 +48,7 @@\n                 }\n                 return PEEKED_NONE;\n             case '.':\n-                if (last == NUMBER_CHAR_DIGIT) {\n+                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_NONE) {\n                     last = NUMBER_CHAR_DECIMAL;\n                     continue;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    // Negative to accommodate Long.MIN_VALUE more easily.\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n    charactersOfNumber: for (; true; i++) {\n        if (p + i == l) {\n            if (i == buffer.length) {\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    negative = true;\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        // Leading '0' prefix is not allowed (since it could be octal).\n                        return PEEKED_NONE;\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (negative ? value != Long.MIN_VALUE : true)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -30,6 +30,7 @@\n                     last = NUMBER_CHAR_SIGN;\n                     continue;\n                 } else if (last == NUMBER_CHAR_EXP_E) {\n+                    negative = true;\n                     last = NUMBER_CHAR_EXP_SIGN;\n                     continue;\n                 }\n@@ -79,7 +80,7 @@\n         }\n     }\n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (negative ? value != Long.MIN_VALUE : true)) {\n         peekedLong = negative ? value : -value;\n         pos += i;\n         return peeked = PEEKED_LONG;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    // Negative to accommodate Long.MIN_VALUE more easily.\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n    charactersOfNumber: for (; true; i++) {\n        if (p + i == l) {\n            if (i == buffer.length) {\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = c - '0';\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        // Leading '0' prefix is not allowed (since it could be octal).\n                        return PEEKED_NONE;\n                    }\n                    long newValue = value * 10 + (c - '0');\n                    fitsInLong &= value < MAX_INCOMPLETE_INTEGER || (value == MAX_INCOMPLETE_INTEGER && newValue > value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -61,15 +61,15 @@\n                     return PEEKED_NONE;\n                 }\n                 if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n-                    value = -(c - '0');\n+                    value = c - '0';\n                     last = NUMBER_CHAR_DIGIT;\n                 } else if (last == NUMBER_CHAR_DIGIT) {\n                     if (value == 0) {\n                         // Leading '0' prefix is not allowed (since it could be octal).\n                         return PEEKED_NONE;\n                     }\n-                    long newValue = value * 10 - (c - '0');\n-                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n+                    long newValue = value * 10 + (c - '0');\n+                    fitsInLong &= value < MAX_INCOMPLETE_INTEGER || (value == MAX_INCOMPLETE_INTEGER && newValue > value);\n                     value = newValue;\n                 } else if (last == NUMBER_CHAR_DECIMAL) {\n                     last = NUMBER_CHAR_FRACTION_DIGIT;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    // Negative to accommodate Long.MIN_VALUE more easily.\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n    charactersOfNumber: for (; true; i++) {\n        if (p + i == l) {\n            if (i == buffer.length) {\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_EXP_E) { // fixed\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        // Leading '0' prefix is not allowed (since it could be octal).\n                        return PEEKED_NONE;\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -48,7 +48,7 @@\n                 }\n                 return PEEKED_NONE;\n             case '.':\n-                if (last == NUMBER_CHAR_DIGIT) {\n+                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_EXP_E) { // fixed\n                     last = NUMBER_CHAR_DECIMAL;\n                     continue;\n                 }\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private int peekNumber() throws IOException {\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n    charactersOfNumber: for (; true; i++) {\n        if (p + i >= l) {\n            if (i == buffer.length) {\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_NONE) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        if (p + i + 1 >= l && !fillBuffer(i + 1)) {\n                            break;\n                        }\n                        char next = buffer[p + i + 1];\n                        if (next == 'e' || next == 'E') {\n                            break;\n                        }\n                        return PEEKED_NONE;\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -1,19 +1,15 @@\n private int peekNumber() throws IOException {\n-    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n     char[] buffer = this.buffer;\n     int p = pos;\n     int l = limit;\n-    // Negative to accommodate Long.MIN_VALUE more easily.\n     long value = 0;\n     boolean negative = false;\n     boolean fitsInLong = true;\n     int last = NUMBER_CHAR_NONE;\n     int i = 0;\n     charactersOfNumber: for (; true; i++) {\n-        if (p + i == l) {\n+        if (p + i >= l) {\n             if (i == buffer.length) {\n-                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n-                // and let the application handle this as an unquoted literal.\n                 return PEEKED_NONE;\n             }\n             if (!fillBuffer(i + 1)) {\n@@ -48,7 +44,7 @@\n                 }\n                 return PEEKED_NONE;\n             case '.':\n-                if (last == NUMBER_CHAR_DIGIT) {\n+                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_NONE) {\n                     last = NUMBER_CHAR_DECIMAL;\n                     continue;\n                 }\n@@ -65,7 +61,13 @@\n                     last = NUMBER_CHAR_DIGIT;\n                 } else if (last == NUMBER_CHAR_DIGIT) {\n                     if (value == 0) {\n-                        // Leading '0' prefix is not allowed (since it could be octal).\n+                        if (p + i + 1 >= l && !fillBuffer(i + 1)) {\n+                            break;\n+                        }\n+                        char next = buffer[p + i + 1];\n+                        if (next == 'e' || next == 'E') {\n+                            break;\n+                        }\n                         return PEEKED_NONE;\n                     }\n                     long newValue = value * 10 - (c - '0');\n@@ -78,7 +80,6 @@\n                 }\n         }\n     }\n-    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n     if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n         peekedLong = negative ? value : -value;\n         pos += i;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private int peekNumber() throws IOException {\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n\n    charactersOfNumber: for (; true; i++) {\n        if (p + i == l) {\n            if (i == buffer.length) {\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_NONE) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        return PEEKED_NONE;\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    if ((negative && newValue < MIN_INCOMPLETE_INTEGER) || (!negative && newValue < MIN_INCOMPLETE_INTEGER + 1)) {\n                        fitsInLong = false;\n                    }\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -1,19 +1,16 @@\n private int peekNumber() throws IOException {\n-    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n     char[] buffer = this.buffer;\n     int p = pos;\n     int l = limit;\n-    // Negative to accommodate Long.MIN_VALUE more easily.\n     long value = 0;\n     boolean negative = false;\n     boolean fitsInLong = true;\n     int last = NUMBER_CHAR_NONE;\n     int i = 0;\n+\n     charactersOfNumber: for (; true; i++) {\n         if (p + i == l) {\n             if (i == buffer.length) {\n-                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n-                // and let the application handle this as an unquoted literal.\n                 return PEEKED_NONE;\n             }\n             if (!fillBuffer(i + 1)) {\n@@ -48,7 +45,7 @@\n                 }\n                 return PEEKED_NONE;\n             case '.':\n-                if (last == NUMBER_CHAR_DIGIT) {\n+                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_NONE) {\n                     last = NUMBER_CHAR_DECIMAL;\n                     continue;\n                 }\n@@ -65,11 +62,12 @@\n                     last = NUMBER_CHAR_DIGIT;\n                 } else if (last == NUMBER_CHAR_DIGIT) {\n                     if (value == 0) {\n-                        // Leading '0' prefix is not allowed (since it could be octal).\n                         return PEEKED_NONE;\n                     }\n                     long newValue = value * 10 - (c - '0');\n-                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n+                    if ((negative && newValue < MIN_INCOMPLETE_INTEGER) || (!negative && newValue < MIN_INCOMPLETE_INTEGER + 1)) {\n+                        fitsInLong = false;\n+                    }\n                     value = newValue;\n                 } else if (last == NUMBER_CHAR_DECIMAL) {\n                     last = NUMBER_CHAR_FRACTION_DIGIT;\n@@ -78,7 +76,7 @@\n                 }\n         }\n     }\n-    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n+\n     if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n         peekedLong = negative ? value : -value;\n         pos += i;\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    // Negative to accommodate Long.MIN_VALUE more easily.\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n    charactersOfNumber: for (; true; i++) {\n        if (p + i == l) {\n            if (i == buffer.length) {\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue charactersOfNumber;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue charactersOfNumber;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue charactersOfNumber;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue charactersOfNumber;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue charactersOfNumber;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        // Leading '0' prefix is not allowed (since it could be octal).\n                        return PEEKED_NONE;\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -28,29 +28,29 @@\n                 if (last == NUMBER_CHAR_NONE) {\n                     negative = true;\n                     last = NUMBER_CHAR_SIGN;\n-                    continue;\n+                    continue charactersOfNumber;\n                 } else if (last == NUMBER_CHAR_EXP_E) {\n                     last = NUMBER_CHAR_EXP_SIGN;\n-                    continue;\n+                    continue charactersOfNumber;\n                 }\n                 return PEEKED_NONE;\n             case '+':\n                 if (last == NUMBER_CHAR_EXP_E) {\n                     last = NUMBER_CHAR_EXP_SIGN;\n-                    continue;\n+                    continue charactersOfNumber;\n                 }\n                 return PEEKED_NONE;\n             case 'e':\n             case 'E':\n                 if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                     last = NUMBER_CHAR_EXP_E;\n-                    continue;\n+                    continue charactersOfNumber;\n                 }\n                 return PEEKED_NONE;\n             case '.':\n                 if (last == NUMBER_CHAR_DIGIT) {\n                     last = NUMBER_CHAR_DECIMAL;\n-                    continue;\n+                    continue charactersOfNumber;\n                 }\n                 return PEEKED_NONE;\n             default:\n", "finish_reason": "stop", "valid": false, "num": 1}, {"output": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    // Negative to accommodate Long.MIN_VALUE more easily.\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n    charactersOfNumber: for (; true; i++) {\n        if (p + i >= l) {\n            if (i + 1 >= buffer.length) {\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        // Leading '0' prefix is not allowed (since it could be octal).\n                        return PEEKED_NONE;\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -10,8 +10,8 @@\n     int last = NUMBER_CHAR_NONE;\n     int i = 0;\n     charactersOfNumber: for (; true; i++) {\n-        if (p + i == l) {\n-            if (i == buffer.length) {\n+        if (p + i >= l) {\n+            if (i + 1 >= buffer.length) {\n                 // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                 // and let the application handle this as an unquoted literal.\n                 return PEEKED_NONE;\n", "finish_reason": "stop", "valid": false, "num": 2}, {"output": "private int peekNumber() throws IOException {\n    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n    char[] buffer = this.buffer;\n    int p = pos;\n    int l = limit;\n    // Negative to accommodate Long.MIN_VALUE more easily.\n    long value = 0;\n    boolean negative = false;\n    boolean fitsInLong = true;\n    int last = NUMBER_CHAR_NONE;\n    int i = 0;\n    charactersOfNumber: for (; true; i++) {\n        if (p + i >= l) {\n            if (i + 1 > buffer.length) {\n                // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                // and let the application handle this as an unquoted literal.\n                return PEEKED_NONE;\n            }\n            if (!fillBuffer(i + 1)) {\n                break;\n            }\n            p = pos;\n            l = limit;\n        }\n        char c = buffer[p + i];\n        switch(c) {\n            case '-':\n                if (last == NUMBER_CHAR_NONE) {\n                    negative = true;\n                    last = NUMBER_CHAR_SIGN;\n                    continue;\n                } else if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '+':\n                if (last == NUMBER_CHAR_EXP_E) {\n                    last = NUMBER_CHAR_EXP_SIGN;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case 'e':\n            case 'E':\n                if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\n                    last = NUMBER_CHAR_EXP_E;\n                    continue;\n                }\n                return PEEKED_NONE;\n            case '.':\n                if (last == NUMBER_CHAR_DIGIT) {\n                    last = NUMBER_CHAR_DECIMAL;\n                    continue;\n                }\n                return PEEKED_NONE;\n            default:\n                if (c < '0' || c > '9') {\n                    if (!isLiteral(c)) {\n                        break charactersOfNumber;\n                    }\n                    return PEEKED_NONE;\n                }\n                if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\n                    value = -(c - '0');\n                    last = NUMBER_CHAR_DIGIT;\n                } else if (last == NUMBER_CHAR_DIGIT) {\n                    if (value == 0) {\n                        // Leading '0' prefix is not allowed (since it could be octal).\n                        return PEEKED_NONE;\n                    }\n                    long newValue = value * 10 - (c - '0');\n                    fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value);\n                    value = newValue;\n                } else if (last == NUMBER_CHAR_DECIMAL) {\n                    last = NUMBER_CHAR_FRACTION_DIGIT;\n                } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\n                    last = NUMBER_CHAR_EXP_DIGIT;\n                }\n        }\n    }\n    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n        peekedLong = negative ? value : -value;\n        pos += i;\n        return peeked = PEEKED_LONG;\n    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) {\n        peekedNumberLength = i;\n        return peeked = PEEKED_NUMBER;\n    } else {\n        return PEEKED_NONE;\n    }\n}", "diff": "--- com/google/gson/stream/JsonReader.java@peekNumber\n+++ com/google/gson/stream/JsonReader.java@peekNumber\n@@ -10,8 +10,8 @@\n     int last = NUMBER_CHAR_NONE;\n     int i = 0;\n     charactersOfNumber: for (; true; i++) {\n-        if (p + i == l) {\n-            if (i == buffer.length) {\n+        if (p + i >= l) {\n+            if (i + 1 > buffer.length) {\n                 // Though this looks like a well-formed number, it's too long to continue reading. Give up\n                 // and let the application handle this as an unquoted literal.\n                 return PEEKED_NONE;\n", "finish_reason": "stop", "valid": false, "num": 1}]